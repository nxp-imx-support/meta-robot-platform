From 656af788ee1a66ff78d4135e45044b099f902bd2 Mon Sep 17 00:00:00 2001
From: nxa22940 <xiaodong.zhang@nxp.com>
Date: Fri, 7 Apr 2023 14:52:10 +0800
Subject: [PATCH] Add i.MX8M Plus AI Robot board

Signed-off-by: nxa22940 <xiaodong.zhang@nxp.com>
---
 arch/arm64/boot/dts/freescale/Makefile        |    2 +
 .../imx8mp-ai-robot-auo-lvds-panel.dts        |   37 +
 .../imx8mp-ai-robot-boe-lvds-panel.dts        |   48 +
 .../imx8mp-ai-robot-powertip-lvds-panel.dts   |   36 +
 .../freescale/imx8mp-ai-robot-rk070cu05h.dts  |   45 +
 .../dts/freescale/imx8mp-ai-robot-root.dts    |   97 +
 .../boot/dts/freescale/imx8mp-ai-robot.dts    | 1456 +++++++++
 arch/arm64/boot/dts/freescale/imx8mp.dtsi     |   11 +-
 arch/arm64/configs/imx_v8_defconfig           |   17 +-
 drivers/gpu/drm/panel/Kconfig                 |   11 +
 drivers/gpu/drm/panel/Makefile                |    1 +
 .../gpu/drm/panel/panel-rocktech-rk070cu05h.c |  424 +++
 drivers/gpu/drm/panel/panel-simple.c          |   63 +
 drivers/iio/imu/Kconfig                       |    1 +
 drivers/iio/imu/Makefile                      |    1 +
 drivers/iio/imu/inv_mpu/Kconfig               |   69 +
 drivers/iio/imu/inv_mpu/Makefile              |   73 +
 drivers/iio/imu/inv_mpu/README                |  117 +
 .../imu/inv_mpu/dmp_support/inv_mpu_misc.c    |   77 +
 .../imu/inv_mpu/iam20680/inv_mpu_core_20680.c | 1090 +++++++
 .../inv_mpu/iam20680/inv_mpu_iio_reg_20680.h  |  239 ++
 .../imu/inv_mpu/iam20680/inv_mpu_init_20680.c |  253 ++
 .../inv_mpu/iam20680/inv_mpu_parsing_20680.c  |  400 +++
 .../inv_mpu/iam20680/inv_mpu_selftest_20680.c |  755 +++++
 .../inv_mpu/iam20680/inv_mpu_setup_20680.c    |  506 +++
 .../iio/imu/inv_mpu/icm20648/dmp3Default.h    |  343 ++
 .../iio/imu/inv_mpu/icm20648/inv_mpu_core.c   | 2846 +++++++++++++++++
 .../imu/inv_mpu/icm20648/inv_mpu_dmp_fifo.c   |  194 ++
 .../inv_mpu/icm20648/inv_mpu_iio_reg_20648.h  |  365 +++
 .../iio/imu/inv_mpu/icm20648/inv_mpu_init.c   |  562 ++++
 .../imu/inv_mpu/icm20648/inv_mpu_load_dmp.c   |  162 +
 .../imu/inv_mpu/icm20648/inv_mpu_parsing.c    |  761 +++++
 .../imu/inv_mpu/icm20648/inv_mpu_selftest.c   |  791 +++++
 .../iio/imu/inv_mpu/icm20648/inv_mpu_setup.c  | 1724 ++++++++++
 .../iio/imu/inv_mpu/icm20648/inv_slave_als.c  |  288 ++
 .../imu/inv_mpu/icm20648/inv_slave_compass.c  |  640 ++++
 .../imu/inv_mpu/icm20648/inv_slave_pressure.c |  521 +++
 drivers/iio/imu/inv_mpu/inv_mpu_common.c      | 1238 +++++++
 drivers/iio/imu/inv_mpu/inv_mpu_dts.c         |  345 ++
 drivers/iio/imu/inv_mpu/inv_mpu_dts.h         |   25 +
 drivers/iio/imu/inv_mpu/inv_mpu_i2c.c         |  552 ++++
 drivers/iio/imu/inv_mpu/inv_mpu_iio.h         | 1215 +++++++
 drivers/iio/imu/inv_mpu/inv_mpu_ring.c        |  613 ++++
 drivers/iio/imu/inv_mpu/inv_mpu_spi.c         |  410 +++
 drivers/iio/imu/inv_mpu/inv_mpu_timestamp.c   |  290 ++
 drivers/input/touchscreen/Kconfig             |    7 +
 drivers/input/touchscreen/Makefile            |    1 +
 drivers/input/touchscreen/egalax_i2c.c        | 1125 +++++++
 drivers/input/touchscreen/goodix.c            |    3 +
 drivers/net/usb/Kconfig                       |   22 +
 drivers/net/usb/Makefile                      |    1 +
 drivers/net/usb/qmi_wwan.c                    |    2 +
 drivers/net/usb/qmi_wwan_q.c                  | 2513 +++++++++++++++
 drivers/regulator/pca9450-regulator.c         |   25 +
 drivers/usb/misc/Kconfig                      |    6 +
 drivers/usb/misc/Makefile                     |    1 +
 drivers/usb/misc/usb5744.c                    |  152 +
 drivers/usb/serial/option.c                   |   40 +
 drivers/usb/serial/qcserial.c                 |    1 -
 drivers/usb/serial/usb_wwan.c                 |   12 +
 drivers/usb/typec/tcpm/tcpci.c                |    5 +
 include/linux/iio/imu/mpu.h                   |  125 +
 sound/soc/codecs/Kconfig                      |    8 +
 sound/soc/codecs/Makefile                     |    2 +
 sound/soc/codecs/tas5760.c                    |  469 +++
 sound/soc/codecs/tas5760.h                    |   72 +
 sound/soc/fsl/Kconfig                         |   12 +
 sound/soc/fsl/Makefile                        |    2 +
 sound/soc/fsl/imx-tas5760.c                   |  236 ++
 69 files changed, 24547 insertions(+), 9 deletions(-)
 create mode 100644 arch/arm64/boot/dts/freescale/imx8mp-ai-robot-auo-lvds-panel.dts
 create mode 100644 arch/arm64/boot/dts/freescale/imx8mp-ai-robot-boe-lvds-panel.dts
 create mode 100644 arch/arm64/boot/dts/freescale/imx8mp-ai-robot-powertip-lvds-panel.dts
 create mode 100644 arch/arm64/boot/dts/freescale/imx8mp-ai-robot-rk070cu05h.dts
 create mode 100644 arch/arm64/boot/dts/freescale/imx8mp-ai-robot-root.dts
 create mode 100644 arch/arm64/boot/dts/freescale/imx8mp-ai-robot.dts
 create mode 100644 drivers/gpu/drm/panel/panel-rocktech-rk070cu05h.c
 create mode 100644 drivers/iio/imu/inv_mpu/Kconfig
 create mode 100644 drivers/iio/imu/inv_mpu/Makefile
 create mode 100644 drivers/iio/imu/inv_mpu/README
 create mode 100644 drivers/iio/imu/inv_mpu/dmp_support/inv_mpu_misc.c
 create mode 100644 drivers/iio/imu/inv_mpu/iam20680/inv_mpu_core_20680.c
 create mode 100644 drivers/iio/imu/inv_mpu/iam20680/inv_mpu_iio_reg_20680.h
 create mode 100644 drivers/iio/imu/inv_mpu/iam20680/inv_mpu_init_20680.c
 create mode 100644 drivers/iio/imu/inv_mpu/iam20680/inv_mpu_parsing_20680.c
 create mode 100644 drivers/iio/imu/inv_mpu/iam20680/inv_mpu_selftest_20680.c
 create mode 100644 drivers/iio/imu/inv_mpu/iam20680/inv_mpu_setup_20680.c
 create mode 100644 drivers/iio/imu/inv_mpu/icm20648/dmp3Default.h
 create mode 100644 drivers/iio/imu/inv_mpu/icm20648/inv_mpu_core.c
 create mode 100644 drivers/iio/imu/inv_mpu/icm20648/inv_mpu_dmp_fifo.c
 create mode 100644 drivers/iio/imu/inv_mpu/icm20648/inv_mpu_iio_reg_20648.h
 create mode 100644 drivers/iio/imu/inv_mpu/icm20648/inv_mpu_init.c
 create mode 100644 drivers/iio/imu/inv_mpu/icm20648/inv_mpu_load_dmp.c
 create mode 100644 drivers/iio/imu/inv_mpu/icm20648/inv_mpu_parsing.c
 create mode 100644 drivers/iio/imu/inv_mpu/icm20648/inv_mpu_selftest.c
 create mode 100644 drivers/iio/imu/inv_mpu/icm20648/inv_mpu_setup.c
 create mode 100644 drivers/iio/imu/inv_mpu/icm20648/inv_slave_als.c
 create mode 100644 drivers/iio/imu/inv_mpu/icm20648/inv_slave_compass.c
 create mode 100644 drivers/iio/imu/inv_mpu/icm20648/inv_slave_pressure.c
 create mode 100644 drivers/iio/imu/inv_mpu/inv_mpu_common.c
 create mode 100644 drivers/iio/imu/inv_mpu/inv_mpu_dts.c
 create mode 100644 drivers/iio/imu/inv_mpu/inv_mpu_dts.h
 create mode 100644 drivers/iio/imu/inv_mpu/inv_mpu_i2c.c
 create mode 100644 drivers/iio/imu/inv_mpu/inv_mpu_iio.h
 create mode 100644 drivers/iio/imu/inv_mpu/inv_mpu_ring.c
 create mode 100644 drivers/iio/imu/inv_mpu/inv_mpu_spi.c
 create mode 100644 drivers/iio/imu/inv_mpu/inv_mpu_timestamp.c
 create mode 100644 drivers/input/touchscreen/egalax_i2c.c
 create mode 100644 drivers/net/usb/qmi_wwan_q.c
 create mode 100644 drivers/usb/misc/usb5744.c
 create mode 100644 include/linux/iio/imu/mpu.h
 create mode 100644 sound/soc/codecs/tas5760.c
 create mode 100644 sound/soc/codecs/tas5760.h
 create mode 100644 sound/soc/fsl/imx-tas5760.c

diff --git a/arch/arm64/boot/dts/freescale/Makefile b/arch/arm64/boot/dts/freescale/Makefile
index 9a7319c6b4e3..a625f3a3e69b 100644
--- a/arch/arm64/boot/dts/freescale/Makefile
+++ b/arch/arm64/boot/dts/freescale/Makefile
@@ -119,6 +119,8 @@ dtb-$(CONFIG_ARCH_MXC) += imx8mp-phyboard-pollux-rdk.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk.dtb imx8mq-evk-rpmsg.dtb imx8mp-ab2.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mp-ddr4-evk.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-ndm.dtb
+dtb-$(CONFIG_ARCH_MXC) += imx8mp-ai-robot.dtb imx8mp-ai-robot-root.dtb imx8mp-ai-robot-powertip-lvds-panel.dtb \
+			  imx8mp-ai-robot-rk070cu05h.dtb imx8mp-ai-robot-auo-lvds-panel.dtb imx8mp-ai-robot-boe-lvds-panel.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk.dtb imx8mq-evk-rpmsg.dtb imx8mq-evk-pcie1-m2.dtb imx8mq-evk-usd-wifi.dtb \
 			  imx8mq-evk-usdhc2-m2.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk-ak4497.dtb imx8mq-evk-audio-tdm.dtb imx8mq-evk-pdm.dtb
diff --git a/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-auo-lvds-panel.dts b/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-auo-lvds-panel.dts
new file mode 100644
index 000000000000..8e6106aa016a
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-auo-lvds-panel.dts
@@ -0,0 +1,37 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ *copyright 2022 NXP
+ */
+ 
+#include "imx8mp-ai-robot.dts"
+ 
+/ {
+	lvds0_panel {
+		compatible = "auo,g133han01";
+		backlight = <&lvds_backlight>;
+		port {
+			panel_lvds_in: endpoint {
+				remote-endpoint = <&lvds_out>;
+			};
+		};
+	};
+};
+ 
+/delete-node/ &lvds_bridge;
+ 
+&ldb {
+	fsl,dual-channel;
+	lvds-channel@0 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <24>;
+		/delete-node/ port@1;
+
+		port@1 {
+			reg = <1>;
+
+			lvds_out: endpoint {
+				remote-endpoint = <&panel_lvds_in>;
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-boe-lvds-panel.dts b/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-boe-lvds-panel.dts
new file mode 100644
index 000000000000..5b5a3cfa76cf
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-boe-lvds-panel.dts
@@ -0,0 +1,48 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ *copyright 2022 NXP
+ */
+ 
+#include "imx8mp-ai-robot.dts"
+
+/ {
+	lvds0_panel {
+		compatible = "boe,ev121wxm-n10";
+		backlight = <&lvds_backlight>;
+		port {
+			panel_lvds_in: endpoint {
+				remote-endpoint = <&lvds_out>;
+			};
+		};
+	};
+};
+
+/delete-node/ &lvds_bridge;
+
+&ldb {
+	lvds-channel@0 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <24>;
+		 /delete-node/ port@1;
+
+			port@1 {
+			reg = <1>;
+			lvds_out: endpoint {
+				 remote-endpoint = <&panel_lvds_in>;
+			};
+		 };
+	 };
+};
+
+&i2c3 {
+	egalax_i2c@2a {
+		compatible = "eeti,egalax_i2c";
+		reg = <0x2a>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_goodix_touch>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <12 8>;
+		int-gpios = <&gpio1 12 0>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-powertip-lvds-panel.dts b/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-powertip-lvds-panel.dts
new file mode 100644
index 000000000000..4517035f95af
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-powertip-lvds-panel.dts
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ *copyright 2022 NXP
+ */
+ 
+#include "imx8mp-ai-robot.dts"
+ 
+/ {
+	lvds0_panel {
+		compatible = "powertip,sh102768T001";
+		backlight = <&lvds_backlight>;
+		port {
+			panel_lvds_in: endpoint {
+			remote-endpoint = <&lvds_out>;
+			};
+		};
+	};
+};
+ 
+/delete-node/ &lvds_bridge;
+ 
+&ldb {
+	lvds-channel@0 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <24>;
+		
+		/delete-node/ port@1;
+
+		port@1 {
+			reg = <1>;
+			lvds_out: endpoint {
+			remote-endpoint = <&panel_lvds_in>;
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-rk070cu05h.dts b/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-rk070cu05h.dts
new file mode 100644
index 000000000000..01dd6710e4ca
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-rk070cu05h.dts
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2022 NXP
+ */
+
+#include "imx8mp-ai-robot.dts"
+
+&adv_bridge {
+	status = "disabled";
+};
+
+&mipi_dsi {
+	panel@0 {
+		compatible = "rocktech,rk070cu05h";
+		reg = <0>;
+		pinctrl-0 = <&pinctrl_mipi_dsi_en>;
+		reset-gpio = <&gpio5 1 GPIO_ACTIVE_LOW>;
+		enable-gpios = <&gpio4 29 GPIO_ACTIVE_HIGH>;
+		backlight = <&dsi_backlight>;
+		dsi-lanes = <4>;
+		video-mode = <2>;   /* 0: burst mode
+				 * 1: non-burst mode with sync event
+				 * 2: non-burst mode with sync pulse
+				 */
+		status = "okay";
+	};
+};
+
+&i2c3 {
+	touchscreen@5d {
+		compatible = "goodix,gt911";
+		reg = <0x5d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_goodix_touch>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <12 IRQ_TYPE_EDGE_FALLING>;
+		irq-gpios = <&gpio1 12 GPIO_ACTIVE_HIGH>;
+		reset-gpios = <&gpio1 1 GPIO_ACTIVE_HIGH>;
+		/*  load-firmware;
+		*   boolean variable, selected if want
+		*   to load goodix_911_cfg.bin
+		*/
+		status = "okay";
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-root.dts b/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-root.dts
new file mode 100644
index 000000000000..f61042dca32b
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mp-ai-robot-root.dts
@@ -0,0 +1,97 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2019 NXP
+ */
+
+#include "imx8mp-ai-robot.dts"
+
+/ {
+	interrupt-parent = <&gic>;
+
+	resmem: reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+	};
+};
+
+&cpu_pd_wait {
+	/delete-property/ compatible;
+};
+
+&clk {
+	init-on-array = <IMX8MP_CLK_USDHC3_ROOT
+			 IMX8MP_CLK_NAND_USDHC_BUS
+			 IMX8MP_CLK_HSIO_ROOT
+			 IMX8MP_CLK_UART4_ROOT>;
+};
+
+&{/busfreq} {
+	status = "disabled";
+};
+
+&{/reserved-memory} {
+	jh_reserved: jh@fdc00000 {
+		no-map;
+		reg = <0 0xfdc00000 0x0 0x400000>;
+	};
+
+	loader_reserved: loader@fdb00000 {
+		no-map;
+		reg = <0 0xfdb00000 0x0 0x00100000>;
+	};
+
+	ivshmem_reserved: ivshmem@fda00000 {
+		no-map;
+		reg = <0 0xfda00000 0x0 0x00100000>;
+	};
+
+	ivshmem2_reserved: ivshmem2@fd900000 {
+		no-map;
+		reg = <0 0xfd900000 0x0 0x00100000>;
+	};
+
+	pci_reserved: pci@fd700000 {
+		no-map;
+		reg = <0 0xfd700000 0x0 0x00200000>;
+	};
+
+	inmate_reserved: inmate@c0000000 {
+		no-map;
+		reg = <0 0xc0000000 0x0 0x3d700000>;
+	};
+};
+
+&iomuxc {
+	pinctrl_uart4: uart4grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART4_RXD__UART4_DCE_RX	0x140
+			MX8MP_IOMUXC_UART4_TXD__UART4_DCE_TX	0x140
+		>;
+	};
+};
+
+&usdhc3 {
+	status = "disabled";
+};
+
+&uart4 {
+	/delete-property/ dmas;	
+	/delete-property/ dma-names;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4>;
+	status = "disabled";
+};
+
+&uart1 {
+	/* uart4 is used by the 2nd OS, so configure pin and clk */
+	pinctrl-0 = <&pinctrl_uart1>, <&pinctrl_uart4>;
+	assigned-clocks = <&clk IMX8MP_CLK_UART4>;
+	assigned-clock-parents = <&clk IMX8MP_CLK_24M>;
+};
+
+&usdhc2 {
+	pinctrl-0 = <&pinctrl_usdhc3>, <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc3>, <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc3>, <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+};
diff --git a/arch/arm64/boot/dts/freescale/imx8mp-ai-robot.dts b/arch/arm64/boot/dts/freescale/imx8mp-ai-robot.dts
new file mode 100644
index 000000000000..b30215f20e19
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mp-ai-robot.dts
@@ -0,0 +1,1456 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2022 NXP
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/usb/pd.h>
+#include "imx8mp.dtsi"
+
+/ {
+	model = "NXP i.MX8MPlus AI Robot board";
+	compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
+
+	chosen {
+		stdout-path = &uart1;
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_led>;
+
+		status {
+			label = "yellow:status";
+			gpios = <&gpio3 16 GPIO_ACTIVE_HIGH>;
+			default-state = "on";
+		};
+	};
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0x0 0x40000000 0 0xc0000000>,
+		      <0x1 0x00000000 0 0xc0000000>;
+	};
+
+	reg_can1_stby: regulator-can1-stby {
+		compatible = "regulator-fixed";
+		regulator-name = "can1-stby";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_flexcan1_reg>;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio4 23 GPIO_ACTIVE_HIGH>;
+		enable-active-low;
+	};
+
+	reg_usb1_vhub_3v3: regulator-usb1-vhub_3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "usb1_vhub_3v3";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_usb1_vhub>;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio3 14 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	reg_usb1_vhub_1v8: regulator-usb1-vhub_1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "usb1_vhub_1v8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	usdhc1_pwrseq: usdhc1_pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_usdhc1_gpio>;
+		reset-gpios = <&gpio3 9 GPIO_ACTIVE_LOW>;
+	};
+
+	reg_m2_pwren: regulator-pcie {
+		compatible = "regulator-fixed";
+		regulator-name = "VPCIE_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio5 0 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	sound-tas5760 {
+		compatible = "fsl,imx-audio-tas5760";
+		model = "tas5760-audio";
+		audio-cpu = <&sai2>;
+		audio-codec = <&tweeter>;
+		tas5760,pdn-gpio = <&gpio5 21 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx-audio-hdmi";
+		model = "audio-hdmi";
+		audio-cpu = <&aud2htx>;
+		hdmi-out;
+		constraint-rate = <44100>,
+				<88200>,
+				<176400>,
+				<32000>,
+				<48000>,
+				<96000>,
+				<192000>;
+		status = "okay";
+	};
+
+	sound-micfil {
+		compatible = "fsl,imx-audio-card";
+		model = "imx-audio-micfil";
+		pri-dai-link {
+			link-name = "micfil hifi";
+			format = "i2s";
+			cpu {
+				sound-dai = <&micfil>;
+			};
+		};
+	};
+
+	sound-xcvr {
+		compatible = "fsl,imx-audio-card";
+		model = "imx-audio-xcvr";
+		pri-dai-link {
+			link-name = "XCVR PCM";
+			cpu {
+				sound-dai = <&xcvr>;
+			};
+		};
+	};
+
+	lvds_backlight: lvds_backlight {
+		compatible = "pwm-backlight";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_bl_power>;
+		pwms = <&pwm1 0 100000>;
+		status = "okay";
+
+		brightness-levels = < 0  1  2  3  4  5  6  7  8  9
+				     10 11 12 13 14 15 16 17 18 19
+				     20 21 22 23 24 25 26 27 28 29
+				     30 31 32 33 34 35 36 37 38 39
+				     40 41 42 43 44 45 46 47 48 49
+				     50 51 52 53 54 55 56 57 58 59
+				     60 61 62 63 64 65 66 67 68 69
+				     70 71 72 73 74 75 76 77 78 79
+				     80 81 82 83 84 85 86 87 88 89
+				     90 91 92 93 94 95 96 97 98 99
+				    100>;
+		default-brightness-level = <80>;
+		enable-gpios = <&gpio5 5 GPIO_ACTIVE_HIGH>;
+	};
+
+	dsi_backlight: dsi_backlight {
+        compatible = "pwm-backlight";
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_dsi_bl_en>;
+        pwms = <&pwm3 0 100000>;
+        status = "okay";
+
+        brightness-levels = < 0  1  2  3  4  5  6  7  8  9
+                     10 11 12 13 14 15 16 17 18 19
+                     20 21 22 23 24 25 26 27 28 29
+                     30 31 32 33 34 35 36 37 38 39
+                     40 41 42 43 44 45 46 47 48 49
+                     50 51 52 53 54 55 56 57 58 59
+                     60 61 62 63 64 65 66 67 68 69
+                     70 71 72 73 74 75 76 77 78 79
+                     80 81 82 83 84 85 86 87 88 89
+                     90 91 92 93 94 95 96 97 98 99
+                    100>;
+        default-brightness-level = <80>;
+        enable-gpios = <&gpio1 9 GPIO_ACTIVE_HIGH>;
+    };
+
+	cbtl04gp {
+		compatible = "nxp,cbtl04gp";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_typec_mux>;
+		switch-gpios = <&gpio1 7 GPIO_ACTIVE_LOW>;
+		orientation-switch;
+
+		port {
+			usb3_data_ss: endpoint {
+				remote-endpoint = <&typec_con_ss>;
+			};
+		};
+	};
+};
+
+&A53_0 {
+	cpu-supply = <&buck2>;
+};
+
+&A53_1 {
+	cpu-supply = <&buck2>;
+};
+
+&A53_2 {
+	cpu-supply = <&buck2>;
+};
+
+&A53_3 {
+	cpu-supply = <&buck2>;
+};
+
+&dsp {
+	status = "okay";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm2>;
+	status = "okay";
+};
+
+&pwm3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm3>;
+	status = "okay";
+};
+
+&aud2htx {
+	status = "okay";
+};
+
+&ecspi1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	fsl,spi-num-chipselects = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1 &pinctrl_ecspi1_cs>;
+	cs-gpios = <&gpio5 9 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&ecspi2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	fsl,spi-num-chipselects = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi2 &pinctrl_ecspi2_cs>;
+	cs-gpios = <&gpio5 13 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&eqos {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_eqos>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy0>;
+	snps,force_thresh_dma_mode;
+	snps,mtl-tx-config = <&mtl_tx_setup>;
+	snps,mtl-rx-config = <&mtl_rx_setup>;
+	status = "okay";
+
+	mdio {
+		compatible = "snps,dwmac-mdio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <1>;
+			eee-broken-1000t;
+			realtek,aldps-enable;
+			realtek,clkout-disable;
+		};
+		ethphy1: ethernet-phy@2 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <2>;
+			eee-broken-1000t;
+			realtek,clkout-disable;
+		};
+	};
+	mtl_tx_setup: tx-queues-config {
+		snps,tx-queues-to-use = <5>;
+		snps,tx-sched-sp;
+		queue0 {
+			snps,dcb-algorithm;
+			snps,priority = <0x1>;
+		};
+		queue1 {
+			snps,dcb-algorithm;
+			snps,priority = <0x2>;
+		};
+		queue2 {
+			snps,dcb-algorithm;
+			snps,priority = <0x4>;
+		};
+		queue3 {
+			snps,dcb-algorithm;
+			snps,priority = <0x8>;
+		};
+		queue4 {
+			snps,dcb-algorithm;
+			snps,priority = <0xf0>;
+		};
+	};
+	mtl_rx_setup: rx-queues-config {
+		snps,rx-queues-to-use = <5>;
+		snps,rx-sched-sp;
+		queue0 {
+			snps,dcb-algorithm;
+			snps,priority = <0x1>;
+			snps,map-to-dma-channel = <0>;
+		};
+		queue1 {
+			snps,dcb-algorithm;
+			snps,priority = <0x2>;
+			snps,map-to-dma-channel = <1>;
+		};
+		queue2 {
+			snps,dcb-algorithm;
+			snps,priority = <0x4>;
+			snps,map-to-dma-channel = <2>;
+		};
+		queue3 {
+			snps,dcb-algorithm;
+			snps,priority = <0x8>;
+			snps,map-to-dma-channel = <3>;
+		};
+		queue4 {
+			snps,dcb-algorithm;
+			snps,priority = <0xf0>;
+			snps,map-to-dma-channel = <4>;
+		};
+	};
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy1>;
+	fsl,magic-packet;
+	status = "okay";
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	xceiver-supply = <&reg_can1_stby>;
+	status = "okay";
+};
+
+&i2c1 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic@25 {
+		compatible = "nxp,pca9450c";
+		reg = <0x25>;
+		pinctrl-names = "default";
+		level-trans-force-en;
+		pinctrl-0 = <&pinctrl_pmic>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+
+		regulators {
+			buck1: BUCK1 {
+				regulator-name = "BUCK1";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2187500>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <3125>;
+			};
+
+			buck2: BUCK2 {
+				regulator-name = "BUCK2";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2187500>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <3125>;
+				nxp,dvs-run-voltage = <950000>;
+				nxp,dvs-standby-voltage = <850000>;
+			};
+
+			buck4: BUCK4{
+				regulator-name = "BUCK4";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck5: BUCK5{
+				regulator-name = "BUCK5";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck6: BUCK6 {
+				regulator-name = "BUCK6";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo1: LDO1 {
+				regulator-name = "LDO1";
+				regulator-min-microvolt = <1600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo2: LDO2 {
+				regulator-name = "LDO2";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo3: LDO3 {
+				regulator-name = "LDO3";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo4: LDO4 {
+				regulator-name = "LDO4";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo5: LDO5 {
+				regulator-name = "LDO5";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+	pcf8563: rtc@51 {
+		compatible = "nxp,pcf8563";
+		reg = <0x51>;
+		#clock-cells = <0>;
+		status = "okay";
+	};
+
+	usb5744_hub: 4_hub@2d {
+		compatible = "smsc,usb5744";
+		reg = <0x2d>;
+		reset-gpios = <&gpio4 31 GPIO_ACTIVE_LOW>;
+		initial-mode = <1>;
+		status = "okay";
+
+		ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0{
+			reg = <0>;
+			usb0: endpoint {
+				remote-endpoint = <&usb0_sw>;
+			};
+		};
+
+		port@1{
+			reg = <1>;
+			usb1: endpoint {
+				remote-endpoint = <&usb1_sw>;
+			};
+		};
+
+		port@2{
+			reg = <2>;
+			usb2: endpoint {
+				remote-endpoint = <&usb2_sw>;
+			};
+		};
+
+		port@3{
+			reg = <3>;
+			usb3: endpoint {
+				remote-endpoint = <&usb3_sw>;
+			};
+		};
+		};
+	};
+
+	icm20689_imu: accelerometer@68 {
+		compatible = "invensense,icm20648";
+		reg = <0x68>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_imu>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <8 IRQ_TYPE_EDGE_RISING>;
+		axis_map_x = <1>;
+		axis_map_y = <0>;
+		axis_map_z = <2>;
+		negate_x = <1>;
+		negate_y = <0>;
+		negate_z = <0>;
+		inven,secondary_axis_map_x = <1>;
+		inven,secondary_axis_map_y = <0>;
+		inven,secondary_axis_map_z = <2>;
+		inven,secondary_negate_x = <0>;
+		inven,secondary_negate_y = <0>;
+		inven,secondary_negate_z = <1>;
+		inven,secondary_type = "compass";
+		inven,secondary_name = "ak09916";
+		inven,secondary_reg = <0x0c>;
+		inven,aux_type = "none";
+		inven,read_only_slave_type = "none";
+		status = "okay";
+	};
+
+	lvds_bridge: lvds-to-hdmi-bridge@4c {
+		compatible = "ite,it6263";
+		reg = <0x4c>;
+
+		port {
+			it6263_in: endpoint {
+				remote-endpoint = <&lvds_out>;
+			};
+		};
+	};
+
+	ar1335_0: ar1335_mipi@36 {
+		compatible = "onsemi,ar1335";
+		reg = <0x36>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_csi0_pwn>, <&pinctrl_csi0_rst>, <&pinctrl_csi_mclk>;
+		clocks = <&clk IMX8MP_CLK_IPP_DO_CLKO2>;
+		clock-names = "csi_mclk";
+		assigned-clocks = <&clk IMX8MP_CLK_IPP_DO_CLKO2>;
+		assigned-clock-parents = <&clk IMX8MP_CLK_24M>;
+		assigned-clock-rates = <24000000>;
+		csi_id = <0>;
+		pwn-gpios = <&gpio4 18 GPIO_ACTIVE_HIGH>;
+		rst-gpios = <&gpio4 20 GPIO_ACTIVE_LOW>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+		mipi_csi;
+		status = "okay";
+
+		port {
+			ar1335_mipi_0_ep: endpoint {
+				remote-endpoint = <&mipi_csi0_ep>;
+				data-lanes = <1 2 3 4>;
+				clock-lanes = <0>;
+			};
+		};
+	};
+
+	ptn5110: tcpc@50 {
+		compatible = "nxp,ptn5110";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_typec>;
+		reg = <0x50>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <7 8>;
+		status = "okay";
+
+		port {
+			typec_dr_sw: endpoint {
+				remote-endpoint = <&usb3_drd_sw>;
+			};
+		};
+
+		usb_con: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			power-role = "dual";
+			data-role = "dual";
+			try-power-role = "sink";
+			source-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+			sink-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)
+				     PDO_VAR(5000, 20000, 3000)>;
+			op-sink-microwatt = <15000000>;
+			self-powered;
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@1 {
+					reg = <1>;
+					typec_con_ss: endpoint {
+						remote-endpoint = <&usb3_data_ss>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&i2c3 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+
+	adv_bridge: adv7535@3d {
+		compatible = "adi,adv7533";
+		reg = <0x3d>;
+		adi,addr-cec = <0x3b>;
+		adi,dsi-lanes = <4>;
+		status = "okay";
+
+		port {
+			adv7535_from_dsim: endpoint {
+				remote-endpoint = <&dsim_to_adv7535>;
+			};
+		};
+	};
+
+	tweeter: tas5760_tweeter@6d {
+		compatible = "ti,tas5760";
+		reg = <0x6d>;
+		status = "okay";
+	};
+};
+
+&irqsteer_hdmi {
+	status = "okay";
+};
+
+&hdmi_blk_ctrl {
+	status = "okay";
+};
+
+&hdmi_pavi {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&hdmiphy {
+	status = "okay";
+};
+
+&lcdif1 {
+	status = "okay";
+};
+
+&lcdif2 {
+	status = "okay";
+};
+
+&lcdif3 {
+	status = "okay";
+};
+
+&ldb {
+	status = "okay";
+
+	lvds-channel@0 {
+		fsl,data-mapping = "jeida";
+		fsl,data-width = <24>;
+		status = "okay";
+
+		port@1 {
+			reg = <1>;
+
+			lvds_out: endpoint {
+				remote-endpoint = <&it6263_in>;
+			};
+		};
+	};
+};
+
+&ldb_phy {
+	status = "okay";
+};
+
+&mipi_dsi {
+	status = "okay";
+
+	port@1 {
+		dsim_to_adv7535: endpoint {
+			remote-endpoint = <&adv7535_from_dsim>;
+			attach-bridge;
+		};
+	};
+};
+
+&snvs_pwrkey {
+	status = "okay";
+};
+
+&micfil {
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pdm>;
+	assigned-clocks = <&clk IMX8MP_CLK_PDM>;
+	assigned-clock-parents = <&clk IMX8MP_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <196608000>;
+	status = "okay";
+};
+
+&pcie{
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie>;
+	reset-gpio = <&gpio4 28 GPIO_ACTIVE_LOW>;
+	ext_osc = <0>;
+	clocks = <&clk IMX8MP_CLK_HSIO_ROOT>,
+		 <&clk IMX8MP_CLK_PCIE_AUX>,
+		 <&clk IMX8MP_CLK_HSIO_AXI>,
+		 <&clk IMX8MP_CLK_PCIE_ROOT>;
+	clock-names = "pcie", "pcie_aux", "pcie_phy", "pcie_bus";
+	assigned-clocks = <&clk IMX8MP_CLK_HSIO_AXI>,
+			  <&clk IMX8MP_CLK_PCIE_AUX>;
+	assigned-clock-rates = <500000000>, <10000000>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_500M>,
+				 <&clk IMX8MP_SYS_PLL2_50M>;
+	l1ss-disabled;
+	status = "okay";
+
+	wifi_wake_host {
+		compatible = "nxp,wifi-wake-host";
+		interrupt-parent = <&gpio5>;
+		interrupts = <21 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-names = "host-wake";
+	};	
+};
+
+&pcie_ep{
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie>;
+	ext_osc = <0>;
+	clocks = <&clk IMX8MP_CLK_HSIO_ROOT>,
+		 <&clk IMX8MP_CLK_PCIE_AUX>,
+		 <&clk IMX8MP_CLK_HSIO_AXI>,
+		 <&clk IMX8MP_CLK_PCIE_ROOT>;
+	clock-names = "pcie", "pcie_aux", "pcie_phy", "pcie_bus";
+	assigned-clocks = <&clk IMX8MP_CLK_HSIO_AXI>,
+			  <&clk IMX8MP_CLK_PCIE_AUX>;
+	assigned-clock-rates = <500000000>, <10000000>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_500M>,
+				 <&clk IMX8MP_SYS_PLL2_50M>;
+	status = "disabled";
+};
+
+&pcie_phy{
+	ext_osc = <0>;
+	status = "okay";
+};
+
+&sai2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai2>;
+	assigned-clocks = <&clk IMX8MP_CLK_SAI2>;
+	assigned-clock-parents = <&clk IMX8MP_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <12288000>;
+	status = "okay";
+};
+
+&xcvr {
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&sdma2 {
+	status = "okay";
+};
+
+&uart1 { /* A53 console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&uart2 {
+	/* RS485 */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	linux,rs485-enabled-at-boot-time;
+	rs485-rts-active-high;
+	fsl,uart-has-rtscts;
+	rts-gpio = <&gpio4 30 0>;
+	status = "okay";
+};
+
+&uart3 { /* BT */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	assigned-clocks = <&clk IMX8MP_CLK_UART3>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+&uart4 { /*M7 console */	
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4>;
+	status = "okay";
+};
+
+&usb3_phy0 {
+	vbus-power-supply = <&ptn5110>;
+	fsl,phy-tx-vref-tune = <0xe>;
+	fsl,phy-tx-preemp-amp-tune = <3>;
+	fsl,phy-tx-vboost-level = <5>;
+	fsl,phy-comp-dis-tune = <7>;
+	fsl,pcs-tx-deemph-3p5db = <0x21>;
+	fsl,phy-pcs-tx-swing-full = <0x7f>;
+	status = "okay";
+};
+
+&usb3_0 {
+	status = "okay";
+};
+
+&usb_dwc3_0 {
+	dr_mode = "otg";
+	hnp-disable;
+	srp-disable;
+	adp-disable;
+	usb-role-switch;
+	role-switch-default-mode = "none";
+	snps,dis-u1-entry-quirk;
+	snps,dis-u2-entry-quirk;
+	status = "okay";
+
+	port {
+		usb3_drd_sw: endpoint {
+			remote-endpoint = <&typec_dr_sw>;
+		};
+	};
+};
+
+&usb3_phy1 {
+	fsl,phy-tx-preemp-amp-tune = <3>;
+	fsl,phy-tx-vref-tune = <0xb>;
+	status = "okay";
+};
+
+&usb3_1 {
+	status = "okay";
+};
+
+&usb_dwc3_1 {
+	dr_mode = "host";
+	status = "okay";
+
+	port@0 {
+		usb0_sw: endpoint {
+		remote-endpoint = <&usb0>;
+		};
+	};
+
+	port@1 {
+		usb1_sw: endpoint {
+		remote-endpoint = <&usb1>;
+		};
+	};
+
+	port@2 {
+		usb2_sw: endpoint {
+		remote-endpoint = <&usb2>;
+		};
+	};
+
+	port@3 {
+		usb3_sw: endpoint {
+		remote-endpoint = <&usb3>;
+		};
+	};
+
+};
+
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1>, <&pinctrl_wlan>;
+	pinctrl-1 = <&pinctrl_usdhc1_100mhz>, <&pinctrl_wlan>;
+	pinctrl-2 = <&pinctrl_usdhc1_200mhz>, <&pinctrl_wlan>;
+	vmmc-supply = <&reg_m2_pwren>;
+	mmc-pwrseq = <&usdhc1_pwrseq>;
+	bus-width = <4>;
+	pm-ignore-notify;
+	keep-power-in-suspend;
+	non-removable;
+	cap-power-off-card;
+	status = "okay";
+};
+
+&usdhc2 {
+	assigned-clocks = <&clk IMX8MP_CLK_USDHC2>;
+	assigned-clock-rates = <400000000>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+	cd-gpios = <&gpio2 12 GPIO_ACTIVE_LOW>;
+	vmmc-supply = <&reg_m2_pwren>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&usdhc3 {
+	assigned-clocks = <&clk IMX8MP_CLK_USDHC3>;
+	assigned-clock-rates = <400000000>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&wdog1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_wdog>;
+	fsl,ext-reset-output;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	pinctrl_hog: hoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_HDMI_DDC_SCL__HDMIMIX_HDMI_SCL	0x400001c2
+			MX8MP_IOMUXC_HDMI_DDC_SDA__HDMIMIX_HDMI_SDA	0x400001c2
+			MX8MP_IOMUXC_HDMI_HPD__HDMIMIX_HDMI_HPD		0x40000010
+			MX8MP_IOMUXC_HDMI_CEC__HDMIMIX_HDMI_CEC		0x40000010
+		>;
+	};
+
+	pinctrl_pwm1: pwm1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO08__PWM1_OUT	0x116
+		>;
+	};
+
+	pinctrl_pwm2: pwm2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO11__PWM2_OUT	0x116
+		>;
+	};
+
+	pinctrl_pwm3: pwm3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO10__PWM3_OUT	0x116
+		>;
+	};
+
+	pinctrl_ecspi1: ecspi1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI1_SCLK__ECSPI1_SCLK		0x82
+			MX8MP_IOMUXC_ECSPI1_MOSI__ECSPI1_MOSI		0x82
+			MX8MP_IOMUXC_ECSPI1_MISO__ECSPI1_MISO		0x82
+		>;
+	};
+
+	pinctrl_ecspi1_cs: ecspi1cs {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI1_SS0__GPIO5_IO09	0x116
+		>;
+	};
+
+	pinctrl_ecspi2: ecspi2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI2_SCLK__ECSPI2_SCLK		0x82
+			MX8MP_IOMUXC_ECSPI2_MOSI__ECSPI2_MOSI		0x82
+			MX8MP_IOMUXC_ECSPI2_MISO__ECSPI2_MISO		0x82
+		>;
+	};
+
+	pinctrl_ecspi2_cs: ecspi2cs {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI2_SS0__GPIO5_IO13		0x40000
+		>;
+	};
+
+	pinctrl_eqos: eqosgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ENET_MDC__ENET_QOS_MDC		0x2
+			MX8MP_IOMUXC_ENET_MDIO__ENET_QOS_MDIO		0x2
+			MX8MP_IOMUXC_ENET_RD0__ENET_QOS_RGMII_RD0	0x90
+			MX8MP_IOMUXC_ENET_RD1__ENET_QOS_RGMII_RD1	0x90
+			MX8MP_IOMUXC_ENET_RD2__ENET_QOS_RGMII_RD2	0x90
+			MX8MP_IOMUXC_ENET_RD3__ENET_QOS_RGMII_RD3	0x90
+			MX8MP_IOMUXC_ENET_RXC__CCM_ENET_QOS_CLOCK_GENERATE_RX_CLK	0x90
+			MX8MP_IOMUXC_ENET_RX_CTL__ENET_QOS_RGMII_RX_CTL	0x90
+			MX8MP_IOMUXC_ENET_TD0__ENET_QOS_RGMII_TD0	0x16
+			MX8MP_IOMUXC_ENET_TD1__ENET_QOS_RGMII_TD1	0x16
+			MX8MP_IOMUXC_ENET_TD2__ENET_QOS_RGMII_TD2	0x16
+			MX8MP_IOMUXC_ENET_TD3__ENET_QOS_RGMII_TD3	0x16
+			MX8MP_IOMUXC_ENET_TX_CTL__ENET_QOS_RGMII_TX_CTL	0x16
+			MX8MP_IOMUXC_ENET_TXC__CCM_ENET_QOS_CLOCK_GENERATE_TX_CLK	0x16
+			MX8MP_IOMUXC_SAI1_RXC__GPIO4_IO01		0x10
+		>;
+	};
+
+	pinctrl_fec: fecgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_RXD4__ENET1_RGMII_RD0		0x90
+			MX8MP_IOMUXC_SAI1_RXD5__ENET1_RGMII_RD1		0x90
+			MX8MP_IOMUXC_SAI1_RXD6__ENET1_RGMII_RD2		0x90
+			MX8MP_IOMUXC_SAI1_RXD7__ENET1_RGMII_RD3		0x90
+			MX8MP_IOMUXC_SAI1_TXC__ENET1_RGMII_RXC		0x90
+			MX8MP_IOMUXC_SAI1_TXFS__ENET1_RGMII_RX_CTL	0x90
+			MX8MP_IOMUXC_SAI1_TXD0__ENET1_RGMII_TD0		0x16
+			MX8MP_IOMUXC_SAI1_TXD1__ENET1_RGMII_TD1		0x16
+			MX8MP_IOMUXC_SAI1_TXD2__ENET1_RGMII_TD2		0x16
+			MX8MP_IOMUXC_SAI1_TXD3__ENET1_RGMII_TD3		0x16
+			MX8MP_IOMUXC_SAI1_TXD4__ENET1_RGMII_TX_CTL	0x16
+			MX8MP_IOMUXC_SAI1_TXD5__ENET1_RGMII_TXC		0x16
+			MX8MP_IOMUXC_SAI1_RXFS__GPIO4_IO00		0x10
+		>;
+	};
+
+	pinctrl_flexcan1: flexcan1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SPDIF_RX__CAN1_RX          0x154
+			MX8MP_IOMUXC_SPDIF_TX__CAN1_TX          0x154
+		>;
+	};
+
+	pinctrl_flexcan1_reg: flexcan1reggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI2_RXD0__GPIO4_IO23	0x154	/* CAN1_STBY */
+		>;
+	};
+
+	pinctrl_bl_power: bl_power {
+		fsl,pins = <
+			MX8MP_IOMUXC_SPDIF_EXT_CLK__GPIO5_IO05  0x16
+		>;
+	};
+
+	pinctrl_mipi_dsi_en: mipi_dsi_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI3_TXD__GPIO5_IO01   0xd6
+			MX8MP_IOMUXC_SAI3_RXC__GPIO4_IO29   0x16
+		>;
+	};
+
+	pinctrl_dsi_bl_en: dsi_bl_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO09__GPIO1_IO09 0x16
+		>;
+	};
+
+	pinctrl_goodix_touch: goodix_touch {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO01__GPIO1_IO01 0x16
+			MX8MP_IOMUXC_GPIO1_IO12__GPIO1_IO12 0x16
+		>;
+	};
+
+	pinctrl_gpio_led: gpioledgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_READY_B__GPIO3_IO16	0x140
+		>;
+	};
+
+	pinctrl_i2c1: i2c1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C1_SCL__I2C1_SCL		0x400001c2
+			MX8MP_IOMUXC_I2C1_SDA__I2C1_SDA		0x400001c2
+		>;
+	};
+
+	pinctrl_i2c2: i2c2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C2_SCL__I2C2_SCL		0x400001c2
+			MX8MP_IOMUXC_I2C2_SDA__I2C2_SDA		0x400001c2
+		>;
+	};
+
+	pinctrl_i2c3: i2c3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C3_SCL__I2C3_SCL		0x400001c2
+			MX8MP_IOMUXC_I2C3_SDA__I2C3_SDA		0x400001c2
+		>;
+	};
+
+	pinctrl_pcie: pciegrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C4_SCL__PCIE_CLKREQ_B		0x60 /* open drain, pull up */
+			MX8MP_IOMUXC_SAI3_TXC__GPIO5_IO00		0x40
+			MX8MP_IOMUXC_SAI3_RXFS__GPIO4_IO28		0x40
+			MX8MP_IOMUXC_GPIO1_IO06__GPIO1_IO06		0x1c4
+		>;
+	};
+
+	pinctrl_pmic: pmicgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO03__GPIO1_IO03	0x000001c0
+		>;
+	};
+
+	pinctrl_imu: imugrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_DATA02__GPIO3_IO08    0x1c4
+		>;
+	};
+
+	pinctrl_pdm: pdmgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_RXC__AUDIOMIX_PDM_CLK		0xd6
+			MX8MP_IOMUXC_SAI5_RXD0__AUDIOMIX_PDM_BIT_STREAM00	0xd6
+			MX8MP_IOMUXC_SAI5_RXD1__AUDIOMIX_PDM_BIT_STREAM01	0xd6
+			MX8MP_IOMUXC_SAI5_RXD2__AUDIOMIX_PDM_BIT_STREAM02	0xd6
+			MX8MP_IOMUXC_SAI5_RXD3__AUDIOMIX_PDM_BIT_STREAM03	0xd6
+		>;
+	};
+
+	pinctrl_sai2: sai2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI2_MCLK__AUDIOMIX_SAI2_MCLK      0xd6
+			MX8MP_IOMUXC_SAI2_TXC__AUDIOMIX_SAI2_TX_BCLK    0xd6
+			MX8MP_IOMUXC_SAI2_TXFS__AUDIOMIX_SAI2_TX_SYNC   0xd6
+			MX8MP_IOMUXC_SAI2_TXD0__AUDIOMIX_SAI2_TX_DATA00 0xd6
+		>;
+	};
+
+	pinctrl_i2c2_synaptics_dsx_io: synaptics_dsx_iogrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO09__GPIO1_IO09		0x16
+		>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART1_RXD__UART1_DCE_RX	0x140
+			MX8MP_IOMUXC_UART1_TXD__UART1_DCE_TX	0x140
+		>;
+	};
+
+	pinctrl_typec: typec1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_DATA5__GPIO2_IO07	0x1c4
+		>;
+	};
+
+	pinctrl_typec_mux: typec1muxgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO07__GPIO1_IO07	0x16
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART2_RXD__UART2_DCE_RX	0x140
+			MX8MP_IOMUXC_UART2_TXD__UART2_DCE_TX    0x140
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_DATA7__UART3_DCE_RX		0x140
+			MX8MP_IOMUXC_SD1_DATA6__UART3_DCE_TX		0x140
+			MX8MP_IOMUXC_SD1_RESET_B__UART3_DCE_RTS		0x140
+			MX8MP_IOMUXC_SD1_STROBE__UART3_DCE_CTS		0x140
+		>;
+	};
+
+	pinctrl_uart4: uart4grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART4_RXD__UART4_DCE_RX	0x49
+			MX8MP_IOMUXC_UART4_TXD__UART4_DCE_TX	0x49
+		>;
+	};
+
+	pinctrl_usb1_vhub: usb1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_DQS__GPIO3_IO14	0x19
+		>;
+	};
+
+	pinctrl_usdhc1_gpio: usdhc1grp-gpio {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_DATA03__GPIO3_IO09    0x41
+		>;
+	};
+
+	pinctrl_usdhc1: usdhc1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_CLK__USDHC1_CLK        0x190
+			MX8MP_IOMUXC_SD1_CMD__USDHC1_CMD	0x1d0
+			MX8MP_IOMUXC_SD1_DATA0__USDHC1_DATA0    0x1d0
+			MX8MP_IOMUXC_SD1_DATA1__USDHC1_DATA1	0x1d0
+			MX8MP_IOMUXC_SD1_DATA2__USDHC1_DATA2	0x1d0
+			MX8MP_IOMUXC_SD1_DATA3__USDHC1_DATA3	0x1d0
+		>;
+	};
+
+	pinctrl_usdhc1_100mhz: usdhc1grp-100mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_CLK__USDHC1_CLK        0x194
+			MX8MP_IOMUXC_SD1_CMD__USDHC1_CMD	0x1d4
+			MX8MP_IOMUXC_SD1_DATA0__USDHC1_DATA0    0x1d4
+			MX8MP_IOMUXC_SD1_DATA1__USDHC1_DATA1	0x1d4
+			MX8MP_IOMUXC_SD1_DATA2__USDHC1_DATA2	0x1d4
+			MX8MP_IOMUXC_SD1_DATA3__USDHC1_DATA3	0x1d4
+		>;
+	};
+
+	pinctrl_usdhc1_200mhz: usdhc1grp-200mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_CLK__USDHC1_CLK        0x196
+			MX8MP_IOMUXC_SD1_CMD__USDHC1_CMD	0x1d6
+			MX8MP_IOMUXC_SD1_DATA0__USDHC1_DATA0    0x1d6
+			MX8MP_IOMUXC_SD1_DATA1__USDHC1_DATA1	0x1d6
+			MX8MP_IOMUXC_SD1_DATA2__USDHC1_DATA2	0x1d6
+			MX8MP_IOMUXC_SD1_DATA3__USDHC1_DATA3	0x1d6
+		>;
+	};
+
+	pinctrl_usdhc2_gpio: usdhc2grp-gpio {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CD_B__GPIO2_IO12 	0x1c4
+			MX8MP_IOMUXC_SD2_RESET_B__GPIO2_IO19	0x41
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x190
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d0
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d0
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d0
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d0
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d0
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT	0xc0
+		>;
+	};
+
+	pinctrl_usdhc2_100mhz: usdhc2-100mhzgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x194
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d4
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d4
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d4
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d4
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d4
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc0
+		>;
+	};
+
+	pinctrl_usdhc2_200mhz: usdhc2-200mhzgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x196
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d6
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d6
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d6
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d6
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d6
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc0
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x190
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d0
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d0
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d0
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d0
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d0
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d0
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d0
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d0
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d0
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x190
+		>;
+	};
+
+	pinctrl_usdhc3_100mhz: usdhc3-100mhzgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x194
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d4
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d4
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d4
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d4
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d4
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d4
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d4
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d4
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d4
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x194
+		>;
+	};
+
+	pinctrl_usdhc3_200mhz: usdhc3-200mhzgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x196
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d6
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d6
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d6
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d6
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d6
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d6
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d6
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d6
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d6
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x196
+		>;
+	};
+
+	pinctrl_wdog: wdoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO02__WDOG1_WDOG_B	0x166
+		>;
+	};
+
+	pinctrl_wlan: wlangrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO00__ANAMIX_REF_CLK_32K      0x141
+			MX8MP_IOMUXC_SD1_DATA4__GPIO2_IO06                0x111
+		>;
+	};
+
+	pinctrl_csi0_rst: csi0_rst_grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_MCLK__GPIO4_IO20	0x10
+		>;
+	};
+
+	pinctrl_csi0_pwn: csi0_pwn_grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_TXD6__GPIO4_IO18		0x10
+		>;
+	};
+
+	pinctrl_csi1_rst: csi1_rst_grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_RXD3__GPIO4_IO05	0x10
+		>;
+	};
+
+	pinctrl_csi1_pwn: csi1_pwn_grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_TXD7__GPIO4_IO19		0x10
+		>;
+	};
+
+	pinctrl_csi_mclk: csi_mclk_grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO15__CCM_CLKO2	0x50
+		>;
+	};
+};
+
+&vpu_g1 {
+	status = "okay";
+};
+
+&vpu_g2 {
+	status = "okay";
+};
+
+&vpu_vc8000e {
+	status = "okay";
+};
+
+&vpu_v4l2 {
+	status = "okay";
+};
+
+&gpu_3d {
+	status = "okay";
+};
+
+&gpu_2d {
+	status = "okay";
+};
+
+&ml_vipsi {
+	status = "okay";
+};
+
+&mix_gpu_ml {
+	status = "okay";
+};
+
+&mipi_csi_0 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	port@0 {
+		reg = <0>;
+		mipi_csi0_ep: endpoint {
+			remote-endpoint = <&ar1335_mipi_0_ep>;
+			data-lanes = <4>;
+			csis-hs-settle = <11>;
+			csis-clk-settle = <2>;
+			csis-wclk;
+		};
+	};
+};
+
+&cameradev {
+	status = "okay";
+};
+
+&isi_0 {
+	status = "disabled";
+
+	cap_device {
+		status = "okay";
+	};
+
+	m2m_device {
+		status = "okay";
+	};
+};
+
+&isi_1 {
+	status = "disabled";
+
+	cap_device {
+		status = "okay";
+	};
+};
+
+&isp_0 {
+	status = "okay";
+};
+
+&isp_1 {
+	status = "disabled";
+};
+
+&dewarp {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/freescale/imx8mp.dtsi b/arch/arm64/boot/dts/freescale/imx8mp.dtsi
index 7e71a112c618..b3561deffef9 100644
--- a/arch/arm64/boot/dts/freescale/imx8mp.dtsi
+++ b/arch/arm64/boot/dts/freescale/imx8mp.dtsi
@@ -214,10 +214,14 @@ dsp_vdev0buffer: vdev0buffer@94300000 {
 			no-map;
 		};
 
-		/* used only by tuning tool, can be removed for normal case */
-		isp0_reserved: isp0@94400000 {
+		isp0_reserved: isp0@B0000000 {
 			no-map;
-			reg = <0 0x94400000 0 0x10000000>;
+			reg = <0 0xB0000000 0 0x10000000>;
+		};
+
+		isp1_reserved: isp1@B0000000 {
+			no-map;
+			reg = <0 0xB0000000 0 0x10000000>;
 		};
 	};
 
@@ -1576,6 +1580,7 @@ isp_1: isp@32e20000 {
 					power-domains = <&ispdwp_pd>;
 					id = <1>;
 					gpr = <&media_blk_ctrl>;
+					memory-region = <&isp1_reserved>;
 					status = "disabled";
 				};
 
diff --git a/arch/arm64/configs/imx_v8_defconfig b/arch/arm64/configs/imx_v8_defconfig
index 97dc633d7800..7ed42b425c84 100644
--- a/arch/arm64/configs/imx_v8_defconfig
+++ b/arch/arm64/configs/imx_v8_defconfig
@@ -279,7 +279,7 @@ CONFIG_BCMGENET=m
 CONFIG_BNX2X=m
 CONFIG_MACB=y
 CONFIG_THUNDER_NIC_PF=y
-CONFIG_FEC=y
+CONFIG_FEC=m
 CONFIG_FEC_UIO=y
 CONFIG_FSL_FMAN=y
 CONFIG_FSL_DPAA_ETH=y
@@ -361,7 +361,8 @@ CONFIG_KEYBOARD_IMX_SC_PWRKEY=y
 CONFIG_KEYBOARD_CROS_EC=y
 CONFIG_INPUT_TOUCHSCREEN=y
 CONFIG_TOUCHSCREEN_ATMEL_MXT=m
-CONFIG_TOUCHSCREEN_GOODIX=m
+CONFIG_TOUCHSCREEN_GOODIX=y
+CONFIG_TOUCHSCREEN_EGALAX_I2C=y
 CONFIG_TOUCHSCREEN_EDT_FT5X06=m
 CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_I2C=m
 CONFIG_TOUCHSCREEN_EXC3000=m
@@ -576,6 +577,7 @@ CONFIG_DRM_PANEL_MANTIX_MLAF057WE51=m
 CONFIG_DRM_PANEL_ONTAT_KD50G21_40NT_A1=y
 CONFIG_DRM_PANEL_RAYDIUM_RM67191=y
 CONFIG_DRM_PANEL_RAYDIUM_RM68200=y
+CONFIG_DRM_PANEL_ROCKTECH_RK070CU05H=y
 CONFIG_DRM_PANEL_ROCKTECK_HIMAX8394F=y
 CONFIG_DRM_PANEL_SEIKO_43WVF1G=y
 CONFIG_DRM_PANEL_SITRONIX_ST7703=m
@@ -649,6 +651,8 @@ CONFIG_SND_SOC_FSL_XCVR=m
 CONFIG_SND_SOC_FSL_ESAI_CLIENT=y
 CONFIG_SND_SOC_FSL_RPMSG=m
 CONFIG_SND_IMX_SOC=m
+CONFIG_SND_SOC_TAS5760=m
+CONFIG_SND_SOC_IMX_TAS5760=m
 CONFIG_SND_SOC_IMX_SGTL5000=m
 CONFIG_SND_SOC_IMX_SPDIF=m
 CONFIG_SND_SOC_FSL_ASOC_CARD=m
@@ -725,12 +729,14 @@ CONFIG_USB_SERIAL=y
 CONFIG_USB_SERIAL_CONSOLE=y
 CONFIG_USB_SERIAL_GENERIC=y
 CONFIG_USB_SERIAL_SIMPLE=y
-CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_CP210X=y
 CONFIG_USB_SERIAL_FTDI_SIO=y
 CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_SERIAL_QUALCOMM=m
 CONFIG_USB_TEST=m
 CONFIG_USB_EHSET_TEST_FIXTURE=y
 CONFIG_USB_HSIC_USB3503=y
+CONFIG_USB_HSIC_USB5744=y
 CONFIG_NOP_USB_XCEIV=y
 CONFIG_USB_MXS_PHY=y
 CONFIG_USB_ULPI=y
@@ -761,8 +767,8 @@ CONFIG_USB_ETH=m
 CONFIG_USB_MASS_STORAGE=m
 CONFIG_USB_G_SERIAL=m
 CONFIG_TYPEC=y
-CONFIG_TYPEC_TCPM=y
-CONFIG_TYPEC_TCPCI=y
+CONFIG_TYPEC_TCPM=m
+CONFIG_TYPEC_TCPCI=m
 CONFIG_TYPEC_FUSB302=m
 CONFIG_TYPEC_TPS6598X=m
 CONFIG_TYPEC_HD3SS3220=m
@@ -809,6 +815,7 @@ CONFIG_RTC_DRV_DS1307=m
 CONFIG_RTC_DRV_HYM8563=m
 CONFIG_RTC_DRV_MAX77686=y
 CONFIG_RTC_DRV_RK808=m
+CONFIG_RTC_DRV_PCF8563=y
 CONFIG_RTC_DRV_PCF85363=m
 CONFIG_RTC_DRV_M41T80=m
 CONFIG_RTC_DRV_RX8581=m
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index bb2eb6808a48..b9f9e78ac42d 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -368,6 +368,17 @@ config DRM_PANEL_RAYDIUM_RM68200
 	  Say Y here if you want to enable support for Raydium RM68200
 	  720x1280 DSI video mode panel.
 
+config DRM_PANEL_ROCKTECH_RK070CU05H
+	tristate "Rocktech RK070CU05H MIPI touchscreen panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+		Say Y here if you want to enable support for Rocktech RK070CU05H
+		MIPI DSI panel. It has a resolution of 1024x600 pixels, a built
+		in backlight and touch controller. Touch input support is provided
+		by the goodix driver and needs to be selected separately.
+
 config DRM_PANEL_ROCKTECK_HIMAX8394F
 	tristate "Rocktech Himax8394f 720x1280 DSI video mode panel"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index d15a67e92319..c9222556e80d 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -35,6 +35,7 @@ obj-$(CONFIG_DRM_PANEL_PANASONIC_VVX10F034N00) += panel-panasonic-vvx10f034n00.o
 obj-$(CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN) += panel-raspberrypi-touchscreen.o
 obj-$(CONFIG_DRM_PANEL_RAYDIUM_RM67191) += panel-raydium-rm67191.o
 obj-$(CONFIG_DRM_PANEL_RAYDIUM_RM68200) += panel-raydium-rm68200.o
+obj-$(CONFIG_DRM_PANEL_ROCKTECH_RK070CU05H) += panel-rocktech-rk070cu05h.o
 obj-$(CONFIG_DRM_PANEL_ROCKTECK_HIMAX8394F) += panel-rocktech-hx8394f.o
 obj-$(CONFIG_DRM_PANEL_RONBO_RB070D30) += panel-ronbo-rb070d30.o
 obj-$(CONFIG_DRM_PANEL_SAMSUNG_ATNA33XC20) += panel-samsung-atna33xc20.o
diff --git a/drivers/gpu/drm/panel/panel-rocktech-rk070cu05h.c b/drivers/gpu/drm/panel/panel-rocktech-rk070cu05h.c
new file mode 100644
index 000000000000..c25cfab2fa49
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-rocktech-rk070cu05h.c
@@ -0,0 +1,424 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Raydium RM67191 MIPI-DSI panel driver
+ *
+ * Copyright 2019 NXP
+ */
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+#include <video/of_videomode.h>
+#include <video/videomode.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_print.h>
+
+/* Panel specific color-format bits */
+#define COL_FMT_16BPP 0x55
+#define COL_FMT_18BPP 0x66
+#define COL_FMT_24BPP 0x77
+
+/* Write Manufacture Command Set Control */
+#define WRMAUCCTR 0xFE
+
+/* Manufacturer Command Set pages (CMD2) */
+struct cmd_set_entry {
+	u8 cmd;
+	u8 param;
+};
+
+
+static const u32 rk070_bus_formats[] = {
+	MEDIA_BUS_FMT_RGB888_1X24,
+	MEDIA_BUS_FMT_RGB666_1X18,
+	MEDIA_BUS_FMT_RGB565_1X16,
+};
+
+static const u32 rk070_bus_flags = DRM_BUS_FLAG_DE_LOW |
+				 DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE;
+
+struct rk070_panel {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+
+	struct gpio_desc *reset;
+	struct gpio_desc *enable;
+	struct backlight_device *backlight;
+
+	struct regulator_bulk_data *supplies;
+	unsigned int num_supplies;
+
+	bool prepared;
+	bool enabled;
+};
+
+static const struct drm_display_mode default_mode = {
+	.clock = 52000,
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 160,
+	.hsync_end = 1024 + 160 + 70,
+	.htotal = 1024 + 160 + 70 + 90,
+	.vdisplay = 600,
+	.vsync_start = 600 + 12,
+	.vsync_end = 600 + 12 + 10,
+	.vtotal = 600 + 12 + 10 + 23,
+	.width_mm = 80,
+	.height_mm = 47,
+};
+
+static inline struct rk070_panel *to_rk070_panel(struct drm_panel *panel)
+{
+	return container_of(panel, struct rk070_panel, panel);
+}
+
+static int rk070_panel_prepare(struct drm_panel *panel)
+{
+	struct rk070_panel *rk070 = to_rk070_panel(panel);
+	int ret;
+
+	if (rk070->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(rk070->num_supplies, rk070->supplies);
+	if (ret)
+		return ret;
+
+	if (rk070->reset) {
+		gpiod_set_value_cansleep(rk070->reset, 0);
+		usleep_range(18000, 20000);
+	}
+
+	rk070->prepared = true;
+
+	return 0;
+}
+
+static int rk070_panel_unprepare(struct drm_panel *panel)
+{
+	struct rk070_panel *rk070 = to_rk070_panel(panel);
+	int ret;
+
+	if (!rk070->prepared)
+		return 0;
+
+	/*
+	 * Right after asserting the reset, we need to release it, so that the
+	 * touch driver can have an active connection with the touch controller
+	 * even after the display is turned off.
+	 */
+	if (rk070->reset) {
+		gpiod_set_value_cansleep(rk070->reset, 1);
+		usleep_range(15000, 17000);
+		gpiod_set_value_cansleep(rk070->reset, 0);
+	}
+
+	ret = regulator_bulk_disable(rk070->num_supplies, rk070->supplies);
+	if (ret)
+		return ret;
+
+	rk070->prepared = false;
+
+	return 0;
+}
+
+static int rk070_panel_enable(struct drm_panel *panel)
+{
+	struct rk070_panel *rk070 = to_rk070_panel(panel);
+	struct mipi_dsi_device *dsi = rk070->dsi;
+
+	if (rk070->enabled)
+		return 0;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	/* Rocktech RK070CU05H panel do not need to set
+	   Manufacture Command Set and User Command Set. */
+
+	backlight_enable(rk070->backlight);
+	rk070->enabled = true;
+
+	return 0;
+}
+
+static int rk070_panel_disable(struct drm_panel *panel)
+{
+	struct rk070_panel *rk070 = to_rk070_panel(panel);
+	struct mipi_dsi_device *dsi = rk070->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	if (!rk070->enabled)
+		return 0;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	backlight_disable(rk070->backlight);
+
+	usleep_range(10000, 12000);
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		DRM_DEV_ERROR(dev, "Failed to set display OFF (%d)\n", ret);
+		return ret;
+	}
+
+	usleep_range(5000, 10000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		DRM_DEV_ERROR(dev, "Failed to enter sleep mode (%d)\n", ret);
+		return ret;
+	}
+
+	rk070->enabled = false;
+
+	return 0;
+}
+
+static int rk070_panel_get_modes(struct drm_panel *panel, struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &default_mode);
+	if (!mode) {
+		DRM_DEV_ERROR(panel->dev, "failed to add mode %ux%ux\n",
+			      default_mode.hdisplay, default_mode.vdisplay);
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	connector->display_info.bus_flags = rk070_bus_flags;
+
+	drm_display_info_set_bus_formats(&connector->display_info,
+					 rk070_bus_formats,
+					 ARRAY_SIZE(rk070_bus_formats));
+	return 1;
+}
+
+static int rk070_bl_get_brightness(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	struct rk070_panel *rk070 = mipi_dsi_get_drvdata(dsi);
+	u16 brightness;
+	int ret;
+
+	if (!rk070->prepared)
+		return 0;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_get_display_brightness(dsi, &brightness);
+	if (ret < 0)
+		return ret;
+
+	bl->props.brightness = brightness;
+
+	return brightness & 0xff;
+}
+
+static int rk070_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	struct rk070_panel *rk070 = mipi_dsi_get_drvdata(dsi);
+	int ret = 0;
+
+	if (!rk070->prepared)
+		return 0;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, bl->props.brightness);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static const struct backlight_ops rk070_bl_ops = {
+	.update_status = rk070_bl_update_status,
+	.get_brightness = rk070_bl_get_brightness,
+};
+
+static const struct drm_panel_funcs rk070_panel_funcs = {
+	.prepare = rk070_panel_prepare,
+	.unprepare = rk070_panel_unprepare,
+	.enable = rk070_panel_enable,
+	.disable = rk070_panel_disable,
+	.get_modes = rk070_panel_get_modes,
+};
+
+static const char * const rk070_supply_names[] = {
+	"v3p3",
+	"v1p8",
+};
+
+static int rk070_init_regulators(struct rk070_panel *rk070)
+{
+	struct device *dev = &rk070->dsi->dev;
+	int i;
+
+	rk070->num_supplies = ARRAY_SIZE(rk070_supply_names);
+	rk070->supplies = devm_kcalloc(dev, rk070->num_supplies,
+				     sizeof(*rk070->supplies), GFP_KERNEL);
+	if (!rk070->supplies)
+		return -ENOMEM;
+
+	for (i = 0; i < rk070->num_supplies; i++)
+		rk070->supplies[i].supply = rk070_supply_names[i];
+
+	return devm_regulator_bulk_get(dev, rk070->num_supplies, rk070->supplies);
+};
+
+static int rk070_panel_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct device_node *np = dev->of_node;
+	struct device_node *backlight;
+	struct rk070_panel *panel;
+	struct backlight_properties bl_props;
+	int ret;
+	u32 video_mode;
+
+	panel = devm_kzalloc(&dsi->dev, sizeof(*panel), GFP_KERNEL);
+	if (!panel)
+		return -ENOMEM;
+
+	mipi_dsi_set_drvdata(dsi, panel);
+
+	panel->dsi = dsi;
+
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags =  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_VIDEO;
+
+	ret = of_property_read_u32(np, "video-mode", &video_mode);
+	if (!ret) {
+		switch (video_mode) {
+		case 0:
+			/* burst mode */
+			dsi->mode_flags |= MIPI_DSI_MODE_VIDEO_BURST;
+			break;
+		case 1:
+			/* non-burst mode with sync event */
+			break;
+		case 2:
+			/* non-burst mode with sync pulse */
+			dsi->mode_flags |= MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+			break;
+		default:
+			dev_warn(dev, "invalid video mode %d\n", video_mode);
+			break;
+		}
+	}
+
+	ret = of_property_read_u32(np, "dsi-lanes", &dsi->lanes);
+	if (ret) {
+		dev_err(dev, "Failed to get dsi-lanes property (%d)\n", ret);
+		return ret;
+	}
+
+	panel->reset = devm_gpiod_get_optional(dev, "reset",
+					       GPIOD_OUT_LOW |
+					       GPIOD_FLAGS_BIT_NONEXCLUSIVE);
+	if (IS_ERR(panel->reset)) {
+		ret = PTR_ERR(panel->reset);
+		dev_err(dev, "Failed to get reset gpio (%d)\n", ret);
+		return ret;
+	}
+	gpiod_set_value_cansleep(panel->reset, 1);
+
+	panel->enable = devm_gpiod_get_optional(dev, "enable",
+					       GPIOD_OUT_LOW);
+	if (IS_ERR(panel->enable)) {
+		ret = PTR_ERR(panel->enable);
+		dev_err(dev, "Failed to get enable gpio (%d)\n", ret);
+		return ret;
+	}
+	gpiod_set_value_cansleep(panel->enable, 1);
+
+	memset(&bl_props, 0, sizeof(bl_props));
+	bl_props.type = BACKLIGHT_RAW;
+	bl_props.brightness = 255;
+	bl_props.max_brightness = 255;
+
+	backlight = of_parse_phandle(dev->of_node, "backlight", 0);
+	if (backlight) {
+		panel->backlight = of_find_backlight_by_node(backlight);
+		of_node_put(backlight);
+
+		if (!panel->backlight)
+			return -EPROBE_DEFER;
+	}
+
+	ret = rk070_init_regulators(panel);
+	if (ret)
+		return ret;
+
+	drm_panel_init(&panel->panel, &dsi->dev, &rk070_panel_funcs, DRM_MODE_CONNECTOR_DSI);
+
+	dev_set_drvdata(dev, panel);
+
+	drm_panel_add(&panel->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret)
+		drm_panel_remove(&panel->panel);
+
+	return ret;
+}
+
+static int rk070_panel_remove(struct mipi_dsi_device *dsi)
+{
+	struct rk070_panel *rk070 = mipi_dsi_get_drvdata(dsi);
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret)
+		DRM_DEV_ERROR(dev, "Failed to detach from host (%d)\n",
+			      ret);
+
+	drm_panel_remove(&rk070->panel);
+
+	return 0;
+}
+
+static void rk070_panel_shutdown(struct mipi_dsi_device *dsi)
+{
+	struct rk070_panel *rk070 = mipi_dsi_get_drvdata(dsi);
+
+	rk070_panel_disable(&rk070->panel);
+	rk070_panel_unprepare(&rk070->panel);
+}
+
+static const struct of_device_id rk070_of_match[] = {
+	{ .compatible = "rocktech,rk070cu05h", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, rk070_of_match);
+
+static struct mipi_dsi_driver rk070_panel_driver = {
+	.driver = {
+		.name = "panel-rocktech-rk070cu05h",
+		.of_match_table = rk070_of_match,
+	},
+	.probe = rk070_panel_probe,
+	.remove = rk070_panel_remove,
+	.shutdown = rk070_panel_shutdown,
+};
+module_mipi_dsi_driver(rk070_panel_driver);
+
+MODULE_DESCRIPTION("DRM Driver for Rochtech RK070CU05H MIPI DSI panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index 47e1a2a60eba..ddfab00ef207 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -1500,6 +1500,31 @@ static const struct panel_desc bananapi_s070wv20_ct16 = {
 	},
 };
 
+static const struct display_timing boe_ev121wxm_timing = {
+       .pixelclock = { 71000000, 71000000, 71000000 },
+       .hactive = { 1280, 1280, 1280 },
+       .hfront_porch = { 55, 55, 55 },
+       .hback_porch = { 55, 55, 55 },
+       .hsync_len = { 50, 50, 50 },
+       .vactive = { 800, 800, 800 },
+       .vfront_porch = { 7, 7, 7 },
+       .vback_porch = { 9, 9, 9 },
+       .vsync_len = { 7, 7, 7 },
+       .flags = DISPLAY_FLAGS_DE_HIGH,
+};
+
+static const struct panel_desc boe_ev121wxm = {
+       .timings = &boe_ev121wxm_timing,
+       .num_timings = 1,
+       .bpc = 8,
+       .size = {
+               .width = 261,
+               .height = 163,
+       },
+       .bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
+	   .connector_type = DRM_MODE_CONNECTOR_LVDS,
+};
+
 static const struct drm_display_mode boe_ev121wxm_n10_1850_mode = {
 	.clock = 71143,
 	.hdisplay = 1280,
@@ -2806,6 +2831,38 @@ static const struct panel_desc innolux_zj070na_01p = {
 	},
 };
 
+static const struct display_timing powertip_sh102768T001_timing = {
+	.pixelclock = { 65000000, 65000000, 65000000 },
+	.hactive = { 1024, 1024, 1024 },
+	.hfront_porch = { 40, 40, 40 },
+	.hback_porch = { 220, 220, 220 },
+	.hsync_len = { 60, 60, 60 },
+	.vactive = { 768, 768, 768},
+	.vfront_porch = { 7, 7, 7 },
+	.vback_porch = { 21, 21, 21 },
+	.vsync_len = { 10, 10, 10 },
+	.flags = DISPLAY_FLAGS_DE_HIGH,
+};
+
+static const struct panel_desc powertip_sh102768T001 = {
+
+        .timings = &powertip_sh102768T001_timing,
+        .num_timings = 1,
+        .bpc = 8,
+        .size = {
+                .width = 245,
+                .height =184,
+    },
+       .delay = {
+               .prepare = 100,
+               .enable = 100,
+               .unprepare = 100,
+               .disable = 100,
+       },
+       .bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
+	   .connector_type = DRM_MODE_CONNECTOR_LVDS,
+};
+
 static const struct drm_display_mode ivo_m133nwf4_r0_mode = {
 	.clock = 138778,
 	.hdisplay = 1920,
@@ -4613,6 +4670,9 @@ static const struct of_device_id platform_of_match[] = {
 	}, {
 		.compatible = "bananapi,s070wv20-ct16",
 		.data = &bananapi_s070wv20_ct16,
+	}, {
+		.compatible = "boe,ev121wxm-n10",
+		.data = &boe_ev121wxm,
 	}, {
 		.compatible = "boe,ev121wxm-n10-1850",
 		.data = &boe_ev121wxm_n10_1850,
@@ -4764,6 +4824,9 @@ static const struct of_device_id platform_of_match[] = {
 		.compatible = "innolux,zj070na-01p",
 		.data = &innolux_zj070na_01p,
 	}, {
+		.compatible = "powertip,sh102768T001",
+		.data =	&powertip_sh102768T001,
+	}, { 
 		.compatible = "ivo,m133nwf4-r0",
 		.data = &ivo_m133nwf4_r0,
 	}, {
diff --git a/drivers/iio/imu/Kconfig b/drivers/iio/imu/Kconfig
index 12f895ea48f8..3b5cc6d18c16 100644
--- a/drivers/iio/imu/Kconfig
+++ b/drivers/iio/imu/Kconfig
@@ -104,6 +104,7 @@ config KMX61
 	  be called kmx61.
 
 source "drivers/iio/imu/inv_icm42600/Kconfig"
+source "drivers/iio/imu/inv_mpu/Kconfig"
 source "drivers/iio/imu/inv_mpu6050/Kconfig"
 source "drivers/iio/imu/st_lsm6dsx/Kconfig"
 source "drivers/iio/imu/st_lsm9ds0/Kconfig"
diff --git a/drivers/iio/imu/Makefile b/drivers/iio/imu/Makefile
index 4a124ec27000..3527431888e9 100644
--- a/drivers/iio/imu/Makefile
+++ b/drivers/iio/imu/Makefile
@@ -23,6 +23,7 @@ obj-$(CONFIG_RPMSG_IIO_PEDOMETER) += rpmsg_iio_pedometer.o
 
 obj-y += inv_icm42600/
 obj-y += inv_mpu6050/
+obj-y += inv_mpu/
 
 obj-$(CONFIG_KMX61) += kmx61.o
 
diff --git a/drivers/iio/imu/inv_mpu/Kconfig b/drivers/iio/imu/inv_mpu/Kconfig
new file mode 100644
index 000000000000..00626f68d16a
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/Kconfig
@@ -0,0 +1,69 @@
+#
+# inv-mpu-iio driver for Invensense MPU devices
+#
+
+config INV_MPU_IIO
+	tristate
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+	select CRC32
+
+choice
+	prompt "Chip name"
+	depends on INV_MPU_IIO
+
+config INV_MPU_IIO_ICM20648
+	bool "ICM20648/ICM20948"
+	help
+	  Select this if you are using a ICM20648/ICM20948 chip.
+
+config INV_MPU_IIO_ICM20608D
+	bool "ICM20608D/ICM206x9/ICM20789"
+	help
+	  Select this if you are using a ICM20608D/ICM206x9/ICM20789 chip.
+
+config INV_MPU_IIO_ICM20602
+	bool "ICM20602"
+	help
+	  Select this if you are using a ICM20602 chip.
+
+config INV_MPU_IIO_ICM20689
+	bool "ICM20689"
+	help
+	  Select this if you are using a ICM20689 chip.
+
+config INV_MPU_IIO_ICM20690
+	bool "ICM20690"
+	help
+	  Select this if you are using a ICM20690 chip.
+
+config INV_MPU_IIO_IAM20680
+	bool "IAM20680"
+	help
+	  Select this if you are using a IAM20680 chip.
+
+config INV_MPU_IIO_ICM42600
+	bool "ICM42600"
+	help
+	  Select this if you are using a ICM426xx/ICM40607/ICM40609D chip.
+
+endchoice
+
+config INV_MPU_IIO_I2C
+	tristate "Invensense ICM20xxx devices (I2C)"
+	depends on I2C && !INV_MPU6050_IIO
+	select INV_MPU_IIO
+	help
+	  This driver supports Invensense ICM20xxx devices over I2C.
+	  This driver can be built as a module. The module will be called
+	  inv-mpu-iio-i2c.
+
+config INV_MPU_IIO_SPI
+	tristate "Invensense ICM20xxx devices (SPI)"
+	depends on SPI_MASTER && !INV_MPU6050_IIO
+	select INV_MPU_IIO
+	help
+	  This driver supports Invensense ICM20xxx devices over SPI.
+	  This driver can be built as a module. The module will be called
+	  inv-mpu-iio-spi.
+
diff --git a/drivers/iio/imu/inv_mpu/Makefile b/drivers/iio/imu/inv_mpu/Makefile
new file mode 100644
index 000000000000..aed1b7297793
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/Makefile
@@ -0,0 +1,73 @@
+#
+# Makefile for Invensense inv-mpu-iio device.
+#
+
+obj-$(CONFIG_INV_MPU_IIO) += inv-mpu-iio.o
+
+inv-mpu-iio-objs += inv_mpu_common.o
+inv-mpu-iio-objs += inv_mpu_ring.o
+inv-mpu-iio-objs += inv_mpu_timestamp.o
+inv-mpu-iio-objs += inv_mpu_dts.o
+
+# chip support
+ifeq ($(CONFIG_INV_MPU_IIO_ICM20648), y)
+inv-mpu-iio-objs += icm20648/inv_mpu_init.o
+inv-mpu-iio-objs += icm20648/inv_mpu_core.o
+inv-mpu-iio-objs += icm20648/inv_mpu_parsing.o
+inv-mpu-iio-objs += icm20648/inv_mpu_setup.o
+inv-mpu-iio-objs += icm20648/inv_mpu_dmp_fifo.o
+inv-mpu-iio-objs += icm20648/inv_slave_compass.o
+inv-mpu-iio-objs += icm20648/inv_slave_pressure.o
+inv-mpu-iio-objs += icm20648/inv_slave_als.o
+inv-mpu-iio-objs += icm20648/inv_mpu_load_dmp.o
+inv-mpu-iio-objs += icm20648/inv_mpu_selftest.o
+inv-mpu-iio-objs += dmp_support/inv_mpu_misc.o
+else ifeq ($(CONFIG_INV_MPU_IIO_ICM20690), y)
+inv-mpu-iio-objs += icm20690/inv_mpu_init_20690.o
+inv-mpu-iio-objs += icm20690/inv_mpu_core_20690.o
+inv-mpu-iio-objs += icm20690/inv_mpu_parsing_20690.o
+inv-mpu-iio-objs += icm20690/inv_mpu_setup_20690.o
+inv-mpu-iio-objs += icm20690/inv_mpu_selftest_20690.o
+inv-mpu-iio-objs += icm20690/inv_slave_compass.o
+else ifeq ($(CONFIG_INV_MPU_IIO_ICM20602), y)
+inv-mpu-iio-objs += icm20602/inv_mpu_init_20602.o
+inv-mpu-iio-objs += icm20602/inv_mpu_core_20602.o
+inv-mpu-iio-objs += icm20602/inv_mpu_parsing_20602.o
+inv-mpu-iio-objs += icm20602/inv_mpu_setup_20602.o
+inv-mpu-iio-objs += icm20602/inv_mpu_selftest_20602.o
+else ifeq ($(CONFIG_INV_MPU_IIO_ICM20608D), y)
+inv-mpu-iio-objs += icm20608d/inv_mpu_init_20608.o
+inv-mpu-iio-objs += icm20608d/inv_mpu_core_20608.o
+inv-mpu-iio-objs += icm20608d/inv_mpu_parsing_20608.o
+inv-mpu-iio-objs += icm20608d/inv_mpu_setup_20608D.o
+inv-mpu-iio-objs += icm20608d/inv_mpu_dmp_fifo.o
+inv-mpu-iio-objs += icm20608d/inv_mpu_load_dmp.o
+inv-mpu-iio-objs += icm20608d/inv_mpu_selftest_20608.o
+inv-mpu-iio-objs += dmp_support/inv_mpu_misc.o
+else ifeq ($(CONFIG_INV_MPU_IIO_IAM20680), y)
+inv-mpu-iio-objs += iam20680/inv_mpu_init_20680.o
+inv-mpu-iio-objs += iam20680/inv_mpu_core_20680.o
+inv-mpu-iio-objs += iam20680/inv_mpu_parsing_20680.o
+inv-mpu-iio-objs += iam20680/inv_mpu_setup_20680.o
+inv-mpu-iio-objs += iam20680/inv_mpu_selftest_20680.o
+else ifeq ($(CONFIG_INV_MPU_IIO_ICM20689), y)
+inv-mpu-iio-objs += iam20680/inv_mpu_init_20680.o
+inv-mpu-iio-objs += iam20680/inv_mpu_core_20680.o
+inv-mpu-iio-objs += iam20680/inv_mpu_parsing_20680.o
+inv-mpu-iio-objs += iam20680/inv_mpu_setup_20680.o
+inv-mpu-iio-objs += iam20680/inv_mpu_selftest_20680.o
+else ifeq ($(CONFIG_INV_MPU_IIO_ICM42600), y)
+inv-mpu-iio-objs += icm42600/inv_mpu_init_42600.o
+inv-mpu-iio-objs += icm42600/inv_mpu_core_42600.o
+inv-mpu-iio-objs += icm42600/inv_mpu_parsing_42600.o
+inv-mpu-iio-objs += icm42600/inv_mpu_setup_42600.o
+inv-mpu-iio-objs += icm42600/inv_mpu_misc_42600.o
+inv-mpu-iio-objs += icm42600/inv_mpu_selftest_42600.o
+endif
+
+# Bus support
+obj-$(CONFIG_INV_MPU_IIO_I2C) += inv-mpu-iio-i2c.o
+inv-mpu-iio-i2c-objs := inv_mpu_i2c.o
+obj-$(CONFIG_INV_MPU_IIO_SPI) += inv-mpu-iio-spi.o
+inv-mpu-iio-spi-objs := inv_mpu_spi.o
+
diff --git a/drivers/iio/imu/inv_mpu/README b/drivers/iio/imu/inv_mpu/README
new file mode 100644
index 000000000000..47ff5029ee6e
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/README
@@ -0,0 +1,117 @@
+Kernel driver inv-mpu-iio
+Author: InvenSense, Inc.
+
+
+Table of Contents
+=================
+- Description
+- Integrating the Driver in the Linux Kernel
+- Dts file
+- Communicating with the Driver in Userspace
+
+
+Description
+===========
+This document describes how to install the Invensense device driver into a
+Linux kernel. The supported chips are listed in Kconfig and user selects an
+appropriate one from .e.g. menuconfig.
+
+
+Integrating the Driver in the Linux Kernel
+==========================================
+Please add the files as follows (kernel 3.10):
+- Copy mpu.h to <kernel_root>/include/linux/iio/imu/
+- Copy inv_mpu folder under <kernel_root>/drivers/iio/imu/
+
+In order to see the driver in menuconfig when building the kernel, please
+make modifications as shown below:
+
+    add "source "drivers/iio/imu/inv_mpu/Kconfig""
+      in <kernel_root>/drivers/iio/imu/Kconfig
+
+    add "obj-y += inv_mpu/"
+      in <kernel_root>/drivers/iio/imu/Makefile
+
+
+
+Dts file
+========
+In order to recognize the Invensense device on the I2C/SPI bus, dts(or dtsi)
+file must be modified.
+
+Example)
+ICM20648 + AK09911/BMP280/APDS9930 on AUX I2C
+
+    i2c@f9968000 {
+        /* Invensense */
+        mpu6515_acc@68 {
+            compatible = "inven,icm20648";
+            reg = <0x68>;
+            interrupt-parent = <&msmgpio>;
+            interrupts = <73 0x2>;
+            inven,vdd_ana-supply = <&pm8941_l17>;
+            inven,vcc_i2c-supply = <&pm8941_lvs1>;
+            inven,gpio_int1 = <&msmgpio 73 0x00>;
+            fs_range = <0x00>;
+            /* mount matrix */
+            axis_map_x = <1>;
+            axis_map_y = <0>;
+            axis_map_z = <2>;
+            negate_x = <0>;
+            negate_y = <0>;
+            negate_z = <1>;
+            poll_interval = <200>;
+            min_interval = <5>;
+            inven,secondary_reg = <0x0c>;
+            /* If no compass sensor,
+             * replace "compass" with "none"
+             */
+            inven,secondary_type = "compass";
+            inven,secondary_name = "ak09911";
+            inven,secondary_axis_map_x = <1>;
+            inven,secondary_axis_map_y = <0>;
+            inven,secondary_axis_map_z = <2>;
+            inven,secondary_negate_x = <1>;
+            inven,secondary_negate_y = <1>;
+            inven,secondary_negate_z = <1>;
+            /* If no pressure sensor,
+             * replace "pressure" with "none"
+             */
+            inven,aux_type = "pressure";
+            inven,aux_name = "bmp280";
+            inven,aux_reg = <0x76>;
+            /* If no ALS sensor
+             * replace "als" with "none"
+             */
+            inven,read_only_slave_type = "als";
+            inven,read_only_slave_name = "apds9930";
+            inven,read_only_slave_reg = <0x39>;
+        };
+    };
+
+
+Communicating with the Driver in Userspace
+==========================================
+The driver generates several files in sysfs upon installation.
+These files are used to communicate with the driver. The files can be found at:
+
+(I2C) /sys/devices/*.i2c/i2c-*/*-*/iio:device*
+(SPI) /sys/devices/*.spi/spi_master/spi*/spi*.*/iio:device*
+
+Group and Owner for all entries should be updated to system/system at
+boot time to allow userspace to access properly.
+
+
+License
+=======
+Copyright (C) 2018 InvenSense, Inc.
+
+This software is licensed under the terms of the GNU General Public
+License version 2, as published by the Free Software Foundation, and
+may be copied, distributed, and modified under those terms.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
diff --git a/drivers/iio/imu/inv_mpu/dmp_support/inv_mpu_misc.c b/drivers/iio/imu/inv_mpu/dmp_support/inv_mpu_misc.c
new file mode 100644
index 000000000000..d65c69af8d93
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/dmp_support/inv_mpu_misc.c
@@ -0,0 +1,77 @@
+/*
+* Copyright (C) 2017-2019 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+int inv_stop_dmp(struct inv_mpu_state *st)
+{
+	return inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+}
+
+int inv_get_pedometer_steps(struct inv_mpu_state *st, int *ped)
+{
+	int r;
+
+	r = read_be32_from_mem(st, ped, PEDSTD_STEPCTR);
+
+	return r;
+}
+
+int inv_process_step_det(struct inv_mpu_state *st, u8 *dptr)
+{
+	u32 tmp;
+	u64 t;
+	s16 s[3];
+
+	tmp = be32_to_int(dptr);
+	tmp = inv_get_cntr_diff(st->ts_algo.start_dmp_counter, tmp);
+	t = st->ts_algo.last_run_time - (u64) tmp * st->eng_info[ENGINE_ACCEL].dur;
+	if (st->step_detector_l_on)
+		inv_push_8bytes_buffer(st, STEP_DETECTOR_HDR, t, s);
+	if (st->step_detector_wake_l_on)
+		inv_push_8bytes_buffer(st, STEP_DETECTOR_WAKE_HDR, t, s);
+
+	return 0;
+}
+
+int inv_get_pedometer_time(struct inv_mpu_state *st, int *ped)
+{
+	int r;
+
+	r = read_be32_from_mem(st, ped, PEDSTD_TIMECTR);
+
+	return r;
+}
+
+int inv_read_pedometer_counter(struct inv_mpu_state *st)
+{
+	int result;
+	u32 last_step_counter, curr_counter;
+	u64 counter;
+
+	result = read_be32_from_mem(st, &last_step_counter, STPDET_TIMESTAMP);
+	if (result)
+		return result;
+	if (0 != last_step_counter) {
+		result = read_be32_from_mem(st, &curr_counter, DMPRATE_CNTR);
+		if (result)
+			return result;
+		counter = inv_get_cntr_diff(curr_counter, last_step_counter);
+		st->ped.last_step_time = get_time_ns() - counter *
+		    st->eng_info[ENGINE_ACCEL].dur;
+	}
+
+	return 0;
+}
+
diff --git a/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_core_20680.c b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_core_20680.c
new file mode 100644
index 000000000000..c2bc2ead5e28
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_core_20680.c
@@ -0,0 +1,1090 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+
+#include "../inv_mpu_iio.h"
+
+static const struct inv_hw_s hw_info[INV_NUM_PARTS] = {
+	[IAM20680] = {128, "iam20680"},
+	[ICM20689] = {128, "icm20689"},
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static char debug_reg_addr = 0x6;
+#endif
+
+const char sensor_l_info[][30] = {
+	"SENSOR_L_ACCEL",
+	"SENSOR_L_GYRO",
+	"SENSOR_L_MAG",
+	"SENSOR_L_ALS",
+	"SENSOR_L_SIXQ",
+	"SENSOR_L_THREEQ",
+	"SENSOR_L_NINEQ",
+	"SENSOR_L_PEDQ",
+	"SENSOR_L_GEOMAG",
+	"SENSOR_L_PRESSURE",
+	"SENSOR_L_GYRO_CAL",
+	"SENSOR_L_MAG_CAL",
+	"SENSOR_L_EIS_GYRO",
+	"SENSOR_L_ACCEL_WAKE",
+	"SENSOR_L_GYRO_WAKE",
+	"SENSOR_L_MAG_WAKE",
+	"SENSOR_L_ALS_WAKE",
+	"SENSOR_L_SIXQ_WAKE",
+	"SENSOR_L_NINEQ_WAKE",
+	"SENSOR_L_PEDQ_WAKE",
+	"SENSOR_L_GEOMAG_WAKE",
+	"SENSOR_L_PRESSURE_WAKE",
+	"SENSOR_L_GYRO_CAL_WAKE",
+	"SENSOR_L_MAG_CAL_WAKE",
+	"SENSOR_L_NUM_MAX",
+};
+
+static int inv_set_accel_bias_reg(struct inv_mpu_state *st,
+			int accel_bias, int axis)
+{
+	int accel_reg_bias;
+	u8 addr;
+	u8 d[2];
+	int result = 0;
+
+	switch (axis) {
+	case 0:
+		/* X */
+		addr = REG_XA_OFFS_H;
+		break;
+	case 1:
+		/* Y */
+		addr = REG_YA_OFFS_H;
+		break;
+	case 2:
+		/* Z* */
+		addr = REG_ZA_OFFS_H;
+		break;
+	default:
+		result = -EINVAL;
+		goto accel_bias_set_err;
+	}
+
+	result = inv_plat_read(st, addr, 2, d);
+	if (result)
+		goto accel_bias_set_err;
+	accel_reg_bias = ((int)d[0] << 8) | d[1];
+
+	/* accel_bias is 2g scaled by 1<<16.
+	 * Convert to 16g, and mask bit0
+	 */
+	accel_reg_bias -= ((accel_bias / 8 / 65536) & ~1);
+
+	d[0] = (accel_reg_bias >> 8) & 0xff;
+	d[1] = (accel_reg_bias) & 0xff;
+	result = inv_plat_single_write(st, addr, d[0]);
+	if (result)
+		goto accel_bias_set_err;
+	result = inv_plat_single_write(st, addr + 1, d[1]);
+	if (result)
+		goto accel_bias_set_err;
+
+accel_bias_set_err:
+	return result;
+}
+
+static int inv_set_gyro_bias_reg(struct inv_mpu_state *st,
+			const int gyro_bias, int axis)
+{
+	int gyro_reg_bias;
+	u8 addr;
+	u8 d[2];
+	int result = 0;
+
+	switch (axis) {
+	case 0:
+		/* X */
+		addr = REG_XG_OFFS_USR_H;
+		break;
+	case 1:
+		/* Y */
+		addr = REG_YG_OFFS_USR_H;
+		break;
+	case 2:
+		/* Z */
+		addr = REG_ZG_OFFS_USR_H;
+		break;
+	default:
+		result = -EINVAL;
+		goto gyro_bias_set_err;
+	}
+
+	/* gyro_bias is 2000dps scaled by 1<<16.
+	 * Convert to 1000dps
+	 */
+	gyro_reg_bias = (-gyro_bias * 2 / 65536);
+
+	d[0] = (gyro_reg_bias >> 8) & 0xff;
+	d[1] = (gyro_reg_bias) & 0xff;
+	result = inv_plat_single_write(st, addr, d[0]);
+	if (result)
+		goto gyro_bias_set_err;
+	result = inv_plat_single_write(st, addr + 1, d[1]);
+	if (result)
+		goto gyro_bias_set_err;
+
+gyro_bias_set_err:
+	return result;
+}
+
+static int _bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		goto bias_store_fail;
+	switch (this_attr->address) {
+	case ATTR_ACCEL_X_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[0] = data;
+		break;
+	case ATTR_ACCEL_Y_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[1] = data;
+		break;
+	case ATTR_ACCEL_Z_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[2] = data;
+		break;
+	case ATTR_GYRO_X_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[0] = data;
+		break;
+	case ATTR_GYRO_Y_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[1] = data;
+		break;
+	case ATTR_GYRO_Z_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[2] = data;
+		break;
+	default:
+		break;
+	}
+
+bias_store_fail:
+	if (result)
+		return result;
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	int result;
+
+	mutex_lock(&indio_dev->mlock);
+	result = _bias_store(dev, attr, buf, count);
+	mutex_unlock(&indio_dev->mlock);
+
+	return result;
+}
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static ssize_t inv_debug_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_LP_EN_OFF:
+		st->chip_config.lp_en_mode_off = !!data;
+		inv_switch_power_in_lp(st, !!data);
+		break;
+	case ATTR_DMP_CLK_SEL:
+		st->chip_config.clk_sel = !!data;
+		inv_switch_power_in_lp(st, !!data);
+		break;
+	case ATTR_DEBUG_REG_ADDR:
+		debug_reg_addr = data;
+		break;
+	case ATTR_DEBUG_REG_WRITE:
+		inv_plat_single_write(st, debug_reg_addr, data);
+		break;
+	}
+	return count;
+}
+#endif
+
+static int _misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_GYRO_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.fsr = data;
+		result = inv_set_gyro_sf(st);
+		return result;
+	case ATTR_ACCEL_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.accel_fs = data;
+		result = inv_set_accel_sf(st);
+		return result;
+	default:
+		return -EINVAL;
+	}
+	st->trigger_state = MISC_TRIGGER;
+	result = set_inv_enable(indio_dev);
+
+	return result;
+}
+
+/*
+ * inv_misc_attr_store() -  calling this function
+ */
+static ssize_t inv_misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	int result;
+
+	mutex_lock(&indio_dev->mlock);
+	result = _misc_attr_store(dev, attr, buf, count);
+	mutex_unlock(&indio_dev->mlock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_sensor_rate_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n",
+					st->sensor_l[this_attr->address].rate);
+}
+
+static ssize_t inv_sensor_rate_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, rate, ind;
+	int result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data <= 0) {
+		pr_err("sensor_rate_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	rate = inv_rate_convert(st, ind, data);
+
+	pr_debug("sensor [%s] requested  rate %d input [%d]\n",
+						sensor_l_info[ind], rate, data);
+
+	if (rate == st->sensor_l[ind].rate)
+		return count;
+	mutex_lock(&indio_dev->mlock);
+	st->sensor_l[ind].rate = rate;
+	st->trigger_state = DATA_TRIGGER;
+	inv_check_sensor_on(st);
+	result = set_inv_enable(indio_dev);
+	pr_debug("%s rate %d div %d\n", sensor_l_info[ind],
+				st->sensor_l[ind].rate, st->sensor_l[ind].div);
+	mutex_unlock(&indio_dev->mlock);
+
+	return count;
+}
+
+static ssize_t inv_sensor_on_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->sensor_l[this_attr->address].on);
+}
+
+static ssize_t inv_sensor_on_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, on, ind;
+	int result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data < 0) {
+		pr_err("sensor_on_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	on = !!data;
+
+	pr_debug("sensor [%s] requested  %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+
+	if (on == st->sensor_l[ind].on) {
+		pr_debug("sensor [%s] is already %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+		return count;
+	}
+
+	mutex_lock(&indio_dev->mlock);
+	st->sensor_l[ind].on = on;
+	st->trigger_state = RATE_TRIGGER;
+	inv_check_sensor_on(st);
+	result = set_inv_enable(indio_dev);
+	mutex_unlock(&indio_dev->mlock);
+	if (result)
+		return result;
+
+	pr_debug("Sensor [%s] is %s by sysfs\n",
+				sensor_l_info[ind], (on == 1) ? "On" : "Off");
+	return count;
+}
+
+static int inv_check_l_step(struct inv_mpu_state *st)
+{
+	if (st->step_counter_l_on || st->step_counter_wake_l_on)
+		st->ped.on = true;
+	else
+		st->ped.on = false;
+
+	return 0;
+}
+
+static int _basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data;
+	int result;
+	u32 power_on_data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result || (data < 0))
+		return -EINVAL;
+
+	switch (this_attr->address) {
+	case ATTR_DMP_PED_ON:
+		if ((!!data) == st->ped.on)
+			return count;
+		st->ped.on = !!data;
+		break;
+	case ATTR_DMP_TILT_ENABLE:
+		if ((!!data) == st->chip_config.tilt_enable)
+			return count;
+		st->chip_config.tilt_enable = !!data;
+		pr_info("Tile %s\n",
+			st->chip_config.tilt_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_DMP_PICK_UP_ENABLE:
+		if ((!!data) == st->chip_config.pick_up_enable) {
+			pr_info("Pick_up enable already %s\n",
+				st->chip_config.pick_up_enable ==
+				1 ? "Enabled" : "Disabled");
+			return count;
+		}
+		st->chip_config.pick_up_enable = !!data;
+		pr_info("Pick up %s\n",
+			st->chip_config.pick_up_enable ==
+			1 ? "Enable" : "Disable");
+		break;
+	case ATTR_IN_POWER_ON:
+		{
+			u8 p0[2];
+			u8 p1[2];
+
+			power_on_data = (u32)data;
+			p0[0] = (power_on_data & 0xff);
+			p0[1] = ((power_on_data >> 8) & 0xff);
+			p1[0] = ((power_on_data >> 16) & 0xff);
+			p1[1] = ((power_on_data >> 24) & 0xff);
+
+			if (st->bus_type == BUS_SPI) {
+				struct spi_transfer power_on;
+				struct spi_message msg;
+
+				memset(&power_on, 0, sizeof(struct spi_transfer));
+
+				power_on.bits_per_word = 8;
+				power_on.len = 2;
+
+				power_on.tx_buf = p0;
+				power_on.rx_buf = p1;
+				spi_message_init(&msg);
+				spi_message_add_tail(&power_on, &msg);
+				spi_sync(to_spi_device(st->dev), &msg);
+
+			} else if (st->bus_type == BUS_I2C) {
+				struct i2c_msg msgs[2];
+
+				p0[0] &= 0x7f;
+
+				msgs[0].addr = st->i2c_addr;
+				msgs[0].flags = 0;	/* write */
+				msgs[0].buf = &p0[0];
+				msgs[0].len = 1;
+
+				msgs[1].addr = st->i2c_addr;
+				msgs[1].flags = I2C_M_RD;
+				msgs[1].buf = &p1[1];
+				msgs[1].len = 1;
+
+				result = i2c_transfer(st->sl_handle, msgs, 2);
+				if (result < 2)
+					return -EIO;
+			}
+			st->power_on_data = ((p0[0] << 24) | (p0[1] << 16) |
+							(p1[0] << 8) | p1[1]);
+			return count;
+		}
+	case ATTR_DMP_EIS_ENABLE:
+		if ((!!data) == st->chip_config.eis_enable)
+			return count;
+		st->chip_config.eis_enable = !!data;
+		pr_info("Eis %s\n",
+			st->chip_config.eis_enable == 1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		st->step_detector_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		st->step_detector_wake_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_COUNTER_ON:
+		st->step_counter_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		st->step_counter_wake_l_on = !!data;
+		break;
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		if (data == st->batch.timeout)
+			return count;
+		st->batch.timeout = data;
+		break;
+	default:
+		return -EINVAL;
+	};
+	inv_check_l_step(st);
+	inv_check_sensor_on(st);
+
+	st->trigger_state = EVENT_TRIGGER;
+	result = set_inv_enable(indio_dev);
+	if (result)
+		return result;
+
+	return count;
+}
+
+/*
+ * inv_basic_attr_store()
+ */
+static ssize_t inv_basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	int result;
+
+	mutex_lock(&indio_dev->mlock);
+	result = _basic_attr_store(dev, attr, buf, count);
+
+	mutex_unlock(&indio_dev->mlock);
+
+	return result;
+}
+
+/*
+ * inv_attr_show()
+ */
+static ssize_t inv_attr_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	s8 *m;
+
+	switch (this_attr->address) {
+	case ATTR_GYRO_SCALE:
+		{
+			const s16 gyro_scale[] = { 250, 500, 1000, 2000 };
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n",
+				gyro_scale[st->chip_config.fsr]);
+		}
+	case ATTR_ACCEL_SCALE:
+		{
+			const s16 accel_scale[] = { 2, 4, 8, 16 };
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n",
+				accel_scale[st->chip_config.accel_fs]);
+		}
+	case ATTR_GYRO_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.gyro_enable);
+	case ATTR_ACCEL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.accel_enable);
+	case ATTR_IN_POWER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->power_on_data);
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->batch.timeout);
+	case ATTR_DMP_PED_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.on);
+	case ATTR_DMP_TILT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.tilt_enable);
+	case ATTR_DMP_PICK_UP_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.pick_up_enable);
+	case ATTR_DMP_EIS_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.eis_enable);
+	case ATTR_DMP_LP_EN_OFF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.lp_en_mode_off);
+	case ATTR_DMP_STEP_COUNTER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_counter_l_on);
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_counter_wake_l_on);
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_detector_l_on);
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_detector_wake_l_on);
+	case ATTR_GYRO_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_ACCEL_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_GYRO_SF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_sf);
+	case ATTR_ANGLVEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[0]);
+	case ATTR_ANGLVEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[1]);
+	case ATTR_ANGLVEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[2]);
+	case ATTR_GYRO_LP_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_lp_mode);
+	case ATTR_ACCEL_LP_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_lp_mode);
+	case ATTR_ACCEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[0]);
+	case ATTR_ACCEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[1]);
+	case ATTR_ACCEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[2]);
+	case ATTR_GYRO_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[0]);
+	case ATTR_GYRO_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[1]);
+	case ATTR_GYRO_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[2]);
+	case ATTR_ACCEL_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[0]);
+	case ATTR_ACCEL_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[1]);
+	case ATTR_ACCEL_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_accel_bias[2]);
+	default:
+		return -EPERM;
+	}
+}
+
+static ssize_t inv_self_test(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int res;
+
+	mutex_lock(&indio_dev->mlock);
+	res = inv_hw_self_test(st);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&indio_dev->mlock);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", res);
+}
+
+
+/*
+ *  inv_temperature_show() - Read temperature data directly from registers.
+ */
+static ssize_t inv_temperature_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	u8 data[2];
+	s32 temp;
+	int res;
+
+	mutex_lock(&indio_dev->mlock);
+	res = inv_plat_read(st, REG_RAW_TEMP, 2, data);
+	if (res)
+		return res;
+	mutex_unlock(&indio_dev->mlock);
+
+	temp = (s32)be16_to_cpup((__be16 *)(data)) * 10000;
+	temp = temp / TEMP_SENSITIVITY + TEMP_OFFSET;
+
+	return snprintf(buf, MAX_WR_SZ, "%d %lld\n", temp, get_time_ns());
+}
+
+/*
+ *  inv_reg_dump_show() - Register dump for testing.
+ */
+static ssize_t inv_reg_dump_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int ii;
+	char data;
+	int bytes_printed = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+
+	for (ii = 0; ii < 0x7F; ii++) {
+		/* don't read fifo r/w register */
+		if ((ii == REG_MEM_R_W) || (ii == REG_FIFO_R_W))
+			data = 0;
+		else
+			inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+	set_inv_enable(indio_dev);
+	mutex_unlock(&indio_dev->mlock);
+
+	return bytes_printed;
+}
+
+static ssize_t inv_flush_batch_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+
+	mutex_lock(&indio_dev->mlock);
+	result = inv_flush_batch_data(indio_dev, data);
+	mutex_unlock(&indio_dev->mlock);
+
+	return count;
+}
+
+static const struct iio_chan_spec inv_mpu_channels[] = {
+	IIO_CHAN_SOFT_TIMESTAMP(INV_MPU_SCAN_TIMESTAMP),
+};
+
+/* special run time sysfs entry, read only */
+static DEVICE_ATTR(debug_reg_dump, S_IRUGO | S_IWUSR, inv_reg_dump_show, NULL);
+static DEVICE_ATTR(out_temperature, S_IRUGO | S_IWUSR,
+			inv_temperature_show, NULL);
+static DEVICE_ATTR(misc_self_test, S_IRUGO | S_IWUSR, inv_self_test, NULL);
+
+static IIO_DEVICE_ATTR(info_anglvel_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_GYRO_MATRIX);
+static IIO_DEVICE_ATTR(info_accel_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_ACCEL_MATRIX);
+
+static IIO_DEVICE_ATTR(info_gyro_sf, S_IRUGO, inv_attr_show, NULL,
+			ATTR_GYRO_SF);
+/* write only sysfs */
+static DEVICE_ATTR(misc_flush_batch, S_IWUSR, NULL, inv_flush_batch_store);
+
+/* sensor on/off sysfs control */
+static IIO_DEVICE_ATTR(in_accel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store, SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store, SENSOR_L_GYRO);
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_eis_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_EIS_GYRO);
+#endif
+static IIO_DEVICE_ATTR(in_accel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_WAKE);
+
+/* sensor rate sysfs control */
+static IIO_DEVICE_ATTR(in_accel_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_GYRO);
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_eis_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_EIS_GYRO);
+#endif
+static IIO_DEVICE_ATTR(in_accel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_WAKE);
+
+static IIO_DEVICE_ATTR(misc_batchmode_timeout, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_BATCHMODE_TIMEOUT);
+
+/* engine scale */
+static IIO_DEVICE_ATTR(in_accel_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_misc_attr_store, ATTR_ACCEL_SCALE);
+static IIO_DEVICE_ATTR(in_anglvel_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_misc_attr_store, ATTR_GYRO_SCALE);
+
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(debug_lp_en_off, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DMP_LP_EN_OFF);
+static IIO_DEVICE_ATTR(debug_clock_sel, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DMP_CLK_SEL);
+static IIO_DEVICE_ATTR(debug_reg_write, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_REG_WRITE);
+static IIO_DEVICE_ATTR(debug_reg_write_addr, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_REG_ADDR);
+#endif
+
+static IIO_DEVICE_ATTR(in_accel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_accel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_X_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_X_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(info_gyro_lp_mode, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_GYRO_LP_MODE);
+static IIO_DEVICE_ATTR(info_accel_lp_mode, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_LP_MODE);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static IIO_DEVICE_ATTR(in_step_detector_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_ON);
+static IIO_DEVICE_ATTR(in_step_detector_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_WAKE_ON);
+static IIO_DEVICE_ATTR(in_step_counter_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_basic_attr_store, ATTR_DMP_STEP_COUNTER_ON);
+static IIO_DEVICE_ATTR(in_step_counter_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_COUNTER_WAKE_ON);
+
+static IIO_DEVICE_ATTR(event_tilt_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_TILT_ENABLE);
+
+static IIO_DEVICE_ATTR(event_eis_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_EIS_ENABLE);
+
+static IIO_DEVICE_ATTR(event_pick_up_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_PICK_UP_ENABLE);
+
+static IIO_DEVICE_ATTR(in_power_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_IN_POWER_ON);
+#endif
+
+static const struct attribute *inv_raw_attributes[] = {
+	&dev_attr_debug_reg_dump.attr,
+	&dev_attr_out_temperature.attr,
+	&dev_attr_misc_flush_batch.attr,
+	&dev_attr_misc_self_test.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_power_on.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_accel_enable.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_info_accel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale.dev_attr.attr,
+	&iio_dev_attr_misc_batchmode_timeout.dev_attr.attr,
+	&iio_dev_attr_in_accel_rate.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_accel_lp_mode.dev_attr.attr,
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static const struct attribute *inv_debug_attributes[] = {
+	&iio_dev_attr_debug_lp_en_off.dev_attr.attr,
+	&iio_dev_attr_debug_clock_sel.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write_addr.dev_attr.attr,
+};
+#endif
+
+static const struct attribute *inv_gyro_attributes[] = {
+	&iio_dev_attr_info_anglvel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_rate.dev_attr.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_eis_enable.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_anglvel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_scale.dev_attr.attr,
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	&iio_dev_attr_in_eis_rate.dev_attr.attr,
+#endif
+	&iio_dev_attr_in_anglvel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_gyro_sf.dev_attr.attr,
+	&iio_dev_attr_info_gyro_lp_mode.dev_attr.attr,
+};
+
+static const struct attribute *inv_bias_attributes[] = {
+	&iio_dev_attr_in_accel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_offset.dev_attr.attr,
+};
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+static const struct attribute *inv_pedometer_attributes[] = {
+	&iio_dev_attr_event_tilt_enable.dev_attr.attr,
+	&iio_dev_attr_event_eis_enable.dev_attr.attr,
+	&iio_dev_attr_event_pick_up_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_wake_enable.dev_attr.attr,
+};
+#endif
+
+static struct attribute *inv_attributes[ARRAY_SIZE(inv_raw_attributes) +
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+					ARRAY_SIZE(inv_debug_attributes) +
+#endif
+					ARRAY_SIZE(inv_gyro_attributes) +
+					ARRAY_SIZE(inv_bias_attributes) +
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+					ARRAY_SIZE(inv_pedometer_attributes) +
+#endif
+					 + 1];
+
+static const struct attribute_group inv_attribute_group = {
+	.name = "mpu",
+	.attrs = inv_attributes
+};
+
+static const struct iio_info mpu_info = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	.driver_module = THIS_MODULE,
+#endif
+	.attrs = &inv_attribute_group,
+};
+
+/*
+ *  inv_check_chip_type() - check and setup chip type.
+ */
+int inv_check_chip_type(struct iio_dev *indio_dev, const char *name)
+{
+	int result;
+	int t_ind;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+	struct inv_mpu_state *st;
+
+	st = iio_priv(indio_dev);
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	if (!strcmp(name, "iam20680"))
+		st->chip_type = IAM20680;
+	else if (!strcmp(name, "icm20689"))
+		st->chip_type = ICM20689;
+	else
+		return -EPERM;
+	st->chip_config.has_gyro = 1;
+
+	st->hw = &hw_info[st->chip_type];
+	result = inv_mpu_initialize(st);
+	if (result)
+		return result;
+
+	t_ind = 0;
+	memcpy(&inv_attributes[t_ind], inv_raw_attributes,
+				sizeof(inv_raw_attributes));
+	t_ind += ARRAY_SIZE(inv_raw_attributes);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	memcpy(&inv_attributes[t_ind], inv_pedometer_attributes,
+				sizeof(inv_pedometer_attributes));
+	t_ind += ARRAY_SIZE(inv_pedometer_attributes);
+#endif
+
+	memcpy(&inv_attributes[t_ind], inv_gyro_attributes,
+				sizeof(inv_gyro_attributes));
+	t_ind += ARRAY_SIZE(inv_gyro_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_bias_attributes,
+				sizeof(inv_bias_attributes));
+	t_ind += ARRAY_SIZE(inv_bias_attributes);
+
+#ifndef SUPPORT_ONLY_BASIC_FEATURES
+	memcpy(&inv_attributes[t_ind], inv_debug_attributes,
+				sizeof(inv_debug_attributes));
+	t_ind += ARRAY_SIZE(inv_debug_attributes);
+#endif
+
+	inv_attributes[t_ind] = NULL;
+
+	indio_dev->name = st->hw->name;
+	indio_dev->channels = inv_mpu_channels;
+	indio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);
+
+	indio_dev->info = &mpu_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->currentmode = INDIO_DIRECT_MODE;
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(inv_check_chip_type);
+
+int inv_create_dmp_sysfs(struct iio_dev *ind)
+{
+	// dummy
+	return 0;
+}
+EXPORT_SYMBOL_GPL(inv_create_dmp_sysfs);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense device ICM20xxx driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_iio_reg_20680.h b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_iio_reg_20680.h
new file mode 100644
index 000000000000..d6e4749b8401
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_iio_reg_20680.h
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _INV_MPU_IIO_REG_20680_H_
+#define _INV_MPU_IIO_REG_20680_H_
+
+/* Uncomment when HAL does not support the algorithm library
+ * for calibration and sensor fusion not to expose unused
+ * sysfs entries
+ */
+// #define SUPPORT_ONLY_BASIC_FEATURES
+
+/* Uncomment to read data registers for sensor data instead of FIFO */
+//#define SENSOR_DATA_FROM_REGISTERS
+
+/* Uncomment to enable timer based batching */
+#define TIMER_BASED_BATCHING
+
+/* Polling (batch mode) can be enabled only when FIFO read */
+#if defined(SENSOR_DATA_FROM_REGISTERS)
+#undef TIMER_BASED_BATCHING
+#endif
+
+/*register and associated bit definition*/
+#define REG_XA_OFFS_H		0x77
+#define REG_YA_OFFS_H		0x7A
+#define REG_ZA_OFFS_H		0x7D
+#define REG_XG_OFFS_USR_H	0x13
+#define REG_YG_OFFS_USR_H	0x15
+#define REG_ZG_OFFS_USR_H	0x17
+#define REG_SAMPLE_RATE_DIV	0x19
+
+#define REG_CONFIG		0x1A
+#define EXT_SYNC_SET		8
+
+#define REG_GYRO_CONFIG		0x1B
+#define BITS_SELF_TEST_EN	0xE0
+#define SHIFT_GYRO_FS_SEL	0x03
+
+#define REG_ACCEL_CONFIG	0x1C
+#define SHIFT_ACCEL_FS		0x03
+
+#define REG_LP_MODE_CTRL	0x1E
+#define BIT_GYRO_CYCLE_EN	0x80
+
+#define REG_ACCEL_WOM_THR	0x1F
+#define REG_ACCEL_WOM_X_THR	0x20
+#define REG_ACCEL_WOM_Y_THR	0x21
+#define REG_ACCEL_WOM_Z_THR	0x22
+
+#define REG_ACCEL_MOT_THR	0x1F
+#define REG_ACCEL_MOT_DUR	0x20
+
+#define REG_ACCEL_CONFIG_2	0x1D
+#define BIT_ACCEL_FCHOCIE_B	0x08
+
+#define REG_FIFO_EN		0x23
+#define BITS_GYRO_FIFO_EN	0x70
+#define BIT_ACCEL_FIFO_EN	0x08
+
+#define REG_FSYNC_INT		0x36
+#define BIT_FSYNC_INT		0x80
+
+#define REG_INT_PIN_CFG		0x37
+
+#define REG_INT_ENABLE		0x38
+#define BIT_WOM_X_INT_EN	0x80
+#define BIT_WOM_Y_INT_EN	0x40
+#define BIT_WOM_Z_INT_EN	0x20
+#define BIT_WOM_ALL_INT_EN	0xE0
+#define BIT_FSYNC_INT_EN	0x8
+#define BIT_DATA_RDY_EN		0x1
+
+#define REG_INT_STATUS		0x3A
+#define BIT_WOM_X_INT		0x80
+#define BIT_WOM_Y_INT		0x40
+#define BIT_WOM_Z_INT		0x20
+
+#define REG_RAW_ACCEL		0x3B
+#define REG_RAW_TEMP		0x41
+#define REG_RAW_GYRO		0x43
+#define REG_EXT_SENS_DATA_00	0x49
+#define REG_EXT_SENS_DATA_08	0x51
+#define REG_EXT_SENS_DATA_09	0x52
+
+#define REG_ACCEL_INTEL_CTRL	0x69
+#define BIT_ACCEL_INTEL_EN	0x80
+#define BIT_ACCEL_INTEL_MODE	0x40
+
+#define REG_USER_CTRL		0x6A
+#define BIT_COND_RST		0x01
+#define BIT_FIFO_RST		0x04
+#define BIT_FIFO_EN		0x40
+
+#define REG_PWR_MGMT_1		0x6B
+#define BIT_H_RESET		0x80
+#define BIT_SLEEP		0x40
+#define BIT_LP_EN		0x20
+#define BIT_CLK_PLL		0x01
+#define BIT_CLK_MASK		0x07
+
+#define REG_PWR_MGMT_2		0x6C
+#define BIT_PWR_ACCEL_STBY	0x38
+#define BIT_PWR_GYRO_STBY	0x07
+#define BIT_PWR_ALL_OFF		0x3F
+#define BIT_FIFO_LP_EN		0x80
+
+#define REG_MEM_BANK_SEL	0x6D
+#define REG_MEM_START_ADDR	0x6E
+#define REG_MEM_R_W		0x6F
+
+#define REG_FIFO_COUNT_H	0x72
+#define REG_FIFO_R_W		0x74
+#define REG_WHO_AM_I		0x75
+
+#define REG_20680_XG_ST_DATA	0x50
+#define REG_20680_XA_ST_DATA	0xD
+#define REG_20680_XA_OFFS_H	0x77
+#define REG_20680_YA_OFFS_H	0x7A
+#define REG_20680_ZA_OFFS_H	0x7D
+#define REG_20680_ACCEL_CONFIG2	0x1D
+#define BIT_ACCEL_FCHOCIE_B	0x08
+#define BIT_FIFO_SIZE_1K	0x40
+
+#define REG_LP_MODE_CFG		0x1E
+
+#define REG_20680_LP_ACCEL_ODR	0x1E
+#define REG_20680_ACCEL_WOM_THR	0x1F
+
+/* data output control reg 2 */
+#define ACCEL_ACCURACY_SET	0x4000
+#define GYRO_ACCURACY_SET	0x2000
+#define CPASS_ACCURACY_SET	0x1000
+
+/* data definitions */
+#define ACCEL_COVARIANCE	0
+#define BYTES_PER_SENSOR	6
+#define BYTES_FOR_TEMP		2
+#define FIFO_COUNT_BYTE		2
+#define HARDWARE_FIFO_SIZE	512
+#define FIFO_SIZE		(HARDWARE_FIFO_SIZE * 7 / 10)
+#define POWER_UP_TIME		100
+#define REG_UP_TIME_USEC	100
+#define LEFT_OVER_BYTES		128
+#define IIO_BUFFER_BYTES	8
+#define BASE_SAMPLE_RATE	1000
+#define DRY_RUN_TIME		50
+#define INV_IAM20680_GYRO_START_TIME	35
+#define INV_IAM20680_ACCEL_START_TIME	30
+#define MODE_1K_INIT_SAMPLE	5
+#define FIRST_SAMPLE_BUF_MS	30
+
+#ifdef BIAS_CONFIDENCE_HIGH
+#define DEFAULT_ACCURACY	3
+#else
+#define DEFAULT_ACCURACY	1
+#endif
+
+/* temperature */
+#define TEMP_SENSITIVITY	32680   // 326.8 LSB/degC * 100
+#define TEMP_OFFSET		2500    // 25 degC * 100
+
+/* enum for sensor */
+enum INV_SENSORS {
+	SENSOR_ACCEL = 0,
+	SENSOR_TEMP,
+	SENSOR_GYRO,
+	SENSOR_COMPASS,
+	SENSOR_NUM_MAX,
+	SENSOR_INVALID,
+};
+
+enum inv_filter_e {
+	INV_FILTER_256HZ_NOLPF2 = 0,
+	INV_FILTER_188HZ,
+	INV_FILTER_98HZ,
+	INV_FILTER_42HZ,
+	INV_FILTER_20HZ,
+	INV_FILTER_10HZ,
+	INV_FILTER_5HZ,
+	INV_FILTER_2100HZ_NOLPF,
+	NUM_FILTER
+};
+
+#define MPU_DEFAULT_DMP_FREQ	200
+#define PEDOMETER_FREQ		(MPU_DEFAULT_DMP_FREQ >> 2)
+#define SENSOR_FUSION_MIN_RATE	100
+#define GESTURE_ACCEL_RATE	50
+#define ESI_GYRO_RATE		1000
+#define MAX_FIFO_PACKET_READ	6
+#define MAX_BATCH_FIFO_SIZE	FIFO_SIZE
+
+#define MIN_MST_ODR_CONFIG	4
+#define MAX_MST_ODR_CONFIG	5
+/* initial rate is important. For non-DMP mode, it is set as 4 1000/256*/
+#define MPU_INIT_SENSOR_RATE	4
+#define MAX_MST_NON_COMPASS_ODR_CONFIG	7
+#define THREE_AXES		3
+#define NINE_ELEM		(THREE_AXES * THREE_AXES)
+#define MPU_TEMP_SHIFT		16
+
+#define DMP_DIVIDER		(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ)
+#define DEFAULT_BATCH_RATE	400
+#define DEFAULT_BATCH_TIME	(MSEC_PER_SEC / DEFAULT_BATCH_RATE)
+
+#define TEMPERATURE_SCALE	3340827L
+#define TEMPERATURE_OFFSET	1376256L
+#define SECONDARY_INIT_WAIT	100
+
+/* data limit definitions */
+#define MIN_FIFO_RATE		4
+#define MAX_FIFO_RATE		MPU_DEFAULT_DMP_FREQ
+
+#define MAX_MPU_MEM		8192
+#define MAX_PRS_RATE		281
+
+enum inv_devices {
+	ICM20608D,
+	ICM20789,
+	ICM20689,
+	ICM20690,
+	ICM20602,
+	IAM20680,
+	ICM42600,
+	ICM42686,
+	ICM40609D,
+	INV_NUM_PARTS,
+};
+#endif
diff --git a/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_init_20680.c b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_init_20680.c
new file mode 100644
index 000000000000..f65faadda793
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_init_20680.c
@@ -0,0 +1,253 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+static int inv_calc_gyro_sf(s8 pll)
+{
+	int a, r;
+	int value, t;
+
+	t = 102870L + 81L * pll;
+	a = (1L << 30) / t;
+	r = (1L << 30) - a * t;
+	value = a * 797 * DMP_DIVIDER;
+	value += (s64) ((a * 1011387LL * DMP_DIVIDER) >> 20);
+	value += r * 797L * DMP_DIVIDER / t;
+	value += (s32) ((s64) ((r * 1011387LL * DMP_DIVIDER) >> 20)) / t;
+	value <<= 1;
+
+	return value;
+}
+
+static int inv_read_timebase(struct inv_mpu_state *st)
+{
+
+	inv_plat_single_write(st, REG_CONFIG, 3);
+
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time_1k = NSEC_PER_SEC;
+	/* talor expansion to calculate base time unit */
+	st->eng_info[ENGINE_GYRO].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_GYRO].base_time_1k = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time_1k = NSEC_PER_SEC;
+
+	st->eng_info[ENGINE_ACCEL].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_GYRO].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_I2C].orig_rate = BASE_SAMPLE_RATE;
+
+	st->gyro_sf = inv_calc_gyro_sf(0);
+
+	return 0;
+}
+
+int inv_set_gyro_sf(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+				   st->chip_config.fsr << SHIFT_GYRO_FS_SEL);
+
+	return result;
+}
+
+int inv_set_accel_sf(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG,
+				st->chip_config.accel_fs << SHIFT_ACCEL_FS);
+	return result;
+}
+
+int inv_set_accel_intel(struct inv_mpu_state *st)
+{
+	return 0;
+}
+
+static void inv_init_sensor_struct(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE;
+
+	st->sensor[SENSOR_ACCEL].sample_size = BYTES_PER_SENSOR;
+	st->sensor[SENSOR_TEMP].sample_size = BYTES_FOR_TEMP;
+	st->sensor[SENSOR_GYRO].sample_size = BYTES_PER_SENSOR;
+
+	st->sensor_l[SENSOR_L_SIXQ].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_PEDQ].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].base = SENSOR_GYRO;
+
+	st->sensor[SENSOR_ACCEL].a_en = true;
+	st->sensor[SENSOR_GYRO].a_en = false;
+
+	st->sensor[SENSOR_ACCEL].g_en = false;
+	st->sensor[SENSOR_GYRO].g_en = true;
+
+	st->sensor[SENSOR_ACCEL].c_en = false;
+	st->sensor[SENSOR_GYRO].c_en = false;
+
+	st->sensor[SENSOR_ACCEL].p_en = false;
+	st->sensor[SENSOR_GYRO].p_en = false;
+
+	st->sensor[SENSOR_ACCEL].engine_base = ENGINE_ACCEL;
+	st->sensor[SENSOR_GYRO].engine_base = ENGINE_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_GYRO_CAL].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_EIS_GYRO].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].base = SENSOR_GYRO;
+
+	st->sensor_l[SENSOR_L_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GYRO].header = GYRO_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL].header = GYRO_CALIB_HDR;
+
+	st->sensor_l[SENSOR_L_EIS_GYRO].header = EIS_GYRO_HDR;
+	st->sensor_l[SENSOR_L_SIXQ].header = SIXQUAT_HDR;
+	st->sensor_l[SENSOR_L_THREEQ].header = LPQ_HDR;
+	st->sensor_l[SENSOR_L_NINEQ].header = NINEQUAT_HDR;
+	st->sensor_l[SENSOR_L_PEDQ].header = PEDQUAT_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].header = ACCEL_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].header = GYRO_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].header = GYRO_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_WAKE].header = COMPASS_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_CAL_WAKE].header = COMPASS_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].header = SIXQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].header = NINEQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].header = PEDQUAT_WAKE_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL].wake_on = false;
+	st->sensor_l[SENSOR_L_GYRO].wake_on = false;
+	st->sensor_l[SENSOR_L_GYRO_CAL].wake_on = false;
+	st->sensor_l[SENSOR_L_MAG].wake_on = false;
+	st->sensor_l[SENSOR_L_MAG_CAL].wake_on = false;
+	st->sensor_l[SENSOR_L_EIS_GYRO].wake_on = false;
+	st->sensor_l[SENSOR_L_SIXQ].wake_on = false;
+	st->sensor_l[SENSOR_L_NINEQ].wake_on = false;
+	st->sensor_l[SENSOR_L_PEDQ].wake_on = false;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_MAG_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].wake_on = true;
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].wake_on = true;
+}
+
+static int inv_init_config(struct inv_mpu_state *st)
+{
+	int res, i;
+
+	st->batch.overflow_on = 0;
+	st->chip_config.fsr = MPU_INIT_GYRO_SCALE;
+	st->chip_config.accel_fs = MPU_INIT_ACCEL_SCALE;
+	st->ped.int_thresh = MPU_INIT_PED_INT_THRESH;
+	st->ped.step_thresh = MPU_INIT_PED_STEP_THRESH;
+	st->chip_config.low_power_gyro_on = 1;
+	st->eis.count_precision = NSEC_PER_MSEC;
+	st->firmware = 0;
+	st->fifo_count_mode = BYTE_MODE;
+#ifdef TIMER_BASED_BATCHING
+	st->batch_timeout = 0;
+	st->is_batch_timer_running = false;
+#endif
+
+	st->eng_info[ENGINE_GYRO].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+
+	inv_init_sensor_struct(st);
+	res = inv_read_timebase(st);
+	if (res)
+		return res;
+
+	res = inv_set_gyro_sf(st);
+	if (res)
+		return res;
+	res = inv_set_accel_sf(st);
+	if (res)
+		return res;
+	res =  inv_set_accel_intel(st);
+	if (res)
+		return res;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].ts = 0;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].previous_ts = 0;
+
+	return res;
+}
+
+int inv_mpu_initialize(struct inv_mpu_state *st)
+{
+	u8 v;
+	int result;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	/* verify whoami */
+	result = inv_plat_read(st, REG_WHO_AM_I, 1, &v);
+	if (result)
+		return result;
+	pr_info("whoami= %x\n", v);
+	if (v == 0x00 || v == 0xff)
+		return -ENODEV;
+
+	/* reset to make sure previous state are not there */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_H_RESET);
+	if (result)
+		return result;
+	usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+	msleep(100);
+	/* toggle power state */
+	result = inv_set_power(st, false);
+	if (result)
+		return result;
+	result = inv_set_power(st, true);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (result)
+		return result;
+	result = inv_init_config(st);
+	if (result)
+		return result;
+
+	st->chip_config.lp_en_mode_off = 0;
+
+	result = inv_set_power(st, false);
+
+	pr_info("%s: initialize result is %d....\n", __func__, result);
+
+	return result;
+}
diff --git a/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_parsing_20680.c b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_parsing_20680.c
new file mode 100644
index 000000000000..99cdf4c3560f
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_parsing_20680.c
@@ -0,0 +1,400 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/math64.h>
+
+#include "../inv_mpu_iio.h"
+
+static int inv_check_fsync(struct inv_mpu_state *st)
+{
+	u8 data[1];
+
+	if (!st->chip_config.eis_enable)
+		return 0;
+	inv_plat_read(st, REG_FSYNC_INT, 1, data);
+	if (data[0] & BIT_FSYNC_INT) {
+		pr_debug("fsync\n");
+		st->eis.eis_triggered = true;
+		st->eis.fsync_delay = 1;
+		st->eis.prev_state = 1;
+		st->eis.frame_count++;
+		st->eis.eis_frame = true;
+	}
+	st->header_count--;
+
+	return 0;
+}
+
+static int inv_push_sensor(struct inv_mpu_state *st, int ind, u64 t, u8 *d)
+{
+	int i;
+	s32 raw[3];
+	s32 calib[3] = { 0, 0, 0 };
+
+	switch (ind) {
+	case SENSOR_ACCEL:
+		for (i = 0; i < 3; i++)
+			raw[i] = (s16)be16_to_cpup((__be16 *) (d + i * 2));
+		inv_push_16bytes_buffer(st, ind, t, raw, 0);
+		break;
+	case SENSOR_TEMP:
+		inv_check_fsync(st);
+		break;
+	case SENSOR_GYRO:
+		for (i = 0; i < 3; i++)
+			raw[i] = (s16)be16_to_cpup((__be16 *) (d + i * 2));
+		inv_push_gyro_data(st, raw, calib, t);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int inv_push_20680_data(struct inv_mpu_state *st, u8 *d)
+{
+	u8 *dptr;
+	int i;
+
+	dptr = d;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			inv_get_dmp_ts(st, i);
+			if (st->sensor[i].send && (!st->ts_algo.first_sample)) {
+				st->sensor[i].sample_calib++;
+				inv_push_sensor(st, i, st->sensor[i].ts, dptr);
+			}
+			dptr += st->sensor[i].sample_size;
+		}
+	}
+	if (st->ts_algo.first_sample)
+		st->ts_algo.first_sample--;
+	st->header_count--;
+
+	return 0;
+}
+
+static int inv_process_20680_data(struct inv_mpu_state *st)
+{
+	int total_bytes, tmp, res, fifo_count, pk_size, i;
+	u8 *dptr, *d;
+	u8 data[14];
+	bool done_flag;
+	u8 v;
+#ifdef SENSOR_DATA_FROM_REGISTERS
+	u8 reg;
+	int len;
+#endif
+
+	if (st->gesture_only_on && (!st->batch.timeout)) {
+		res = inv_plat_read(st, REG_INT_STATUS, 1, data);
+		if (res)
+			return res;
+		pr_debug("ges cnt=%d, statu=%x\n",
+						st->gesture_int_count, data[0]);
+		if (data[0] & (BIT_WOM_ALL_INT_EN)) {
+			if (!st->gesture_int_count) {
+				inv_switch_power_in_lp(st, true);
+				res = inv_plat_single_write(st, REG_INT_ENABLE,
+					BIT_WOM_ALL_INT_EN | BIT_DATA_RDY_EN);
+				if (res)
+					return res;
+				v = 0;
+				if (st->chip_config.gyro_enable)
+					v |= BITS_GYRO_FIFO_EN;
+
+				if (st->chip_config.accel_enable)
+					v |= BIT_ACCEL_FIFO_EN;
+				res = inv_plat_single_write(st, REG_FIFO_EN, v);
+				if (res)
+					return res;
+				/* First time wake up from WOM.
+				 * We don't need data in the FIFO
+				 */
+				res = inv_reset_fifo(st, true);
+				if (res)
+					return res;
+				res = inv_switch_power_in_lp(st, false);
+				st->gesture_int_count = WOM_DELAY_THRESHOLD;
+
+				return res;
+			}
+			st->gesture_int_count = WOM_DELAY_THRESHOLD;
+		} else {
+			if (!st->gesture_int_count) {
+				inv_switch_power_in_lp(st, true);
+				res = inv_plat_single_write(st, REG_FIFO_EN, 0);
+				res = inv_plat_single_write(st, REG_INT_ENABLE,
+					BIT_WOM_ALL_INT_EN);
+				inv_switch_power_in_lp(st, false);
+
+				return res;
+			}
+			st->gesture_int_count--;
+		}
+	}
+
+	fifo_count = inv_get_last_run_time_non_dmp_record_mode(st);
+	pr_debug("fifc= %d\n", fifo_count);
+	if (!fifo_count) {
+		pr_debug("REG_FIFO_COUNT_H size is 0\n");
+		return 0;
+	}
+	pk_size = st->batch.pk_size;
+	if (!pk_size)
+		return -EINVAL;
+
+	if (fifo_count >= (HARDWARE_FIFO_SIZE / st->batch.pk_size)) {
+		pr_warn("fifo overflow pkt count=%d pkt sz=%d\n",
+				fifo_count, st->batch.pk_size);
+		return -EOVERFLOW;
+	}
+
+	fifo_count *= st->batch.pk_size;
+	st->fifo_count = fifo_count;
+	d = st->fifo_data_store;
+	dptr = d;
+	total_bytes = fifo_count;
+
+#ifdef SENSOR_DATA_FROM_REGISTERS
+	len = 0;
+	if (st->sensor[SENSOR_GYRO].on) {
+		reg = REG_RAW_GYRO;
+		len += BYTES_PER_SENSOR;
+		if (st->sensor[SENSOR_ACCEL].on && !st->sensor[SENSOR_TEMP].on)
+			len += BYTES_FOR_TEMP;
+	}
+	if (st->sensor[SENSOR_TEMP].on) {
+		reg = REG_RAW_TEMP;
+		len += BYTES_FOR_TEMP;
+	}
+	if (st->sensor[SENSOR_ACCEL].on) {
+		reg = REG_RAW_ACCEL;
+		len += BYTES_PER_SENSOR;
+	}
+
+	if (len == 0) {
+		pr_debug("No sensor is enabled\n");
+		return 0;
+	}
+
+	/* read data registers */
+	res = inv_plat_read(st, reg, len, data);
+	if (res < 0) {
+		pr_err("read data registers is failed\n");
+		return res;
+	}
+
+	/* copy sensor data to buffer as FIFO data format */
+	tmp = 0;
+	if (st->sensor[SENSOR_ACCEL].on) {
+		for (i = 0; i < BYTES_PER_SENSOR; i++)
+			dptr[i] = data[tmp + i];
+		dptr += BYTES_PER_SENSOR;
+		tmp += BYTES_PER_SENSOR;
+	}
+
+	if (st->sensor[SENSOR_TEMP].on) {
+		for (i = 0; i < BYTES_FOR_TEMP; i++)
+			dptr[i] = data[tmp + i];
+		dptr += BYTES_FOR_TEMP;
+		tmp += BYTES_FOR_TEMP;
+	}
+
+	if (st->sensor[SENSOR_GYRO].on) {
+		if (st->sensor[SENSOR_ACCEL].on && !st->sensor[SENSOR_TEMP].on)
+			tmp += BYTES_FOR_TEMP;
+		for (i = 0; i < BYTES_PER_SENSOR; i++)
+			dptr[i] = data[tmp + i];
+	}
+#else
+	while (total_bytes > 0) {
+		if (total_bytes < pk_size * MAX_FIFO_PACKET_READ)
+			tmp = total_bytes;
+		else
+			tmp = pk_size * MAX_FIFO_PACKET_READ;
+		res = inv_plat_read(st, REG_FIFO_R_W, tmp, dptr);
+		if (res < 0) {
+			pr_err("read REG_FIFO_R_W is failed\n");
+			return res;
+		}
+		pr_debug("inside: %x, %x, %x, %x, %x, %x, %x, %x\n",
+				dptr[0], dptr[1], dptr[2], dptr[3],
+				dptr[4], dptr[5], dptr[6], dptr[7]);
+		pr_debug("insid2: %x, %x, %x, %x, %x, %x, %x, %x\n",
+				dptr[8], dptr[9], dptr[10], dptr[11],
+				dptr[12], dptr[13], dptr[14], dptr[15]);
+
+		dptr += tmp;
+		total_bytes -= tmp;
+	}
+#endif /* SENSOR_DATA_FROM_REGISTERS */
+	dptr = d;
+	pr_debug("dd: %x, %x, %x, %x, %x, %x, %x, %x\n",
+			d[0], d[1], d[2], d[3],
+			d[4], d[5], d[6], d[7]);
+	pr_debug("dd2: %x, %x, %x, %x, %x, %x, %x, %x\n",
+			d[8], d[9], d[10], d[11],
+			d[12], d[13], d[14], d[15]);
+	total_bytes = fifo_count;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->sensor[i].count =  total_bytes / pk_size;
+	}
+	st->header_count = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->header_count = max(st->header_count,
+							st->sensor[i].count);
+	}
+
+	st->ts_algo.calib_counter++;
+	inv_bound_timestamp(st);
+
+	dptr = d;
+	done_flag = false;
+
+	while (!done_flag) {
+		pr_debug("total%d, pk=%d\n", total_bytes, pk_size);
+		if (total_bytes >= pk_size) {
+			res = inv_push_20680_data(st, dptr);
+			if (res)
+				return res;
+			total_bytes -= pk_size;
+			dptr += pk_size;
+		} else {
+			done_flag = true;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  _inv_read_fifo() - Transfer data from FIFO to ring buffer.
+ */
+static void _inv_read_fifo(struct inv_mpu_state *st)
+{
+	struct iio_dev *indio_dev = iio_priv_to_dev(st);
+	int result;
+
+	result = wait_event_interruptible_timeout(st->wait_queue,
+					st->resume_state, msecs_to_jiffies(300));
+	if (result <= 0)
+		return;
+	mutex_lock(&indio_dev->mlock);
+#ifdef TIMER_BASED_BATCHING
+	if (st->batch_timeout) {
+		if (inv_plat_single_write(st, REG_INT_ENABLE, st->int_en))
+			pr_err("REG_INT_ENABLE write error\n");
+	}
+#endif
+	st->wake_sensor_received = false;
+	result = inv_process_20680_data(st);
+	if (result)
+		goto err_reset_fifo;
+	mutex_unlock(&indio_dev->mlock);
+
+	if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+		wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+		__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+	return;
+
+err_reset_fifo:
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!st->chip_config.slave_enable) &&
+		(!st->chip_config.pressure_enable)) {
+		inv_switch_power_in_lp(st, false);
+		mutex_unlock(&indio_dev->mlock);
+
+		return;
+	}
+
+	pr_err("error to reset fifo\n");
+	inv_switch_power_in_lp(st, true);
+	inv_reset_fifo(st, true);
+	inv_switch_power_in_lp(st, false);
+	mutex_unlock(&indio_dev->mlock);
+}
+
+irqreturn_t inv_read_fifo(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	_inv_read_fifo(st);
+	iio_trigger_notify_done(indio_dev->trig);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef TIMER_BASED_BATCHING
+void inv_batch_work(struct work_struct *work)
+{
+	struct inv_mpu_state *st =
+		container_of(work, struct inv_mpu_state, batch_work);
+	struct iio_dev *indio_dev = iio_priv_to_dev(st);
+
+	mutex_lock(&indio_dev->mlock);
+	if (inv_plat_single_write(st, REG_INT_ENABLE, st->int_en | BIT_DATA_RDY_EN))
+		pr_err("REG_INT_ENABLE write error\n");
+	mutex_unlock(&indio_dev->mlock);
+}
+#endif
+
+int inv_flush_batch_data(struct iio_dev *indio_dev, int data)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+#ifndef SENSOR_DATA_FROM_REGISTERS
+	if (st->chip_config.gyro_enable ||
+		st->chip_config.accel_enable ||
+		st->chip_config.slave_enable ||
+		st->chip_config.pressure_enable) {
+		st->wake_sensor_received = false;
+		inv_process_20680_data(st);
+		if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+			wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+			__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+		inv_switch_power_in_lp(st, false);
+	}
+#endif /* SENSOR_DATA_FROM_REGISTERS */
+	inv_push_marker_to_buffer(st, END_MARKER, data);
+
+	return 0;
+}
+
diff --git a/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_selftest_20680.c b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_selftest_20680.c
new file mode 100644
index 000000000000..2262efde65c7
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_selftest_20680.c
@@ -0,0 +1,755 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/* register settings */
+#define DEF_SELFTEST_GYRO_SENS		(32768 / 250)
+/* wait time before collecting data */
+#define MAX_PACKETS			20
+#define SELFTEST_WAIT_TIME		(MAX_PACKETS * 10)
+#define DEF_ST_STABLE_TIME		20
+#define DEF_GYRO_SCALE			131
+#define DEF_ST_PRECISION		1000
+#define DEF_ST_ACCEL_FS_MG		2000UL
+#define DEF_ST_SCALE			32768
+#define DEF_ST_TRY_TIMES		2
+#define DEF_ST_ACCEL_RESULT_SHIFT	1
+#define DEF_ST_SAMPLES			200
+
+#define DEF_ACCEL_ST_SHIFT_DELTA_MIN	500
+#define DEF_ACCEL_ST_SHIFT_DELTA_MAX	1500
+#define DEF_GYRO_CT_SHIFT_DELTA		500
+
+#define SENSOR_UP_TIME			30
+#define REG_UP_TIME			2
+
+#define DEF_ST_ACCEL_FS_MG		2000UL
+#define DEF_ACCEL_ST_SHIFT_DELTA	500
+#define ACCEL_ST_AL_MIN ((DEF_ACCEL_ST_AL_MIN * DEF_ST_SCALE \
+				 / DEF_ST_ACCEL_FS_MG) * DEF_ST_PRECISION)
+#define ACCEL_ST_AL_MAX ((DEF_ACCEL_ST_AL_MAX * DEF_ST_SCALE \
+				 / DEF_ST_ACCEL_FS_MG) * DEF_ST_PRECISION)
+
+#define THREE_AXIS			3
+#define DEF_ST_IAM20680_ACCEL_LPF	2
+#define DEF_SELFTEST_SAMPLE_RATE	0  /* 1000Hz */
+#define DEF_SELFTEST_SAMPLE_RATE_LP	3  /*  250Hz */
+#define DEF_SELFTEST_SAMPLE_RATE_ACC_LP	10 /*  250Hz LPOSC_CLKSEL */
+#define SAMPLE_RATE_CHANGE_STABLE	50
+#define DEF_SELFTEST_20680_ACCEL_FS	(0 << 3)
+#define DEF_SELFTEST_GYRO_FS		(0 << 3)
+#define DEF_ST_20680_STABLE_TIME	20
+#define BIT_ACCEL_OUT			0x08
+#define BITS_GYRO_OUT			0x70
+#define THREE_AXIS			3
+#define DEF_GYRO_WAIT_TIME		10
+#define DEF_GYRO_WAIT_TIME_LP		50
+
+/* Gyro Offset Max Value (dps) */
+#define DEF_GYRO_OFFSET_MAX		20
+/* Gyro Self Test Absolute Limits ST_AL (dps) */
+#define DEF_GYRO_ST_AL			60
+/* Accel Self Test Absolute Limits ST_AL (mg) */
+#define DEF_ACCEL_ST_AL_MIN		225
+#define DEF_ACCEL_ST_AL_MAX		675
+
+struct recover_regs {
+	u8 int_enable;		/* REG_INT_ENABLE */
+	u8 fifo_en;		/* REG_FIFO_EN */
+	u8 user_ctrl;		/* REG_USER_CTRL */
+	u8 config;		/* REG_CONFIG */
+	u8 gyro_config;		/* REG_GYRO_CONFIG */
+	u8 accel_config;	/* REG_ACCEL_CONFIG */
+	u8 accel_config_2;	/* REG_ACCEL_CONFIG_2 */
+	u8 smplrt_div;		/* REG_SAMPLE_RATE_DIV */
+	u8 lp_mode;		/* REG_LP_MODE_CTRL */
+	u8 pwr_mgmt_1;		/* REG_PWR_MGMT_1 */
+	u8 pwr_mgmt_2;		/* REG_PWR_MGMT_2 */
+};
+
+static struct recover_regs saved_regs;
+
+static const u16 mpu_st_tb[256] = {
+	2620, 2646, 2672, 2699, 2726, 2753, 2781, 2808,
+	2837, 2865, 2894, 2923, 2952, 2981, 3011, 3041,
+	3072, 3102, 3133, 3165, 3196, 3228, 3261, 3293,
+	3326, 3359, 3393, 3427, 3461, 3496, 3531, 3566,
+	3602, 3638, 3674, 3711, 3748, 3786, 3823, 3862,
+	3900, 3939, 3979, 4019, 4059, 4099, 4140, 4182,
+	4224, 4266, 4308, 4352, 4395, 4439, 4483, 4528,
+	4574, 4619, 4665, 4712, 4759, 4807, 4855, 4903,
+	4953, 5002, 5052, 5103, 5154, 5205, 5257, 5310,
+	5363, 5417, 5471, 5525, 5581, 5636, 5693, 5750,
+	5807, 5865, 5924, 5983, 6043, 6104, 6165, 6226,
+	6289, 6351, 6415, 6479, 6544, 6609, 6675, 6742,
+	6810, 6878, 6946, 7016, 7086, 7157, 7229, 7301,
+	7374, 7448, 7522, 7597, 7673, 7750, 7828, 7906,
+	7985, 8065, 8145, 8227, 8309, 8392, 8476, 8561,
+	8647, 8733, 8820, 8909, 8998, 9088, 9178, 9270,
+	9363, 9457, 9551, 9647, 9743, 9841, 9939, 10038,
+	10139, 10240, 10343, 10446, 10550, 10656, 10763, 10870,
+	10979, 11089, 11200, 11312, 11425, 11539, 11654, 11771,
+	11889, 12008, 12128, 12249, 12371, 12495, 12620, 12746,
+	12874, 13002, 13132, 13264, 13396, 13530, 13666, 13802,
+	13940, 14080, 14221, 14363, 14506, 14652, 14798, 14946,
+	15096, 15247, 15399, 15553, 15709, 15866, 16024, 16184,
+	16346, 16510, 16675, 16842, 17010, 17180, 17352, 17526,
+	17701, 17878, 18057, 18237, 18420, 18604, 18790, 18978,
+	19167, 19359, 19553, 19748, 19946, 20145, 20347, 20550,
+	20756, 20963, 21173, 21385, 21598, 21814, 22033, 22253,
+	22475, 22700, 22927, 23156, 23388, 23622, 23858, 24097,
+	24338, 24581, 24827, 25075, 25326, 25579, 25835, 26093,
+	26354, 26618, 26884, 27153, 27424, 27699, 27976, 28255,
+	28538, 28823, 29112, 29403, 29697, 29994, 30294, 30597,
+	30903, 31212, 31524, 31839, 32157, 32479, 32804
+};
+
+static void inv_show_saved_setting(struct inv_mpu_state *st)
+{
+	pr_debug(" REG_INT_ENABLE      : 0x%02X\n", saved_regs.int_enable);
+	pr_debug(" REG_FIFO_EN         : 0x%02X\n", saved_regs.fifo_en);
+	pr_debug(" REG_USER_CTRL       : 0x%02X\n", saved_regs.user_ctrl);
+	pr_debug(" REG_CONFIG          : 0x%02X\n", saved_regs.config);
+	pr_debug(" REG_GYRO_CONFIG     : 0x%02X\n", saved_regs.gyro_config);
+	pr_debug(" REG_ACCEL_CONFIG    : 0x%02X\n", saved_regs.accel_config);
+	pr_debug(" REG_ACCEL_CONFIG_2  : 0x%02X\n", saved_regs.accel_config_2);
+	pr_debug(" REG_SAMPLE_RATE_DIV : 0x%02X\n", saved_regs.smplrt_div);
+	pr_debug(" REG_LP_MODE_CTRL    : 0x%02X\n", saved_regs.lp_mode);
+	pr_debug(" REG_PWR_MGMT_1      : 0x%02X\n", saved_regs.pwr_mgmt_1);
+	pr_debug(" REG_PWR_MGMT_2      : 0x%02X\n", saved_regs.pwr_mgmt_2);
+}
+
+static int inv_save_setting(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_plat_read(st, REG_PWR_MGMT_1, 1,
+			&saved_regs.pwr_mgmt_1);
+	if (result)
+		return result;
+
+	/* wake up */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1,
+			(saved_regs.pwr_mgmt_1 & ~BIT_SLEEP));
+	if (result)
+		return result;
+
+	result = inv_plat_read(st, REG_INT_ENABLE, 1,
+			&saved_regs.int_enable);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_FIFO_EN, 1,
+			&saved_regs.fifo_en);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_USER_CTRL, 1,
+			&saved_regs.user_ctrl);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_CONFIG, 1,
+			&saved_regs.config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_GYRO_CONFIG, 1,
+			&saved_regs.gyro_config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_CONFIG, 1,
+			&saved_regs.accel_config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_CONFIG_2, 1,
+			&saved_regs.accel_config_2);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_SAMPLE_RATE_DIV, 1,
+			&saved_regs.smplrt_div);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_LP_MODE_CTRL, 1,
+			&saved_regs.lp_mode);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_PWR_MGMT_2, 1,
+			&saved_regs.pwr_mgmt_2);
+	if (result)
+		return result;
+
+	inv_show_saved_setting(st);
+
+	return result;
+}
+
+static int inv_recover_setting(struct inv_mpu_state *st)
+{
+	int result;
+	/* Stop sensors */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	/* Restore sensor configurations */
+	result = inv_plat_single_write(st, REG_INT_ENABLE,
+			saved_regs.int_enable);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_FIFO_EN,
+			saved_regs.fifo_en);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_USER_CTRL,
+			saved_regs.user_ctrl);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_CONFIG,
+			saved_regs.config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+			saved_regs.gyro_config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG,
+			saved_regs.accel_config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG_2,
+			saved_regs.accel_config_2);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+			saved_regs.smplrt_div);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_LP_MODE_CTRL,
+			saved_regs.lp_mode);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1,
+			saved_regs.pwr_mgmt_1);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			saved_regs.pwr_mgmt_2);
+	if (result)
+		return result;
+
+	return result;
+}
+
+int inv_switch_engine(struct inv_mpu_state *st, bool en, u32 mask)
+{
+	u8 data, mgmt_1;
+	int result;
+
+	if (mask == BIT_PWR_GYRO_STBY) {
+		result = inv_plat_read(st, REG_PWR_MGMT_1, 1, &mgmt_1);
+		if (result)
+			return result;
+		mgmt_1 &= ~BIT_CLK_MASK;
+	}
+
+	if ((mask == BIT_PWR_GYRO_STBY) && (!en)) {
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, mgmt_1);
+		if (result)
+			return result;
+	}
+
+	result = inv_plat_read(st, REG_PWR_MGMT_2, 1, &data);
+	if (result)
+		return result;
+	if (en)
+		data &= (~mask);
+	else
+		data |= mask;
+	data |= BIT_FIFO_LP_EN;
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2, data);
+	if (result)
+		return result;
+
+	if ((mask == BIT_PWR_GYRO_STBY) && en) {
+		/* only gyro on needs sensor up time */
+		msleep(SENSOR_UP_TIME);
+		/* after gyro is on & stable, switch internal clock to PLL */
+		mgmt_1 |= BIT_CLK_PLL;
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, mgmt_1);
+		if (result)
+			return result;
+	}
+	if ((mask == BIT_PWR_ACCEL_STBY) && en)
+		msleep(REG_UP_TIME);
+
+	return 0;
+}
+
+int inv_set_offset_reg(struct inv_mpu_state *st, int reg, int val)
+{
+	int result;
+	u8 d;
+
+	d = ((val >> 8) & 0xff);
+	result = inv_plat_single_write(st, reg, d);
+	if (result)
+		return result;
+
+	d = (val & 0xff);
+	result = inv_plat_single_write(st, reg + 1, d);
+
+	return result;
+}
+
+/**
+ * inv_check_gyro_self_test() - check gyro self test. this function
+ *                                   returns zero as success. A non-zero return
+ *                                   value indicates failure in self test.
+ *  @*st: main data structure.
+ *  @*reg_avg: average value of normal test.
+ *  @*st_avg:  average value of self test
+ */
+int inv_check_gyro_self_test(struct inv_mpu_state *st,
+						int *reg_avg, int *st_avg)
+{
+	u8 regs[3];
+	int ret_val, result;
+	int otp_value_zero = 0;
+	int st_shift_prod[3], st_shift_cust[3], i;
+
+	ret_val = 0;
+	result = inv_plat_read(st, REG_20680_XG_ST_DATA, 3, regs);
+	if (result)
+		return result;
+	pr_debug("%s self_test gyro shift_code - %02x %02x %02x\n",
+		st->hw->name, regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			st_shift_prod[i] = mpu_st_tb[regs[i] - 1];
+		} else {
+			st_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	pr_debug("%s self_test gyro st_shift_prod - %+d %+d %+d\n",
+		st->hw->name, st_shift_prod[0], st_shift_prod[1],
+		st_shift_prod[2]);
+
+	for (i = 0; i < 3; i++) {
+		st_shift_cust[i] = st_avg[i] - reg_avg[i];
+		if (!otp_value_zero) {
+			/* Self Test Pass/Fail Criteria A */
+			if (st_shift_cust[i] < DEF_GYRO_CT_SHIFT_DELTA *
+					st_shift_prod[i])
+				ret_val = 1;
+		} else {
+			/* Self Test Pass/Fail Criteria B */
+			if (st_shift_cust[i] < DEF_GYRO_ST_AL *
+						DEF_SELFTEST_GYRO_SENS *
+						DEF_ST_PRECISION)
+				ret_val = 1;
+		}
+	}
+	pr_debug("%s self_test gyro st_shift_cust - %+d %+d %+d\n",
+		st->hw->name, st_shift_cust[0], st_shift_cust[1],
+		st_shift_cust[2]);
+
+	if (ret_val == 0) {
+		/* Self Test Pass/Fail Criteria C */
+		for (i = 0; i < 3; i++)
+			if (abs(reg_avg[i]) > DEF_GYRO_OFFSET_MAX *
+						DEF_SELFTEST_GYRO_SENS *
+						DEF_ST_PRECISION)
+				ret_val = 1;
+	}
+
+	return ret_val;
+}
+
+/**
+ * inv_check_accel_self_test() - check 20680 accel self test. this function
+ *                                   returns zero as success. A non-zero return
+ *                                   value indicates failure in self test.
+ *  @*st: main data structure.
+ *  @*reg_avg: average value of normal test.
+ *  @*st_avg:  average value of self test
+ */
+int inv_check_accel_self_test(struct inv_mpu_state *st,
+						int *reg_avg, int *st_avg)
+{
+	int ret_val, result;
+	int st_shift_prod[3], st_shift_cust[3], st_shift_ratio[3], i;
+	u8 regs[3];
+	int otp_value_zero = 0;
+
+	ret_val = 0;
+	result = inv_plat_read(st, REG_20680_XA_ST_DATA, 3, regs);
+	if (result)
+		return result;
+	pr_debug("%s self_test accel shift_code - %02x %02x %02x\n",
+		st->hw->name, regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			st_shift_prod[i] = mpu_st_tb[regs[i] - 1];
+		} else {
+			st_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	pr_debug("%s self_test accel st_shift_prod - %+d %+d %+d\n",
+		st->hw->name, st_shift_prod[0], st_shift_prod[1],
+		st_shift_prod[2]);
+
+	if (!otp_value_zero) {
+		/* Self Test Pass/Fail Criteria A */
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = st_avg[i] - reg_avg[i];
+			st_shift_ratio[i] = abs(st_shift_cust[i] /
+					st_shift_prod[i] - DEF_ST_PRECISION);
+			if (st_shift_ratio[i] > DEF_ACCEL_ST_SHIFT_DELTA)
+				ret_val = 1;
+		}
+	} else {
+		/* Self Test Pass/Fail Criteria B */
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = abs(st_avg[i] - reg_avg[i]);
+			if (st_shift_cust[i] < ACCEL_ST_AL_MIN ||
+					st_shift_cust[i] > ACCEL_ST_AL_MAX)
+				ret_val = 1;
+		}
+	}
+	pr_debug("%s self_test accel st_shift_cust - %+d %+d %+d\n",
+		st->hw->name, st_shift_cust[0], st_shift_cust[1],
+		st_shift_cust[2]);
+
+	return ret_val;
+}
+
+/*
+ *  inv_do_test() - do the actual test of self testing
+ */
+int inv_do_test(struct inv_mpu_state *st, int self_test_flag,
+		int *gyro_result, int *accel_result, int lp_mode)
+{
+	int result, i, j, packet_size;
+	u8 data[BYTES_PER_SENSOR * 2], d, dd;
+	int fifo_count, packet_count, ind, s;
+
+	packet_size = BYTES_PER_SENSOR * 2;
+
+	/* disable interrupt */
+	result = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+	if (result)
+		return result;
+	/* disable the sensor output to FIFO */
+	result = inv_plat_single_write(st, REG_FIFO_EN, 0);
+	if (result)
+		return result;
+	/* disable fifo reading */
+	result = inv_plat_single_write(st, REG_USER_CTRL, 0);
+	if (result)
+		return result;
+	/* clear FIFO */
+	result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_RST);
+	if (result)
+		return result;
+	/* setup parameters */
+	result = inv_plat_single_write(st, REG_CONFIG, INV_FILTER_98HZ);
+	if (result)
+		return result;
+
+	/* gyro lp mode */
+	if (lp_mode == 1)
+		d = BIT_GYRO_CYCLE_EN;
+	else if (lp_mode == 2)
+		d = DEF_SELFTEST_SAMPLE_RATE_ACC_LP;
+	else
+		d = 0;
+	result = inv_plat_single_write(st, REG_LP_MODE_CTRL, d);
+	if (result)
+		return result;
+
+	/* config accel LPF register */
+	if (lp_mode == 2)
+		d = BIT_ACCEL_FCHOCIE_B;
+	else
+		d = DEF_ST_IAM20680_ACCEL_LPF;
+	result = inv_plat_single_write(st, REG_20680_ACCEL_CONFIG2, d);
+	if (result)
+		return result;
+
+	if (lp_mode) {
+		result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+				DEF_SELFTEST_SAMPLE_RATE_LP);
+	} else {
+		result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV,
+				DEF_SELFTEST_SAMPLE_RATE);
+	}
+	if (result)
+		return result;
+	/* wait for the sampling rate change to stabilize */
+	mdelay(SAMPLE_RATE_CHANGE_STABLE);
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG,
+		self_test_flag | DEF_SELFTEST_GYRO_FS);
+	if (result)
+		return result;
+
+	d = DEF_SELFTEST_20680_ACCEL_FS;
+	d |= self_test_flag;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG, d);
+	if (result)
+		return result;
+
+	/* wait for the output to get stable */
+	msleep(DEF_ST_20680_STABLE_TIME);
+
+	/* enable FIFO reading */
+	result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_EN);
+	if (result)
+		return result;
+	/* enable sensor output to FIFO */
+	d = BITS_GYRO_OUT | BIT_ACCEL_OUT;
+	for (i = 0; i < THREE_AXIS; i++) {
+		gyro_result[i] = 0;
+		accel_result[i] = 0;
+	}
+	s = 0;
+	while (s < 200 /*st->self_test.samples*/) {
+		/* Stop FIFO */
+		result = inv_plat_single_write(st, REG_USER_CTRL, 0);
+		if (result)
+			return result;
+		/* clear FIFO */
+		result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_RST);
+		if (result)
+			return result;
+		/* enable FIFO reading */
+		result = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_EN);
+		if (result)
+			return result;
+
+		/* accel lp mode */
+		dd = BIT_CLK_PLL;
+		if (lp_mode == 2)
+			dd |= BIT_LP_EN;
+		else
+			dd &= ~BIT_LP_EN;
+		result = inv_plat_single_write(st, REG_PWR_MGMT_1, dd);
+		if (result)
+			return result;
+
+		result = inv_plat_single_write(st, REG_FIFO_EN, d);
+		if (result)
+			return result;
+		if (lp_mode)
+			mdelay(DEF_GYRO_WAIT_TIME_LP);
+		else
+			mdelay(DEF_GYRO_WAIT_TIME);
+
+		result = inv_plat_single_write(st, REG_FIFO_EN, 0);
+		if (result)
+			return result;
+
+		result = inv_plat_read(st, REG_FIFO_COUNT_H,
+					FIFO_COUNT_BYTE, data);
+		if (result)
+			return result;
+		fifo_count = be16_to_cpup((__be16 *)(&data[0]));
+		pr_debug("%s self_test fifo_count - %d\n",
+			 st->hw->name, fifo_count);
+		packet_count = fifo_count / packet_size;
+		i = 0;
+		while ((i < packet_count) && (s < 200)) {
+			short vals[3];
+
+			result = inv_plat_read(st, REG_FIFO_R_W,
+				packet_size, data);
+			if (result)
+				return result;
+			ind = 0;
+
+			for (j = 0; j < THREE_AXIS; j++) {
+				vals[j] = (short)be16_to_cpup(
+					(__be16 *)(&data[ind + 2 * j]));
+				accel_result[j] += vals[j];
+			}
+			ind += BYTES_PER_SENSOR;
+			pr_debug(
+				"%s self_test accel data - %d %+d %+d %+d\n",
+				st->hw->name, s, vals[0], vals[1], vals[2]);
+
+			for (j = 0; j < THREE_AXIS; j++) {
+				vals[j] = (short)be16_to_cpup(
+					(__be16 *)(&data[ind + 2 * j]));
+				gyro_result[j] += vals[j];
+			}
+			pr_debug("%s self_test gyro data - %d %+d %+d %+d\n",
+				st->hw->name, s, vals[0], vals[1], vals[2]);
+
+			s++;
+			i++;
+		}
+	}
+
+	for (j = 0; j < THREE_AXIS; j++) {
+		accel_result[j] = accel_result[j] / s;
+		accel_result[j] *= DEF_ST_PRECISION;
+	}
+	for (j = 0; j < THREE_AXIS; j++) {
+		gyro_result[j] = gyro_result[j] / s;
+		gyro_result[j] *= DEF_ST_PRECISION;
+	}
+
+	return 0;
+}
+
+
+int inv_power_up_self_test(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_switch_power_in_lp(st, true);
+
+	/* make sure no interrupts */
+	result = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+	if (result)
+		return result;
+
+	if (result)
+		return result;
+	result = inv_switch_engine(st, true, BIT_PWR_ACCEL_STBY);
+	if (result)
+		return result;
+	result = inv_switch_engine(st, true, BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+/*
+ *  inv_hw_self_test() - main function to do hardware self test
+ */
+int inv_hw_self_test(struct inv_mpu_state *st)
+{
+	int result;
+	int gyro_bias_st[THREE_AXIS], gyro_bias_regular[THREE_AXIS];
+	int accel_bias_st[THREE_AXIS], accel_bias_regular[THREE_AXIS];
+#if 0
+	int gyro_bias_regular_lp[THREE_AXIS];
+	int accel_bias_regular_lp[THREE_AXIS];
+	int dummy_bias_regular[THREE_AXIS];
+#endif
+	int test_times, i;
+	char accel_result, gyro_result;
+
+	result = inv_save_setting(st);
+	if (result)
+		return result;
+
+	result = inv_power_up_self_test(st);
+	if (result)
+		return result;
+	accel_result = 0;
+	gyro_result = 0;
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, 0, gyro_bias_regular,
+			accel_bias_regular, 0);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_regular - %+d %+d %+d\n",
+		st->hw->name, accel_bias_regular[0],
+		accel_bias_regular[1], accel_bias_regular[2]);
+	pr_debug("%s self_test gyro bias_regular - %+d %+d %+d\n",
+		st->hw->name, gyro_bias_regular[0], gyro_bias_regular[1],
+		gyro_bias_regular[2]);
+
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, BITS_SELF_TEST_EN, gyro_bias_st,
+					accel_bias_st, 0);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			break;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_st - %+d %+d %+d\n",
+		st->hw->name, accel_bias_st[0], accel_bias_st[1],
+		accel_bias_st[2]);
+	pr_debug("%s self_test gyro bias_st - %+d %+d %+d\n",
+		st->hw->name, gyro_bias_st[0], gyro_bias_st[1],
+		gyro_bias_st[2]);
+
+#if 0
+	/* lp gyro mode */
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, 0, gyro_bias_regular_lp,
+			dummy_bias_regular, 1);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test gyro bias_regular lp - %+d %+d %+d\n",
+		 st->hw->name, gyro_bias_regular_lp[0], gyro_bias_regular_lp[1],
+		 gyro_bias_regular_lp[2]);
+
+	/* lp accel mode */
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test(st, 0, dummy_bias_regular,
+			accel_bias_regular_lp, 2);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("%s self_test accel bias_regular lp - %+d %+d %+d\n",
+		 st->hw->name, accel_bias_regular_lp[0],
+		 accel_bias_regular_lp[1], accel_bias_regular_lp[2]);
+#endif
+
+	/* copy bias */
+	for (i = 0; i < 3; i++) {
+		/* gyro : LN bias as LN is default mode */
+		st->gyro_st_bias[i] = gyro_bias_regular[i] / DEF_ST_PRECISION;
+		/* accel : LN bias as LN is default mode */
+		st->accel_st_bias[i] = accel_bias_regular[i] / DEF_ST_PRECISION;
+	}
+
+	/* Check is done on continuous mode data */
+	accel_result = !inv_check_accel_self_test(st,
+		accel_bias_regular, accel_bias_st);
+	gyro_result = !inv_check_gyro_self_test(st,
+		gyro_bias_regular, gyro_bias_st);
+
+test_fail:
+	inv_recover_setting(st);
+	return (accel_result << DEF_ST_ACCEL_RESULT_SHIFT) | gyro_result;
+}
diff --git a/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_setup_20680.c b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_setup_20680.c
new file mode 100644
index 000000000000..8c9347f52244
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/iam20680/inv_mpu_setup_20680.c
@@ -0,0 +1,506 @@
+/*
+ * Copyright (C) 2017-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+/* set LN mode for gyro regardless of conditions */
+#define USE_GYRO_LN_MODE
+
+static int inv_calc_engine_dur(struct inv_engine_info *ei)
+{
+	if (!ei->running_rate)
+		return -EINVAL;
+	ei->dur = ei->base_time / ei->orig_rate;
+	ei->dur *= ei->divider;
+
+	return 0;
+}
+
+static int inv_turn_on_fifo(struct inv_mpu_state *st)
+{
+	u8 int_en, fifo_en, mode, user;
+	int r;
+
+	r = inv_plat_single_write(st, REG_FIFO_EN, 0);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_USER_CTRL, BIT_FIFO_RST);
+	if (r)
+		return r;
+	fifo_en = 0;
+	int_en = 0;
+
+	if (st->gesture_only_on && (!st->batch.timeout)) {
+		st->gesture_int_count = WOM_DELAY_THRESHOLD;
+		int_en |= BIT_WOM_ALL_INT_EN;
+	}
+#ifdef TIMER_BASED_BATCHING
+	if (st->chip_config.eis_enable)
+		int_en |= BIT_FSYNC_INT_EN;
+	if (!st->batch_timeout)
+		int_en |= BIT_DATA_RDY_EN;
+#else
+	if (st->batch.timeout) {
+		if (!st->batch.fifo_wm_th)
+			int_en = BIT_DATA_RDY_EN;
+	} else {
+		int_en = BIT_DATA_RDY_EN;
+		if (st->chip_config.eis_enable)
+			int_en |= BIT_FSYNC_INT_EN;
+	}
+#endif
+	if (st->sensor[SENSOR_GYRO].on)
+		fifo_en |= BITS_GYRO_FIFO_EN;
+
+	if (st->sensor[SENSOR_ACCEL].on)
+		fifo_en |= BIT_ACCEL_FIFO_EN;
+	r = inv_plat_single_write(st, REG_FIFO_EN, fifo_en);
+	if (r)
+		return r;
+	st->int_en = int_en;
+	r = inv_plat_single_write(st, REG_INT_ENABLE, int_en);
+	if (r)
+		return r;
+	if (st->gesture_only_on && (!st->batch.timeout))
+		mode = BIT_ACCEL_INTEL_EN | BIT_ACCEL_INTEL_MODE;
+	else
+		mode = 0;
+	r = inv_plat_single_write(st, REG_ACCEL_INTEL_CTRL, mode);
+#ifdef SENSOR_DATA_FROM_REGISTERS
+	user = 0;
+#else
+	user = BIT_FIFO_EN;
+#endif
+	r = inv_plat_single_write(st, REG_USER_CTRL, user | st->i2c_dis);
+#ifdef TIMER_BASED_BATCHING
+	if (fifo_en && st->batch_timeout) {
+		if (st->is_batch_timer_running)
+			hrtimer_cancel(&st->hr_batch_timer);
+		st->is_batch_timer_running = true;
+		hrtimer_start(&st->hr_batch_timer,
+			ns_to_ktime(st->batch_timeout), HRTIMER_MODE_REL);
+	} else {
+		if (st->is_batch_timer_running)
+			hrtimer_cancel(&st->hr_batch_timer);
+		st->is_batch_timer_running = false;
+	}
+#endif
+
+	return r;
+}
+
+/*
+ *  inv_reset_fifo() - Reset FIFO related registers.
+ */
+int inv_reset_fifo(struct inv_mpu_state *st, bool turn_off)
+{
+	int r, i;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+	int dur_ms;
+
+	r = inv_turn_on_fifo(st);
+	if (r)
+		return r;
+
+	ts_algo->last_run_time = get_time_ns();
+	ts_algo->reset_ts = ts_algo->last_run_time;
+	if (st->mode_1k_on)
+		ts_algo->first_sample = MODE_1K_INIT_SAMPLE;
+	else
+		ts_algo->first_sample = 1;
+
+	dur_ms = st->smplrt_div + 1;
+	if ((ts_algo->first_sample * dur_ms) < FIRST_SAMPLE_BUF_MS)
+		ts_algo->first_sample = FIRST_SAMPLE_BUF_MS / dur_ms;
+	if (ts_algo->first_sample == 0)
+		ts_algo->first_sample = 1;
+
+	st->last_temp_comp_time = ts_algo->last_run_time;
+	st->left_over_size = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		st->sensor[i].calib_flag = 0;
+		st->sensor[i].sample_calib = 0;
+		st->sensor[i].time_calib = ts_algo->last_run_time;
+	}
+
+	ts_algo->calib_counter = 0;
+
+	return 0;
+}
+
+static int inv_turn_on_engine(struct inv_mpu_state *st)
+{
+	u8 v, w;
+	int r;
+	unsigned int wait_ms;
+
+	if (st->chip_config.gyro_enable | st->chip_config.accel_enable) {
+		w = 0;
+		if (!st->chip_config.gyro_enable)
+			w |= BIT_PWR_GYRO_STBY;
+		if (!st->chip_config.accel_enable)
+			w |= BIT_PWR_ACCEL_STBY;
+	} else if (st->chip_config.compass_enable) {
+		w = BIT_PWR_GYRO_STBY;
+	} else {
+		w = (BIT_PWR_GYRO_STBY | BIT_PWR_ACCEL_STBY);
+	}
+
+	r = inv_plat_read(st, REG_PWR_MGMT_2, 1, &v);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_PWR_MGMT_2, w);
+	if (r)
+		return r;
+
+	wait_ms = 0;
+	if (st->chip_config.gyro_enable
+		&& (v & BIT_PWR_GYRO_STBY)) {
+		wait_ms = INV_IAM20680_GYRO_START_TIME;
+	}
+	if (st->chip_config.accel_enable
+		&& (v & BIT_PWR_ACCEL_STBY)) {
+		if (wait_ms < INV_IAM20680_ACCEL_START_TIME)
+			wait_ms = INV_IAM20680_ACCEL_START_TIME;
+	}
+	if (wait_ms)
+		msleep(wait_ms);
+
+	if (st->chip_config.has_compass) {
+		if (st->chip_config.compass_enable)
+			r = st->slave_compass->resume(st);
+		else
+			r = st->slave_compass->suspend(st);
+		if (r)
+			return r;
+	}
+
+	return 0;
+}
+
+static int inv_setup_dmp_rate(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			st->cntl |= st->sensor[i].output;
+			st->sensor[i].dur =
+				st->eng_info[st->sensor[i].engine_base].dur;
+			st->sensor[i].div = 1;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  inv_set_lpf() - set low pass filer based on fifo rate.
+ */
+static int inv_set_lpf(struct inv_mpu_state *st, int rate)
+{
+	const short hz[] = {188, 98, 42, 20, 10, 5};
+	const int   d[] = {INV_FILTER_188HZ, INV_FILTER_98HZ,
+			INV_FILTER_42HZ, INV_FILTER_20HZ,
+			INV_FILTER_10HZ, INV_FILTER_5HZ};
+	int i, h, data, result;
+
+#ifdef USE_GYRO_LN_MODE
+	if (1) {
+#else
+	if (st->chip_config.eis_enable || st->ois.en || st->mode_1k_on) {
+#endif
+		h = (rate >> 1);
+		i = 0;
+		while ((h < hz[i]) && (i < ARRAY_SIZE(d) - 1))
+			i++;
+		data = d[i];
+		data |= EXT_SYNC_SET;
+		result = inv_plat_single_write(st, REG_CONFIG, data);
+		if (result)
+			return result;
+
+		st->chip_config.lpf = data;
+		result = inv_plat_single_write(st, REG_LP_MODE_CTRL, 0);
+		st->gyro_lp_mode = 0;
+	} else {
+		result = inv_plat_single_write(st, REG_LP_MODE_CTRL,
+							BIT_GYRO_CYCLE_EN);
+		if (result)
+			return result;
+		data = 0;
+		result = inv_plat_single_write(st, REG_CONFIG, data | 3);
+		st->gyro_lp_mode = 1;
+	}
+
+	return result;
+}
+
+static int inv_set_div(struct inv_mpu_state *st, int a_d, int g_d)
+{
+	int result, div;
+
+	if (st->chip_config.gyro_enable)
+		div = g_d;
+	else
+		div = a_d;
+	if (st->chip_config.eis_enable)
+		div = 0;
+
+	st->smplrt_div = div;
+	pr_debug("div= %d\n", div);
+	result = inv_plat_single_write(st, REG_SAMPLE_RATE_DIV, div);
+
+	return result;
+}
+
+static int inv_set_batch(struct inv_mpu_state *st)
+{
+#ifdef TIMER_BASED_BATCHING
+	u64 timeout;
+	int required_fifo_size;
+
+	if (st->batch.timeout) {
+		required_fifo_size = st->batch.timeout * st->eng_info[ENGINE_GYRO].running_rate
+					* st->batch.pk_size / 1000;
+		if (required_fifo_size > MAX_BATCH_FIFO_SIZE) {
+			required_fifo_size = MAX_BATCH_FIFO_SIZE;
+			timeout = (required_fifo_size / st->batch.pk_size) * (1000 / st->eng_info[ENGINE_GYRO].running_rate);
+		} else {
+			timeout = st->batch.timeout;
+		}
+	} else {
+		timeout = 1000 / st->eng_info[ENGINE_GYRO].running_rate;
+	}
+	if (timeout <= 1000 / st->eng_info[ENGINE_GYRO].running_rate)
+		st->batch_timeout = 0;
+	else
+		st->batch_timeout = timeout * 1000000; // ms to ns
+#endif
+	st->batch.fifo_wm_th = 0;
+
+	return 0;
+}
+
+static int inv_set_rate(struct inv_mpu_state *st)
+{
+	int g_d, a_d, result, i;
+
+	result = inv_setup_dmp_rate(st);
+	if (result)
+		return result;
+
+	g_d = st->eng_info[ENGINE_GYRO].divider - 1;
+	a_d = st->eng_info[ENGINE_ACCEL].divider - 1;
+	result = inv_set_div(st, a_d, g_d);
+	if (result)
+		return result;
+	result = inv_set_lpf(st, st->eng_info[ENGINE_GYRO].running_rate);
+	if (result)
+		return result;
+	// set ADLPF at this point not to change after accel is enabled
+	result = inv_set_accel_config2(st, false);
+	st->batch.pk_size = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->batch.pk_size +=  st->sensor[i].sample_size;
+	}
+
+	inv_set_batch(st);
+
+	return result;
+}
+
+static int inv_determine_engine(struct inv_mpu_state *st)
+{
+	int i;
+	bool a_en, g_en;
+	int accel_rate, gyro_rate;
+
+	a_en = false;
+	g_en = false;
+	gyro_rate = MPU_INIT_SENSOR_RATE;
+	accel_rate = MPU_INIT_SENSOR_RATE;
+	/* loop the streaming sensors to see which engine needs to be turned on */
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			a_en |= st->sensor[i].a_en;
+			g_en |= st->sensor[i].g_en;
+		}
+	}
+
+	if (st->chip_config.eis_enable) {
+		g_en = true;
+		st->eis.frame_count = 0;
+		st->eis.fsync_delay = 0;
+		st->eis.gyro_counter = 0;
+		st->eis.voting_count = 0;
+		st->eis.voting_count_sub = 0;
+		gyro_rate = BASE_SAMPLE_RATE;
+	} else {
+		st->eis.eis_triggered = false;
+		st->eis.prev_state = false;
+	}
+
+	accel_rate = st->sensor[SENSOR_ACCEL].rate;
+	gyro_rate  = max(gyro_rate, st->sensor[SENSOR_GYRO].rate);
+
+	st->ts_algo.clock_base = ENGINE_ACCEL;
+
+	if (g_en) {
+		/* gyro engine needs to be fastest */
+		if (a_en)
+			gyro_rate = max(gyro_rate, accel_rate);
+		accel_rate = gyro_rate;
+		st->ts_algo.clock_base = ENGINE_GYRO;
+	} else if (a_en) {
+		/* accel engine needs to be fastest if gyro engine is off */
+		gyro_rate = accel_rate;
+		st->ts_algo.clock_base = ENGINE_ACCEL;
+	}
+
+	st->eng_info[ENGINE_GYRO].running_rate = gyro_rate;
+	st->eng_info[ENGINE_ACCEL].running_rate = accel_rate;
+	if ((gyro_rate >= BASE_SAMPLE_RATE) ||
+					(accel_rate >= BASE_SAMPLE_RATE))
+		st->mode_1k_on = true;
+	else
+		st->mode_1k_on = false;
+	/* engine divider for pressure and compass is set later */
+	if (st->chip_config.eis_enable || st->mode_1k_on) {
+		st->eng_info[ENGINE_GYRO].divider = 1;
+		st->eng_info[ENGINE_ACCEL].divider = 1;
+		// need to update rate and div for 1khz mode
+		for (i = 0 ; i < SENSOR_L_NUM_MAX ; i++) {
+			if (st->sensor_l[i].on) {
+				st->sensor_l[i].counter = 0;
+				if (st->sensor_l[i].rate)
+					st->sensor_l[i].div =
+						BASE_SAMPLE_RATE
+						/ st->sensor_l[i].rate;
+				else
+					st->sensor_l[i].div = 0xffff;
+			}
+		}
+	} else {
+		st->eng_info[ENGINE_GYRO].divider = BASE_SAMPLE_RATE /
+			st->eng_info[ENGINE_GYRO].running_rate;
+		st->eng_info[ENGINE_ACCEL].divider = BASE_SAMPLE_RATE /
+			st->eng_info[ENGINE_ACCEL].running_rate;
+	}
+
+	for (i = 0 ; i < SENSOR_L_NUM_MAX ; i++)
+		st->sensor_l[i].counter = 0;
+
+	inv_calc_engine_dur(&st->eng_info[ENGINE_GYRO]);
+	inv_calc_engine_dur(&st->eng_info[ENGINE_ACCEL]);
+
+	pr_debug("gen: %d aen: %d grate: %d arate: %d\n",
+				g_en, a_en, gyro_rate, accel_rate);
+
+	st->chip_config.gyro_enable = g_en;
+	st->chip_config.accel_enable = a_en;
+
+	return 0;
+}
+
+/*
+ *  set_inv_enable() - enable function.
+ */
+int set_inv_enable(struct iio_dev *indio_dev)
+{
+	int result;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	inv_stop_interrupt(st);
+	inv_determine_engine(st);
+	result = inv_set_rate(st);
+	if (result) {
+		pr_err("inv_set_rate error\n");
+		return result;
+	}
+	result = inv_turn_on_engine(st);
+	if (result) {
+		pr_err("inv_turn_on_engine error\n");
+		return result;
+	}
+	result = inv_reset_fifo(st, false);
+	if (result)
+		return result;
+	result = inv_switch_power_in_lp(st, false);
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable)) {
+		inv_set_power(st, false);
+		return 0;
+	}
+
+	return result;
+}
+
+static int inv_save_interrupt_config(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_read(st, REG_INT_ENABLE, 1, &st->int_en);
+
+	return res;
+}
+
+int inv_stop_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_save_interrupt_config(st);
+	if (res)
+		return res;
+
+	res = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+
+	return res;
+}
+
+int inv_restore_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_single_write(st, REG_INT_ENABLE, st->int_en);
+
+	return res;
+}
+
+int inv_stop_stream_interrupt(struct inv_mpu_state *st)
+{
+	return inv_stop_interrupt(st);
+}
+
+int inv_restore_stream_interrupt(struct inv_mpu_state *st)
+{
+	return inv_restore_interrupt(st);
+}
+
+/* dummy function for 20608D */
+int inv_enable_pedometer_interrupt(struct inv_mpu_state *st, bool en)
+{
+	return 0;
+}
+int inv_dmp_read(struct inv_mpu_state *st, int off, int size, u8 *buf)
+{
+	return 0;
+}
+int inv_firmware_load(struct inv_mpu_state *st)
+{
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/dmp3Default.h b/drivers/iio/imu/inv_mpu/icm20648/dmp3Default.h
new file mode 100644
index 000000000000..d5c1a7547a4d
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/dmp3Default.h
@@ -0,0 +1,343 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define CFG_FIFO_SIZE                   (4184)
+
+/* data output control */
+#define DATA_OUT_CTL1			(4 * 16)
+#define DATA_OUT_CTL2			(4 * 16 + 2)
+#define DATA_INTR_CTL			(4 * 16 + 12)
+#define FIFO_WATERMARK			(31 * 16 + 14)
+
+/* motion event control */
+#define MOTION_EVENT_CTL		(4 * 16 + 14)
+
+/* indicates to DMP which sensors are available */
+/*	1: gyro samples available
+	2: accel samples available
+	8: secondary samples available	*/
+#define DATA_RDY_STATUS			(8 * 16 + 10)
+
+/* batch mode */
+#define BM_BATCH_CNTR			(27 * 16)
+#define BM_BATCH_THLD			(19 * 16 + 12)
+#define BM_BATCH_MASK			(21 * 16 + 14)
+
+/* sensor output data rate */
+#define ODR_ACCEL				(11 * 16 + 14)
+#define ODR_GYRO				(11 * 16 + 10)
+#define ODR_CPASS				(11 * 16 +  6)
+#define ODR_ALS					(11 * 16 +  2)
+#define ODR_QUAT6				(10 * 16 + 12)
+#define ODR_QUAT9				(10 * 16 +  8)
+#define ODR_PQUAT6				(10 * 16 +  4)
+#define ODR_GEOMAG				(10 * 16 +  0)
+#define ODR_PRESSURE			(11 * 16 + 12)
+#define ODR_GYRO_CALIBR			(11 * 16 +  8)
+#define ODR_CPASS_CALIBR		(11 * 16 +  4)
+
+/* sensor output data rate counter */
+#define ODR_CNTR_ACCEL			(9 * 16 + 14)
+#define ODR_CNTR_GYRO			(9 * 16 + 10)
+#define ODR_CNTR_CPASS			(9 * 16 +  6)
+#define ODR_CNTR_ALS			(9 * 16 +  2)
+#define ODR_CNTR_QUAT6			(8 * 16 + 12)
+#define ODR_CNTR_QUAT9			(8 * 16 +  8)
+#define ODR_CNTR_PQUAT6			(8 * 16 +  4)
+#define ODR_CNTR_GEOMAG			(8 * 16 +  0)
+#define ODR_CNTR_PRESSURE		(9 * 16 + 12)
+#define ODR_CNTR_GYRO_CALIBR	(9 * 16 +  8)
+#define ODR_CNTR_CPASS_CALIBR	(9 * 16 +  4)
+
+/* mounting matrix */
+#define CPASS_MTX_00            (23 * 16)
+#define CPASS_MTX_01            (23 * 16 + 4)
+#define CPASS_MTX_02            (23 * 16 + 8)
+#define CPASS_MTX_10            (23 * 16 + 12)
+#define CPASS_MTX_11            (24 * 16)
+#define CPASS_MTX_12            (24 * 16 + 4)
+#define CPASS_MTX_20            (24 * 16 + 8)
+#define CPASS_MTX_21            (24 * 16 + 12)
+#define CPASS_MTX_22            (25 * 16)
+
+#define GYRO_SF					(19 * 16)
+#define ACCEL_FB_GAIN			(34 * 16)
+#define ACCEL_ONLY_GAIN			(16 * 16 + 12)
+
+/* bias calibration */
+#define GYRO_BIAS_X				(139 * 16 +  4)
+#define GYRO_BIAS_Y				(139 * 16 +  8)
+#define GYRO_BIAS_Z				(139 * 16 + 12)
+#define GYRO_ACCURACY			(138 * 16 +  2)
+#define GYRO_BIAS_SET			(138 * 16 +  6)
+#define GYRO_LAST_TEMPR			(134 * 16)
+#define GYRO_SLOPE_X			(78 * 16 +  4)
+#define GYRO_SLOPE_Y			(78 * 16 +  8)
+#define GYRO_SLOPE_Z			(78 * 16 + 12)
+
+#define ACCEL_BIAS_X            (110 * 16 +  4)
+#define ACCEL_BIAS_Y            (110 * 16 +  8)
+#define ACCEL_BIAS_Z            (110 * 16 + 12)
+#define ACCEL_ACCURACY			(97 * 16)
+#define ACCEL_CAL_RESET			(77 * 16)
+#define ACCEL_VARIANCE_THRESH	(93 * 16)
+#define ACCEL_CAL_RATE			(94 * 16 + 4)
+#define ACCEL_PRE_SENSOR_DATA	(97 * 16 + 4)
+#define ACCEL_COVARIANCE		(101 * 16 + 8)
+#define ACCEL_ALPHA_VAR			(91 * 16)
+#define ACCEL_A_VAR				(92 * 16)
+#define ACCEL_CAL_INIT			(94 * 16 + 2)
+
+#define CPASS_BIAS_X            (126 * 16 +  4)
+#define CPASS_BIAS_Y            (126 * 16 +  8)
+#define CPASS_BIAS_Z            (126 * 16 + 12)
+#define CPASS_ACCURACY			(37 * 16)
+#define CPASS_BIAS_SET			(34 * 16 + 14)
+#define MAR_MODE				(37 * 16 + 2)
+#define CPASS_COVARIANCE		(115 * 16)
+#define CPASS_COVARIANCE_CUR	(118 * 16 +  8)
+#define CPASS_REF_MAG_3D		(122 * 16)
+#define CPASS_CAL_INIT			(114 * 16)
+#define CPASS_EST_FIRST_BIAS	(113 * 16)
+#define MAG_DISTURB_STATE		(113 * 16 + 2)
+#define CPASS_VAR_COUNT			(112 * 16 + 6)
+#define CPASS_COUNT_7			(87 * 16 + 2)
+#define CPASS_MAX_INNO			(124 * 16)
+#define CPASS_BIAS_OFFSET		(113 * 16 + 4)
+#define CPASS_CUR_BIAS_OFFSET	(114 * 16 + 4)
+#define CPASS_PRE_SENSOR_DATA	(87 * 16 + 4)
+
+/* Compass Cal params to be adjusted according to sampling rate */
+#define CPASS_TIME_BUFFER		(112 * 16 + 14)
+#define CPASS_RADIUS_3D_THRESH_ANOMALY	(112 * 16 + 8)
+
+#define CPASS_STATUS_CHK		(25 * 16 + 12)
+
+/* 9-axis */
+#define MAGN_THR_9X				(80 * 16)
+#define MAGN_LPF_THR_9X			(80 * 16 +  8)
+#define QFB_THR_9X				(80 * 16 + 12)
+
+/* DMP running counter */
+#define DMPRATE_CNTR			(18 * 16 + 4)
+
+/* pedometer */
+#define PEDSTD_BP_B				(49 * 16 + 12)
+#define PEDSTD_BP_A4			(52 * 16)
+#define PEDSTD_BP_A3			(52 * 16 +  4)
+#define PEDSTD_BP_A2			(52 * 16 +  8)
+#define PEDSTD_BP_A1			(52 * 16 + 12)
+#define PEDSTD_SB				(50 * 16 +  8)
+#define PEDSTD_SB_TIME			(50 * 16 + 12)
+#define PEDSTD_PEAKTHRSH		(57 * 16 +  8)
+#define PEDSTD_TIML				(50 * 16 + 10)
+#define PEDSTD_TIMH				(50 * 16 + 14)
+#define PEDSTD_PEAK				(57 * 16 +  4)
+#define PEDSTD_STEPCTR			(54 * 16)
+#define PEDSTD_STEPCTR2			(58 * 16 +  8)
+#define PEDSTD_TIMECTR			(60 * 16 +  4)
+#define PEDSTD_DECI				(58 * 16)
+#define PEDSTD_SB2				(60 * 16 + 14)
+#define STPDET_TIMESTAMP		(18 * 16 +  8)
+#define PEDSTEP_IND				(19 * 16 +  4)
+
+/* SMD */
+#define SMD_VAR_TH              (141 * 16 + 12)
+#define SMD_VAR_TH_DRIVE        (143 * 16 + 12)
+#define SMD_DRIVE_TIMER_TH      (143 * 16 +  8)
+#define SMD_TILT_ANGLE_TH       (179 * 16 + 12)
+#define BAC_SMD_ST_TH           (179 * 16 +  8)
+#define BAC_ST_ALPHA4           (180 * 16 + 12)
+#define BAC_ST_ALPHA4A          (176 * 16 + 12)
+
+/* Wake on Motion */
+#define WOM_ENABLE              (64 * 16 + 14)
+#define WOM_STATUS              (64 * 16 + 6)
+#define WOM_THRESHOLD           (64 * 16)
+#define WOM_CNTR_TH             (64 * 16 + 12)
+
+/* Activity Recognition */
+#define BAC_RATE                (48  * 16 + 10)
+#define BAC_STATE               (179 * 16 +  0)
+#define BAC_STATE_PREV          (179 * 16 +  4)
+#define BAC_ACT_ON              (182 * 16 +  0)
+#define BAC_ACT_OFF             (183 * 16 +  0)
+#define BAC_STILL_S_F           (177 * 16 +  0)
+#define BAC_RUN_S_F             (177 * 16 +  4)
+#define BAC_DRIVE_S_F           (178 * 16 +  0)
+#define BAC_WALK_S_F            (178 * 16 +  4)
+#define BAC_SMD_S_F             (178 * 16 +  8)
+#define BAC_BIKE_S_F            (178 * 16 + 12)
+#define BAC_E1_SHORT            (146 * 16 +  0)
+#define BAC_E2_SHORT            (146 * 16 +  4)
+#define BAC_E3_SHORT            (146 * 16 +  8)
+#define BAC_VAR_RUN             (148 * 16 + 12)
+#define BAC_TILT_INIT           (181 * 16 +  0)
+#define BAC_MAG_ON              (225 * 16 +  0)
+#define BAC_PS_ON               (74  * 16 +  0)
+#define BAC_BIKE_PREFERENCE     (173 * 16 +  8)
+#define BAC_MAG_I2C_ADDR        (229 * 16 +  8)
+#define BAC_PS_I2C_ADDR         (75  * 16 +  4)
+#define BAC_DRIVE_CONFIDENCE    (144 * 16 +  0)
+#define BAC_WALK_CONFIDENCE     (144 * 16 +  4)
+#define BAC_SMD_CONFIDENCE      (144 * 16 +  8)
+#define BAC_BIKE_CONFIDENCE     (144 * 16 + 12)
+#define BAC_STILL_CONFIDENCE    (145 * 16 +  0)
+#define BAC_RUN_CONFIDENCE      (145 * 16 +  4)
+
+/* Flip/Pick-up */
+#define FP_VAR_ALPHA            (245 * 16 +  8)
+#define FP_STILL_TH             (246 * 16 +  4)
+#define FP_MID_STILL_TH         (244 * 16 +  8)
+#define FP_NOT_STILL_TH         (246 * 16 +  8)
+#define FP_VIB_REJ_TH           (241 * 16 +  8)
+#define FP_MAX_PICKUP_T_TH      (244 * 16 + 12)
+#define FP_PICKUP_TIMEOUT_TH    (248 * 16 +  8)
+#define FP_STILL_CONST_TH       (246 * 16 + 12)
+#define FP_MOTION_CONST_TH      (240 * 16 +  8)
+#define FP_VIB_COUNT_TH         (242 * 16 +  8)
+#define FP_STEADY_TILT_TH       (247 * 16 +  8)
+#define FP_STEADY_TILT_UP_TH    (242 * 16 + 12)
+#define FP_Z_FLAT_TH_MINUS      (243 * 16 +  8)
+#define FP_Z_FLAT_TH_PLUS       (243 * 16 + 12)
+#define FP_DEV_IN_POCKET_TH     (76  * 16 + 12)
+#define FP_PICKUP_CNTR          (247 * 16 +  4)
+#define FP_RATE                 (240 * 16 + 12)
+
+/* Accel FSR */
+#define ACC_SCALE               (30 * 16 + 0)
+#define ACC_SCALE2              (79 * 16 + 4)
+
+/* S-Health keys */
+#define S_HEALTH_WALK_RUN_1		(213 * 16 +  12)
+#define S_HEALTH_WALK_RUN_2		(213 * 16 +   8)
+#define S_HEALTH_WALK_RUN_3		(213 * 16 +   4)
+#define S_HEALTH_WALK_RUN_4		(213 * 16 +   0)
+#define S_HEALTH_WALK_RUN_5		(212 * 16 +  12)
+#define S_HEALTH_WALK_RUN_6		(212 * 16 +   8)
+#define S_HEALTH_WALK_RUN_7		(212 * 16 +   4)
+#define S_HEALTH_WALK_RUN_8		(212 * 16 +   0)
+#define S_HEALTH_WALK_RUN_9		(211 * 16 +  12)
+#define S_HEALTH_WALK_RUN_10	(211 * 16 +   8)
+#define S_HEALTH_WALK_RUN_11	(211 * 16 +   4)
+#define S_HEALTH_WALK_RUN_12	(211 * 16 +   0)
+#define S_HEALTH_WALK_RUN_13	(210 * 16 +  12)
+#define S_HEALTH_WALK_RUN_14	(210 * 16 +   8)
+#define S_HEALTH_WALK_RUN_15	(210 * 16 +   4)
+#define S_HEALTH_WALK_RUN_16	(210 * 16 +   0)
+#define S_HEALTH_WALK_RUN_17	(209 * 16 +  12)
+#define S_HEALTH_WALK_RUN_18	(209 * 16 +   8)
+#define S_HEALTH_WALK_RUN_19	(209 * 16 +   4)
+#define S_HEALTH_WALK_RUN_20	(209 * 16 +   0)
+#define S_HEALTH_CADENCE1		(213 * 16 +  14)
+#define S_HEALTH_CADENCE2		(213 * 16 +  10)
+#define S_HEALTH_CADENCE3		(213 * 16 +   6)
+#define S_HEALTH_CADENCE4		(213 * 16 +   2)
+#define S_HEALTH_CADENCE5		(212 * 16 +  14)
+#define S_HEALTH_CADENCE6		(212 * 16 +  10)
+#define S_HEALTH_CADENCE7		(212 * 16 +   6)
+#define S_HEALTH_CADENCE8		(212 * 16 +   2)
+#define S_HEALTH_CADENCE9		(211 * 16 +  14)
+#define S_HEALTH_CADENCE10		(211 * 16 +  10)
+#define S_HEALTH_CADENCE11		(211 * 16 +   6)
+#define S_HEALTH_CADENCE12		(211 * 16 +   2)
+#define S_HEALTH_CADENCE13		(210 * 16 +  14)
+#define S_HEALTH_CADENCE14		(210 * 16 +  10)
+#define S_HEALTH_CADENCE15		(210 * 16 +   6)
+#define S_HEALTH_CADENCE16		(210 * 16 +   2)
+#define S_HEALTH_CADENCE17		(209 * 16 +  14)
+#define S_HEALTH_CADENCE18		(209 * 16 +  10)
+#define S_HEALTH_CADENCE19		(209 * 16 +   6)
+#define S_HEALTH_CADENCE20		(209 * 16 +   2)
+#define S_HEALTH_INT_PERIOD		(214 * 16 +   6)
+#define S_HEALTH_INT_PERIOD2	(214 * 16 +  10)
+#define S_HEALTH_BACKUP1		(214 * 16 +   0)
+#define S_HEALTH_BACKUP2		(214 * 16 +   2)
+#define S_HEALTH_RATE           (208 * 16 +  14)
+
+/* EIS authentication */
+#define EIS_AUTH_INPUT			(160 * 16 +   4)
+#define EIS_AUTH_OUTPUT			(160 * 16 +   0)
+
+#define ACCEL_SET		0x8000
+#define GYRO_SET		0x4000
+#define CPASS_SET		0x2000
+#define ALS_SET			0x1000
+#define QUAT6_SET		0x0800
+#define QUAT9_SET		0x0400
+#define PQUAT6_SET		0x0200
+#define GEOMAG_SET		0x0100
+#define PRESSURE_SET	0x0080
+#define CPASS_CALIBR_SET 0x0020
+#define PED_STEPDET_SET	0x0010
+#define HEADER2_SET		0x0008
+#define PED_STEPIND_SET 0x0007
+
+/* data output control reg 2 */
+#define ACCEL_ACCURACY_SET  0x4000
+#define GYRO_ACCURACY_SET   0x2000
+#define CPASS_ACCURACY_SET  0x1000
+#define FSYNC_SET           0x0800
+#define FLIP_PICKUP_SET     0x0400
+#define BATCH_MODE_EN       0x0100
+#define ACT_RECOG_SET       0x0080
+#define SECOND_SEN_OFF_SET  0x0040
+
+/* motion event control reg
+ high byte of motion event control */
+#define PEDOMETER_EN        0x4000
+#define PEDOMETER_INT_EN    0x2000
+#define TILT_INT_EN         0x1000
+#define SMD_EN              0x0800
+#define SECOND_SENSOR_AUTO  0x0400
+#define ACCEL_CAL_EN        0x0200
+#define GYRO_CAL_EN         0x0100
+/* low byte of motion event control */
+#define COMPASS_CAL_EN      0x0080
+#define NINE_AXIS_EN        0x0040
+#define S_HEALTH_EN         0x0020
+#define FLIP_PICKUP_EN      0x0010
+#define GEOMAG_RV_EN        0x0008
+#define BRING_LOOK_SEE_EN   0x0004
+#define BAC_ACCEL_ONLY_EN   0x0002
+
+/* data packet size reg 1 */
+#define HEADER_SZ		2
+#define ACCEL_DATA_SZ	6
+#define GYRO_DATA_SZ	12
+#define CPASS_DATA_SZ	6
+#define ALS_DATA_SZ		8
+#define QUAT6_DATA_SZ	12
+#define QUAT9_DATA_SZ	14
+#define PQUAT6_DATA_SZ	6
+#define GEOMAG_DATA_SZ	14
+#define PRESSURE_DATA_SZ		6
+#define CPASS_CALIBR_DATA_SZ	12
+#define PED_STEPDET_TIMESTAMP_SZ	4
+#define FOOTER_SZ		2
+
+/* data packet size reg 2 */
+#define HEADER2_SZ			2
+#define ACCEL_ACCURACY_SZ	2
+#define GYRO_ACCURACY_SZ	2
+#define CPASS_ACCURACY_SZ	2
+#define FSYNC_SZ			2
+#define FLIP_PICKUP_SZ      2
+#define ACT_RECOG_SZ        6
+#define SECOND_AUTO_OFF_SZ    2
+
+#define DMP_START_ADDRESS   ((unsigned short)0x1000)
+#define DMP_MEM_BANK_SIZE   256
+#define DMP_LOAD_START      0x90
+
+#define DMP_CODE_SIZE 13463
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_core.c b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_core.c
new file mode 100644
index 000000000000..212ae54ef51a
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_core.c
@@ -0,0 +1,2846 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/crc32.h>
+
+#include "../inv_mpu_iio.h"
+
+static const struct inv_hw_s hw_info[INV_NUM_PARTS] = {
+	[ICM20648] = {128, "icm20648"},
+};
+
+static int debug_mem_read_addr = 0x900;
+static char debug_reg_addr = 0x6;
+
+const char sensor_l_info[][30] = {
+	"SENSOR_L_ACCEL",
+	"SENSOR_L_GYRO",
+	"SENSOR_L_MAG",
+	"SENSOR_L_ALS",
+	"SENSOR_L_SIXQ",
+	"SENSOR_L_NINEQ",
+	"SENSOR_L_PEDQ",
+	"SENSOR_L_GEOMAG",
+	"SENSOR_L_PRESSURE",
+	"SENSOR_L_GYRO_CAL",
+	"SENSOR_L_MAG_CAL",
+	"SENSOR_L_EIS_GYRO",
+	"SENSOR_L_ACCEL_WAKE",
+	"SENSOR_L_GYRO_WAKE",
+	"SENSOR_L_MAG_WAKE",
+	"SENSOR_L_ALS_WAKE",
+	"SENSOR_L_SIXQ_WAKE",
+	"SENSOR_L_NINEQ_WAKE",
+	"SENSOR_L_PEDQ_WAKE",
+	"SENSOR_L_GEOMAG_WAKE",
+	"SENSOR_L_PRESSURE_WAKE",
+	"SENSOR_L_GYRO_CAL_WAKE",
+	"SENSOR_L_MAG_CAL_WAKE",
+	"SENSOR_L_NUM_MAX",
+};
+
+/*
+ * inv_firmware_loaded_store() -  calling this function will change
+ *                        firmware load
+ */
+static ssize_t inv_firmware_loaded_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+
+	if (data)
+		return -EINVAL;
+	st->chip_config.firmware_loaded = 0;
+
+	return count;
+
+}
+static int inv_setup_poke_mode(struct inv_mpu_state *st, bool data)
+{
+	int result;
+
+	if (data)
+		result = inv_plat_single_write(st, REG_DMP_START_MODE,
+							BIT_DMP_START_MODE);
+	else
+		result = inv_plat_single_write(st, REG_DMP_START_MODE, 0);
+
+	return result;
+}
+static ssize_t inv_poke_mode_store(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+
+	if (st->poke_mode_on == data)
+		return count;
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	st->poke_mode_on = data;
+	result = inv_setup_poke_mode(st, data);
+
+	if (result)
+		return result;
+
+	set_inv_enable(indio_dev);
+
+	return count;
+}
+
+static int inv_dry_run_dmp(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	st->smd.on = 1;
+	inv_check_sensor_on(st);
+	st->trigger_state = EVENT_TRIGGER;
+	set_inv_enable(indio_dev);
+	msleep(DRY_RUN_TIME);
+	st->smd.on = 0;
+	inv_check_sensor_on(st);
+	st->trigger_state = EVENT_TRIGGER;
+	set_inv_enable(indio_dev);
+
+	return 0;
+}
+
+static int _dmp_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data, output;
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		goto dmp_bias_store_fail;
+	switch (this_attr->address) {
+	case ATTR_DMP_ACCEL_X_DMP_BIAS:
+		if (data)
+			st->sensor_acurracy_flag[SENSOR_ACCEL_ACCURACY] = true;
+		result = write_be32_to_mem(st, data, ACCEL_BIAS_X);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_accel_dmp_bias[0] = data;
+		break;
+	case ATTR_DMP_ACCEL_Y_DMP_BIAS:
+		result = write_be32_to_mem(st, data, ACCEL_BIAS_Y);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_accel_dmp_bias[1] = data;
+		break;
+	case ATTR_DMP_ACCEL_Z_DMP_BIAS:
+		result = write_be32_to_mem(st, data, ACCEL_BIAS_Z);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_accel_dmp_bias[2] = data;
+		break;
+	case ATTR_DMP_GYRO_X_DMP_BIAS:
+		if (data)
+			st->sensor_acurracy_flag[SENSOR_GYRO_ACCURACY] = true;
+		result = write_be32_to_mem(st, data, GYRO_BIAS_X);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_gyro_dmp_bias[0] = data;
+		break;
+	case ATTR_DMP_GYRO_Y_DMP_BIAS:
+		result = write_be32_to_mem(st, data, GYRO_BIAS_Y);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_gyro_dmp_bias[1] = data;
+		break;
+	case ATTR_DMP_GYRO_Z_DMP_BIAS:
+		result = write_be32_to_mem(st, data, GYRO_BIAS_Z);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_gyro_dmp_bias[2] = data;
+		break;
+	case ATTR_DMP_SC_AUTH:
+	case ATTR_DMP_EIS_AUTH:
+		result = write_be32_to_mem(st, data, EIS_AUTH_INPUT);
+		if (result)
+			goto dmp_bias_store_fail;
+		inv_dry_run_dmp(indio_dev);
+		result = inv_switch_power_in_lp(st, true);
+		if (result)
+			goto dmp_bias_store_fail;
+		result = read_be32_from_mem(st, &output, EIS_AUTH_OUTPUT);
+		if (result)
+			goto dmp_bias_store_fail;
+		inv_push_marker_to_buffer(st, EIS_CALIB_HDR, output);
+		break;
+	case ATTR_DMP_MAGN_X_DMP_BIAS:
+		if (data)
+			st->sensor_acurracy_flag[SENSOR_COMPASS_ACCURACY] =
+							true;
+		result = write_be32_to_mem(st, data, CPASS_BIAS_X);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_compass_dmp_bias[0] = data;
+		break;
+	case ATTR_DMP_MAGN_Y_DMP_BIAS:
+		result = write_be32_to_mem(st, data, CPASS_BIAS_Y);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_compass_dmp_bias[1] = data;
+		break;
+	case ATTR_DMP_MAGN_Z_DMP_BIAS:
+		result = write_be32_to_mem(st, data, CPASS_BIAS_Z);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->input_compass_dmp_bias[2] = data;
+		break;
+	case ATTR_DMP_MISC_GYRO_RECALIBRATION:
+		result = write_be32_to_mem(st, 0, GYRO_LAST_TEMPR);
+		if (result)
+			goto dmp_bias_store_fail;
+		break;
+	case ATTR_DMP_MISC_ACCEL_RECALIBRATION:
+		{
+			u8 d[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+			int i;
+			u32 d1[] = { 0, 0, 0, 0,
+				0, 0, 0, 0, 0, 0,
+				3276800, 3276800, 3276800, 3276800
+			};
+			u32 *w_d;
+
+			if (data) {
+				result =
+					inv_write_2bytes(st, ACCEL_CAL_RESET, 1);
+				if (result)
+					goto dmp_bias_store_fail;
+				result =
+					mem_w(ACCEL_PRE_SENSOR_DATA, ARRAY_SIZE(d),
+					d);
+				w_d = d1;
+			} else {
+				w_d = st->accel_covariance;
+			}
+			for (i = 0; i < ARRAY_SIZE(d1); i++) {
+				result = write_be32_to_mem(st, w_d[i],
+					ACCEL_COVARIANCE +
+					i * sizeof(int));
+				if (result)
+					goto dmp_bias_store_fail;
+			}
+
+			break;
+		}
+	case ATTR_DMP_PARAMS_ACCEL_CALIBRATION_THRESHOLD:
+		result = write_be32_to_mem(st, data, ACCEL_VARIANCE_THRESH);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->accel_calib_threshold = data;
+		break;
+	/* this serves as a divider of calibration rate, 0->225, 3->55 */
+	case ATTR_DMP_PARAMS_ACCEL_CALIBRATION_RATE:
+		if (data < 0)
+			data = 0;
+		result = inv_write_2bytes(st, ACCEL_CAL_RATE, data);
+		if (result)
+			goto dmp_bias_store_fail;
+		st->accel_calib_rate = data;
+		break;
+	case ATTR_DMP_DEBUG_MEM_READ:
+		debug_mem_read_addr = data;
+		break;
+	case ATTR_DMP_DEBUG_MEM_WRITE:
+		inv_write_2bytes(st, debug_mem_read_addr, data);
+		break;
+	default:
+		break;
+	}
+
+dmp_bias_store_fail:
+	if (result)
+		return result;
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static int inv_set_accel_bias_reg(struct inv_mpu_state *st,
+			int accel_bias, int axis)
+{
+	int accel_reg_bias;
+	u8 addr;
+	u8 d[2];
+	int result = 0;
+
+	switch (axis) {
+	case 0:
+		/* X */
+		addr = REG_XA_OFFS_H;
+		accel_reg_bias = st->org_accel_offset_reg[0];
+		break;
+	case 1:
+		/* Y */
+		addr = REG_YA_OFFS_H;
+		accel_reg_bias = st->org_accel_offset_reg[1];
+		break;
+	case 2:
+		/* Z* */
+		addr = REG_ZA_OFFS_H;
+		accel_reg_bias = st->org_accel_offset_reg[2];
+		break;
+	default:
+		result = -EINVAL;
+		goto accel_bias_set_err;
+	}
+
+	/* accel_bias is 2g scaled by 1<<16.
+	 * Convert to 16g, and mask bit0 */
+	inv_set_bank(st, BANK_SEL_1);
+
+	accel_reg_bias -= ((accel_bias / 8 / 65536) & ~1);
+
+	d[0] = (accel_reg_bias >> 8) & 0xff;
+	d[1] = (accel_reg_bias) & 0xff;
+	result = inv_plat_single_write(st, addr, d[0]);
+	if (result)
+		goto accel_bias_set_err;
+	result = inv_plat_single_write(st, addr + 1, d[1]);
+	if (result)
+		goto accel_bias_set_err;
+
+accel_bias_set_err:
+	inv_set_bank(st, BANK_SEL_0);
+	return result;
+}
+
+static int inv_set_gyro_bias_reg(struct inv_mpu_state *st,
+			const int gyro_bias, int axis)
+{
+	int gyro_reg_bias;
+	u8 addr;
+	u8 d[2];
+	int result = 0;
+
+	inv_set_bank(st, BANK_SEL_2);
+
+	switch (axis) {
+	case 0:
+		/* X */
+		addr = REG_XG_OFFS_USR_H;
+		break;
+	case 1:
+		/* Y */
+		addr = REG_YG_OFFS_USR_H;
+		break;
+	case 2:
+		/* Z */
+		addr = REG_ZG_OFFS_USR_H;
+		break;
+	default:
+		result = -EINVAL;
+		goto gyro_bias_set_err;
+	}
+
+	/* gyro_bias is 2000dps scaled by 1<<16.
+	 * Convert to 1000dps */
+	gyro_reg_bias = (-gyro_bias * 2 / 65536);
+
+	d[0] = (gyro_reg_bias >> 8) & 0xff;
+	d[1] = (gyro_reg_bias) & 0xff;
+	result = inv_plat_single_write(st, addr, d[0]);
+	if (result)
+		goto gyro_bias_set_err;
+	result = inv_plat_single_write(st, addr + 1, d[1]);
+	if (result)
+		goto gyro_bias_set_err;
+
+gyro_bias_set_err:
+	inv_set_bank(st, BANK_SEL_0);
+	return result;
+}
+
+static int _bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		goto bias_store_fail;
+	switch (this_attr->address) {
+	case ATTR_ACCEL_X_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[0] = data;
+		break;
+	case ATTR_ACCEL_Y_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[1] = data;
+		break;
+	case ATTR_ACCEL_Z_OFFSET:
+		result = inv_set_accel_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_accel_bias[2] = data;
+		break;
+	case ATTR_GYRO_X_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 0);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[0] = data;
+		break;
+	case ATTR_GYRO_Y_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 1);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[1] = data;
+		break;
+	case ATTR_GYRO_Z_OFFSET:
+		result = inv_set_gyro_bias_reg(st, data, 2);
+		if (result)
+			goto bias_store_fail;
+		st->input_gyro_bias[2] = data;
+		break;
+	default:
+		break;
+	}
+
+bias_store_fail:
+	if (result)
+		return result;
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_dmp_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	int result;
+
+	mutex_lock(&indio_dev->mlock);
+	result = _dmp_bias_store(dev, attr, buf, count);
+	mutex_unlock(&indio_dev->mlock);
+
+	return result;
+}
+
+static ssize_t inv_bias_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	int result;
+
+	mutex_lock(&indio_dev->mlock);
+	result = _bias_store(dev, attr, buf, count);
+	mutex_unlock(&indio_dev->mlock);
+
+	return result;
+}
+
+static ssize_t inv_debug_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_LP_EN_OFF:
+		st->chip_config.lp_en_mode_off = !!data;
+		inv_switch_power_in_lp(st, !!data);
+		break;
+	case ATTR_DMP_CLK_SEL:
+		st->chip_config.clk_sel = !!data;
+		inv_switch_power_in_lp(st, !!data);
+		break;
+	case ATTR_DEBUG_REG_ADDR:
+		debug_reg_addr = data;
+		break;
+	case ATTR_DEBUG_REG_WRITE:
+		inv_plat_single_write(st, debug_reg_addr, data);
+		break;
+	case ATTR_DEBUG_WRITE_CFG:
+		break;
+	}
+	return count;
+}
+
+static int _misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_LOW_POWER_GYRO_ON:
+		st->chip_config.low_power_gyro_on = !!data;
+		break;
+	case ATTR_DMP_DEBUG_DETERMINE_ENGINE_ON:
+		st->debug_determine_engine_on = !!data;
+		break;
+	case ATTR_GYRO_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.fsr = data;
+		result = inv_set_gyro_sf(st);
+		return result;
+	case ATTR_ACCEL_SCALE:
+		if (data > 3)
+			return -EINVAL;
+		st->chip_config.accel_fs = data;
+		result = inv_set_accel_sf(st);
+		if (result)
+			return result;
+		result = inv_write_accel_sf(st);
+		return result;
+	case ATTR_DMP_PED_INT_ON:
+		result = inv_write_cntl(st, PEDOMETER_INT_EN, !!data,
+					MOTION_EVENT_CTL);
+		if (result)
+			return result;
+		st->ped.int_on = !!data;
+		return 0;
+	case ATTR_DMP_PED_STEP_THRESH:
+		result = inv_write_2bytes(st, PEDSTD_SB, data);
+		if (result)
+			return result;
+		st->ped.step_thresh = data;
+		return 0;
+	case ATTR_DMP_PED_INT_THRESH:
+		result = inv_write_2bytes(st, PEDSTD_SB2, data);
+		if (result)
+			return result;
+		st->ped.int_thresh = data;
+		return 0;
+	case ATTR_DMP_PED_INT_MODE:
+		st->ped.int_mode = !!data;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+	st->trigger_state = MISC_TRIGGER;
+	result = set_inv_enable(indio_dev);
+
+	return result;
+}
+
+/*
+ * inv_misc_attr_store() -  calling this function will store current
+ *                        dmp parameter settings
+ */
+static ssize_t inv_misc_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	int result;
+
+	mutex_lock(&indio_dev->mlock);
+	result = _misc_attr_store(dev, attr, buf, count);
+	mutex_unlock(&indio_dev->mlock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static int _debug_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result, data;
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+	if (!st->debug_determine_engine_on)
+		return -EINVAL;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+	switch (this_attr->address) {
+	case ATTR_DMP_IN_ANGLVEL_ACCURACY_ENABLE:
+		st->sensor_accuracy[SENSOR_GYRO_ACCURACY].on = !!data;
+		break;
+	case ATTR_DMP_IN_ACCEL_ACCURACY_ENABLE:
+		st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].on = !!data;
+		break;
+	case ATTR_DMP_ACCEL_CAL_ENABLE:
+		st->accel_cal_enable = !!data;
+		break;
+	case ATTR_DMP_GYRO_CAL_ENABLE:
+		st->gyro_cal_enable = !!data;
+		break;
+	case ATTR_DMP_EVENT_INT_ON:
+		st->chip_config.dmp_event_int_on = !!data;
+		break;
+	case ATTR_DMP_ON:
+		st->chip_config.dmp_on = !!data;
+		break;
+	case ATTR_GYRO_ENABLE:
+		st->chip_config.gyro_enable = !!data;
+		break;
+	case ATTR_ACCEL_ENABLE:
+		st->chip_config.accel_enable = !!data;
+		break;
+	case ATTR_COMPASS_ENABLE:
+		st->chip_config.compass_enable = !!data;
+		break;
+	default:
+		return -EINVAL;
+	}
+	st->trigger_state = DEBUG_TRIGGER;
+	result = set_inv_enable(indio_dev);
+	if (result)
+		return result;
+
+	return count;
+}
+
+/*
+ * inv_debug_attr_store() -  calling this function will store current
+ *                        dmp parameter settings
+ */
+static ssize_t inv_debug_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	int result;
+
+	mutex_lock(&indio_dev->mlock);
+	result = _debug_attr_store(dev, attr, buf, count);
+	mutex_unlock(&indio_dev->mlock);
+
+	return result;
+}
+
+static ssize_t inv_sensor_rate_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n",
+					st->sensor_l[this_attr->address].rate);
+}
+
+static ssize_t inv_sensor_rate_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, rate, ind;
+	int result;
+
+	if (!st->chip_config.firmware_loaded) {
+		pr_err("sensor_rate_store: firmware not loaded\n");
+		return -EINVAL;
+	}
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data <= 0) {
+		pr_err("sensor_rate_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	rate = inv_rate_convert(st, ind, data);
+
+	pr_debug("sensor [%s] requested  rate %d input [%d]\n",
+						sensor_l_info[ind], rate, data);
+
+	if (rate == st->sensor_l[ind].rate)
+		return count;
+	mutex_lock(&indio_dev->mlock);
+	st->sensor_l[ind].rate = rate;
+	st->trigger_state = DATA_TRIGGER;
+	inv_check_sensor_on(st);
+	if (st->sensor_l[ind].on) {
+		result = set_inv_enable(indio_dev);
+		if (result) {
+			mutex_unlock(&indio_dev->mlock);
+			return result;
+		}
+	}
+	pr_debug("%s rate %d div %d\n", sensor_l_info[ind],
+				st->sensor_l[ind].rate, st->sensor_l[ind].div);
+	mutex_unlock(&indio_dev->mlock);
+
+	return count;
+}
+
+static ssize_t inv_sensor_on_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n",
+					st->sensor_l[this_attr->address].on);
+}
+
+static ssize_t inv_sensor_on_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data, on, ind;
+	int result;
+
+	if (!st->chip_config.firmware_loaded) {
+		pr_err("sensor_on store: firmware not loaded\n");
+		return -EINVAL;
+	}
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return -EINVAL;
+	if (data < 0) {
+		pr_err("sensor_on_store: invalid data=%d\n", data);
+		return -EINVAL;
+	}
+	ind = this_attr->address;
+	on = !!data;
+
+	pr_debug("sensor [%s] requested  %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+
+	if (on == st->sensor_l[ind].on) {
+		pr_debug("sensor [%s] is already %s, input [%d]\n",
+			sensor_l_info[ind], (on == 1) ? "On" : "Off", data);
+		return count;
+	}
+
+	mutex_lock(&indio_dev->mlock);
+	st->sensor_l[ind].on = on;
+	st->trigger_state = RATE_TRIGGER;
+	inv_check_sensor_on(st);
+	if (on && (!st->sensor_l[ind].rate)) {
+		mutex_unlock(&indio_dev->mlock);
+		pr_info("rate error for [%s]\n", sensor_l_info[ind]);
+		return count;
+	}
+	result = set_inv_enable(indio_dev);
+	mutex_unlock(&indio_dev->mlock);
+	if (result)
+		return result;
+
+	pr_debug("Sensor [%s] is %s by sysfs\n",
+				sensor_l_info[ind], (on == 1) ? "On" : "Off");
+	return count;
+}
+
+static int inv_check_l_step(struct inv_mpu_state *st)
+{
+	if (st->step_counter_l_on || st->step_counter_wake_l_on)
+		st->ped.on = true;
+	else
+		st->ped.on = false;
+
+	return 0;
+}
+
+static int _send_pedo_steps(struct inv_mpu_state *st)
+{
+	int result;
+	int step;
+
+	result = inv_get_pedometer_steps(st, &step);
+	if (result) {
+		pr_info("Failed to read step count\n");
+		return result;
+	}
+	inv_send_steps(st, step, get_time_ns());
+	st->prev_steps = step;
+
+	return 0;
+}
+
+static int inv_send_pedo_steps(struct inv_mpu_state *st)
+{
+	inv_switch_power_in_lp(st, true);
+	_send_pedo_steps(st);
+	inv_switch_power_in_lp(st, false);
+
+	return 0;
+}
+
+static int _basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int data;
+	int result;
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+	result = kstrtoint(buf, 10, &data);
+	if (result || (data < 0))
+		return -EINVAL;
+
+	switch (this_attr->address) {
+	case ATTR_DMP_PED_ON:
+		if ((!!data) == st->ped.on)
+			return count;
+		st->ped.on = !!data;
+		break;
+	case ATTR_DMP_SMD_ENABLE:
+		if ((!!data) == st->smd.on) {
+			pr_info("SMD is %s\n  Same", st->smd.on ? "On" : "Off");
+			return count;
+		}
+		st->smd.on = !!data;
+		pr_info("SMD is %s\n", st->smd.on ? "On" : "Off");
+		break;
+	case ATTR_DMP_TILT_ENABLE:
+		if ((!!data) == st->chip_config.tilt_enable)
+			return count;
+		st->chip_config.tilt_enable = !!data;
+		pr_info("Tile %s\n",
+			st->chip_config.tilt_enable ==
+			1 ? "Enabled" : "Disabled");
+		break;
+	case ATTR_DMP_PICK_UP_ENABLE:
+		if ((!!data) == st->chip_config.pick_up_enable) {
+			pr_info("Pick_up enable already %s\n",
+				st->chip_config.pick_up_enable ==
+				1 ? "Enabled" : "Disabled");
+			return count;
+		}
+		st->chip_config.pick_up_enable = !!data;
+		pr_info("Pick up %s\n",
+			st->chip_config.pick_up_enable ==
+			1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_EIS_ENABLE:
+		if ((!!data) == st->chip_config.eis_enable)
+			return count;
+		st->chip_config.eis_enable = !!data;
+		pr_info("Eis %s\n",
+			st->chip_config.eis_enable ==
+			1 ? "Enable" : "Disable");
+		break;
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		st->step_detector_l_on = !!data;
+		break;
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		st->step_detector_wake_l_on = !!data;
+		break;
+	case ATTR_DMP_ACTIVITY_ON:
+		if ((!!data) == st->chip_config.activity_on)
+			return count;
+		st->chip_config.activity_on = !!data;
+		break;
+	case ATTR_DMP_STEP_COUNTER_ON:
+		st->step_counter_l_on = !!data;
+		if (st->step_counter_l_on)
+			inv_send_pedo_steps(st);
+		break;
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		st->step_counter_wake_l_on = !!data;
+		if (st->step_counter_wake_l_on)
+			inv_send_pedo_steps(st);
+		break;
+	case ATTR_DMP_STEP_COUNTER_SEND:
+		if (st->step_counter_l_on || st->step_counter_wake_l_on)
+			inv_send_pedo_steps(st);
+		return count;
+		break;
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		if (data == st->batch.timeout)
+			return count;
+		st->batch.timeout = data;
+		break;
+	default:
+		return -EINVAL;
+	};
+	inv_check_l_step(st);
+	inv_check_sensor_on(st);
+
+	st->trigger_state = EVENT_TRIGGER;
+	result = set_inv_enable(indio_dev);
+	if (result)
+		return result;
+
+	return count;
+}
+
+/*
+ * inv_basic_attr_store() -  calling this function will store current
+ *                        non-dmp parameter settings
+ */
+static ssize_t inv_basic_attr_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	int result;
+
+	mutex_lock(&indio_dev->mlock);
+	result = _basic_attr_store(dev, attr, buf, count);
+
+	mutex_unlock(&indio_dev->mlock);
+
+	return result;
+}
+
+/*
+ * inv_attr_bias_show() -  calling this function will show current
+ *                        dmp gyro/accel bias.
+ */
+static int _attr_bias_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int axes, addr, result, dmp_bias;
+	int sensor_type;
+
+	switch (this_attr->address) {
+	case ATTR_ANGLVEL_X_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_bias[0]);
+	case ATTR_ANGLVEL_Y_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_bias[1]);
+	case ATTR_ANGLVEL_Z_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_bias[2]);
+	case ATTR_ACCEL_X_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_bias[0]);
+	case ATTR_ACCEL_Y_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_bias[1]);
+	case ATTR_ACCEL_Z_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_bias[2]);
+	case ATTR_DMP_ACCEL_X_DMP_BIAS:
+		axes = 0;
+		addr = ACCEL_BIAS_X;
+		sensor_type = SENSOR_ACCEL;
+		break;
+	case ATTR_DMP_ACCEL_Y_DMP_BIAS:
+		axes = 1;
+		addr = ACCEL_BIAS_Y;
+		sensor_type = SENSOR_ACCEL;
+		break;
+	case ATTR_DMP_ACCEL_Z_DMP_BIAS:
+		axes = 2;
+		addr = ACCEL_BIAS_Z;
+		sensor_type = SENSOR_ACCEL;
+		break;
+	case ATTR_DMP_GYRO_X_DMP_BIAS:
+		axes = 0;
+		addr = GYRO_BIAS_X;
+		sensor_type = SENSOR_GYRO;
+		break;
+	case ATTR_DMP_GYRO_Y_DMP_BIAS:
+		axes = 1;
+		addr = GYRO_BIAS_Y;
+		sensor_type = SENSOR_GYRO;
+		break;
+	case ATTR_DMP_GYRO_Z_DMP_BIAS:
+		axes = 2;
+		addr = GYRO_BIAS_Z;
+		sensor_type = SENSOR_GYRO;
+		break;
+	case ATTR_DMP_MAGN_X_DMP_BIAS:
+		axes = 0;
+		addr = CPASS_BIAS_X;
+		sensor_type = SENSOR_COMPASS;
+		break;
+	case ATTR_DMP_MAGN_Y_DMP_BIAS:
+		axes = 1;
+		addr = CPASS_BIAS_Y;
+		sensor_type = SENSOR_COMPASS;
+		break;
+	case ATTR_DMP_MAGN_Z_DMP_BIAS:
+		axes = 2;
+		addr = CPASS_BIAS_Z;
+		sensor_type = SENSOR_COMPASS;
+		break;
+	case ATTR_DMP_SC_AUTH:
+	case ATTR_DMP_EIS_AUTH:
+		axes = 0;
+		addr = EIS_AUTH_OUTPUT;
+		sensor_type = -1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	result = read_be32_from_mem(st, &dmp_bias, addr);
+	if (result)
+		return result;
+	inv_switch_power_in_lp(st, false);
+	if (SENSOR_GYRO == sensor_type)
+		st->input_gyro_dmp_bias[axes] = dmp_bias;
+	else if (SENSOR_ACCEL == sensor_type)
+		st->input_accel_dmp_bias[axes] = dmp_bias;
+	else if (SENSOR_COMPASS == sensor_type)
+		st->input_compass_dmp_bias[axes] = dmp_bias;
+	else if (sensor_type != -1)
+		return -EINVAL;
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", dmp_bias);
+}
+
+static ssize_t inv_attr_bias_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	int result;
+
+	mutex_lock(&indio_dev->mlock);
+	result = _attr_bias_show(dev, attr, buf);
+
+	mutex_unlock(&indio_dev->mlock);
+
+	return result;
+}
+
+/*
+ * inv_attr_show() -  calling this function will show current
+ *                        dmp parameters.
+ */
+static ssize_t inv_attr_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result;
+	s8 *m;
+
+	switch (this_attr->address) {
+	case ATTR_GYRO_SCALE:
+		{
+			const s16 gyro_scale[] = { 250, 500, 1000, 2000 };
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n",
+				gyro_scale[st->chip_config.fsr]);
+		}
+	case ATTR_ACCEL_SCALE:
+		{
+			const s16 accel_scale[] = { 2, 4, 8, 16 };
+			return snprintf(buf, MAX_WR_SZ, "%d\n",
+				accel_scale[st->chip_config.accel_fs]);
+		}
+	case ATTR_COMPASS_SCALE:
+		st->slave_compass->get_scale(st, &result);
+
+		return snprintf(buf, MAX_WR_SZ, "%d\n", result);
+	case ATTR_COMPASS_SENSITIVITY_X:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_info.compass_sens[0]);
+	case ATTR_COMPASS_SENSITIVITY_Y:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_info.compass_sens[1]);
+	case ATTR_COMPASS_SENSITIVITY_Z:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_info.compass_sens[2]);
+	case ATTR_GYRO_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.gyro_enable);
+	case ATTR_ACCEL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.accel_enable);
+	case ATTR_DMP_ACCEL_CAL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_cal_enable);
+	case ATTR_DMP_GYRO_CAL_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_cal_enable);
+	case ATTR_DMP_DEBUG_DETERMINE_ENGINE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->debug_determine_engine_on);
+	case ATTR_DMP_PARAMS_ACCEL_CALIBRATION_THRESHOLD:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->accel_calib_threshold);
+	case ATTR_DMP_PARAMS_ACCEL_CALIBRATION_RATE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_calib_rate);
+	case ATTR_FIRMWARE_LOADED:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.firmware_loaded);
+	case ATTR_POKE_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->poke_mode_on);
+	case ATTR_DMP_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.dmp_on);
+	case ATTR_DMP_BATCHMODE_TIMEOUT:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->batch.timeout);
+	case ATTR_DMP_EVENT_INT_ON:
+		return snprintf(buf, MAX_WR_SZ,
+			"%d\n", st->chip_config.dmp_event_int_on);
+	case ATTR_DMP_PED_INT_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.int_on);
+	case ATTR_DMP_PED_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.on);
+	case ATTR_DMP_PED_STEP_THRESH:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.step_thresh);
+	case ATTR_DMP_PED_INT_THRESH:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.int_thresh);
+	case ATTR_DMP_PED_INT_MODE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->ped.int_mode);
+	case ATTR_DMP_SMD_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->smd.on);
+	case ATTR_DMP_TILT_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.tilt_enable);
+	case ATTR_DMP_PICK_UP_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.pick_up_enable);
+	case ATTR_DMP_EIS_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->chip_config.eis_enable);
+	case ATTR_DMP_LOW_POWER_GYRO_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.low_power_gyro_on);
+	case ATTR_DMP_LP_EN_OFF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.lp_en_mode_off);
+	case ATTR_COMPASS_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.compass_enable);
+	case ATTR_DMP_STEP_COUNTER_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_counter_l_on);
+	case ATTR_DMP_STEP_COUNTER_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->step_counter_wake_l_on);
+	case ATTR_DMP_STEP_DETECTOR_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->step_detector_l_on);
+	case ATTR_DMP_STEP_DETECTOR_WAKE_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->step_detector_wake_l_on);
+	case ATTR_DMP_ACTIVITY_ON:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->chip_config.activity_on);
+	case ATTR_DMP_IN_ANGLVEL_ACCURACY_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->sensor_accuracy[SENSOR_GYRO_ACCURACY].on);
+	case ATTR_DMP_IN_ACCEL_ACCURACY_ENABLE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].on);
+	case ATTR_GYRO_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_ACCEL_MATRIX:
+		m = st->plat_data.orientation;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_COMPASS_MATRIX:
+		if (st->plat_data.sec_slave_type ==
+			SECONDARY_SLAVE_TYPE_COMPASS)
+			m = st->plat_data.secondary_orientation;
+		else
+			return -ENODEV;
+		return snprintf(buf, MAX_WR_SZ, "%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
+			m[8]);
+	case ATTR_SECONDARY_NAME:
+		{
+			const char *n[] = { "NULL", "AK8975", "AK8972",
+				"AK8963", "MLX90399", "AK09911", "AK09912", "AK09916"};
+
+			switch (st->plat_data.sec_slave_id) {
+			case COMPASS_ID_AK8975:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[1]);
+			case COMPASS_ID_AK8972:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[2]);
+			case COMPASS_ID_AK8963:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[3]);
+			case COMPASS_ID_MLX90399:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[4]);
+			case COMPASS_ID_AK09911:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[5]);
+			case COMPASS_ID_AK09912:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[6]);
+			case COMPASS_ID_AK09916:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[7]);
+			default:
+				return snprintf(buf, MAX_WR_SZ, "%s\n", n[0]);
+			}
+		}
+	case ATTR_DMP_DEBUG_MEM_READ:
+		{
+			int out;
+
+			inv_switch_power_in_lp(st, true);
+			result =
+				read_be32_from_mem(st, &out, debug_mem_read_addr);
+			if (result)
+				return result;
+			inv_switch_power_in_lp(st, false);
+			return snprintf(buf, MAX_WR_SZ, "0x%x\n", out);
+		}
+	case ATTR_DMP_MAGN_ACCURACY:
+		{
+			int out;
+
+			inv_switch_power_in_lp(st, true);
+			result = read_be32_from_mem(st, &out, CPASS_ACCURACY);
+			inv_switch_power_in_lp(st, false);
+			inv_switch_power_in_lp(st, false);
+
+			if (result)
+				return result;
+
+			return snprintf(buf, MAX_WR_SZ, "%d\n", out);
+		}
+	case ATTR_GYRO_SF:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_sf);
+	case ATTR_ANGLVEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[0]);
+	case ATTR_ANGLVEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[1]);
+	case ATTR_ANGLVEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->gyro_st_bias[2]);
+	case ATTR_ACCEL_X_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[0]);
+	case ATTR_ACCEL_Y_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[1]);
+	case ATTR_ACCEL_Z_ST_CALIBBIAS:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->accel_st_bias[2]);
+	case ATTR_GYRO_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[0]);
+	case ATTR_GYRO_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[1]);
+	case ATTR_GYRO_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->input_gyro_bias[2]);
+	case ATTR_ACCEL_X_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_accel_bias[0]);
+	case ATTR_ACCEL_Y_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_accel_bias[1]);
+	case ATTR_ACCEL_Z_OFFSET:
+		return snprintf(buf, MAX_WR_SZ, "%d\n",
+			st->input_accel_bias[2]);
+	case ATTR_BAC_DRIVE_CONFIDENCE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->bac_drive_conf);
+	case ATTR_BAC_WALK_CONFIDENCE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->bac_walk_conf);
+	case ATTR_BAC_SMD_CONFIDENCE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->bac_smd_conf);
+	case ATTR_BAC_BIKE_CONFIDENCE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->bac_bike_conf);
+	case ATTR_BAC_STILL_CONFIDENCE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->bac_still_conf);
+	case ATTR_BAC_RUN_CONFIDENCE:
+		return snprintf(buf, MAX_WR_SZ, "%d\n", st->bac_run_conf);
+	default:
+		return -EPERM;
+	}
+}
+
+static ssize_t inv_attr64_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result;
+	u64 tmp;
+	u32 ped;
+
+	mutex_lock(&indio_dev->mlock);
+	result = 0;
+	switch (this_attr->address) {
+	case ATTR_DMP_PEDOMETER_STEPS:
+		inv_switch_power_in_lp(st, true);
+		result = inv_get_pedometer_steps(st, &ped);
+		result |= inv_read_pedometer_counter(st);
+		tmp = (u64) st->ped.step + (u64) ped;
+		inv_switch_power_in_lp(st, false);
+		break;
+	case ATTR_DMP_PEDOMETER_TIME:
+		inv_switch_power_in_lp(st, true);
+		result = inv_get_pedometer_time(st, &ped);
+		tmp = (u64) st->ped.time + ((u64) ped) * MS_PER_PED_TICKS;
+		inv_switch_power_in_lp(st, false);
+		break;
+	case ATTR_DMP_PEDOMETER_COUNTER:
+		tmp = st->ped.last_step_time;
+		break;
+	default:
+		tmp = 0;
+		result = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&indio_dev->mlock);
+	if (result)
+		return -EINVAL;
+	return snprintf(buf, MAX_WR_SZ, "%lld\n", tmp);
+}
+
+static ssize_t inv_attr64_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int result;
+	u8 d[4] = { 0, 0, 0, 0 };
+	u64 data;
+
+	mutex_lock(&indio_dev->mlock);
+	if (!st->chip_config.firmware_loaded) {
+		mutex_unlock(&indio_dev->mlock);
+		return -EINVAL;
+	}
+	result = inv_switch_power_in_lp(st, true);
+	if (result) {
+		mutex_unlock(&indio_dev->mlock);
+		return result;
+	}
+	result = kstrtoull(buf, 10, &data);
+	if (result)
+		goto attr64_store_fail;
+	switch (this_attr->address) {
+	case ATTR_DMP_PEDOMETER_STEPS:
+		result = mem_w(PEDSTD_STEPCTR, ARRAY_SIZE(d), d);
+		if (result)
+			goto attr64_store_fail;
+		st->ped.step = data;
+		break;
+	case ATTR_DMP_PEDOMETER_TIME:
+		result = mem_w(PEDSTD_TIMECTR, ARRAY_SIZE(d), d);
+		if (result)
+			goto attr64_store_fail;
+		st->ped.time = data;
+		break;
+	default:
+		result = -EINVAL;
+		break;
+	}
+attr64_store_fail:
+	mutex_unlock(&indio_dev->mlock);
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_self_test(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int res;
+	int test_res = 0;
+	s16 accel_offset_reg[3];
+	s16 gyro_offset_reg[3];
+
+	mutex_lock(&indio_dev->mlock);
+	res = inv_switch_power_in_lp(st, true);
+	if (res)
+		goto err_out;
+
+	/* save the current offset registers */
+	res = inv_read_offset_regs(st, accel_offset_reg, gyro_offset_reg);
+	if (res)
+		goto err_out;
+	/* write initial offset register values */
+	res = inv_write_offset_regs(st,
+			st->org_accel_offset_reg, st->org_gyro_offset_reg);
+	if (res)
+		goto restore_regs;
+
+	res = inv_switch_power_in_lp(st, false);
+	if (res)
+		goto restore_regs;
+
+	test_res = inv_hw_self_test(st);
+
+restore_regs:
+	res = inv_switch_power_in_lp(st, true);
+	if (res)
+		goto err_out;
+	/* restore offset register values */
+	inv_write_offset_regs(st, accel_offset_reg, gyro_offset_reg);
+
+err_out:
+	inv_switch_power_in_lp(st, false);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&indio_dev->mlock);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", test_res);
+}
+
+/*
+ *  inv_temperature_show() - Read temperature data directly from registers.
+ */
+static ssize_t inv_temperature_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result, scale_t;
+	short temp;
+	u8 data[2];
+
+	mutex_lock(&indio_dev->mlock);
+	result = inv_switch_power_in_lp(st, true);
+	if (result) {
+		mutex_unlock(&indio_dev->mlock);
+		return result;
+	}
+
+	result = inv_plat_read(st, REG_TEMPERATURE, 2, data);
+	mutex_unlock(&indio_dev->mlock);
+	if (result) {
+		pr_err("Could not read temperature register.\n");
+		return result;
+	}
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+	temp = (s16) (be16_to_cpup((short *)&data[0]));
+	scale_t = TEMPERATURE_OFFSET +
+		inv_q30_mult((int)temp << MPU_TEMP_SHIFT, TEMPERATURE_SCALE);
+
+	return snprintf(buf, MAX_WR_SZ, "%d %lld\n", scale_t, get_time_ns());
+}
+
+/*
+ * inv_smd_show() -  calling this function showes smd interrupt.
+ *                         This event must use poll.
+ */
+static ssize_t inv_smd_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+/*
+ * inv_ped_show() -  calling this function showes pedometer interrupt.
+ *                         This event must use poll.
+ */
+static ssize_t inv_ped_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+static ssize_t inv_activity_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	return snprintf(buf, MAX_WR_SZ, "%d\n", st->activity_size);
+}
+
+static ssize_t inv_tilt_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+static ssize_t inv_pick_up_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MAX_WR_SZ, "1\n");
+}
+
+/*
+ *  inv_reg_dump_show() - Register dump for testing.
+ */
+static ssize_t inv_reg_dump_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int ii;
+	char data;
+	int bytes_printed = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+	inv_set_bank(st, BANK_SEL_0);
+	bytes_printed += snprintf(buf + bytes_printed,
+			MAX_WR_SZ - bytes_printed, "bank 0\n");
+
+	for (ii = 0; ii < 0x7F; ii++) {
+		/* don't read fifo r/w register */
+		if ((ii == REG_MEM_R_W) || (ii == REG_FIFO_R_W))
+			data = 0;
+		else
+			inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+	inv_set_bank(st, BANK_SEL_1);
+	bytes_printed += snprintf(buf + bytes_printed,
+			MAX_WR_SZ - bytes_printed, "bank 1\n");
+	for (ii = 0; ii < 0x2A; ii++) {
+		inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+	inv_set_bank(st, BANK_SEL_2);
+	bytes_printed += snprintf(buf + bytes_printed,
+			MAX_WR_SZ - bytes_printed, "bank 2\n");
+	for (ii = 0; ii < 0x55; ii++) {
+		inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+	inv_set_bank(st, BANK_SEL_3);
+	bytes_printed += snprintf(buf + bytes_printed,
+			MAX_WR_SZ - bytes_printed, "bank 3\n");
+	for (ii = 0; ii < 0x18; ii++) {
+		inv_plat_read(st, ii, 1, &data);
+		bytes_printed += snprintf(buf + bytes_printed,
+				MAX_WR_SZ - bytes_printed, "%#2x: %#2x\n", ii, data);
+	}
+	inv_set_bank(st, BANK_SEL_0);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&indio_dev->mlock);
+
+	return bytes_printed;
+}
+
+static ssize_t inv_flush_batch_store(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t count)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	int result, data;
+
+	result = kstrtoint(buf, 10, &data);
+	if (result)
+		return result;
+
+	mutex_lock(&indio_dev->mlock);
+	result = inv_flush_batch_data(indio_dev, data);
+	mutex_unlock(&indio_dev->mlock);
+
+	return count;
+}
+
+static ssize_t inv_sensor_raw_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int res, i, mag[3];
+	u8 d[DATA_AKM_99_BYTES_DMP];
+	u8 *sens;
+
+	switch (this_attr->address) {
+	case SENSOR_L_ACCEL:
+		{
+		res = inv_plat_read(st, REG_ACCEL_XOUT_H_SH,
+						INV_RAW_DATA_BYTES, d);
+		if (res)
+			return res;
+		return snprintf(buf, MAX_WR_SZ, "%d, %d, %d\n",
+				(s16) (be16_to_cpup((short *)&d[0])),
+				(s16) (be16_to_cpup((short *)&d[2])),
+				(s16) (be16_to_cpup((short *)&d[4])));
+		}
+
+	case SENSOR_L_GYRO:
+		{
+		res = inv_plat_read(st, REG_GYRO_XOUT_H_SH,
+						INV_RAW_DATA_BYTES, d);
+		if (res)
+			return res;
+
+		return snprintf(buf, MAX_WR_SZ, "%d, %d, %d\n",
+				(s16) (be16_to_cpup((short *)&d[0])),
+				(s16) (be16_to_cpup((short *)&d[2])),
+				(s16) (be16_to_cpup((short *)&d[4])));
+
+		}
+	case SENSOR_L_MAG:
+		{
+		res = inv_plat_read(st, REG_EXT_SLV_SENS_DATA_00,
+						DATA_AKM_99_BYTES_DMP, d);
+		if (res)
+			return res;
+		sens = st->chip_info.compass_sens;
+		for (i = 0; i < 3; i++) {
+			mag[i] = (s16) (be16_to_cpup((short *)&d[i * 2 + 2]));
+			mag[i] *= (sens[i] + 128);
+			mag[i] >>= 7;
+		}
+
+		return snprintf(buf, MAX_WR_SZ, "%d, %d, %d\n",
+							mag[0], mag[1], mag[2]);
+		}
+	default:
+		break;
+	}
+	return 0;
+}
+
+static const struct iio_chan_spec inv_mpu_channels[] = {
+	IIO_CHAN_SOFT_TIMESTAMP(INV_MPU_SCAN_TIMESTAMP),
+};
+
+static DEVICE_ATTR(poll_smd, S_IRUGO, inv_smd_show, NULL);
+static DEVICE_ATTR(poll_pedometer, S_IRUGO, inv_ped_show, NULL);
+static DEVICE_ATTR(poll_activity, S_IRUGO, inv_activity_show, NULL);
+static DEVICE_ATTR(poll_tilt, S_IRUGO, inv_tilt_show, NULL);
+static DEVICE_ATTR(poll_pick_up, S_IRUGO, inv_pick_up_show, NULL);
+
+/* special run time sysfs entry, read only */
+static DEVICE_ATTR(debug_reg_dump, S_IRUGO | S_IWUSR, inv_reg_dump_show, NULL);
+static DEVICE_ATTR(out_temperature, S_IRUGO | S_IWUSR,
+			inv_temperature_show, NULL);
+static DEVICE_ATTR(misc_self_test, S_IRUGO | S_IWUSR, inv_self_test, NULL);
+
+static IIO_DEVICE_ATTR(info_anglvel_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_GYRO_MATRIX);
+static IIO_DEVICE_ATTR(info_accel_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_ACCEL_MATRIX);
+static IIO_DEVICE_ATTR(info_magn_matrix, S_IRUGO, inv_attr_show, NULL,
+			ATTR_COMPASS_MATRIX);
+
+static IIO_DEVICE_ATTR(info_secondary_name, S_IRUGO, inv_attr_show, NULL,
+			ATTR_SECONDARY_NAME);
+static IIO_DEVICE_ATTR(info_gyro_sf, S_IRUGO, inv_attr_show, NULL,
+			ATTR_GYRO_SF);
+/* write only sysfs */
+static DEVICE_ATTR(misc_flush_batch, S_IWUSR, NULL, inv_flush_batch_store);
+
+/* sensor on/off sysfs control */
+static IIO_DEVICE_ATTR(in_accel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store, SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store, SENSOR_L_GYRO);
+static IIO_DEVICE_ATTR(in_calib_anglvel_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_CAL);
+static IIO_DEVICE_ATTR(in_magn_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_MAG);
+static IIO_DEVICE_ATTR(in_calib_magn_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_MAG_CAL);
+static IIO_DEVICE_ATTR(in_eis_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_EIS_GYRO);
+static IIO_DEVICE_ATTR(in_accel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_WAKE);
+static IIO_DEVICE_ATTR(in_magn_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_MAG_WAKE);
+static IIO_DEVICE_ATTR(in_calib_magn_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_MAG_CAL_WAKE);
+static IIO_DEVICE_ATTR(in_calib_anglvel_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GYRO_CAL_WAKE);
+static IIO_DEVICE_ATTR(in_6quat_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_SIXQ);
+static IIO_DEVICE_ATTR(in_6quat_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_SIXQ_WAKE);
+static IIO_DEVICE_ATTR(in_9quat_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_NINEQ);
+static IIO_DEVICE_ATTR(in_9quat_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_NINEQ_WAKE);
+static IIO_DEVICE_ATTR(in_p6quat_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_PEDQ);
+static IIO_DEVICE_ATTR(in_p6quat_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_PEDQ_WAKE);
+static IIO_DEVICE_ATTR(in_geomag_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_GEOMAG);
+static IIO_DEVICE_ATTR(in_geomag_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_GEOMAG_WAKE);
+static IIO_DEVICE_ATTR(in_pressure_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_PRESSURE);
+static IIO_DEVICE_ATTR(in_pressure_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_PRESSURE_WAKE);
+static IIO_DEVICE_ATTR(in_als_px_enable, S_IRUGO | S_IWUSR, inv_sensor_on_show,
+			inv_sensor_on_store, SENSOR_L_ALS);
+static IIO_DEVICE_ATTR(in_als_px_wake_enable, S_IRUGO | S_IWUSR,
+			inv_sensor_on_show, inv_sensor_on_store,
+			SENSOR_L_ALS_WAKE);
+
+/* sensor rate sysfs control */
+static IIO_DEVICE_ATTR(in_accel_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_GYRO);
+static IIO_DEVICE_ATTR(in_calib_anglvel_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_CAL);
+static IIO_DEVICE_ATTR(in_magn_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_MAG);
+static IIO_DEVICE_ATTR(in_calib_magn_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_MAG_CAL);
+static IIO_DEVICE_ATTR(in_eis_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_EIS_GYRO);
+static IIO_DEVICE_ATTR(in_accel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ACCEL_WAKE);
+static IIO_DEVICE_ATTR(in_anglvel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_WAKE);
+static IIO_DEVICE_ATTR(in_calib_anglvel_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GYRO_CAL_WAKE);
+static IIO_DEVICE_ATTR(in_magn_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_MAG_WAKE);
+static IIO_DEVICE_ATTR(in_calib_magn_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_MAG_CAL_WAKE);
+static IIO_DEVICE_ATTR(in_6quat_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_SIXQ);
+static IIO_DEVICE_ATTR(in_6quat_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_SIXQ_WAKE);
+static IIO_DEVICE_ATTR(in_9quat_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_NINEQ);
+static IIO_DEVICE_ATTR(in_9quat_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_NINEQ_WAKE);
+static IIO_DEVICE_ATTR(in_p6quat_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_PEDQ);
+static IIO_DEVICE_ATTR(in_p6quat_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_PEDQ_WAKE);
+static IIO_DEVICE_ATTR(in_geomag_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_GEOMAG);
+static IIO_DEVICE_ATTR(in_geomag_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_GEOMAG_WAKE);
+static IIO_DEVICE_ATTR(in_pressure_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_PRESSURE);
+static IIO_DEVICE_ATTR(in_pressure_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_PRESSURE_WAKE);
+static IIO_DEVICE_ATTR(in_als_px_rate, S_IRUGO | S_IWUSR, inv_sensor_rate_show,
+			inv_sensor_rate_store, SENSOR_L_ALS);
+static IIO_DEVICE_ATTR(in_als_px_wake_rate, S_IRUGO | S_IWUSR,
+			inv_sensor_rate_show, inv_sensor_rate_store,
+			SENSOR_L_ALS_WAKE);
+
+/* test related raw data reading sysfs entries */
+static IIO_DEVICE_ATTR(in_accel_raw, S_IRUGO, inv_sensor_raw_show, NULL,
+			SENSOR_L_ACCEL);
+static IIO_DEVICE_ATTR(in_anglvel_raw, S_IRUGO, inv_sensor_raw_show, NULL,
+			SENSOR_L_GYRO);
+static IIO_DEVICE_ATTR(in_magn_raw, S_IRUGO, inv_sensor_raw_show, NULL,
+			SENSOR_L_MAG);
+
+/* debug determine engine related sysfs */
+static IIO_DEVICE_ATTR(debug_anglvel_accuracy_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store,
+			ATTR_DMP_IN_ANGLVEL_ACCURACY_ENABLE);
+static IIO_DEVICE_ATTR(debug_accel_accuracy_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store,
+			ATTR_DMP_IN_ACCEL_ACCURACY_ENABLE);
+static IIO_DEVICE_ATTR(debug_gyro_cal_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_GYRO_CAL_ENABLE);
+static IIO_DEVICE_ATTR(debug_accel_cal_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_ACCEL_CAL_ENABLE);
+
+static IIO_DEVICE_ATTR(debug_gyro_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store, ATTR_GYRO_ENABLE);
+static IIO_DEVICE_ATTR(debug_accel_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store, ATTR_ACCEL_ENABLE);
+static IIO_DEVICE_ATTR(debug_compass_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_debug_attr_store,
+			ATTR_COMPASS_ENABLE);
+static IIO_DEVICE_ATTR(debug_dmp_on, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_ON);
+static IIO_DEVICE_ATTR(debug_dmp_event_int_on, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_attr_store, ATTR_DMP_EVENT_INT_ON);
+static IIO_DEVICE_ATTR(debug_mem_read, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_dmp_bias_store, ATTR_DMP_DEBUG_MEM_READ);
+static IIO_DEVICE_ATTR(debug_mem_write, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_dmp_bias_store, ATTR_DMP_DEBUG_MEM_WRITE);
+static IIO_DEVICE_ATTR(debug_magn_accuracy, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_DMP_MAGN_ACCURACY);
+
+static IIO_DEVICE_ATTR(misc_batchmode_timeout, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_BATCHMODE_TIMEOUT);
+
+static IIO_DEVICE_ATTR(info_firmware_loaded, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_firmware_loaded_store, ATTR_FIRMWARE_LOADED);
+static IIO_DEVICE_ATTR(info_poke_mode, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_poke_mode_store, ATTR_POKE_MODE);
+
+/* engine scale */
+static IIO_DEVICE_ATTR(in_accel_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_misc_attr_store, ATTR_ACCEL_SCALE);
+static IIO_DEVICE_ATTR(in_anglvel_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_misc_attr_store, ATTR_GYRO_SCALE);
+static IIO_DEVICE_ATTR(in_magn_scale, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_COMPASS_SCALE);
+
+static IIO_DEVICE_ATTR(in_magn_sensitivity_x, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_COMPASS_SENSITIVITY_X);
+static IIO_DEVICE_ATTR(in_magn_sensitivity_y, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_COMPASS_SENSITIVITY_Y);
+static IIO_DEVICE_ATTR(in_magn_sensitivity_z, S_IRUGO | S_IWUSR, inv_attr_show,
+			NULL, ATTR_COMPASS_SENSITIVITY_Z);
+
+static IIO_DEVICE_ATTR(debug_low_power_gyro_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_DMP_LOW_POWER_GYRO_ON);
+static IIO_DEVICE_ATTR(debug_lp_en_off, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DMP_LP_EN_OFF);
+static IIO_DEVICE_ATTR(debug_clock_sel, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DMP_CLK_SEL);
+static IIO_DEVICE_ATTR(debug_reg_write, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_REG_WRITE);
+static IIO_DEVICE_ATTR(debug_cfg_write, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_WRITE_CFG);
+static IIO_DEVICE_ATTR(debug_reg_write_addr, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_debug_store, ATTR_DEBUG_REG_ADDR);
+
+static IIO_DEVICE_ATTR(in_accel_x_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, NULL, ATTR_ACCEL_X_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_y_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, NULL, ATTR_ACCEL_Y_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_z_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, NULL, ATTR_ACCEL_Z_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_x_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, NULL, ATTR_ANGLVEL_X_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, NULL, ATTR_ANGLVEL_Y_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, NULL, ATTR_ANGLVEL_Z_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_x_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_ACCEL_X_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_accel_y_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_ACCEL_Y_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_accel_z_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_ACCEL_Z_DMP_BIAS);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_GYRO_X_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_GYRO_Y_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_GYRO_Z_DMP_BIAS);
+
+static IIO_DEVICE_ATTR(in_magn_x_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_MAGN_X_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_magn_y_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_MAGN_Y_DMP_BIAS);
+static IIO_DEVICE_ATTR(in_magn_z_dmp_bias, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_MAGN_Z_DMP_BIAS);
+
+static IIO_DEVICE_ATTR(in_accel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_accel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ACCEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_X_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_y_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Y_ST_CALIBBIAS);
+static IIO_DEVICE_ATTR(in_anglvel_z_st_calibbias, S_IRUGO | S_IWUSR,
+			inv_attr_show, NULL, ATTR_ANGLVEL_Z_ST_CALIBBIAS);
+
+static IIO_DEVICE_ATTR(in_accel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_X_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_accel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_ACCEL_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(in_anglvel_x_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_X_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_y_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Y_OFFSET);
+static IIO_DEVICE_ATTR(in_anglvel_z_offset, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_bias_store, ATTR_GYRO_Z_OFFSET);
+
+static IIO_DEVICE_ATTR(in_sc_auth, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_SC_AUTH);
+
+static IIO_DEVICE_ATTR(in_eis_auth, S_IRUGO | S_IWUSR,
+			inv_attr_bias_show, inv_dmp_bias_store,
+			ATTR_DMP_EIS_AUTH);
+
+static IIO_DEVICE_ATTR(debug_determine_engine_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_DMP_DEBUG_DETERMINE_ENGINE_ON);
+static IIO_DEVICE_ATTR(misc_gyro_recalibration, S_IRUGO | S_IWUSR, NULL,
+			inv_dmp_bias_store, ATTR_DMP_MISC_GYRO_RECALIBRATION);
+static IIO_DEVICE_ATTR(misc_accel_recalibration, S_IRUGO | S_IWUSR, NULL,
+			inv_dmp_bias_store, ATTR_DMP_MISC_ACCEL_RECALIBRATION);
+static IIO_DEVICE_ATTR(params_accel_calibration_threshold, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_dmp_bias_store,
+			ATTR_DMP_PARAMS_ACCEL_CALIBRATION_THRESHOLD);
+static IIO_DEVICE_ATTR(params_accel_calibration_rate, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_dmp_bias_store,
+			ATTR_DMP_PARAMS_ACCEL_CALIBRATION_RATE);
+
+static IIO_DEVICE_ATTR(in_step_detector_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_ON);
+static IIO_DEVICE_ATTR(in_step_detector_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_DETECTOR_WAKE_ON);
+static IIO_DEVICE_ATTR(in_step_counter_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_basic_attr_store, ATTR_DMP_STEP_COUNTER_ON);
+static IIO_DEVICE_ATTR(in_step_counter_wake_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_STEP_COUNTER_WAKE_ON);
+static IIO_DEVICE_ATTR(in_step_counter_send, S_IRUGO | S_IWUSR, NULL,
+			inv_basic_attr_store, ATTR_DMP_STEP_COUNTER_SEND);
+static IIO_DEVICE_ATTR(in_activity_enable, S_IRUGO | S_IWUSR, inv_attr_show,
+			inv_basic_attr_store, ATTR_DMP_ACTIVITY_ON);
+
+static IIO_DEVICE_ATTR(event_smd_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_SMD_ENABLE);
+
+static IIO_DEVICE_ATTR(event_tilt_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_TILT_ENABLE);
+
+static IIO_DEVICE_ATTR(event_eis_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_EIS_ENABLE);
+
+static IIO_DEVICE_ATTR(event_pick_up_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store,
+			ATTR_DMP_PICK_UP_ENABLE);
+
+static IIO_DEVICE_ATTR(params_pedometer_int_on, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store, ATTR_DMP_PED_INT_ON);
+static IIO_DEVICE_ATTR(event_pedometer_enable, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_basic_attr_store, ATTR_DMP_PED_ON);
+static IIO_DEVICE_ATTR(params_pedometer_step_thresh, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_DMP_PED_STEP_THRESH);
+static IIO_DEVICE_ATTR(params_pedometer_int_thresh, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store,
+			ATTR_DMP_PED_INT_THRESH);
+static IIO_DEVICE_ATTR(params_pedometer_int_mode, S_IRUGO | S_IWUSR,
+			inv_attr_show, inv_misc_attr_store, ATTR_DMP_PED_INT_MODE);
+
+static IIO_DEVICE_ATTR(out_pedometer_steps, S_IRUGO | S_IWUSR, inv_attr64_show,
+			inv_attr64_store, ATTR_DMP_PEDOMETER_STEPS);
+static IIO_DEVICE_ATTR(out_pedometer_time, S_IRUGO | S_IWUSR, inv_attr64_show,
+			inv_attr64_store, ATTR_DMP_PEDOMETER_TIME);
+static IIO_DEVICE_ATTR(out_pedometer_counter, S_IRUGO | S_IWUSR,
+			inv_attr64_show, NULL, ATTR_DMP_PEDOMETER_COUNTER);
+
+static IIO_DEVICE_ATTR(bac_drive_confidence, S_IRUGO,
+			inv_attr_show, NULL, ATTR_BAC_DRIVE_CONFIDENCE);
+static IIO_DEVICE_ATTR(bac_walk_confidence, S_IRUGO,
+			inv_attr_show, NULL, ATTR_BAC_WALK_CONFIDENCE);
+static IIO_DEVICE_ATTR(bac_smd_confidence, S_IRUGO,
+			inv_attr_show, NULL, ATTR_BAC_SMD_CONFIDENCE);
+static IIO_DEVICE_ATTR(bac_bike_confidence, S_IRUGO,
+			inv_attr_show, NULL, ATTR_BAC_BIKE_CONFIDENCE);
+static IIO_DEVICE_ATTR(bac_still_confidence, S_IRUGO,
+			inv_attr_show, NULL, ATTR_BAC_STILL_CONFIDENCE);
+static IIO_DEVICE_ATTR(bac_run_confidence, S_IRUGO,
+			inv_attr_show, NULL, ATTR_BAC_RUN_CONFIDENCE);
+
+static const struct attribute *inv_raw_attributes[] = {
+	&dev_attr_debug_reg_dump.attr,
+	&dev_attr_out_temperature.attr,
+	&dev_attr_misc_flush_batch.attr,
+	&dev_attr_misc_self_test.attr,
+	&iio_dev_attr_in_sc_auth.dev_attr.attr,
+	&iio_dev_attr_in_eis_auth.dev_attr.attr,
+	&iio_dev_attr_in_accel_enable.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_info_accel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale.dev_attr.attr,
+	&iio_dev_attr_info_firmware_loaded.dev_attr.attr,
+	&iio_dev_attr_misc_batchmode_timeout.dev_attr.attr,
+	&iio_dev_attr_in_accel_rate.dev_attr.attr,
+	&iio_dev_attr_in_accel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_secondary_name.dev_attr.attr,
+	&iio_dev_attr_info_poke_mode.dev_attr.attr,
+	&iio_dev_attr_debug_mem_read.dev_attr.attr,
+	&iio_dev_attr_debug_mem_write.dev_attr.attr,
+	&iio_dev_attr_debug_magn_accuracy.dev_attr.attr,
+	&iio_dev_attr_in_accel_raw.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_raw.dev_attr.attr,
+	&iio_dev_attr_in_magn_raw.dev_attr.attr,
+};
+
+static const struct attribute *inv_debug_attributes[] = {
+	&iio_dev_attr_debug_accel_enable.dev_attr.attr,
+	&iio_dev_attr_debug_dmp_event_int_on.dev_attr.attr,
+	&iio_dev_attr_debug_low_power_gyro_on.dev_attr.attr,
+	&iio_dev_attr_debug_lp_en_off.dev_attr.attr,
+	&iio_dev_attr_debug_clock_sel.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write.dev_attr.attr,
+	&iio_dev_attr_debug_reg_write_addr.dev_attr.attr,
+	&iio_dev_attr_debug_cfg_write.dev_attr.attr,
+	&iio_dev_attr_debug_dmp_on.dev_attr.attr,
+	&iio_dev_attr_debug_accel_cal_enable.dev_attr.attr,
+	&iio_dev_attr_debug_accel_accuracy_enable.dev_attr.attr,
+	&iio_dev_attr_debug_determine_engine_on.dev_attr.attr,
+	&iio_dev_attr_debug_gyro_enable.dev_attr.attr,
+	&iio_dev_attr_debug_gyro_cal_enable.dev_attr.attr,
+	&iio_dev_attr_debug_anglvel_accuracy_enable.dev_attr.attr,
+	&iio_dev_attr_debug_compass_enable.dev_attr.attr,
+	&iio_dev_attr_params_pedometer_step_thresh.dev_attr.attr,
+	&iio_dev_attr_params_pedometer_int_thresh.dev_attr.attr,
+	&iio_dev_attr_misc_gyro_recalibration.dev_attr.attr,
+	&iio_dev_attr_misc_accel_recalibration.dev_attr.attr,
+	&iio_dev_attr_params_accel_calibration_threshold.dev_attr.attr,
+	&iio_dev_attr_params_accel_calibration_rate.dev_attr.attr,
+};
+
+static const struct attribute *inv_gyro_attributes[] = {
+	&iio_dev_attr_info_anglvel_matrix.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_enable.dev_attr.attr,
+	&iio_dev_attr_in_calib_anglvel_enable.dev_attr.attr,
+	&iio_dev_attr_in_eis_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_calib_anglvel_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_scale.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_rate.dev_attr.attr,
+	&iio_dev_attr_in_calib_anglvel_rate.dev_attr.attr,
+	&iio_dev_attr_in_eis_rate.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_in_calib_anglvel_wake_rate.dev_attr.attr,
+	&iio_dev_attr_in_6quat_enable.dev_attr.attr,
+	&iio_dev_attr_in_6quat_rate.dev_attr.attr,
+	&iio_dev_attr_in_6quat_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_6quat_wake_rate.dev_attr.attr,
+	&iio_dev_attr_in_9quat_enable.dev_attr.attr,
+	&iio_dev_attr_in_9quat_rate.dev_attr.attr,
+	&iio_dev_attr_in_9quat_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_9quat_wake_rate.dev_attr.attr,
+	&iio_dev_attr_in_p6quat_enable.dev_attr.attr,
+	&iio_dev_attr_in_p6quat_rate.dev_attr.attr,
+	&iio_dev_attr_in_p6quat_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_p6quat_wake_rate.dev_attr.attr,
+	&iio_dev_attr_info_gyro_sf.dev_attr.attr,
+};
+
+static const struct attribute *inv_bias_attributes[] = {
+	&iio_dev_attr_in_accel_x_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_calibbias.dev_attr.attr,
+};
+
+static const struct attribute *inv_gyro_bias_attributes[] = {
+	&iio_dev_attr_in_anglvel_x_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_calibbias.dev_attr.attr,
+};
+
+static const struct attribute *inv_bias_st_attributes[] = {
+	&iio_dev_attr_in_anglvel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_st_calibbias.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_z_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_x_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_y_offset.dev_attr.attr,
+	&iio_dev_attr_in_accel_z_offset.dev_attr.attr,
+};
+
+static const struct attribute *inv_compass_attributes[] = {
+	&iio_dev_attr_in_magn_sensitivity_x.dev_attr.attr,
+	&iio_dev_attr_in_magn_sensitivity_y.dev_attr.attr,
+	&iio_dev_attr_in_magn_sensitivity_z.dev_attr.attr,
+	&iio_dev_attr_in_magn_scale.dev_attr.attr,
+	&iio_dev_attr_info_magn_matrix.dev_attr.attr,
+	&iio_dev_attr_in_magn_x_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_magn_y_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_magn_z_dmp_bias.dev_attr.attr,
+	&iio_dev_attr_in_magn_enable.dev_attr.attr,
+	&iio_dev_attr_in_calib_magn_enable.dev_attr.attr,
+	&iio_dev_attr_in_magn_rate.dev_attr.attr,
+	&iio_dev_attr_in_calib_magn_rate.dev_attr.attr,
+	&iio_dev_attr_in_magn_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_magn_wake_rate.dev_attr.attr,
+	&iio_dev_attr_in_calib_magn_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_calib_magn_wake_rate.dev_attr.attr,
+	&iio_dev_attr_in_geomag_enable.dev_attr.attr,
+	&iio_dev_attr_in_geomag_rate.dev_attr.attr,
+	&iio_dev_attr_in_geomag_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_geomag_wake_rate.dev_attr.attr,
+};
+
+static const struct attribute *inv_pedometer_attributes[] = {
+	&dev_attr_poll_pedometer.attr,
+	&dev_attr_poll_activity.attr,
+	&dev_attr_poll_tilt.attr,
+	&dev_attr_poll_pick_up.attr,
+	&iio_dev_attr_params_pedometer_int_on.dev_attr.attr,
+	&iio_dev_attr_params_pedometer_int_mode.dev_attr.attr,
+	&iio_dev_attr_event_pedometer_enable.dev_attr.attr,
+	&iio_dev_attr_event_tilt_enable.dev_attr.attr,
+	&iio_dev_attr_event_eis_enable.dev_attr.attr,
+	&iio_dev_attr_event_pick_up_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_counter_send.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_enable.dev_attr.attr,
+	&iio_dev_attr_in_step_detector_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_activity_enable.dev_attr.attr,
+	&iio_dev_attr_out_pedometer_steps.dev_attr.attr,
+	&iio_dev_attr_out_pedometer_time.dev_attr.attr,
+	&iio_dev_attr_out_pedometer_counter.dev_attr.attr,
+};
+
+static const struct attribute *inv_smd_attributes[] = {
+	&dev_attr_poll_smd.attr,
+	&iio_dev_attr_event_smd_enable.dev_attr.attr,
+};
+
+static const struct attribute *inv_pressure_attributes[] = {
+	&iio_dev_attr_in_pressure_enable.dev_attr.attr,
+	&iio_dev_attr_in_pressure_rate.dev_attr.attr,
+	&iio_dev_attr_in_pressure_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_pressure_wake_rate.dev_attr.attr,
+};
+
+static const struct attribute *inv_als_attributes[] = {
+	&iio_dev_attr_in_als_px_enable.dev_attr.attr,
+	&iio_dev_attr_in_als_px_rate.dev_attr.attr,
+	&iio_dev_attr_in_als_px_wake_enable.dev_attr.attr,
+	&iio_dev_attr_in_als_px_wake_rate.dev_attr.attr,
+};
+
+static const struct attribute *inv_bac_confidence_attributes[] = {
+	&iio_dev_attr_bac_drive_confidence.dev_attr.attr,
+	&iio_dev_attr_bac_walk_confidence.dev_attr.attr,
+	&iio_dev_attr_bac_smd_confidence.dev_attr.attr,
+	&iio_dev_attr_bac_bike_confidence.dev_attr.attr,
+	&iio_dev_attr_bac_still_confidence.dev_attr.attr,
+	&iio_dev_attr_bac_run_confidence.dev_attr.attr,
+};
+
+static struct attribute *inv_attributes[ARRAY_SIZE(inv_raw_attributes) +
+					ARRAY_SIZE(inv_pedometer_attributes) +
+					ARRAY_SIZE(inv_smd_attributes) +
+					ARRAY_SIZE(inv_compass_attributes) +
+					ARRAY_SIZE(inv_pressure_attributes) +
+					ARRAY_SIZE(inv_als_attributes) +
+					ARRAY_SIZE(inv_bias_attributes) +
+					ARRAY_SIZE(inv_gyro_attributes) +
+					ARRAY_SIZE(inv_gyro_bias_attributes) +
+					ARRAY_SIZE(inv_bac_confidence_attributes) +
+					ARRAY_SIZE(inv_debug_attributes) + 1];
+
+static const struct attribute_group inv_attribute_group = {
+	.name = "mpu",
+	.attrs = inv_attributes
+};
+
+static const struct iio_info mpu_info = {
+	.attrs = &inv_attribute_group,
+};
+
+/*
+ *  inv_check_chip_type() - check and setup chip type.
+ */
+int inv_check_chip_type(struct iio_dev *indio_dev, const char *name)
+{
+	int result;
+	int t_ind;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+	struct inv_mpu_state *st;
+
+	st = iio_priv(indio_dev);
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	if (!strcmp(name, "icm20648"))
+		st->chip_type = ICM20648;
+	else
+		return -EPERM;
+
+	st->dmp_image_size = DMP_IMAGE_SIZE_20648;
+	st->dmp_start_address = DMP_START_ADDR_20648;
+	st->chip_config.has_gyro = 1;
+
+	st->hw = &hw_info[st->chip_type];
+	result = inv_mpu_initialize(st);
+	if (result)
+		return result;
+
+	t_ind = 0;
+	memcpy(&inv_attributes[t_ind], inv_raw_attributes,
+				sizeof(inv_raw_attributes));
+	t_ind += ARRAY_SIZE(inv_raw_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_pedometer_attributes,
+				sizeof(inv_pedometer_attributes));
+	t_ind += ARRAY_SIZE(inv_pedometer_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_smd_attributes,
+				sizeof(inv_smd_attributes));
+	t_ind += ARRAY_SIZE(inv_smd_attributes);
+
+	if (st->chip_config.has_compass) {
+		memcpy(&inv_attributes[t_ind], inv_compass_attributes,
+					sizeof(inv_compass_attributes));
+		t_ind += ARRAY_SIZE(inv_compass_attributes);
+	}
+	if (st->chip_config.has_pressure) {
+		memcpy(&inv_attributes[t_ind], inv_pressure_attributes,
+					sizeof(inv_pressure_attributes));
+		t_ind += ARRAY_SIZE(inv_pressure_attributes);
+	}
+	if (st->chip_config.has_als) {
+		memcpy(&inv_attributes[t_ind], inv_als_attributes,
+					sizeof(inv_als_attributes));
+		t_ind += ARRAY_SIZE(inv_als_attributes);
+	}
+	if (ICM20648 == st->chip_type) {
+		memcpy(&inv_attributes[t_ind], inv_bias_attributes,
+					sizeof(inv_bias_attributes));
+		t_ind += ARRAY_SIZE(inv_bias_attributes);
+	}
+	if (st->chip_config.has_gyro) {
+		memcpy(&inv_attributes[t_ind], inv_gyro_attributes,
+					sizeof(inv_gyro_attributes));
+		t_ind += ARRAY_SIZE(inv_gyro_attributes);
+	}
+	if (ICM20648 == st->chip_type && st->chip_config.has_gyro) {
+		memcpy(&inv_attributes[t_ind], inv_gyro_bias_attributes,
+					sizeof(inv_gyro_bias_attributes));
+		t_ind += ARRAY_SIZE(inv_gyro_bias_attributes);
+	}
+
+	memcpy(&inv_attributes[t_ind], inv_bias_st_attributes,
+				sizeof(inv_bias_st_attributes));
+	t_ind += ARRAY_SIZE(inv_bias_st_attributes);
+
+	memcpy(&inv_attributes[t_ind], inv_bac_confidence_attributes,
+				sizeof(inv_bac_confidence_attributes));
+	t_ind += ARRAY_SIZE(inv_bac_confidence_attributes);
+
+	inv_attributes[t_ind] = NULL;
+
+	indio_dev->name = st->hw->name;
+	indio_dev->channels = inv_mpu_channels;
+	indio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);
+
+	indio_dev->info = &mpu_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->currentmode = INDIO_DIRECT_MODE;
+	INIT_KFIFO(st->kf);
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(inv_check_chip_type);
+
+/*
+ * inv_dmp_firmware_write() -  calling this function will load the firmware.
+ */
+static ssize_t inv_dmp_firmware_write(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	int result, offset;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+	u32 crc_value;
+
+	/*	New DMP Image - 0.2.09 -  */
+/* /system/vendor/firmware/inv_dmpfirmware.bin */
+/* from vanadium-host-hal/sources/vendor/invensense/hammerhead/proprietary */
+#define FIRMWARE_CRC_20648           0x84dcfdda
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (!st->firmware) {
+		st->firmware = kmalloc(st->dmp_image_size, GFP_KERNEL);
+		if (!st->firmware) {
+			pr_err("no memory while loading firmware\n");
+			return -ENOMEM;
+		}
+	}
+	offset = pos;
+	memcpy(st->firmware + pos, buf, size);
+	if ((!size) && (st->dmp_image_size != pos)) {
+		pr_err("wrong size for DMP firmware 0x%08x vs 0x%08x\n",
+			offset, st->dmp_image_size);
+		kfree(st->firmware);
+		st->firmware = 0;
+		return -EINVAL;
+	}
+	if (st->dmp_image_size == (pos + size)) {
+		result = ~crc32(~0, st->firmware, st->dmp_image_size);
+		crc_value = FIRMWARE_CRC_20648;
+		pr_info("%s: firmware CRC actual:0x%08x expected:0x%08x\n",
+			__func__, result, crc_value);
+		if (crc_value != result) {
+			pr_err("%s: firmware CRC error\n", __func__);
+			return -EINVAL;
+		} else
+			pr_info("%s: CRC matched\n", __func__);
+
+		mutex_lock(&indio_dev->mlock);
+		result = inv_firmware_load(st);
+		kfree(st->firmware);
+		st->firmware = 0;
+		mutex_unlock(&indio_dev->mlock);
+		if (result) {
+			pr_err("firmware load failed\n");
+			return result;
+		}
+	}
+
+	return size;
+}
+
+static ssize_t inv_dmp_firmware_read(struct file *filp,
+			struct kobject *kobj,
+			struct bin_attribute *bin_attr,
+			char *buf, loff_t off, size_t count)
+{
+	int result, offset;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+
+	mutex_lock(&indio_dev->mlock);
+	offset = off;
+	result = inv_dmp_read(st, offset, count, buf);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&indio_dev->mlock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+ssize_t inv_soft_iron_matrix_write(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+	int m[NINE_ELEM], *n, *r;
+	int i, j, k;
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+	if (size != SOFT_IRON_MATRIX_SIZE) {
+		pr_err("wrong size for soft iron matrix 0x%08x vs 0x%08x\n",
+			(u8)size, SOFT_IRON_MATRIX_SIZE);
+		return -EINVAL;
+	}
+	n = st->current_compass_matrix;
+	r = st->final_compass_matrix;
+	for (i = 0; i < NINE_ELEM; i++)
+		memcpy((u8 *) &m[i], &buf[i * sizeof(int)], sizeof(int));
+
+	for (i = 0; i < THREE_AXES; i++) {
+		for (j = 0; j < THREE_AXES; j++) {
+			r[i * THREE_AXES + j] = 0;
+			for (k = 0; k < THREE_AXES; k++)
+				r[i * THREE_AXES + j] +=
+				inv_q30_mult(m[i * THREE_AXES + k],
+						 n[j + k * THREE_AXES]);
+		}
+	}
+
+	return size;
+}
+
+ssize_t inv_accel_covariance_write(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	int i;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (size != ACCEL_COVARIANCE_SIZE)
+		return -EINVAL;
+
+	for (i = 0; i < COVARIANCE_SIZE; i++)
+		memcpy((u8 *) &st->accel_covariance[i],
+			&buf[i * sizeof(int)], sizeof(int));
+
+	return size;
+}
+
+static int inv_handle_poke(struct inv_mpu_state *st, char *buf,
+			int addr, int size)
+{
+	int result, wait_times;
+	u8 dd[1];
+
+	if (!st->poke_mode_on)
+		return -EINVAL;
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	wait_times  = 0;
+	result = inv_plat_read(st, REG_DMP_START_MODE, 1, dd);
+	while ((dd[0] != 1) && (wait_times < 5)) {
+		usleep_range(1000, 1000);
+		result = inv_plat_read(st, REG_DMP_START_MODE, 1, dd);
+		wait_times++;
+	}
+	if (dd[0] != 1)
+		return -EINVAL;
+
+	mem_w(addr, size, buf);
+	result = inv_plat_single_write(st, REG_DMP_START_MODE,
+			BIT_DMP_POKE | BIT_DMP_START_MODE);
+	result = inv_switch_power_in_lp(st, false);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+static ssize_t inv_poke_write_accel(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+	int result, scale, i;
+	short accel_data[3];
+	int input_accel[3];
+	short input_buf[3];
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+	scale = 2;
+	switch (st->chip_config.accel_fs) {
+	case 0:
+		scale = 2;
+		break;
+	case 1:
+		scale = 4;
+		break;
+	case 2:
+		scale = 8;
+		break;
+	case 3:
+		scale = 16;
+		break;
+	default:
+		break;
+	}
+	for (i = 0; i < 3; i++) {
+		memcpy(&input_accel[i], buf + i * 4,
+				sizeof(input_accel[i]));
+		accel_data[i] = (short)(input_accel[i] * 2 / scale);
+		input_buf[i] = cpu_to_be16(accel_data[i]);
+	}
+
+	memcpy((char *)&st->poke_ts, buf + INV_POKE_ACCEL_OFFSET_TO_TS,
+			sizeof(st->poke_ts));
+
+	result = inv_handle_poke(st, (char *)&input_buf[0],
+			INV_DMP_ACCEL_START_ADDR, BYTES_PER_SENSOR);
+	mutex_unlock(&indio_dev->mlock);
+	if (result)
+		return result;
+
+	return size;
+}
+
+static ssize_t inv_poke_write_gyro(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+	int result, scale, i;
+	short gyro_data[3];
+	int input_gyro[3];
+	short input_buf[3];
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+	scale = 250;
+	switch (st->chip_config.fsr) {
+	case 0:
+		scale = 250;
+		break;
+	case 1:
+		scale = 500;
+		break;
+	case 2:
+		scale = 1000;
+		break;
+	case 3:
+		scale = 2000;
+		break;
+	default:
+		break;
+	}
+	for (i = 0; i < 3; i++) {
+		memcpy(&input_gyro[i], buf + i * 4,
+				sizeof(input_gyro[i]));
+		gyro_data[i] = (short)(input_gyro[i] * 250 / scale);
+		input_buf[i] = cpu_to_be16(gyro_data[i]);
+	}
+
+	memcpy((char *)&st->poke_ts, buf + INV_POKE_GYRO_OFFSET_TO_TS,
+			sizeof(st->poke_ts));
+
+	result = inv_handle_poke(st, (char *)&input_buf[0],
+			INV_DMP_GYRO_START_ADDR, BYTES_PER_SENSOR);
+	mutex_unlock(&indio_dev->mlock);
+	if (result)
+		return result;
+
+	return size;
+}
+
+static ssize_t inv_poke_write_mag(struct file *fp, struct kobject *kobj,
+			struct bin_attribute *attr, char *buf,
+			loff_t pos, size_t size)
+{
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+	int result, i;
+	short mag_data[3];
+	int input_mag[3];
+	short input_buf[3];
+	char buf_data[DATA_AKM_99_BYTES_DMP];
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+	for (i = 0; i < DATA_AKM_99_BYTES_DMP; i++)
+		buf_data[i] = 0;
+	for (i = 0; i < 3; i++) {
+		memcpy(&input_mag[i], buf + i * 4,
+					sizeof(input_mag[i]));
+		mag_data[i] = (short)(input_mag[i]);
+		input_buf[i] = cpu_to_be16(mag_data[i]);
+		memcpy(buf_data + 2 + i * 2, &input_buf[i],
+							sizeof(input_buf[i]));
+	}
+	buf_data[0] = 1;
+
+	memcpy((char *)&st->poke_ts, buf + INV_POKE_ACCEL_OFFSET_TO_TS,
+						sizeof(st->poke_ts));
+
+	result = inv_handle_poke(st, buf_data, INV_DMP_MAG_START_ADDR,
+							DATA_AKM_99_BYTES_DMP);
+	mutex_unlock(&indio_dev->mlock);
+	if (result)
+		return result;
+
+	return size;
+}
+
+static int inv_dmp_covar_read(struct inv_mpu_state *st,
+			int off, int size, u8 *buf)
+{
+	int data, result, i;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	inv_stop_dmp(st);
+	for (i = 0; i < COVARIANCE_SIZE * sizeof(int); i += sizeof(int)) {
+		result = read_be32_from_mem(st, (u32 *) &data, off + i);
+		if (result)
+			return result;
+		memcpy(buf + i, (u8 *) &data, sizeof(int));
+	}
+
+	return 0;
+}
+
+int inv_accel_covariance_read(struct file *filp,
+			struct kobject *kobj,
+			struct bin_attribute *bin_attr,
+			char *buf, loff_t off, size_t count)
+{
+	int result;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	if (!st->chip_config.firmware_loaded)
+		return -EINVAL;
+
+	mutex_lock(&indio_dev->mlock);
+	result = inv_dmp_covar_read(st, ACCEL_COVARIANCE, count, buf);
+	set_inv_enable(indio_dev);
+	mutex_unlock(&indio_dev->mlock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+static ssize_t inv_activity_read(struct file *filp,
+			struct kobject *kobj,
+			struct bin_attribute *bin_attr,
+			char *buf, loff_t off, size_t count)
+{
+	int copied;
+	struct iio_dev *indio_dev;
+	struct inv_mpu_state *st;
+	u8 ddd[128];
+
+	indio_dev = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	st = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+	copied = kfifo_out(&st->kf, ddd, count);
+	memcpy(buf, ddd, copied);
+	mutex_unlock(&indio_dev->mlock);
+
+	return copied;
+}
+
+/*
+ *  inv_create_dmp_sysfs() - create binary sysfs dmp entry.
+ */
+static struct bin_attribute dmp_firmware = {
+	.attr = {
+		.name = "misc_bin_dmp_firmware",
+		.mode = S_IRUGO | S_IWUGO},
+	.read = inv_dmp_firmware_read,
+	.write = inv_dmp_firmware_write,
+};
+
+#if 0
+static const struct bin_attribute soft_iron_matrix = {
+	.attr = {
+		.name = "misc_bin_soft_iron_matrix",
+		.mode = S_IRUGO | S_IWUGO},
+	.size = SOFT_IRON_MATRIX_SIZE,
+	.write = inv_soft_iron_matrix_write,
+};
+
+static const struct bin_attribute accel_covariance = {
+	.attr = {
+		.name = "misc_bin_accel_covariance",
+		.mode = S_IRUGO | S_IWUGO},
+	.size = ACCEL_COVARIANCE_SIZE,
+	.write = inv_accel_covariance_write,
+	.read = inv_accel_covariance_read,
+};
+#endif
+
+static const struct bin_attribute input_poke_gyro = {
+	.attr = {
+		.name = "misc_bin_poke_gyro",
+		.mode = S_IWUGO},
+	.size = INV_POKE_SIZE_GYRO,
+	.write = inv_poke_write_gyro,
+};
+
+static const struct bin_attribute input_poke_accel = {
+	.attr = {
+		.name = "misc_bin_poke_accel",
+		.mode = S_IWUGO},
+	.size = INV_POKE_SIZE_ACCEL,
+	.write = inv_poke_write_accel,
+};
+
+static const struct bin_attribute input_poke_mag = {
+	.attr = {
+		.name = "misc_bin_poke_mag",
+		.mode = S_IWUGO},
+	.size = INV_POKE_SIZE_MAG,
+	.write = inv_poke_write_mag,
+};
+
+static const struct bin_attribute activity_bin = {
+	.attr = {
+		.name = "misc_bin_activity_out",
+		.mode = S_IRUGO},
+	.size = HARDWARE_FIFO_SIZE,
+	.read = inv_activity_read,
+};
+
+int inv_create_dmp_sysfs(struct iio_dev *ind)
+{
+	int result = 0;
+	struct inv_mpu_state *st = iio_priv(ind);
+
+	dmp_firmware.size = st->dmp_image_size;
+
+	result = sysfs_create_bin_file(&ind->dev.kobj, &dmp_firmware);
+	if (result)
+		return result;
+	result = sysfs_create_bin_file(&ind->dev.kobj, &activity_bin);
+	if (result)
+		return result;
+	result = sysfs_create_bin_file(&ind->dev.kobj, &input_poke_gyro);
+	if (result)
+		return result;
+	result = sysfs_create_bin_file(&ind->dev.kobj, &input_poke_accel);
+	if (result)
+		return result;
+	result = sysfs_create_bin_file(&ind->dev.kobj, &input_poke_mag);
+	if (result)
+		return result;
+
+#if 0
+	result = sysfs_create_bin_file(&ind->dev.kobj, &soft_iron_matrix);
+	if (result)
+		return result;
+
+	result = sysfs_create_bin_file(&ind->dev.kobj, &accel_covariance);
+	if (result)
+		return result;
+#endif
+	return result;
+}
+EXPORT_SYMBOL_GPL(inv_create_dmp_sysfs);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense device ICM20xxx driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_dmp_fifo.c b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_dmp_fifo.c
new file mode 100644
index 000000000000..e20cddd57c63
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_dmp_fifo.c
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2017-2018 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/math64.h>
+
+#include "../inv_mpu_iio.h"
+
+static int inv_get_step_params(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_switch_power_in_lp(st, true);
+	st->prev_steps = st->curr_steps;
+	result |= read_be32_from_mem(st, &st->curr_steps, PEDSTD_STEPCTR);
+	result |= read_be32_from_mem(st, &st->ts_algo.start_dmp_counter,
+								DMPRATE_CNTR);
+	result |= inv_switch_power_in_lp(st, false);
+
+	return result;
+}
+/**
+  * static int inv_prescan_data(struct inv_mpu_state *st, u8 * dptr, int len)
+  *  prescan data to know what type of data and how many samples of data
+  *  in current FIFO reading.
+*/
+static int inv_prescan_data(struct inv_mpu_state *st, u8 *dptr, int len)
+{
+	int res, pk_size, i;
+	bool done_flag;
+	u16 hdr;
+
+	done_flag = false;
+	st->header_count = 0;
+	st->step_det_count = 0;
+	st->ts_algo.calib_counter++;
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].count = 0;
+	while (!done_flag) {
+		if (len > HEADER_SZ) {
+			hdr = (u16) be16_to_cpup((__be16 *) (dptr));
+			if (!hdr) {
+				pr_err("error header zero\n");
+				st->left_over_size = 0;
+				return -EINVAL;
+			}
+			res = inv_get_packet_size(st, hdr, &pk_size, dptr);
+			if (res) {
+				if (!st->chip_config.is_asleep)
+					pr_err
+				("prescan error in header parsing=%x size=%d\n",
+				hdr, len);
+				st->left_over_size = 0;
+
+				return -EINVAL;
+			}
+			if (len >= pk_size) {
+				inv_pre_parse_packet(st, hdr, dptr + HEADER_SZ);
+				len -= pk_size;
+				dptr += pk_size;
+			} else {
+				done_flag = true;
+			}
+		} else {
+			done_flag = true;
+		}
+	}
+	if (st->step_det_count)
+		inv_get_step_params(st);
+	inv_bound_timestamp(st);
+
+	return 0;
+}
+int inv_process_dmp_data(struct inv_mpu_state *st)
+{
+	int total_bytes, tmp, res, fifo_count, pk_size;
+	u8 *dptr, *d;
+	u16 hdr;
+	u8 data[2];
+	bool done_flag;
+
+	st->ts_algo.last_run_time = get_time_ns();
+	res = inv_plat_read(st, REG_FIFO_COUNT_H, FIFO_COUNT_BYTE, data);
+	if (res) {
+		pr_debug("read REG_FIFO_COUNT_H failed\n");
+		return res;
+	}
+	fifo_count = be16_to_cpup((__be16 *) (data));
+	if (!fifo_count) {
+		pr_debug("REG_FIFO_COUNT_H size is 0\n");
+		return 0;
+	}
+
+	if (fifo_count >= HARDWARE_FIFO_SIZE) {
+		pr_warn("fifo overflow fifo_count=%d\n", fifo_count);
+		return -EOVERFLOW;
+	}
+
+	st->fifo_count = fifo_count;
+	d = st->fifo_data_store;
+
+	if (st->left_over_size > LEFT_OVER_BYTES) {
+		st->left_over_size = 0;
+		pr_debug("left over size error\n");
+		return -EINVAL;
+	}
+
+	if (st->left_over_size > 0)
+		memcpy(d, st->left_over, st->left_over_size);
+
+	dptr = d + st->left_over_size;
+	total_bytes = fifo_count;
+	while (total_bytes > 0) {
+		if (total_bytes < MAX_FIFO_READ_SIZE)
+			tmp = total_bytes;
+		else
+			tmp = MAX_FIFO_READ_SIZE;
+		res = inv_plat_read(st, REG_FIFO_R_W, tmp, dptr);
+		if (res < 0) {
+			pr_debug("read REG_FIFO_R_W is failed\n");
+			return res;
+		}
+		dptr += tmp;
+		total_bytes -= tmp;
+	}
+	dptr = d;
+	total_bytes = fifo_count + st->left_over_size;
+	res = inv_prescan_data(st, dptr, total_bytes);
+	if (res) {
+		pr_info("prescan failed\n");
+		return -EINVAL;
+	}
+	dptr = d;
+	done_flag = false;
+	pr_debug("dd: %x, %x, %x, %x, %x, %x, %x, %x\n", d[0], d[1], d[2],
+						d[3], d[4], d[5], d[6], d[7]);
+	pr_debug("dd2: %x, %x, %x, %x, %x, %x, %x, %x\n", d[8], d[9], d[10],
+					d[11], d[12], d[13], d[14], d[15]);
+	while (!done_flag) {
+		if (total_bytes > HEADER_SZ) {
+			hdr = (u16) be16_to_cpup((__be16 *) (dptr));
+			res = inv_get_packet_size(st, hdr, &pk_size, dptr);
+			if (res) {
+				pr_err
+		("processing error in header parsing=%x fifo_count= %d\n",
+		hdr, fifo_count);
+				st->left_over_size = 0;
+
+				return -EINVAL;
+			}
+			if (total_bytes >= pk_size) {
+				inv_parse_packet(st, hdr, dptr + HEADER_SZ);
+				total_bytes -= pk_size;
+				dptr += pk_size;
+			} else {
+				done_flag = true;
+			}
+		} else {
+			done_flag = true;
+		}
+	}
+	st->left_over_size = total_bytes;
+	if (st->left_over_size > LEFT_OVER_BYTES) {
+		st->left_over_size = 0;
+		return -EINVAL;
+	}
+
+	if (st->left_over_size)
+		memcpy(st->left_over, dptr, st->left_over_size);
+
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_iio_reg_20648.h b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_iio_reg_20648.h
new file mode 100644
index 000000000000..88b3f8721dec
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_iio_reg_20648.h
@@ -0,0 +1,365 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _INV_MPU_IIO_20648_H_
+#define _INV_MPU_IIO_20648_H_
+
+/* #define DEBUG */
+
+/* #define BIAS_CONFIDENCE_HIGH 1 */
+
+/* register and associated bit definition */
+/* bank 0 register map */
+#define REG_WHO_AM_I            0x00
+
+#define REG_USER_CTRL           0x03
+#define BIT_DMP_EN                      0x80
+#define BIT_FIFO_EN                     0x40
+#define BIT_I2C_MST_EN                  0x20
+#define BIT_I2C_IF_DIS                  0x10
+#define BIT_DMP_RST                     0x08
+
+#define REG_LP_CONFIG           0x05
+#define BIT_I2C_MST_CYCLE               0x40
+#define BIT_ACCEL_CYCLE                 0x20
+#define BIT_GYRO_CYCLE                  0x10
+
+#define REG_PWR_MGMT_1          0x06
+#define BIT_H_RESET                     0x80
+#define BIT_SLEEP                       0x40
+#define BIT_LP_EN                       0x20
+#define BIT_CLK_PLL                     0x01
+
+#define REG_PWR_MGMT_2          0x07
+#define BIT_PWR_PRESSURE_STBY           0x40
+#define BIT_PWR_ACCEL_STBY              0x38
+#define BIT_PWR_GYRO_STBY               0x07
+#define BIT_PWR_ALL_OFF                 0x7f
+
+#define REG_INT_PIN_CFG         0x0F
+#define BIT_BYPASS_EN                   0x2
+
+#define REG_INT_ENABLE          0x10
+#define BIT_DMP_INT_EN                  0x02
+#define BIT_WOM_INT_EN                  0x08
+
+#define REG_INT_ENABLE_1        0x11
+#define BIT_DATA_RDY_3_EN               0x08
+#define BIT_DATA_RDY_2_EN               0x04
+#define BIT_DATA_RDY_1_EN               0x02
+#define BIT_DATA_RDY_0_EN               0x01
+
+#define REG_INT_ENABLE_2        0x12
+#define BIT_FIFO_OVERFLOW_EN_0          0x1
+
+#define REG_INT_ENABLE_3        0x13
+#define REG_DMP_INT_STATUS      0x18
+#define REG_INT_STATUS          0x19
+#define REG_INT_STATUS_1        0x1A
+
+#define REG_ACCEL_XOUT_H_SH     0x2D
+
+#define REG_GYRO_XOUT_H_SH      0x33
+
+#define REG_DMP_START_MODE      0x27
+#define BIT_DMP_POKE                   0x2
+#define BIT_DMP_START_MODE             0x1
+
+#define REG_TEMPERATURE         0x39
+
+#define REG_EXT_SLV_SENS_DATA_00 0x3B
+#define REG_EXT_SLV_SENS_DATA_08 0x43
+#define REG_EXT_SLV_SENS_DATA_09 0x44
+#define REG_EXT_SLV_SENS_DATA_10 0x45
+
+#define REG_FIFO_EN             0x66
+#define BIT_SLV_0_FIFO_EN               1
+
+#define REG_FIFO_EN_2           0x67
+#define BIT_PRS_FIFO_EN                 0x20
+#define BIT_ACCEL_FIFO_EN               0x10
+#define BITS_GYRO_FIFO_EN               0x0E
+
+#define REG_FIFO_RST            0x68
+
+#define REG_FIFO_SIZE_0         0x6E
+#define BIT_ACCEL_FIFO_SIZE_128         0x00
+#define BIT_ACCEL_FIFO_SIZE_256         0x04
+#define BIT_ACCEL_FIFO_SIZE_512         0x08
+#define BIT_ACCEL_FIFO_SIZE_1024        0x0C
+#define BIT_GYRO_FIFO_SIZE_128          0x00
+#define BIT_GYRO_FIFO_SIZE_256          0x01
+#define BIT_GYRO_FIFO_SIZE_512          0x02
+#define BIT_GYRO_FIFO_SIZE_1024         0x03
+#define BIT_FIFO_SIZE_1024              0x01
+#define BIT_FIFO_SIZE_512               0x00
+#define BIT_FIFO_3_SIZE_256             0x40
+#define BIT_FIFO_3_SIZE_64              0x00
+
+#define REG_FIFO_COUNT_H        0x70
+#define REG_FIFO_R_W            0x72
+
+#define REG_FIFO_CFG            0x76
+#define BIT_MULTI_FIFO_CFG              0x01
+#define BIT_SINGLE_FIFO_CFG             0x00
+#define BIT_GYRO_FIFO_NUM               (0 << 2)
+#define BIT_ACCEL_FIFO_NUM              (1 << 2)
+#define BIT_PRS_FIFO_NUM                2
+#define BIT_EXT_FIFO_NUM                3
+
+#define REG_MEM_START_ADDR      0x7C
+#define REG_MEM_R_W             0x7D
+#define REG_MEM_BANK_SEL        0x7E
+
+/* bank 1 register map */
+#define REG_XA_OFFS_H           0x14
+#define REG_YA_OFFS_H           0x17
+#define REG_ZA_OFFS_H           0x1A
+
+#define REG_TIMEBASE_CORRECTION_PLL 0x28
+#define REG_TIMEBASE_CORRECTION_RCOSC 0x29
+#define REG_SELF_TEST1                0x02
+#define REG_SELF_TEST2                0x03
+#define REG_SELF_TEST3                0x04
+#define REG_SELF_TEST4                0x0E
+#define REG_SELF_TEST5                0x0F
+#define REG_SELF_TEST6                0x10
+
+/* bank 2 register map */
+#define REG_GYRO_SMPLRT_DIV     0x00
+
+#define REG_GYRO_CONFIG_1       0x01
+#define SHIFT_GYRO_FS_SEL               1
+#define BIT_GYRO_DLPCFG_184Hz           (1 << 3)
+#define BIT_GYRO_FCHOICE                1
+
+#define REG_GYRO_CONFIG_2       0x02
+#define BIT_GYRO_CTEN                   0x38
+
+#define REG_XG_OFFS_USR_H       0x03
+#define REG_YG_OFFS_USR_H       0x05
+#define REG_ZG_OFFS_USR_H       0x07
+
+#define REG_ODR_ALIGN_EN        0x09
+#define BIT_ODR_ALIGN_EN                   1
+
+#define REG_ACCEL_SMPLRT_DIV_1  0x10
+#define REG_ACCEL_SMPLRT_DIV_2  0x11
+
+#define REG_ACCEL_WOM_THR       0x13
+
+#define REG_ACCEL_CONFIG        0x14
+#define BIT_ACCEL_FCHOICE               1
+#define SHIFT_ACCEL_FS                  1
+#define SHIFT_ACCEL_DLPCFG              3
+#define ACCEL_CONFIG_LOW_POWER_SET      7
+
+#define REG_ACCEL_CONFIG_2       0x15
+#define BIT_ACCEL_CTEN                  0x1C
+
+#define REG_PRS_ODR_CONFIG      0x20
+#define REG_PRGM_START_ADDRH    0x50
+
+#define REG_FSYNC_CONFIG        0x52
+#define BIT_TRIGGER_EIS                 0x91
+
+#define REG_MOD_CTRL_USR        0x54
+#define BIT_ODR_SYNC                    0x7
+
+/* bank 3 register map */
+#define REG_I2C_MST_ODR_CONFIG  0
+
+#define REG_I2C_MST_CTRL         1
+#define BIT_I2C_MST_P_NSR       0x10
+
+#define REG_I2C_MST_DELAY_CTRL  0x02
+#define BIT_DELAY_ES_SHADOW     0x80
+#define BIT_SLV0_DLY_EN                 0x01
+#define BIT_SLV1_DLY_EN                 0x02
+#define BIT_SLV2_DLY_EN                 0x04
+#define BIT_SLV3_DLY_EN                 0x08
+
+#define REG_I2C_SLV0_ADDR       0x03
+#define REG_I2C_SLV0_REG        0x04
+#define REG_I2C_SLV0_CTRL       0x05
+#define REG_I2C_SLV0_DO         0x06
+
+#define REG_I2C_SLV1_ADDR       0x07
+#define REG_I2C_SLV1_REG        0x08
+#define REG_I2C_SLV1_CTRL       0x09
+#define REG_I2C_SLV1_DO         0x0A
+
+#define REG_I2C_SLV2_ADDR       0x0B
+#define REG_I2C_SLV2_REG        0x0C
+#define REG_I2C_SLV2_CTRL       0x0D
+#define REG_I2C_SLV2_DO         0x0E
+
+#define REG_I2C_SLV3_ADDR       0x0F
+#define REG_I2C_SLV3_REG        0x10
+#define REG_I2C_SLV3_CTRL       0x11
+#define REG_I2C_SLV3_DO         0x12
+
+#define REG_I2C_SLV4_CTRL       0x15
+
+#define INV_MPU_BIT_SLV_EN      0x80
+#define INV_MPU_BIT_BYTE_SW     0x40
+#define INV_MPU_BIT_REG_DIS     0x20
+#define INV_MPU_BIT_GRP         0x10
+#define INV_MPU_BIT_I2C_READ    0x80
+
+/* register for all banks */
+#define REG_BANK_SEL            0x7F
+#define BANK_SEL_0                      0x00
+#define BANK_SEL_1                      0x10
+#define BANK_SEL_2                      0x20
+#define BANK_SEL_3                      0x30
+
+/* data definitions */
+#define BYTES_PER_SENSOR         6
+#define FIFO_COUNT_BYTE          2
+#define HARDWARE_FIFO_SIZE       1024
+#define FIFO_SIZE                (HARDWARE_FIFO_SIZE * 7 / 8)
+#define POWER_UP_TIME            100
+#define REG_UP_TIME_USEC         100
+#define DMP_RESET_TIME           20
+#define GYRO_ENGINE_UP_TIME      50
+#define MPU_MEM_BANK_SIZE        256
+#define IIO_BUFFER_BYTES         8
+#define HEADERED_NORMAL_BYTES    8
+#define HEADERED_Q_BYTES         16
+#define LEFT_OVER_BYTES          128
+#define BASE_SAMPLE_RATE         1125
+#define DRY_RUN_TIME             50
+/* initial rate is important. For DMP mode, it is set as 1 since DMP decimate*/
+#define MPU_INIT_SENSOR_RATE     1
+
+#ifdef BIAS_CONFIDENCE_HIGH
+#define DEFAULT_ACCURACY         3
+#else
+#define DEFAULT_ACCURACY         1
+#endif
+
+#define FREQ_225
+
+#ifdef FREQ_225
+#define MPU_DEFAULT_DMP_FREQ     225
+#define PEDOMETER_FREQ           (MPU_DEFAULT_DMP_FREQ >> 2)
+#define PED_ACCEL_GAIN           67108864L
+#define DEFAULT_ACCEL_GAIN       (33554432L * 5 / 11)
+#define DEFAULT_ACCEL_GAIN_112       (33554432L * 10 / 11)
+#define ALPHA_FILL_FULL          1020054733
+#define A_FILL_FULL              53687091
+#else
+#define MPU_DEFAULT_DMP_FREQ     102
+#define PEDOMETER_FREQ           (MPU_DEFAULT_DMP_FREQ >> 1)
+#define PED_ACCEL_GAIN           67108864L
+#define DEFAULT_ACCEL_GAIN       33554432L
+#define ALPHA_FILL_FULL          966367642
+#define A_FILL_FULL              107374182
+#endif
+#define ALPHA_FILL_PED           858993459
+#define A_FILL_PED               214748365
+
+#define DMP_OFFSET               0x90
+#define DMP_IMAGE_SIZE_20648           (14250 + DMP_OFFSET)
+#define MIN_MST_ODR_CONFIG       4
+#define MAX_MST_ODR_CONFIG       5
+#define MAX_COMPASS_RATE    100
+#define MAX_MST_NON_COMPASS_ODR_CONFIG 7
+#define THREE_AXES               3
+#define NINE_ELEM                (THREE_AXES * THREE_AXES)
+#define MPU_TEMP_SHIFT           16
+#define SOFT_IRON_MATRIX_SIZE    (4 * 9)
+#define DMP_DIVIDER              (BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ)
+#define MAX_5_BIT_VALUE          0x1F
+#define BAD_COMPASS_DATA         0x7FFF
+#define BAD_CAL_COMPASS_DATA     0x7FFF0000
+#define DEFAULT_BATCH_RATE       400
+#define DEFAULT_BATCH_TIME    (MSEC_PER_SEC / DEFAULT_BATCH_RATE)
+#define NINEQ_DEFAULT_COMPASS_RATE 25
+#define DMP_ACCEL_SCALE_2G       0x2000000 /* scale for Q25 */
+#define DMP_ACCEL_SCALE2_2G      0x80000   /* scale back to LSB */
+
+#define SENCONDARY_GYRO_OFF       0x01
+#define SENCONDARY_GYRO_ON        0x02
+#define SENCONDARY_COMPASS_OFF    0x04
+#define SENCONDARY_COMPASS_ON     0x08
+#define SENCONDARY_PROX_OFF       0x10
+#define SENCONDARY_PROX_ON        0x20
+
+#define NINEQ_MIN_COMPASS_RATE 35
+#define GEOMAG_MIN_COMPASS_RATE    70
+
+#define MAX_PRESSURE_RATE        30
+#define MAX_ALS_RATE             5
+#define DATA_AKM_99_BYTES_DMP  10
+#define DATA_AKM_89_BYTES_DMP  9
+#define DATA_ALS_BYTES_DMP     8
+#define APDS9900_AILTL_REG      0x04
+#define BMP280_DIG_T1_LSB_REG                0x88
+#define INV_RAW_DATA_BYTES             6
+/* poke feature related. */
+#define INV_POKE_SIZE_GYRO           20
+#define INV_POKE_GYRO_OFFSET_TO_TS  12
+#define INV_DMP_GYRO_START_ADDR      10
+#define INV_POKE_SIZE_ACCEL          20
+#define INV_POKE_ACCEL_OFFSET_TO_TS  12
+#define INV_DMP_ACCEL_START_ADDR     4
+#define INV_POKE_SIZE_MAG           20
+#define INV_POKE_MAG_OFFSET_TO_TS  12
+#define INV_DMP_MAG_START_ADDR     18
+
+#define TEMPERATURE_SCALE  3216048L    /* 2^30 / 333.87 */
+#define TEMPERATURE_OFFSET 1376256L    /* 21degC in Q16 */
+#define SECONDARY_INIT_WAIT 100
+#define SW_REV_NO_RUN_FLAG              8
+#define AK99XX_SHIFT                    23
+#define AK89XX_SHIFT                    22
+
+/* this is derived from 1000 divided by 55, which is the pedometer
+   running frequency */
+#define MS_PER_PED_TICKS         18
+
+/* data limit definitions */
+#define MIN_FIFO_RATE            4
+#define MAX_FIFO_RATE            MPU_DEFAULT_DMP_FREQ
+#define MAX_DMP_OUTPUT_RATE      MPU_DEFAULT_DMP_FREQ
+
+#define MAX_MPU_MEM              8192
+#define MAX_PRS_RATE             281
+#define MIN_COMPASS_RATE         35
+
+/* enum for sensor
+   The sequence is important.
+   It represents the order of apperance from DMP */
+enum INV_SENSORS {
+	SENSOR_ACCEL = 0,
+	SENSOR_TEMP,
+	SENSOR_GYRO,
+	SENSOR_COMPASS,
+	SENSOR_ALS,
+	SENSOR_SIXQ,
+	SENSOR_NINEQ,
+	SENSOR_PEDQ,
+	SENSOR_GEOMAG,
+	SENSOR_PRESSURE,
+	SENSOR_COMPASS_CAL,
+	SENSOR_NUM_MAX,
+	SENSOR_INVALID,
+};
+
+enum inv_devices {
+	ICM20648,
+	INV_NUM_PARTS
+};
+#endif /* #ifndef _INV_MPU_IIO_20648_H_ */
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_init.c b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_init.c
new file mode 100644
index 000000000000..70c4dfb869fe
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_init.c
@@ -0,0 +1,562 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+static const struct inv_hw_s hw_info[INV_NUM_PARTS] = {
+	{128, "ICM20648"},
+};
+
+static int inv_set_dmp(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_PRGM_START_ADDRH,
+				st->dmp_start_address >> 8);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_PRGM_START_ADDRH + 1,
+				st->dmp_start_address & 0xff);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+static int inv_calc_gyro_sf(s8 pll)
+{
+	int a, r;
+	int value, t;
+
+	t = 102870L + 81L * pll;
+	a = (1L << 30) / t;
+	r = (1L << 30) - a * t;
+	value = a * 797 * DMP_DIVIDER;
+	value += (s64) ((a * 1011387LL * DMP_DIVIDER) >> 20);
+	value += r * 797L * DMP_DIVIDER / t;
+	value += (s32) ((s64) ((r * 1011387LL * DMP_DIVIDER) >> 20)) / t;
+	value <<= 1;
+
+	return value;
+}
+
+static int inv_read_timebase(struct inv_mpu_state *st)
+{
+	int result;
+	u8 d;
+	s8 t;
+
+/* ((20 * 1270 * NSEC_PER_SEC)/(27 * 1000 * 768)) */
+#define INV_PRECISION_CONST 1224922
+
+
+	result = inv_set_bank(st, BANK_SEL_1);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_TIMEBASE_CORRECTION_PLL, 1, &d);
+	if (result)
+		return result;
+	t = abs(d & 0x7f);
+	if (d & 0x80)
+		t = -t;
+	st->eis.count_precision = INV_PRECISION_CONST / (1270 + t);
+	st->eng_info[ENGINE_ACCEL].base_time = NSEC_PER_SEC;
+	/* talor expansion to calculate base time unit */
+	st->eng_info[ENGINE_GYRO].base_time = (NSEC_PER_SEC / (1270 + t)) * 1270;
+	st->eng_info[ENGINE_PRESSURE].base_time = NSEC_PER_SEC;
+	st->eng_info[ENGINE_I2C].base_time = NSEC_PER_SEC;
+
+	st->eng_info[ENGINE_ACCEL].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_GYRO].orig_rate = BASE_SAMPLE_RATE;
+	st->eng_info[ENGINE_PRESSURE].orig_rate = MAX_PRS_RATE;
+	st->eng_info[ENGINE_I2C].orig_rate = BASE_SAMPLE_RATE;
+
+	st->gyro_sf = inv_calc_gyro_sf(t);
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+int inv_set_gyro_sf(struct inv_mpu_state *st)
+{
+	int result;
+	u8 averaging = 4;
+	u8 dec3_cfg;
+
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG_1,
+				(st->chip_config.fsr
+				<< SHIFT_GYRO_FS_SEL) |
+				BIT_GYRO_FCHOICE);
+	if (result)
+		return result;
+	switch (averaging) {
+	case 1:
+		dec3_cfg = 0;
+		break;
+	case 2:
+		dec3_cfg = 1;
+		break;
+	case 4:
+		dec3_cfg = 2;
+		break;
+	case 8:
+		dec3_cfg = 3;
+		break;
+	case 16:
+		dec3_cfg = 4;
+		break;
+	case 32:
+		dec3_cfg = 5;
+		break;
+	case 64:
+		dec3_cfg = 6;
+		break;
+	case 128:
+		dec3_cfg = 7;
+		break;
+	default:
+		dec3_cfg = 0;
+		break;
+	}
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG_2, dec3_cfg);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+int inv_set_accel_sf(struct inv_mpu_state *st)
+{
+	int result;
+	u8 averaging = 1;
+	u8 dec3_cfg;
+
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+
+	/* The FCHOICE is 1 even in cycle mode so that averaging is 4 */
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG,
+			(st->chip_config. accel_fs << SHIFT_ACCEL_FS) |
+			(ACCEL_CONFIG_LOW_POWER_SET << SHIFT_ACCEL_DLPCFG) |
+			BIT_ACCEL_FCHOICE);
+	if (result)
+		return result;
+	switch (averaging) {
+	case 4:
+		dec3_cfg = 0;
+		break;
+	case 8:
+		dec3_cfg = 1;
+		break;
+	case 16:
+		dec3_cfg = 2;
+		break;
+	case 32:
+		dec3_cfg = 3;
+		break;
+	default:
+		dec3_cfg = 0;
+		break;
+	}
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG_2, dec3_cfg);
+
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+static int inv_set_secondary(struct inv_mpu_state *st)
+{
+	int r;
+
+	r = inv_set_bank(st, BANK_SEL_3);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_I2C_MST_CTRL, BIT_I2C_MST_P_NSR);
+	if (r)
+		return r;
+
+	r = inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG,
+					MIN_MST_ODR_CONFIG);
+	if (r)
+		return r;
+
+	r = inv_plat_single_write(st, REG_I2C_MST_DELAY_CTRL,
+					BIT_DELAY_ES_SHADOW);
+	if (r)
+		return r;
+
+	r = inv_set_bank(st, BANK_SEL_0);
+
+	return r;
+}
+
+static int inv_init_secondary(struct inv_mpu_state *st)
+{
+	st->slv_reg[0].addr = REG_I2C_SLV0_ADDR;
+	st->slv_reg[0].reg = REG_I2C_SLV0_REG;
+	st->slv_reg[0].ctrl = REG_I2C_SLV0_CTRL;
+	st->slv_reg[0].d0 = REG_I2C_SLV0_DO;
+
+	st->slv_reg[1].addr = REG_I2C_SLV1_ADDR;
+	st->slv_reg[1].reg = REG_I2C_SLV1_REG;
+	st->slv_reg[1].ctrl = REG_I2C_SLV1_CTRL;
+	st->slv_reg[1].d0 = REG_I2C_SLV1_DO;
+
+	st->slv_reg[2].addr = REG_I2C_SLV2_ADDR;
+	st->slv_reg[2].reg = REG_I2C_SLV2_REG;
+	st->slv_reg[2].ctrl = REG_I2C_SLV2_CTRL;
+	st->slv_reg[2].d0 = REG_I2C_SLV2_DO;
+
+	st->slv_reg[3].addr = REG_I2C_SLV3_ADDR;
+	st->slv_reg[3].reg = REG_I2C_SLV3_REG;
+	st->slv_reg[3].ctrl = REG_I2C_SLV3_CTRL;
+	st->slv_reg[3].d0 = REG_I2C_SLV3_DO;
+
+	return 0;
+}
+
+static void inv_init_sensor_struct(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE;
+
+	st->sensor[SENSOR_ACCEL].sample_size = ACCEL_DATA_SZ;
+	st->sensor[SENSOR_GYRO].sample_size = GYRO_DATA_SZ;
+	st->sensor[SENSOR_COMPASS].sample_size = CPASS_DATA_SZ;
+	st->sensor[SENSOR_COMPASS_CAL].sample_size = CPASS_CALIBR_DATA_SZ;
+	st->sensor[SENSOR_ALS].sample_size = ALS_DATA_SZ;
+	st->sensor[SENSOR_PRESSURE].sample_size = PRESSURE_DATA_SZ;
+	st->sensor[SENSOR_SIXQ].sample_size = QUAT6_DATA_SZ;
+	st->sensor[SENSOR_NINEQ].sample_size = QUAT9_DATA_SZ;
+	st->sensor[SENSOR_PEDQ].sample_size = PQUAT6_DATA_SZ;
+	st->sensor[SENSOR_GEOMAG].sample_size = GEOMAG_DATA_SZ;
+
+	st->sensor[SENSOR_ACCEL].odr_addr = ODR_ACCEL;
+	st->sensor[SENSOR_GYRO].odr_addr = ODR_GYRO;
+	st->sensor[SENSOR_COMPASS].odr_addr = ODR_CPASS;
+	st->sensor[SENSOR_COMPASS_CAL].odr_addr = ODR_CPASS_CALIBR;
+	st->sensor[SENSOR_ALS].odr_addr = ODR_ALS;
+	st->sensor[SENSOR_PRESSURE].odr_addr = ODR_PRESSURE;
+	st->sensor[SENSOR_SIXQ].odr_addr = ODR_QUAT6;
+	st->sensor[SENSOR_NINEQ].odr_addr = ODR_QUAT9;
+	st->sensor[SENSOR_PEDQ].odr_addr = ODR_PQUAT6;
+	st->sensor[SENSOR_GEOMAG].odr_addr = ODR_GEOMAG;
+
+	st->sensor[SENSOR_ACCEL].counter_addr = ODR_CNTR_ACCEL;
+	st->sensor[SENSOR_GYRO].counter_addr = ODR_CNTR_GYRO;
+	st->sensor[SENSOR_COMPASS].counter_addr = ODR_CNTR_CPASS;
+	st->sensor[SENSOR_COMPASS_CAL].counter_addr = ODR_CNTR_CPASS_CALIBR;
+	st->sensor[SENSOR_ALS].counter_addr = ODR_CNTR_ALS;
+	st->sensor[SENSOR_PRESSURE].counter_addr = ODR_CNTR_PRESSURE;
+	st->sensor[SENSOR_SIXQ].counter_addr = ODR_CNTR_QUAT6;
+	st->sensor[SENSOR_NINEQ].counter_addr = ODR_CNTR_QUAT9;
+	st->sensor[SENSOR_PEDQ].counter_addr = ODR_CNTR_PQUAT6;
+	st->sensor[SENSOR_GEOMAG].counter_addr = ODR_CNTR_GEOMAG;
+
+	st->sensor[SENSOR_ACCEL].output = ACCEL_SET;
+	st->sensor[SENSOR_GYRO].output = GYRO_SET;
+	st->sensor[SENSOR_COMPASS].output = CPASS_SET;
+	st->sensor[SENSOR_COMPASS_CAL].output = CPASS_CALIBR_SET;
+	st->sensor[SENSOR_ALS].output = ALS_SET;
+	st->sensor[SENSOR_PRESSURE].output = PRESSURE_SET;
+	st->sensor[SENSOR_SIXQ].output = QUAT6_SET;
+	st->sensor[SENSOR_NINEQ].output = QUAT9_SET;
+	st->sensor[SENSOR_PEDQ].output = PQUAT6_SET;
+	st->sensor[SENSOR_GEOMAG].output = GEOMAG_SET;
+
+	st->sensor[SENSOR_ACCEL].a_en = true;
+	st->sensor[SENSOR_GYRO].a_en = false;
+	st->sensor[SENSOR_COMPASS].a_en = false;
+	st->sensor[SENSOR_COMPASS_CAL].a_en = false;
+	st->sensor[SENSOR_ALS].a_en = false;
+	st->sensor[SENSOR_PRESSURE].a_en = false;
+	st->sensor[SENSOR_SIXQ].a_en = true;
+	st->sensor[SENSOR_NINEQ].a_en = true;
+	st->sensor[SENSOR_PEDQ].a_en = true;
+	st->sensor[SENSOR_GEOMAG].a_en = true;
+
+	st->sensor[SENSOR_ACCEL].g_en = false;
+	st->sensor[SENSOR_GYRO].g_en = true;
+	st->sensor[SENSOR_COMPASS].g_en = false;
+	st->sensor[SENSOR_COMPASS_CAL].g_en = false;
+	st->sensor[SENSOR_ALS].g_en = false;
+	st->sensor[SENSOR_PRESSURE].g_en = false;
+	st->sensor[SENSOR_SIXQ].g_en = true;
+	st->sensor[SENSOR_NINEQ].g_en = true;
+	st->sensor[SENSOR_PEDQ].g_en = true;
+	st->sensor[SENSOR_GEOMAG].g_en = false;
+
+	st->sensor[SENSOR_ACCEL].c_en = false;
+	st->sensor[SENSOR_GYRO].c_en = false;
+	st->sensor[SENSOR_COMPASS].c_en = true;
+	st->sensor[SENSOR_COMPASS_CAL].c_en = true;
+	st->sensor[SENSOR_ALS].c_en = false;
+	st->sensor[SENSOR_PRESSURE].c_en = false;
+	st->sensor[SENSOR_SIXQ].c_en = false;
+	st->sensor[SENSOR_NINEQ].c_en = true;
+	st->sensor[SENSOR_PEDQ].c_en = false;
+	st->sensor[SENSOR_GEOMAG].c_en = true;
+
+	st->sensor[SENSOR_ACCEL].p_en = false;
+	st->sensor[SENSOR_GYRO].p_en = false;
+	st->sensor[SENSOR_COMPASS].p_en = false;
+	st->sensor[SENSOR_COMPASS_CAL].p_en = false;
+	st->sensor[SENSOR_ALS].p_en = false;
+	st->sensor[SENSOR_PRESSURE].p_en = true;
+	st->sensor[SENSOR_SIXQ].p_en = false;
+	st->sensor[SENSOR_NINEQ].p_en = false;
+	st->sensor[SENSOR_PEDQ].p_en = false;
+	st->sensor[SENSOR_GEOMAG].p_en = false;
+
+	st->sensor[SENSOR_ACCEL].engine_base = ENGINE_ACCEL;
+	st->sensor[SENSOR_GYRO].engine_base = ENGINE_GYRO;
+	st->sensor[SENSOR_COMPASS].engine_base = ENGINE_I2C;
+	st->sensor[SENSOR_COMPASS_CAL].engine_base = ENGINE_I2C;
+	st->sensor[SENSOR_ALS].engine_base = ENGINE_I2C;
+	st->sensor[SENSOR_PRESSURE].engine_base = ENGINE_I2C;
+	st->sensor[SENSOR_SIXQ].engine_base = ENGINE_GYRO;
+	st->sensor[SENSOR_NINEQ].engine_base = ENGINE_GYRO;
+	st->sensor[SENSOR_PEDQ].engine_base = ENGINE_GYRO;
+	st->sensor[SENSOR_GEOMAG].engine_base = ENGINE_ACCEL;
+
+	st->sensor_l[SENSOR_L_ACCEL].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_GYRO_CAL].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_MAG].base = SENSOR_COMPASS;
+	st->sensor_l[SENSOR_L_MAG_CAL].base = SENSOR_COMPASS_CAL;
+	st->sensor_l[SENSOR_L_EIS_GYRO].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_SIXQ].base = SENSOR_SIXQ;
+	st->sensor_l[SENSOR_L_NINEQ].base = SENSOR_NINEQ;
+	st->sensor_l[SENSOR_L_PEDQ].base = SENSOR_PEDQ;
+	st->sensor_l[SENSOR_L_PRESSURE].base = SENSOR_PRESSURE;
+	st->sensor_l[SENSOR_L_ALS].base = SENSOR_ALS;
+	st->sensor_l[SENSOR_L_GEOMAG].base = SENSOR_GEOMAG;
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].base = SENSOR_ACCEL;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_MAG_WAKE].base = SENSOR_COMPASS;
+	st->sensor_l[SENSOR_L_ALS_WAKE].base = SENSOR_ALS;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].base = SENSOR_SIXQ;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].base = SENSOR_NINEQ;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].base = SENSOR_PEDQ;
+	st->sensor_l[SENSOR_L_GEOMAG_WAKE].base = SENSOR_GEOMAG;
+	st->sensor_l[SENSOR_L_PRESSURE_WAKE].base = SENSOR_PRESSURE;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].base = SENSOR_GYRO;
+	st->sensor_l[SENSOR_L_MAG_CAL_WAKE].base = SENSOR_COMPASS_CAL;
+
+	st->sensor_l[SENSOR_L_ACCEL].header = ACCEL_HDR;
+	st->sensor_l[SENSOR_L_GYRO].header = GYRO_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL].header = GYRO_CALIB_HDR;
+	st->sensor_l[SENSOR_L_MAG].header = COMPASS_HDR;
+	st->sensor_l[SENSOR_L_MAG_CAL].header = COMPASS_CALIB_HDR;
+	st->sensor_l[SENSOR_L_EIS_GYRO].header = EIS_GYRO_HDR;
+	st->sensor_l[SENSOR_L_SIXQ].header = SIXQUAT_HDR;
+	st->sensor_l[SENSOR_L_NINEQ].header = NINEQUAT_HDR;
+	st->sensor_l[SENSOR_L_PEDQ].header = PEDQUAT_HDR;
+	st->sensor_l[SENSOR_L_PRESSURE].header = PRESSURE_HDR;
+	st->sensor_l[SENSOR_L_ALS].header = ALS_HDR;
+	st->sensor_l[SENSOR_L_GEOMAG].header = GEOMAG_HDR;
+
+	st->sensor_l[SENSOR_L_ACCEL_WAKE].header = ACCEL_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_WAKE].header = GYRO_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GYRO_CAL_WAKE].header = GYRO_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_WAKE].header = COMPASS_WAKE_HDR;
+	st->sensor_l[SENSOR_L_MAG_CAL_WAKE].header = COMPASS_CALIB_WAKE_HDR;
+	st->sensor_l[SENSOR_L_SIXQ_WAKE].header = SIXQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_NINEQ_WAKE].header = NINEQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_PEDQ_WAKE].header = PEDQUAT_WAKE_HDR;
+	st->sensor_l[SENSOR_L_PRESSURE_WAKE].header = PRESSURE_WAKE_HDR;
+	st->sensor_l[SENSOR_L_ALS_WAKE].header = ALS_WAKE_HDR;
+	st->sensor_l[SENSOR_L_GEOMAG_WAKE].header = GEOMAG_WAKE_HDR;
+
+	for (i = SENSOR_L_ACCEL; i <= SENSOR_L_EIS_GYRO; i++)
+		st->sensor_l[i].wake_on = false;
+
+	for (i = SENSOR_L_ACCEL_WAKE; i <= SENSOR_L_MAG_CAL_WAKE; i++)
+		st->sensor_l[i].wake_on = true;
+
+	st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].sample_size =
+			ACCEL_ACCURACY_SZ;
+	st->sensor_accuracy[SENSOR_GYRO_ACCURACY].sample_size =
+			GYRO_ACCURACY_SZ;
+	st->sensor_accuracy[SENSOR_COMPASS_ACCURACY].sample_size =
+			CPASS_ACCURACY_SZ;
+
+	st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].output = ACCEL_ACCURACY_SET;
+	st->sensor_accuracy[SENSOR_GYRO_ACCURACY].output = GYRO_ACCURACY_SET;
+	st->sensor_accuracy[SENSOR_COMPASS_ACCURACY].output =
+			CPASS_ACCURACY_SET;
+
+	st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].header = ACCEL_ACCURACY_HDR;
+	st->sensor_accuracy[SENSOR_GYRO_ACCURACY].header = GYRO_ACCURACY_HDR;
+	st->sensor_accuracy[SENSOR_COMPASS_ACCURACY].header =
+			COMPASS_ACCURACY_HDR;
+}
+
+static int inv_init_config(struct inv_mpu_state *st)
+{
+	int res, i;
+	u8 reg = 0x0;
+
+	st->batch.overflow_on = 0;
+	st->chip_config.fsr = MPU_INIT_GYRO_SCALE;
+	st->chip_config.accel_fs = MPU_INIT_ACCEL_SCALE;
+	st->ped.int_thresh = MPU_INIT_PED_INT_THRESH;
+	st->ped.step_thresh = MPU_INIT_PED_STEP_THRESH;
+	st->chip_config.low_power_gyro_on = 1;
+	st->firmware = 0;
+	st->secondary_switch = false;
+	st->fifo_count_mode = BYTE_MODE;
+
+	inv_init_secondary(st);
+	inv_init_sensor_struct(st);
+
+	/* Implemented for HW_FIX_DISABLE */
+	res = inv_plat_read(st, 0x75, 1, &reg);
+	if (res) {
+		pr_info("Error : cannot read 0x75 (HW_FIX_DIABLE) register\n");
+		return res;
+	}
+	reg |= 0x8;
+	res = inv_plat_single_write(st, 0x75, reg);
+	res = inv_plat_read(st, 0x75, 1, &reg);
+	pr_info("Write %04X to HW_FIX_DIABLE register\n", reg);
+	/* End of implemented for HW_FIX_DISABLE */
+
+	res = inv_read_timebase(st);
+	if (res)
+		return res;
+	res = inv_set_dmp(st);
+	if (res)
+		return res;
+
+	res = inv_set_gyro_sf(st);
+	if (res)
+		return res;
+	res = inv_set_accel_sf(st);
+	if (res)
+		return res;
+	res = inv_set_secondary(st);
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].ts = 0;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].previous_ts = 0;
+
+	return res;
+}
+
+int inv_mpu_initialize(struct inv_mpu_state *st)
+{
+	u8 v;
+	int result;
+	struct inv_chip_config_s *conf;
+	struct mpu_platform_data *plat;
+
+	conf = &st->chip_config;
+	plat = &st->plat_data;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+
+	/* verify whoami */
+	result = inv_plat_read(st, REG_WHO_AM_I, 1, &v);
+	if (result)
+		return result;
+	pr_info("whoami= %x\n", v);
+	if (v == 0x00 || v == 0xff)
+		return -ENODEV;
+
+	/* reset to make sure previous state are not there */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_H_RESET);
+	if (result)
+		return result;
+	msleep(100);
+	/* toggle power state */
+	result = inv_set_power(st, false);
+	if (result)
+		return result;
+	result = inv_set_power(st, true);
+	if (result)
+		return result;
+
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (result)
+		return result;
+
+	result = inv_read_offset_regs(st,
+			st->org_accel_offset_reg, st->org_gyro_offset_reg);
+	if (result)
+		return result;
+
+	result = inv_init_config(st);
+	if (result)
+		return result;
+
+	if (SECONDARY_SLAVE_TYPE_COMPASS == plat->sec_slave_type)
+		st->chip_config.has_compass = 1;
+	else
+		st->chip_config.has_compass = 0;
+	if (SECONDARY_SLAVE_TYPE_PRESSURE == plat->aux_slave_type)
+		st->chip_config.has_pressure = 1;
+	else
+		st->chip_config.has_pressure = 0;
+	if (SECONDARY_SLAVE_TYPE_ALS == plat->read_only_slave_type)
+		st->chip_config.has_als = 1;
+	else
+		st->chip_config.has_als = 0;
+
+	if (st->chip_config.has_compass) {
+		result = inv_mpu_setup_compass_slave(st);
+		if (result)
+			pr_err("compass setup failed\n");
+	}
+	if (st->chip_config.has_pressure) {
+		result = inv_mpu_setup_pressure_slave(st);
+		if (result) {
+			pr_err("pressure setup failed\n");
+			st->chip_config.has_pressure = 0;
+			plat->aux_slave_type = SECONDARY_SLAVE_TYPE_NONE;
+		}
+	}
+	if (st->chip_config.has_als) {
+		result = inv_mpu_setup_als_slave(st);
+		if (result) {
+			pr_err("als setup failed\n");
+			st->chip_config.has_als = 0;
+			plat->read_only_slave_type = SECONDARY_SLAVE_TYPE_NONE;
+		}
+	}
+
+	st->chip_config.lp_en_mode_off = 0;
+
+	result = inv_set_power(st, false);
+
+	pr_info("%s: initialize result is %d....\n", __func__, result);
+
+	return result;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_load_dmp.c b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_load_dmp.c
new file mode 100644
index 000000000000..c3325b8eb176
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_load_dmp.c
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "../inv_mpu_iio.h"
+
+static int inv_load_firmware(struct inv_mpu_state *st)
+{
+	int bank, write_size;
+	int result, size;
+	u16 memaddr;
+	u8 *data;
+
+	data = st->firmware;
+	size = st->dmp_image_size - DMP_OFFSET;
+	memaddr = DMP_OFFSET;
+	data += DMP_OFFSET;
+	for (bank = 0; size > 0; bank++, size -= write_size) {
+		if (size > MAX_DMP_READ_SIZE)
+			write_size = MAX_DMP_READ_SIZE;
+		else
+			write_size = size;
+		result = mem_w(memaddr, write_size, data);
+		if (result) {
+			pr_err("error writing firmware:%d\n", bank);
+			pr_info("%s: error writing firmware %d\n", __func__,
+				bank);
+			return result;
+		}
+		memaddr += write_size;
+		data += write_size;
+	}
+
+	pr_info("%s: DMP load firmware successed DMP_Size %d\n",
+		__func__, st->dmp_image_size);
+	return 0;
+}
+
+static int inv_verify_firmware(struct inv_mpu_state *st)
+{
+	int bank, write_size, size;
+	int result;
+	u16 memaddr;
+	u8 firmware[MPU_MEM_BANK_SIZE];
+	u8 *data;
+
+	data = st->firmware;
+	size = st->dmp_image_size - DMP_OFFSET;
+	memaddr = DMP_OFFSET;
+	data += DMP_OFFSET;
+	for (bank = 0; size > 0; bank++, size -= write_size) {
+		if (size > MAX_DMP_READ_SIZE)
+			write_size = MAX_DMP_READ_SIZE;
+		else
+			write_size = size;
+		result = mem_r(memaddr, write_size, firmware);
+		if (result)
+			return result;
+		if (0 != memcmp(firmware, data, write_size)) {
+			pr_err("load data error, bank=%d\n", bank);
+			pr_info("%s: varification, load data error bank %d\n",
+				__func__, bank);
+			return -EINVAL;
+		}
+		memaddr += write_size;
+		data += write_size;
+	}
+	return 0;
+}
+
+/*
+ * inv_firmware_load() -  calling this function will load the firmware.
+ */
+int inv_firmware_load(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result) {
+		pr_info("%s: load firmware set power error\n", __func__);
+		pr_err("load firmware set power error\n");
+		goto firmware_write_fail;
+	}
+	result = inv_stop_dmp(st);
+	if (result) {
+		pr_info("%s: load firmware : stop dmp error\n", __func__);
+		pr_err("load firmware:stop dmp error\n");
+		goto firmware_write_fail;
+	}
+	result = inv_load_firmware(st);
+	if (result) {
+		pr_info("%s: load firmware:load firmware error\n", __func__);
+		pr_err("load firmware:load firmware eror\n");
+		goto firmware_write_fail;
+	}
+	result = inv_verify_firmware(st);
+	if (result) {
+		pr_info("%s: load firmware:verify firmware error\n", __func__);
+		pr_err("load firmware:verify firmware error\n");
+		goto firmware_write_fail;
+	}
+	result = inv_setup_dmp_firmware(st);
+	if (result) {
+		pr_info("%s: load firmware:setup dmp error\n", __func__);
+		pr_err("load firmware:setup dmp error\n");
+	}
+firmware_write_fail:
+	result |= inv_set_power(st, false);
+	if (result) {
+		pr_info("%s: load firmware:shuting down power error\n",
+			__func__);
+		pr_err("load firmware:shuting down power error\n");
+		return result;
+	}
+
+	st->chip_config.firmware_loaded = 1;
+
+	pr_info("%s: load firmware successed\n", __func__);
+	return 0;
+}
+
+int inv_dmp_read(struct inv_mpu_state *st, int off, int size, u8 *buf)
+{
+	int read_size, i, result;
+	u16 addr;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+	inv_stop_dmp(st);
+
+	addr = off;
+	i = 0;
+	while (size > 0) {
+		if (addr % MAX_DMP_READ_SIZE)
+			read_size = MAX_DMP_READ_SIZE
+				- (addr % MAX_DMP_READ_SIZE);
+		else if (size > MAX_DMP_READ_SIZE)
+			read_size = MAX_DMP_READ_SIZE;
+		else
+			read_size = size;
+
+		result = mem_r(addr, read_size, &buf[i]);
+		if (result)
+			return result;
+
+		addr += read_size;
+		i += read_size;
+		size -= read_size;
+	}
+
+	return 0;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_parsing.c b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_parsing.c
new file mode 100644
index 000000000000..17b8ce29a684
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_parsing.c
@@ -0,0 +1,761 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/math64.h>
+
+#include "../inv_mpu_iio.h"
+
+static char iden[] = { 1, 0, 0, 0, 1, 0, 0, 0, 1 };
+
+static int inv_apply_soft_iron(struct inv_mpu_state *st, s16 *out_1, s32 *out_2)
+{
+	int *r, i, j;
+	s64 tmp;
+
+	r = st->final_compass_matrix;
+	for (i = 0; i < THREE_AXES; i++) {
+		tmp = 0;
+		for (j = 0; j < THREE_AXES; j++)
+			tmp  +=
+			(s64)r[i * THREE_AXES + j] * (((int)out_1[j]) << 16);
+		out_2[i] = (int)(tmp >> 30);
+	}
+
+	return 0;
+}
+
+static int inv_process_gyro(struct inv_mpu_state *st, u8 *d, u64 t)
+{
+	s16 raw[3];
+	s16 bias[3];
+	s32 calib[3];
+	int i;
+
+	for (i = 0; i < 3; i++)
+		raw[i] = be16_to_cpup((__be16 *) (d + i * 2));
+	for (i = 0; i < 3; i++)
+		bias[i] = be16_to_cpup((__be16 *) (d + i * 2 + 6));
+	for (i = 0; i < 3; i++) {
+		calib[i] = raw[i];
+		calib[i] <<= 15;
+		calib[i] -= (bias[i] << 10);
+	}
+	inv_push_gyro_data(st, raw, calib, t);
+
+	return 0;
+}
+static int inv_push_sensor(struct inv_mpu_state *st, int ind, u64 t, u8 *d)
+{
+	int i, res;
+	s16 out_1[3];
+	s32 out_2[3];
+	u16 accur;
+#ifdef ACCEL_BIAS_TEST
+	s16 acc[3], avg[3];
+#endif
+
+	res = 0;
+	switch (ind) {
+	case SENSOR_ACCEL:
+		inv_convert_and_push_8bytes(st, ind, d, t, iden);
+#ifdef ACCEL_BIAS_TEST
+		acc[0] = be16_to_cpup((__be16 *) (d));
+		acc[1] = be16_to_cpup((__be16 *) (d + 2));
+		acc[2] = be16_to_cpup((__be16 *) (d + 4));
+		if (inv_get_3axis_average(acc, avg, 0))
+			pr_debug("accel 200 samples average = %5d, %5d, %5d\n", avg[0], avg[1], avg[2]);
+#endif
+		break;
+	case SENSOR_GYRO:
+		inv_process_gyro(st, d, t);
+		break;
+	case SENSOR_COMPASS_CAL:
+		for (i = 0; i < 3; i++)
+			out_2[i] = be32_to_int(d + i * 4);
+
+		if ((out_2[0] == BAD_CAL_COMPASS_DATA) &&
+			(out_2[1] == BAD_CAL_COMPASS_DATA) &&
+			(out_2[2] == BAD_CAL_COMPASS_DATA)) {
+			pr_info("Bad cal compass\n");
+			return 0;
+		}
+		inv_convert_and_push_16bytes(st, ind, d, t,
+						st->plat_data.orientation);
+		/* raw sensor needs to be sent after calib sensor */
+		if (st->send_raw_compass) {
+			inv_push_16bytes_buffer(st, SENSOR_COMPASS,
+					st->sensor[SENSOR_COMPASS].ts,
+					st->raw_compass_data, 0);
+			st->send_raw_compass = false;
+		}
+		break;
+	case SENSOR_COMPASS:
+		st->send_raw_compass = true;
+		for (i = 0; i < 3; i++)
+			out_1[i] = be16_to_cpup((__be16 *) (d + i * 2));
+		/* bad compass handling */
+		if ((out_1[0] == BAD_COMPASS_DATA) &&
+			(out_1[1] == BAD_COMPASS_DATA) &&
+			(out_1[2] == BAD_COMPASS_DATA)) {
+			pr_info("Bad compass data\n");
+			return 0;
+		}
+		if (st->poke_mode_on) {
+			for (i = 0; i < 3; i++)
+				out_2[i] = out_1[i];
+			inv_push_16bytes_buffer(st, ind, t, out_2, 0);
+		} else {
+			inv_apply_soft_iron(st, out_1, out_2);
+			memcpy(st->raw_compass_data, out_2, 12);
+		}
+		break;
+	case SENSOR_ALS:
+		for (i = 0; i < 8; i++)
+			st->fifo_data[i] = d[i];
+		if (st->chip_config.has_als) {
+			res = st->slave_als->read_data(st, out_1);
+			inv_push_8bytes_buffer(st, ind, t, out_1);
+
+			return res;
+		}
+		break;
+	case SENSOR_SIXQ:
+		inv_convert_and_push_16bytes(st, ind, d, t, iden);
+		break;
+	case SENSOR_NINEQ:
+	case SENSOR_GEOMAG:
+		for (i = 0; i < 3; i++)
+			out_2[i] = be32_to_int(d + i * 4);
+		accur = be16_to_cpup((__be16 *)(d + 3 * 4));
+		inv_push_16bytes_buffer(st, ind, t, out_2, accur);
+		break;
+	case SENSOR_PEDQ:
+		inv_convert_and_push_8bytes(st, ind, d, t, iden);
+		break;
+	case SENSOR_PRESSURE:
+		for (i = 0; i < 6; i++)
+			st->fifo_data[i] = d[i];
+		if (st->chip_config.has_pressure) {
+			res = st->slave_pressure->read_data(st, out_1);
+			inv_push_8bytes_buffer(st, ind, t, out_1);
+		} else {
+			for (i = 0; i < 3; i++)
+				out_1[i] = be16_to_cpup((__be16 *) (d + i * 2));
+
+			inv_push_8bytes_buffer(st, ind, t, out_1);
+		}
+		break;
+	default:
+		break;
+	}
+
+	return res;
+}
+
+int inv_get_packet_size(struct inv_mpu_state *st, u16 hdr,
+			u32 *pk_size, u8 *dptr)
+{
+	int i, size;
+	u16 hdr2;
+
+	size = HEADER_SZ;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (hdr & st->sensor[i].output)
+			size += st->sensor[i].sample_size;
+	}
+	if (hdr & HEADER2_SET) {
+		size += HEADER2_SZ;
+		hdr2 = be16_to_cpup((__be16 *) (dptr + 2));
+
+		for (i = 0; i < SENSOR_ACCURACY_NUM_MAX; i++) {
+			if (hdr2 & st->sensor_accuracy[i].output)
+				size += st->sensor_accuracy[i].sample_size;
+		}
+
+		if (hdr2 & ACT_RECOG_SET) {
+			if (st->chip_config.activity_eng_on) {
+				size += ACT_RECOG_SZ;
+			} else {
+				pr_err("ERROR: activity should not be here\n");
+				return -EINVAL;
+			}
+		}
+		if (hdr2 & SECOND_SEN_OFF_SET) {
+			if (st->chip_config.activity_eng_on) {
+				size += SECOND_AUTO_OFF_SZ;
+			} else {
+				pr_err("ERROR: activity should not be here\n");
+				return -EINVAL;
+			}
+		}
+
+		if (hdr2 & FLIP_PICKUP_SET) {
+			if (st->chip_config.pick_up_enable)
+				size += FLIP_PICKUP_SZ;
+			else
+				pr_err("ERROR: pick up should not be here\n");
+		}
+
+		if (hdr2 & FSYNC_SET) {
+			if (st->chip_config.eis_enable)
+				size += FSYNC_SZ;
+			else
+				pr_err("ERROR: eis should not be here\n");
+		}
+	}
+	if ((!st->chip_config.step_indicator_on) && (hdr & PED_STEPIND_SET)) {
+		pr_err("ERROR: step inditor should not be here=%x\n", hdr);
+		return -EINVAL;
+	}
+	if (hdr & PED_STEPDET_SET) {
+		if (st->chip_config.step_detector_on) {
+			size += PED_STEPDET_TIMESTAMP_SZ;
+		} else {
+			pr_err("ERROR: step detector should not be here\n");
+			return -EINVAL;
+		}
+	}
+	size += FOOTER_SZ;
+	*pk_size = size;
+
+	return 0;
+}
+
+static int inv_push_accuracy(struct inv_mpu_state *st, int ind, u8 *d)
+{
+	struct iio_dev *indio_dev = iio_priv_to_dev(st);
+	u8 buf[IIO_BUFFER_BYTES];
+	u16 hdr, accur;
+
+	hdr = st->sensor_accuracy[ind].header;
+	accur = be16_to_cpup((__be16 *)(d));
+	if (st->sensor_acurracy_flag[ind]) {
+		if (!accur)
+			accur = DEFAULT_ACCURACY;
+		else
+			st->sensor_acurracy_flag[ind] = 0;
+	}
+	memcpy(buf, &hdr, sizeof(hdr));
+	memcpy(buf + sizeof(hdr), &accur, sizeof(accur));
+	iio_push_to_buffers(indio_dev, buf);
+
+	pr_debug("Accuracy for sensor [%d] is [%d]\n", ind, accur);
+
+	return 0;
+}
+/* this function parse the FIFO information and set the sensor on/off */
+static int inv_switch_secondary(struct inv_mpu_state *st, u8 *dptr)
+{
+	struct iio_dev *indio_dev = iio_priv_to_dev(st);
+	u16 data;
+	bool run_setup = false;
+
+	data = be16_to_cpup((__be16 *) (dptr));
+	switch (data) {
+	case SENCONDARY_GYRO_OFF:
+		st->secondary_gyro_on = 0;
+		run_setup = true;
+		break;
+	case SENCONDARY_GYRO_ON:
+		st->secondary_gyro_on = 1;
+		run_setup = true;
+		break;
+	case SENCONDARY_COMPASS_OFF:
+		st->secondary_mag_on = 0;
+		break;
+	case SENCONDARY_COMPASS_ON:
+		st->secondary_mag_on = 0;
+		break;
+	case SENCONDARY_PROX_OFF:
+		st->secondary_prox_on = 0;
+		if (st->chip_config.has_als)
+			run_setup = true;
+		break;
+	case SENCONDARY_PROX_ON:
+		st->secondary_prox_on = 1;
+		if (st->chip_config.has_als)
+			run_setup = true;
+		break;
+	default:
+		break;
+	}
+	if (run_setup) {
+		st->secondary_switch = true;
+		st->secondary_switch_data = data;
+
+		set_inv_enable(indio_dev);
+
+		st->secondary_switch = false;
+	}
+
+	return 0;
+}
+/* static int inv_set_fsync_trigger(struct inv_mpu_state *st)
+	while receiving a FSYNC trigger for the first time, we set
+	cycle mode into continuous mode and set the correponding filter
+	parameters.
+*/
+static int inv_set_fsync_trigger(struct inv_mpu_state *st)
+{
+	int res;
+
+	if (st->eis.eis_triggered)
+		return 0;
+	st->eis.eis_triggered = true;
+		return 0;
+	res = inv_plat_single_write(st, REG_LP_CONFIG, BIT_I2C_MST_CYCLE);
+	if (res)
+		return res;
+	res = inv_set_bank(st, BANK_SEL_2);
+	if (res)
+		return res;
+	res = inv_plat_single_write(st, REG_GYRO_CONFIG_1,
+					BIT_GYRO_DLPCFG_184Hz |
+					(st->chip_config.fsr
+					<< SHIFT_GYRO_FS_SEL) |
+					BIT_GYRO_FCHOICE);
+	res = inv_set_bank(st, BANK_SEL_0);
+	if (res)
+		return res;
+	st->eis.eis_triggered = true;
+
+	return 0;
+}
+
+static void inv_calc_gyro_shift(struct inv_mpu_state *st, u16 tmp)
+{
+	int counter_1k[] = {3, 2, 1, 0, 4};
+	int gyro_9k_counter, gyro_1k_counter;
+
+#define GYRO_1K_DUR       (890 * 1000)
+#define GYRO_9K_DUR       (110 * 1000)
+
+	gyro_9k_counter = ((tmp >> 12) & 7);
+	gyro_1k_counter = (tmp & 0xfff);
+	if (gyro_1k_counter > 4)
+		gyro_1k_counter = 4;
+	st->ts_algo.gyro_ts_shift = counter_1k[gyro_1k_counter] * GYRO_1K_DUR +
+				gyro_9k_counter * GYRO_9K_DUR;
+	pr_debug("shif= %d, tmp= %x\n", st->ts_algo.gyro_ts_shift, tmp);
+}
+
+int inv_parse_packet(struct inv_mpu_state *st, u16 hdr, u8 *dptr)
+{
+	struct iio_dev *indio_dev = iio_priv_to_dev(st);
+	int i;
+	s16 s[3];
+	u64 t;
+	u16 hdr2 = 0;
+	bool data_header;
+	u8 *d_tmp;
+	u16 delay;
+	u16 tmp;
+
+	t = 0;
+	if (hdr & HEADER2_SET) {
+		hdr2 = be16_to_cpup((__be16 *) (dptr));
+		dptr += HEADER2_SZ;
+	}
+
+	st->eis.eis_frame = false;
+	if (hdr & GYRO_SET)
+		st->eis.gyro_counter++;
+	if (hdr2 & FSYNC_SET) {
+		d_tmp = dptr;
+		for (i = 0; i < SENSOR_NUM_MAX; i++) {
+			if (hdr & st->sensor[i].output)
+				dptr += st->sensor[i].sample_size;
+		}
+		inv_set_fsync_trigger(st);
+		st->eis.frame_count++;
+		st->eis.eis_frame = true;
+		delay = be16_to_cpup((__be16 *) (dptr));
+		inv_process_eis(st, delay);
+
+		dptr = d_tmp;
+	}
+
+	data_header = false;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (hdr & st->sensor[i].output) {
+			inv_get_dmp_ts(st, i);
+			if (!st->ts_algo.first_sample) {
+				st->sensor[i].sample_calib++;
+				inv_push_sensor(st, i, st->sensor[i].ts, dptr);
+			}
+			dptr += st->sensor[i].sample_size;
+			t = st->sensor[i].ts;
+			data_header = true;
+		}
+	}
+	if (st->ts_algo.first_sample)
+		st->ts_algo.first_sample--;
+
+	if (data_header)
+		st->header_count--;
+	if (hdr & PED_STEPDET_SET) {
+		inv_process_step_det(st, dptr);
+		dptr += PED_STEPDET_TIMESTAMP_SZ;
+		st->step_det_count--;
+	}
+
+	if (hdr & PED_STEPIND_SET)
+		inv_push_step_indicator(st, t);
+	/* if hdr2 is not zero, it contains information and needs parsing */
+	if (hdr2) {
+		if (hdr2 & ACT_RECOG_SET) {
+			t = st->ts_algo.last_run_time;
+			s[0] = be16_to_cpup((__be16 *) (dptr));
+			s[1] = 0;
+			s[2] = 0;
+			inv_push_8bytes_kf(st, ACTIVITY_HDR, t, s);
+			dptr += ACT_RECOG_SZ;
+		}
+
+		if (hdr2 & SECOND_SEN_OFF_SET) {
+			inv_switch_secondary(st, dptr);
+			dptr += SECOND_AUTO_OFF_SZ;
+		}
+		if (hdr2 & FSYNC_SET)
+			dptr += FSYNC_SZ;
+
+		if (hdr2 & FLIP_PICKUP_SET) {
+			sysfs_notify(&indio_dev->dev.kobj, NULL,
+				     "poll_pick_up");
+			dptr += FLIP_PICKUP_SZ;
+			st->chip_config.pick_up_enable = 0;
+			inv_check_sensor_on(st);
+			set_inv_enable(indio_dev);
+			st->wake_sensor_received = true;
+			pr_debug("Pick up detected\n");
+		}
+
+		/* Implemented for Sensor accuracy */
+		for (i = 0; i < SENSOR_ACCURACY_NUM_MAX; i++) {
+			if (hdr2 & st->sensor_accuracy[i].output) {
+				inv_push_accuracy(st, i, dptr);
+				dptr += st->sensor_accuracy[i].sample_size;
+			}
+		}
+	}
+	tmp = be16_to_cpup((__be16 *) (dptr));
+	inv_calc_gyro_shift(st, tmp);
+
+	return 0;
+}
+
+int inv_pre_parse_packet(struct inv_mpu_state *st, u16 hdr, u8 *dptr)
+{
+	int i;
+	u16 hdr2 = 0;
+	bool data_header;
+
+	if (hdr & HEADER2_SET) {
+		hdr2 = be16_to_cpup((__be16 *) (dptr));
+		dptr += HEADER2_SZ;
+	}
+
+	data_header = false;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (hdr & st->sensor[i].output) {
+			st->sensor[i].count++;
+			dptr += st->sensor[i].sample_size;
+			data_header = true;
+		}
+	}
+	if (data_header)
+		st->header_count++;
+	if (hdr & PED_STEPDET_SET) {
+		st->step_det_count++;
+		dptr += PED_STEPDET_TIMESTAMP_SZ;
+	}
+	if (hdr2) {
+		if (hdr2 & ACT_RECOG_SET)
+			dptr += ACT_RECOG_SZ;
+
+		if (hdr2 & SECOND_SEN_OFF_SET)
+			dptr += SECOND_AUTO_OFF_SZ;
+
+		if (hdr2 & FLIP_PICKUP_SET)
+			dptr += FLIP_PICKUP_SZ;
+		if (hdr2 & FSYNC_SET)
+			dptr += FSYNC_SZ;
+		for (i = 0; i < SENSOR_ACCURACY_NUM_MAX; i++) {
+			if (hdr2 & st->sensor_accuracy[i].output)
+				dptr += st->sensor_accuracy[i].sample_size;
+		}
+	}
+
+	return 0;
+}
+
+static int inv_get_gyro_bias(struct inv_mpu_state *st, int *bias)
+{
+	int b_addr[] = { GYRO_BIAS_X, GYRO_BIAS_Y, GYRO_BIAS_Z };
+	int i, r;
+
+	for (i = 0; i < THREE_AXES; i++) {
+		r = read_be32_from_mem(st, &bias[i], b_addr[i]);
+		if (r)
+			return r;
+	}
+
+	return 0;
+}
+
+static int inv_process_temp_comp(struct inv_mpu_state *st)
+{
+	u8 d[2];
+	int r, l1, scale_t, curr_temp, i;
+	s16 temp;
+	s64 tmp, recp;
+	bool update_slope;
+	struct inv_temp_comp *t_c;
+	int s_addr[] = { GYRO_SLOPE_X, GYRO_SLOPE_Y, GYRO_SLOPE_Z };
+
+#define TEMP_COMP_WIDTH  4
+#define TEMP_COMP_MID_L  (12 + TEMP_COMP_WIDTH)
+#define TEMP_COMP_MID_H  (32 + TEMP_COMP_WIDTH)
+
+	if (st->ts_algo.last_run_time - st->last_temp_comp_time < (NSEC_PER_SEC >> 1))
+		return 0;
+	st->last_temp_comp_time = st->ts_algo.last_run_time;
+	if ((!st->gyro_cal_enable) ||
+		(!st->chip_config.gyro_enable) || (!st->chip_config.accel_enable))
+		return 0;
+	r = inv_plat_read(st, REG_TEMPERATURE, 2, d);
+	if (r)
+		return r;
+	temp = (s16) (be16_to_cpup((short *)d));
+	scale_t = TEMPERATURE_OFFSET +
+		inv_q30_mult((int)temp << MPU_TEMP_SHIFT, TEMPERATURE_SCALE);
+	curr_temp = (scale_t >> MPU_TEMP_SHIFT);
+
+	update_slope = false;
+	/* check the lower part of the temperature */
+	l1 = abs(curr_temp - TEMP_COMP_MID_L);
+	l1 = l1 - TEMP_COMP_WIDTH;
+	l1 = l1 - TEMP_COMP_WIDTH;
+	t_c = &st->temp_comp;
+	if (l1 < 0) {
+		t_c->t_lo = temp;
+		r = inv_get_gyro_bias(st, t_c->b_lo);
+		if (r)
+			return r;
+		t_c->has_low = true;
+		update_slope = true;
+	}
+
+	l1 = abs(curr_temp - TEMP_COMP_MID_H);
+	l1 = l1 - TEMP_COMP_WIDTH;
+	l1 = l1 - TEMP_COMP_WIDTH;
+	if (l1 < 0) {
+		t_c->t_hi = temp;
+		r = inv_get_gyro_bias(st, t_c->b_hi);
+		if (r)
+			return r;
+		t_c->has_high = true;
+		update_slope = true;
+	}
+	if (t_c->has_high && t_c->has_low && update_slope) {
+		if (t_c->t_hi != t_c->t_lo) {
+			recp = (1 << 30) / (t_c->t_hi - t_c->t_lo);
+			for (i = 0; i < THREE_AXES; i++) {
+				tmp = recp * (t_c->b_hi[i] - t_c->b_lo[i]);
+				t_c->slope[i] = (tmp >> 15);
+				r = write_be32_to_mem(st,
+					t_c->slope[i], s_addr[i]);
+				if (r)
+					return r;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int inv_process_dmp_interrupt(struct inv_mpu_state *st, u8 dmp_int_status)
+{
+	struct iio_dev *indio_dev = iio_priv_to_dev(st);
+	int result, step;
+
+#define DMP_INT_SMD  0x02
+#define DMP_INT_PED  0x04
+
+	if ((!st->smd.on) && (!st->ped.on))
+		return 0;
+
+	if (dmp_int_status & DMP_INT_SMD) {
+		pr_debug("Sinificant motion detected\n");
+		sysfs_notify(&indio_dev->dev.kobj, NULL, "poll_smd");
+		st->smd.on = false;
+		st->trigger_state = EVENT_TRIGGER;
+		inv_check_sensor_on(st);
+		set_inv_enable(indio_dev);
+		st->wake_sensor_received = true;
+	}
+
+	if (st->ped.int_on) {
+		if (dmp_int_status & DMP_INT_PED) {
+			if (st->ped.int_mode) {
+				result = inv_get_pedometer_steps(st, &step);
+				if (result) {
+					pr_info("Failed to read step count\n");
+					return result;
+				}
+				inv_send_steps(st, step, st->ts_algo.last_run_time);
+				st->prev_steps = step;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *  inv_read_fifo() - Transfer data from FIFO to ring buffer.
+ */
+irqreturn_t inv_read_fifo(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+	int i;
+	u8 d[1];
+
+#define DMP_INT_FIFO	0x01
+
+	result = wait_event_interruptible_timeout(st->wait_queue,
+					st->resume_state, msecs_to_jiffies(300));
+	if (result <= 0)
+		goto exit_handled;
+
+	mutex_lock(&indio_dev->mlock);
+
+	if (st->chip_config.is_asleep)
+		goto end_read_fifo;
+
+	inv_switch_power_in_lp(st, true);
+
+	result = inv_plat_read(st, REG_DMP_INT_STATUS, 1, d);
+	if (result) {
+		pr_info("REG_DMP_INT_STATUS result [%d]\n", result);
+		goto end_read_fifo;
+	}
+
+	st->ts_algo.last_run_time = get_time_ns();
+	st->wake_sensor_received = false;
+	st->activity_size = 0;
+
+	result = inv_process_dmp_interrupt(st, d[0]);
+	if (result)
+		goto end_read_fifo;
+
+	if (!(d[0] & DMP_INT_FIFO))
+		goto end_read_fifo;
+
+	result = inv_process_temp_comp(st);
+	if (result)
+		goto end_read_fifo;
+
+	result = inv_process_dmp_data(st);
+
+	if (st->activity_size > 0)
+		sysfs_notify(&indio_dev->dev.kobj, NULL, "poll_activity");
+	if (result)
+		goto err_reset_fifo;
+
+end_read_fifo:
+	inv_switch_power_in_lp(st, false);
+	mutex_unlock(&indio_dev->mlock);
+
+	/* set wake_sensor_received flag when streaming is enabled along with
+	 * any wakeup gesture sensor which is reported as FIFO data packet
+	 */
+	if (st->chip_config.tilt_enable || st->chip_config.pick_up_enable||
+			st->step_detector_wake_l_on) {
+		for (i = 0; i < SENSOR_NUM_MAX; i++) {
+			if (st->sensor[i].on) {
+				st->wake_sensor_received = true;
+				break;
+			}
+		}
+	}
+
+	if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+		wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+		__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+	goto exit_handled;
+
+err_reset_fifo:
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!st->chip_config.slave_enable) &&
+		(!st->chip_config.pressure_enable)) {
+		inv_switch_power_in_lp(st, false);
+		mutex_unlock(&indio_dev->mlock);
+		goto exit_handled;
+	}
+
+	pr_err("error to reset fifo\n");
+	inv_reset_fifo(st, true);
+	inv_switch_power_in_lp(st, false);
+	mutex_unlock(&indio_dev->mlock);
+
+exit_handled:
+	iio_trigger_notify_done(indio_dev->trig);
+	return IRQ_HANDLED;
+}
+
+int inv_flush_batch_data(struct iio_dev *indio_dev, int data)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result = 0;
+
+	if (st->chip_config.gyro_enable ||
+		st->chip_config.accel_enable ||
+		st->chip_config.slave_enable ||
+		st->chip_config.pressure_enable) {
+		inv_switch_power_in_lp(st, true);
+		st->wake_sensor_received = false;
+		if (inv_process_dmp_data(st))
+			pr_err("error on batch.. need reset fifo\n");
+		if (st->wake_sensor_received)
+#ifdef CONFIG_HAS_WAKELOCK
+			wake_lock_timeout(&st->wake_lock, msecs_to_jiffies(200));
+#else
+			__pm_wakeup_event(st->wake_lock, 200); /* 200 msecs */
+#endif
+		inv_switch_power_in_lp(st, false);
+	}
+	inv_push_marker_to_buffer(st, END_MARKER, data);
+
+	return result;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_selftest.c b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_selftest.c
new file mode 100644
index 000000000000..294628859707
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_selftest.c
@@ -0,0 +1,791 @@
+/*
+* Copyright (C) 2017-2017 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/* full scale and LPF setting */
+#define SELFTEST_GYRO_FS            ((0 << 3) | 1)
+#define SELFTEST_ACCEL_FS           ((7 << 3) | 1)
+
+/* register settings */
+#define SELFTEST_GYRO_SMPLRT_DIV        10
+#define SELFTEST_GYRO_AVGCFG            3
+#define SELFTEST_ACCEL_SMPLRT_DIV       10
+#define SELFTEST_ACCEL_DEC3_CFG         2
+
+#define DEF_SELFTEST_GYRO_SENS          (32768 / 250)
+/* wait time before collecting data */
+#define MAX_PACKETS                     20
+#define SELFTEST_WAIT_TIME              (MAX_PACKETS * 10)
+#define DEF_ST_STABLE_TIME              20
+#define DEF_GYRO_SCALE                  131
+#define DEF_ST_PRECISION                1000
+#define DEF_ST_ACCEL_FS_MG              2000UL
+#define DEF_ST_SCALE                    32768
+#define DEF_ST_TRY_TIMES                2
+#define DEF_ST_ACCEL_RESULT_SHIFT       1
+#define DEF_ST_COMPASS_RESULT_SHIFT     2
+#define DEF_ST_SAMPLES                  200
+
+#define DEF_ACCEL_ST_SHIFT_DELTA_MIN    500
+#define DEF_ACCEL_ST_SHIFT_DELTA_MAX    1500
+#define DEF_GYRO_CT_SHIFT_DELTA         500
+
+/* Gyro Offset Max Value (dps) */
+#define DEF_GYRO_OFFSET_MAX             20
+/* Gyro Self Test Absolute Limits ST_AL (dps) */
+#define DEF_GYRO_ST_AL                  60
+/* Accel Self Test Absolute Limits ST_AL (mg) */
+#define DEF_ACCEL_ST_AL_MIN             225
+#define DEF_ACCEL_ST_AL_MAX             675
+
+struct recover_regs {
+	/* Bank#0 */
+	u8 fifo_cfg;		/* REG_FIFO_CFG */
+	u8 user_ctrl;		/* REG_USER_CTRL */
+	u8 lp_config;		/* REG_LP_CONFIG */
+	u8 int_enable;		/* REG_INT_ENABLE */
+	u8 int_enable_1;	/* REG_INT_ENABLE_1 */
+	u8 fifo_en;		/* REG_FIFO_EN */
+	u8 fifo_en_2;		/* REG_FIFO_EN_2 */
+	u8 fifo_rst;		/* REG_FIFO_RST */
+
+	/* Bank#2 */
+	u8 gyro_smplrt_div;	/* REG_GYRO_SMPLRT_DIV */
+	u8 gyro_config_1;	/* REG_GYRO_CONFIG_1 */
+	u8 gyro_config_2;	/* REG_GYRO_CONFIG_2 */
+	u8 accel_smplrt_div_1;	/* REG_ACCEL_SMPLRT_DIV_1 */
+	u8 accel_smplrt_div_2;	/* REG_ACCEL_SMPLRT_DIV_2 */
+	u8 accel_config;	/* REG_ACCEL_CONFIG */
+	u8 accel_config_2;	/* REG_ACCEL_CONFIG_2 */
+};
+
+static struct recover_regs saved_regs;
+
+static const u16 mpu_st_tb[256] = {
+	2620, 2646, 2672, 2699, 2726, 2753, 2781, 2808,
+	2837, 2865, 2894, 2923, 2952, 2981, 3011, 3041,
+	3072, 3102, 3133, 3165, 3196, 3228, 3261, 3293,
+	3326, 3359, 3393, 3427, 3461, 3496, 3531, 3566,
+	3602, 3638, 3674, 3711, 3748, 3786, 3823, 3862,
+	3900, 3939, 3979, 4019, 4059, 4099, 4140, 4182,
+	4224, 4266, 4308, 4352, 4395, 4439, 4483, 4528,
+	4574, 4619, 4665, 4712, 4759, 4807, 4855, 4903,
+	4953, 5002, 5052, 5103, 5154, 5205, 5257, 5310,
+	5363, 5417, 5471, 5525, 5581, 5636, 5693, 5750,
+	5807, 5865, 5924, 5983, 6043, 6104, 6165, 6226,
+	6289, 6351, 6415, 6479, 6544, 6609, 6675, 6742,
+	6810, 6878, 6946, 7016, 7086, 7157, 7229, 7301,
+	7374, 7448, 7522, 7597, 7673, 7750, 7828, 7906,
+	7985, 8065, 8145, 8227, 8309, 8392, 8476, 8561,
+	8647, 8733, 8820, 8909, 8998, 9088, 9178, 9270,
+	9363, 9457, 9551, 9647, 9743, 9841, 9939, 10038,
+	10139, 10240, 10343, 10446, 10550, 10656, 10763, 10870,
+	10979, 11089, 11200, 11312, 11425, 11539, 11654, 11771,
+	11889, 12008, 12128, 12249, 12371, 12495, 12620, 12746,
+	12874, 13002, 13132, 13264, 13396, 13530, 13666, 13802,
+	13940, 14080, 14221, 14363, 14506, 14652, 14798, 14946,
+	15096, 15247, 15399, 15553, 15709, 15866, 16024, 16184,
+	16346, 16510, 16675, 16842, 17010, 17180, 17352, 17526,
+	17701, 17878, 18057, 18237, 18420, 18604, 18790, 18978,
+	19167, 19359, 19553, 19748, 19946, 20145, 20347, 20550,
+	20756, 20963, 21173, 21385, 21598, 21814, 22033, 22253,
+	22475, 22700, 22927, 23156, 23388, 23622, 23858, 24097,
+	24338, 24581, 24827, 25075, 25326, 25579, 25835, 26093,
+	26354, 26618, 26884, 27153, 27424, 27699, 27976, 28255,
+	28538, 28823, 29112, 29403, 29697, 29994, 30294, 30597,
+	30903, 31212, 31524, 31839, 32157, 32479, 32804
+};
+
+static void inv_show_saved_setting(struct inv_mpu_state *st)
+{
+	pr_debug(" REG_FIFO_CFG : 0x%02X\n", saved_regs.fifo_cfg);
+	pr_debug(" REG_USER_CTRL : 0x%02X\n", saved_regs.user_ctrl);
+	pr_debug(" REG_LP_CONFIG : 0x%02X\n", saved_regs.lp_config);
+	pr_debug(" REG_INT_ENABLE : 0x%02X\n", saved_regs.int_enable);
+	pr_debug(" REG_INT_ENABLE_1 : 0x%02X\n", saved_regs.int_enable_1);
+	pr_debug(" REG_FIFO_EN : 0x%02x\n", saved_regs.fifo_en);
+	pr_debug(" REG_FIFO_EN_2 : 0x%02x\n", saved_regs.fifo_en_2);
+	pr_debug(" REG_FIFO_RST : 0x%02x\n", saved_regs.fifo_rst);
+	if (st->chip_config.has_gyro) {
+		pr_debug(" REG_GYRO_SMPLRT_DIV : 0x%02x\n",
+			saved_regs.gyro_smplrt_div);
+		pr_debug(" REG_GYRO_CONFIG_1 : 0x%02x\n",
+			saved_regs.gyro_config_1);
+		pr_debug(" REG_GYRO_CONFIG_2 : 0x%02x\n",
+			saved_regs.gyro_config_2);
+	}
+	pr_debug(" REG_ACCEL_SMPLRT_DIV_1 : 0x%02x\n",
+		saved_regs.accel_smplrt_div_1);
+	pr_debug(" REG_ACCEL_SMPLRT_DIV_2 : 0x%02x\n",
+		saved_regs.accel_smplrt_div_2);
+	pr_debug(" REG_ACCEL_CONFIG : 0x%02x\n", saved_regs.accel_config);
+	pr_debug(" REG_ACCEL_CONFIG_2 : 0x%02x\n", saved_regs.accel_config_2);
+}
+
+static int inv_save_setting(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+
+	result = inv_plat_read(st, REG_FIFO_CFG, 1, &saved_regs.fifo_cfg);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_USER_CTRL, 1, &saved_regs.user_ctrl);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_LP_CONFIG, 1, &saved_regs.lp_config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_INT_ENABLE, 1, &saved_regs.int_enable);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_INT_ENABLE_1, 1,
+			       &saved_regs.int_enable_1);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_FIFO_EN, 1, &saved_regs.fifo_en);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_FIFO_EN_2, 1, &saved_regs.fifo_en_2);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_FIFO_RST, 1, &saved_regs.fifo_rst);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+
+	if (st->chip_config.has_gyro) {
+		result = inv_plat_read(st, REG_GYRO_SMPLRT_DIV, 1,
+				&saved_regs.gyro_smplrt_div);
+		if (result)
+			return result;
+		result = inv_plat_read(st, REG_GYRO_CONFIG_1, 1,
+				&saved_regs.gyro_config_1);
+		if (result)
+			return result;
+		result = inv_plat_read(st, REG_GYRO_CONFIG_2, 1,
+				&saved_regs.gyro_config_2);
+		if (result)
+			return result;
+	}
+
+	result = inv_plat_read(st, REG_ACCEL_SMPLRT_DIV_1, 1,
+			&saved_regs.accel_smplrt_div_1);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_SMPLRT_DIV_2, 1,
+			&saved_regs.accel_smplrt_div_2);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_CONFIG, 1,
+			&saved_regs.accel_config);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_ACCEL_CONFIG_2, 1,
+			&saved_regs.accel_config_2);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+
+	inv_show_saved_setting(st);
+
+	return result;
+}
+
+static int inv_recover_setting(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+
+	/* Stop sensors */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			BIT_PWR_PRESSURE_STBY |
+			BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+
+	/* Restore sensor configurations */
+	if (st->chip_config.has_gyro) {
+		result = inv_plat_single_write(st, REG_GYRO_SMPLRT_DIV,
+				saved_regs.gyro_smplrt_div);
+		if (result)
+			return result;
+		result = inv_plat_single_write(st, REG_GYRO_CONFIG_1,
+				saved_regs.gyro_config_1);
+		if (result)
+			return result;
+		result = inv_plat_single_write(st, REG_GYRO_CONFIG_2,
+				saved_regs.gyro_config_2);
+		if (result)
+			return result;
+	}
+
+	result = inv_plat_single_write(st, REG_ACCEL_SMPLRT_DIV_1,
+			saved_regs.accel_smplrt_div_1);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_SMPLRT_DIV_2,
+			saved_regs.accel_smplrt_div_2);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG,
+			saved_regs.accel_config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG_2,
+			saved_regs.accel_config_2);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+
+	/* Restore FIFO configurations */
+	result = inv_plat_single_write(st, REG_FIFO_CFG, saved_regs.fifo_cfg);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_LP_CONFIG, saved_regs.lp_config);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_INT_ENABLE,
+			saved_regs.int_enable);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_INT_ENABLE_1,
+			saved_regs.int_enable_1);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_FIFO_EN, saved_regs.fifo_en);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_FIFO_EN_2, saved_regs.fifo_en_2);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_FIFO_RST, MAX_5_BIT_VALUE);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_FIFO_RST, saved_regs.fifo_rst);
+	if (result)
+		return result;
+
+	/* Reset DMP */
+	result = inv_plat_single_write(st, REG_USER_CTRL,
+			(saved_regs.
+			user_ctrl & (~BIT_FIFO_EN)) |
+			BIT_DMP_RST);
+	if (result)
+		return result;
+	usleep_range(DMP_RESET_TIME, DMP_RESET_TIME + 100);
+
+	result = inv_set_power(st, false);
+	return result;
+}
+
+/**
+* inv_check_gyro_self_test() - check gyro self test. this function
+*                                   returns zero as success. A non-zero return
+*                                   value indicates failure in self test.
+*  @*st: main data structure.
+*  @*reg_avg: average value of normal test.
+*  @*st_avg:  average value of self test
+*/
+static int inv_check_gyro_self_test(struct inv_mpu_state *st,
+			int *reg_avg, int *st_avg)
+{
+	u8 *regs;
+	int ret_val;
+	int otp_value_zero = 0;
+	int st_shift_prod[3], st_shift_cust[3], i;
+
+	ret_val = 0;
+	regs = st->gyro_st_data;
+	pr_debug("self_test gyro shift_code - %02x %02x %02x\n",
+		regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			st_shift_prod[i] = mpu_st_tb[regs[i] - 1];
+		} else {
+			st_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	pr_debug("self_test gyro st_shift_prod - %+d %+d %+d\n",
+		st_shift_prod[0], st_shift_prod[1], st_shift_prod[2]);
+
+	for (i = 0; i < 3; i++) {
+		st_shift_cust[i] = st_avg[i] - reg_avg[i];
+		if (!otp_value_zero) {
+			/* Self Test Pass/Fail Criteria A */
+			if (st_shift_cust[i] < DEF_GYRO_CT_SHIFT_DELTA
+				* st_shift_prod[i])
+				ret_val = 1;
+		} else {
+			ret_val = 1;
+		}
+	}
+	pr_debug("self_test gyro st_shift_cust - %+d %+d %+d\n",
+		st_shift_cust[0], st_shift_cust[1], st_shift_cust[2]);
+
+	return ret_val;
+}
+
+/**
+* inv_check_accel_self_test() - check accel self test. this function
+*                                   returns zero as success. A non-zero return
+*                                   value indicates failure in self test.
+*  @*st: main data structure.
+*  @*reg_avg: average value of normal test.
+*  @*st_avg:  average value of self test
+*/
+static int inv_check_accel_self_test(struct inv_mpu_state *st,
+			int *reg_avg, int *st_avg)
+{
+	int ret_val;
+	int st_shift_prod[3], st_shift_cust[3], i;
+	u8 *regs;
+	int otp_value_zero = 0;
+
+#define ACCEL_ST_AL_MIN ((DEF_ACCEL_ST_AL_MIN * DEF_ST_SCALE \
+			/ DEF_ST_ACCEL_FS_MG) * DEF_ST_PRECISION)
+#define ACCEL_ST_AL_MAX ((DEF_ACCEL_ST_AL_MAX * DEF_ST_SCALE \
+			/ DEF_ST_ACCEL_FS_MG) * DEF_ST_PRECISION)
+
+	ret_val = 0;
+	regs = st->accel_st_data;
+	pr_debug("self_test accel shift_code - %02x %02x %02x\n",
+		 regs[0], regs[1], regs[2]);
+
+	for (i = 0; i < 3; i++) {
+		if (regs[i] != 0) {
+			st_shift_prod[i] = mpu_st_tb[regs[i] - 1];
+		} else {
+			st_shift_prod[i] = 0;
+			otp_value_zero = 1;
+		}
+	}
+	pr_debug("self_test accel st_shift_prod - %+d %+d %+d\n",
+		st_shift_prod[0], st_shift_prod[1], st_shift_prod[2]);
+	if (!otp_value_zero) {
+		/* Self Test Pass/Fail Criteria A */
+		for (i = 0; i < 3; i++) {
+			st_shift_cust[i] = st_avg[i] - reg_avg[i];
+			if (st_shift_cust[i] < DEF_ACCEL_ST_SHIFT_DELTA_MIN
+				* st_shift_prod[i])
+				ret_val = 1;
+			if (st_shift_cust[i] > DEF_ACCEL_ST_SHIFT_DELTA_MAX
+				* st_shift_prod[i])
+				ret_val = 1;
+		}
+	} else {
+		ret_val = 1;
+	}
+	pr_debug("self_test accel st_shift_cust - %+d %+d %+d\n",
+		st_shift_cust[0], st_shift_cust[1], st_shift_cust[2]);
+
+	return ret_val;
+}
+
+static int inv_setup_selftest(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+
+	/* Wake up */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_CLK_PLL);
+	if (result)
+		return result;
+
+	/* Save the current settings */
+	result = inv_save_setting(st);
+	if (result)
+		return result;
+
+	/* Stop sensors */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			BIT_PWR_PRESSURE_STBY |
+			BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	/* Enable FIFO */
+	result = inv_plat_single_write(st, REG_USER_CTRL,
+			BIT_FIFO_EN | st->i2c_dis);
+	if (result)
+		return result;
+
+	/* Set cycle mode */
+	result = inv_plat_single_write(st, REG_LP_CONFIG,
+			BIT_I2C_MST_CYCLE | BIT_ACCEL_CYCLE |
+			BIT_GYRO_CYCLE);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+
+	/* Configure FSR and DLPF */
+	if (st->chip_config.has_gyro) {
+		result = inv_plat_single_write(st, REG_GYRO_SMPLRT_DIV,
+				SELFTEST_GYRO_SMPLRT_DIV);
+		if (result)
+			return result;
+		result = inv_plat_single_write(st, REG_GYRO_CONFIG_1,
+				SELFTEST_GYRO_FS);
+		if (result)
+			return result;
+		result = inv_plat_single_write(st, REG_GYRO_CONFIG_2,
+				SELFTEST_GYRO_AVGCFG);
+		if (result)
+			return result;
+	}
+
+	result = inv_plat_single_write(st, REG_ACCEL_SMPLRT_DIV_1, 0);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_SMPLRT_DIV_2,
+			SELFTEST_ACCEL_SMPLRT_DIV);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG, SELFTEST_ACCEL_FS);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG_2,
+			SELFTEST_ACCEL_DEC3_CFG);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_1);
+	if (result)
+		return result;
+
+	/* Read selftest values */
+	if (st->chip_config.has_gyro) {
+		result = inv_plat_read(st, REG_SELF_TEST1, 1,
+			&st->gyro_st_data[0]);
+		if (result)
+			return result;
+		result = inv_plat_read(st, REG_SELF_TEST2, 1,
+			&st->gyro_st_data[1]);
+		if (result)
+			return result;
+		result = inv_plat_read(st, REG_SELF_TEST3, 1,
+			&st->gyro_st_data[2]);
+		if (result)
+			return result;
+	}
+
+	result = inv_plat_read(st, REG_SELF_TEST4, 1, &st->accel_st_data[0]);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_SELF_TEST5, 1, &st->accel_st_data[1]);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_SELF_TEST6, 1, &st->accel_st_data[2]);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	/* Restart sensors */
+	result = inv_plat_single_write(st, REG_PWR_MGMT_2,
+			BIT_PWR_PRESSURE_STBY);
+	if (result)
+		return result;
+	msleep(GYRO_ENGINE_UP_TIME);
+
+	return result;
+}
+
+static int inv_selftest_read_samples(struct inv_mpu_state *st, enum INV_SENSORS
+			type, int *sum_result, int *s)
+{
+	u8 w;
+	u16 fifo_count;
+	s16 vals[3];
+	u8 d[MAX_PACKETS * BYTES_PER_SENSOR];
+	int r, i, j, t, packet_count;
+
+	r = inv_plat_single_write(st, REG_FIFO_EN_2, 0);
+	if (r)
+		return r;
+
+	/* Reset FIFO */
+	r = inv_plat_single_write(st, REG_FIFO_RST, 0x1F);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_FIFO_RST, 0x1E);
+	if (r)
+		return r;
+
+	if (SENSOR_GYRO == type)
+		w = BITS_GYRO_FIFO_EN;
+	else
+		w = BIT_ACCEL_FIFO_EN;
+
+	while (*s < DEF_ST_SAMPLES) {
+		r = inv_plat_single_write(st, REG_FIFO_EN_2, w);
+		if (r)
+			return r;
+
+		msleep(SELFTEST_WAIT_TIME);
+
+		r = inv_plat_single_write(st, REG_FIFO_EN_2, 0);
+		if (r)
+			return r;
+
+		r = inv_plat_read(st, REG_FIFO_COUNT_H, FIFO_COUNT_BYTE, d);
+		if (r)
+			return r;
+		fifo_count = be16_to_cpup((__be16 *) (&d[0]));
+		pr_debug("self_test fifo_count - %d\n", fifo_count);
+		if (MAX_PACKETS * BYTES_PER_SENSOR < fifo_count) {
+			r = inv_plat_read(st, REG_FIFO_R_W,
+				MAX_PACKETS * BYTES_PER_SENSOR, d);
+			packet_count = MAX_PACKETS;
+		} else {
+			r = inv_plat_read(st, REG_FIFO_R_W, fifo_count, d);
+			packet_count = fifo_count / BYTES_PER_SENSOR;
+		}
+		if (r)
+			return r;
+
+		i = 0;
+		while (i < packet_count) {
+			for (j = 0; j < THREE_AXES; j++) {
+				t = 2 * j + i * BYTES_PER_SENSOR;
+				vals[j] =
+					(s16) be16_to_cpup((__be16 *) (&d[t]));
+				sum_result[j] += vals[j];
+			}
+			pr_debug("self_test data - %d %+d %+d %+d",
+				*s, vals[0], vals[1], vals[2]);
+			(*s)++;
+			i++;
+		}
+	}
+	return 0;
+}
+
+/*
+ *  inv_do_test_accel() - do the actual test of self testing
+ */
+static int inv_do_test_accel(struct inv_mpu_state *st, int *accel_result,
+			int *accel_st_result)
+{
+	int result, i, j;
+	int accel_s;
+	u8 w;
+
+	for (i = 0; i < THREE_AXES; i++) {
+		accel_result[i] = 0;
+		accel_st_result[i] = 0;
+	}
+
+	accel_s = 0;
+	result = inv_selftest_read_samples(st, SENSOR_ACCEL,
+			accel_result, &accel_s);
+	if (result)
+		return result;
+
+	for (j = 0; j < THREE_AXES; j++) {
+		accel_result[j] = accel_result[j] / accel_s;
+		accel_result[j] *= DEF_ST_PRECISION;
+	}
+
+	/* Set Self-Test Bit */
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+	w = BIT_ACCEL_CTEN | SELFTEST_ACCEL_DEC3_CFG;
+	result = inv_plat_single_write(st, REG_ACCEL_CONFIG_2, w);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+	msleep(DEF_ST_STABLE_TIME);
+
+	accel_s = 0;
+	result = inv_selftest_read_samples(st, SENSOR_ACCEL,
+			accel_st_result, &accel_s);
+	if (result)
+		return result;
+
+	for (j = 0; j < THREE_AXES; j++) {
+		accel_st_result[j] = accel_st_result[j] / accel_s;
+		accel_st_result[j] *= DEF_ST_PRECISION;
+	}
+
+	pr_debug("accel=%d, %d, %d\n", accel_result[0], accel_result[1],
+		accel_result[2]);
+
+	return 0;
+}
+
+/*
+ *  inv_do_test() - do the actual test of self testing
+ */
+static int inv_do_test_gyro(struct inv_mpu_state *st, int *gyro_result,
+			    int *gyro_st_result)
+{
+	int result, i, j;
+	int gyro_s;
+	u8 w;
+
+	for (i = 0; i < THREE_AXES; i++) {
+		gyro_result[i] = 0;
+		gyro_st_result[i] = 0;
+	}
+
+	gyro_s = 0;
+	result = inv_selftest_read_samples(st, SENSOR_GYRO,
+			gyro_result, &gyro_s);
+	if (result)
+		return result;
+
+	for (j = 0; j < THREE_AXES; j++) {
+		gyro_result[j] = gyro_result[j] / gyro_s;
+		gyro_result[j] *= DEF_ST_PRECISION;
+	}
+
+	/* Set Self-Test Bit */
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+	w = BIT_GYRO_CTEN | SELFTEST_GYRO_AVGCFG;
+	result = inv_plat_single_write(st, REG_GYRO_CONFIG_2, w);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+	msleep(DEF_ST_STABLE_TIME);
+
+	gyro_s = 0;
+	result = inv_selftest_read_samples(st, SENSOR_GYRO,
+			gyro_st_result, &gyro_s);
+	if (result)
+		return result;
+
+	for (j = 0; j < THREE_AXES; j++) {
+		gyro_st_result[j] = gyro_st_result[j] / gyro_s;
+		gyro_st_result[j] *= DEF_ST_PRECISION;
+	}
+
+	pr_debug("gyro=%d, %d, %d\n", gyro_result[0], gyro_result[1],
+		gyro_result[2]);
+
+	return 0;
+}
+
+/*
+ *  inv_hw_self_test() - main function to do hardware self test
+ */
+int inv_hw_self_test(struct inv_mpu_state *st)
+{
+	int result;
+	int gyro_bias_st[THREE_AXES], gyro_bias_regular[THREE_AXES];
+	int accel_bias_st[THREE_AXES], accel_bias_regular[THREE_AXES];
+	int test_times, i;
+	char accel_result, gyro_result, compass_result;
+
+	accel_result = 0;
+	gyro_result = 0;
+	compass_result = 0;
+
+	result = inv_setup_selftest(st);
+	if (result)
+		goto test_fail;
+
+	if (!st->chip_config.has_gyro) {
+		pr_debug("self_test skip gyro test\n");
+		goto accel_test;
+	}
+
+	/* gyro test */
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test_gyro(st, gyro_bias_regular, gyro_bias_st);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			test_times = 0;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("self_test gyro bias_regular - %+d %+d %+d\n",
+		gyro_bias_regular[0],
+		gyro_bias_regular[1], gyro_bias_regular[2]);
+	pr_debug("self_test gyro bias_st - %+d %+d %+d\n",
+		gyro_bias_st[0], gyro_bias_st[1], gyro_bias_st[2]);
+
+accel_test:
+	/* accel test */
+	test_times = DEF_ST_TRY_TIMES;
+	while (test_times > 0) {
+		result = inv_do_test_accel(st, accel_bias_regular,
+				accel_bias_st);
+		if (result == -EAGAIN)
+			test_times--;
+		else
+			break;
+	}
+	if (result)
+		goto test_fail;
+	pr_debug("self_test accel bias_regular - %+d %+d %+d\n",
+		accel_bias_regular[0],
+		accel_bias_regular[1], accel_bias_regular[2]);
+	pr_debug("self_test accel bias_st - %+d %+d %+d\n",
+		accel_bias_st[0], accel_bias_st[1], accel_bias_st[2]);
+
+	for (i = 0; i < 3; i++) {
+		st->gyro_st_bias[i] = gyro_bias_regular[i] / DEF_ST_PRECISION;
+		st->accel_st_bias[i] = accel_bias_regular[i] / DEF_ST_PRECISION;
+	}
+
+	accel_result = !inv_check_accel_self_test(st,
+				accel_bias_regular,
+				accel_bias_st);
+	if (st->chip_config.has_gyro) {
+		gyro_result = !inv_check_gyro_self_test(st,
+					gyro_bias_regular,
+					gyro_bias_st);
+	}
+	if (st->chip_config.has_compass)
+		compass_result = !st->slave_compass->self_test(st);
+
+test_fail:
+	inv_recover_setting(st);
+	return (compass_result << DEF_ST_COMPASS_RESULT_SHIFT) |
+		(accel_result << DEF_ST_ACCEL_RESULT_SHIFT) | gyro_result;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_setup.c b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_setup.c
new file mode 100644
index 000000000000..87be4099e2d7
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_mpu_setup.c
@@ -0,0 +1,1724 @@
+/*
+ * Copyright (C) 2017-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "../inv_mpu_iio.h"
+
+struct inv_local_store {
+	u8 reg_lp_config;
+	u8 reg_delay_enable;
+	u8 reg_delay_time;
+	u8 reg_gyro_smplrt;
+	bool wom_on;
+	bool activity_eng_on;
+	int accel_cal_ind;
+};
+
+static struct inv_local_store local;
+
+static int compass_cal_param[] = { 200, 70, 35, 15, 8, 4 };
+
+struct inv_accel_cal_params {
+	int freq;
+	int rate;
+	int bac_rate;
+	int gain;
+	int alpha;
+	int a;
+};
+
+static struct inv_accel_cal_params accel_cal_para[] = {
+	{
+		.freq = 1000,
+		},
+	{
+		.freq = 225,
+		.rate = 0,
+		.bac_rate = 3,
+		.gain = DEFAULT_ACCEL_GAIN,
+		.alpha = 1026019965,
+		.a = 47721859,
+		},
+	{
+		.freq = 112,
+		.gain = DEFAULT_ACCEL_GAIN_112,
+		.rate = 0,
+		.bac_rate = 1,
+		.alpha = 977872018,
+		.a = 95869806,
+	},
+	{
+		.freq = 56,
+		.gain = PED_ACCEL_GAIN,
+		.rate = 0,
+		.bac_rate = 0,
+		.alpha = 882002213,
+		.a = 191739611,
+		},
+	{
+		.freq = 15,
+		.gain = DEFAULT_ACCEL_GAIN,
+		.rate = 0,
+		.bac_rate = 0,
+		.alpha = 357913941,
+		.a = 715827883,
+	},
+	{
+		.freq = 5,
+		.gain = DEFAULT_ACCEL_GAIN,
+		.rate = 0,
+		.bac_rate = 0,
+		.alpha = 107374182,
+		.a = 966367642,
+	},
+};
+
+static int accel_gyro_rate[] = { 5, 6, 7, 8, 9, 10, 11, 12, 13,
+	14, 15, 17, 18, 22, 25, 28, 32, 37, 45,
+	56, 75, 112, 225
+};
+
+static int inv_set_batchmode(struct inv_mpu_state *st, bool enable)
+{
+	if (enable)
+		st->cntl2 |= BATCH_MODE_EN;
+
+	return 0;
+}
+
+static int inv_calc_engine_dur(struct inv_engine_info *ei)
+{
+	if (!ei->running_rate)
+		return -EINVAL;
+	ei->dur = ei->base_time / ei->orig_rate;
+	ei->dur *= ei->divider;
+
+	return 0;
+}
+
+static int inv_batchmode_calc(struct inv_mpu_state *st)
+{
+	int b, timeout;
+	int i, bps;
+	enum INV_ENGINE eng;
+
+	bps = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			bps += (st->sensor[i].sample_size + 2) *
+				st->sensor[i].rate;
+		}
+	}
+	if (bps) {
+		b = st->batch.timeout * bps;
+		if ((b > (FIFO_SIZE * MSEC_PER_SEC)) &&
+			(!st->batch.overflow_on))
+			timeout = FIFO_SIZE * MSEC_PER_SEC / bps;
+		else
+			timeout = st->batch.timeout;
+	} else {
+		if (st->chip_config.step_detector_on ||
+			st->step_counter_l_on ||
+			st->step_counter_wake_l_on ||
+			st->chip_config.activity_eng_on) {
+			timeout = st->batch.timeout;
+		} else {
+			return -EINVAL;
+		}
+	}
+	if (st->chip_config.gyro_enable)
+		eng = ENGINE_GYRO;
+	else if (st->chip_config.accel_enable)
+		eng = ENGINE_ACCEL;
+	else
+		eng = ENGINE_I2C;
+	b = st->eng_info[eng].dur / USEC_PER_MSEC;
+	st->batch.engine_base = eng;
+	st->batch.counter = timeout * USEC_PER_MSEC / b;
+
+	if (st->batch.counter)
+		st->batch.on = true;
+
+	return 0;
+}
+
+static int inv_set_default_batch(struct inv_mpu_state *st)
+{
+	if (st->batch.max_rate > DEFAULT_BATCH_RATE) {
+		st->batch.default_on = true;
+		st->batch.counter = DEFAULT_BATCH_TIME * NSEC_PER_MSEC /
+			st->eng_info[ENGINE_GYRO].dur;
+	}
+
+	return 0;
+}
+
+int inv_batchmode_setup(struct inv_mpu_state *st)
+{
+	int r;
+	bool on;
+	s16 mask[ENGINE_NUM_MAX] = { 1, 2, 8, 8 };
+
+	st->batch.on = false;
+	st->batch.default_on = false;
+	if (st->batch.timeout > 0) {
+		r = inv_batchmode_calc(st);
+		if (r)
+			return r;
+	} else {
+		r = inv_set_default_batch(st);
+		if (r)
+			return r;
+	}
+
+	on = (st->batch.on || st->batch.default_on);
+
+	if (on) {
+		r = write_be32_to_mem(st, 0, BM_BATCH_CNTR);
+		if (r)
+			return r;
+		r = write_be32_to_mem(st, st->batch.counter, BM_BATCH_THLD);
+		if (r)
+			return r;
+		r = inv_write_2bytes(st, BM_BATCH_MASK,
+				mask[st->batch.engine_base]);
+		if (r)
+			return r;
+		r = inv_write_2bytes(st, FIFO_WATERMARK, FIFO_SIZE);
+		if (r)
+			return r;
+	} else {
+		/* disable FIFO WM interrupt */
+		r = inv_write_2bytes(st, FIFO_WATERMARK, HARDWARE_FIFO_SIZE);
+		if (r)
+			return r;
+	}
+
+	r = inv_set_batchmode(st, on);
+
+	return r;
+}
+
+static int inv_turn_on_fifo(struct inv_mpu_state *st)
+{
+	u8 w, x;
+	int r;
+
+	/* clear FIFO data */
+	r = inv_plat_single_write(st, REG_FIFO_RST, MAX_5_BIT_VALUE);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_FIFO_RST, MAX_5_BIT_VALUE - 1);
+	if (r)
+		return r;
+	w = 0;
+	x = 0;
+	r = inv_plat_single_write(st, REG_FIFO_EN_2, 0);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_FIFO_EN, 0);
+	if (r)
+		return r;
+
+	/* turn on user ctrl register */
+	w = BIT_DMP_RST;
+	r = inv_plat_single_write(st, REG_USER_CTRL, w | st->i2c_dis);
+	if (r)
+		return r;
+	usleep_range(DMP_RESET_TIME, DMP_RESET_TIME + 100);
+
+	/* turn on interrupt */
+	w = BIT_DMP_INT_EN;
+	r = inv_plat_single_write(st, REG_INT_ENABLE, w);
+	if (r)
+		return r;
+
+	w = BIT_FIFO_EN;
+	w |= BIT_DMP_EN;
+	if (st->chip_config.slave_enable && (!st->poke_mode_on))
+		w |= BIT_I2C_MST_EN;
+	r = inv_plat_single_write(st, REG_USER_CTRL, w | st->i2c_dis);
+
+	return r;
+}
+
+/*
+ *  inv_reset_fifo() - Reset FIFO related registers.
+ */
+int inv_reset_fifo(struct inv_mpu_state *st, bool turn_off)
+{
+	int r, i;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+	int max_rate = 0;
+
+	r = inv_turn_on_fifo(st);
+	if (r)
+		return r;
+
+	ts_algo->last_run_time = get_time_ns();
+	ts_algo->reset_ts = ts_algo->last_run_time;
+
+	/* Drop first some samples for better timestamping.
+	 * The number depends on the frequency not to make
+	 * large latency for the first sample at application.
+	 */
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			max_rate = max(st->sensor[i].rate, max_rate);
+	}
+	if (max_rate < 5)
+		ts_algo->first_sample = 0;
+	else if (max_rate < 100)
+		ts_algo->first_sample = 1;
+	else
+		ts_algo->first_sample = 2;
+
+	st->last_temp_comp_time = ts_algo->last_run_time;
+	st->left_over_size = 0;
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		st->sensor[i].calib_flag = 0;
+		st->sensor[i].time_calib = ts_algo->last_run_time;
+	}
+
+	ts_algo->calib_counter = 0;
+
+	return 0;
+}
+
+static int inv_turn_on_engine(struct inv_mpu_state *st)
+{
+	u8 w;
+	int r;
+
+	if ((st->chip_config.gyro_enable | st->chip_config.accel_enable)
+		&& (!st->poke_mode_on)) {
+		w = BIT_PWR_PRESSURE_STBY;
+		if (!st->chip_config.gyro_enable)
+			w |= BIT_PWR_GYRO_STBY;
+		if (!st->chip_config.accel_enable)
+			w |= BIT_PWR_ACCEL_STBY;
+	} else {
+		w = (BIT_PWR_GYRO_STBY |
+			BIT_PWR_ACCEL_STBY | BIT_PWR_PRESSURE_STBY);
+	}
+	r = inv_plat_single_write(st, REG_PWR_MGMT_2, w);
+	if (r)
+		return r;
+	if ((!st->chip_config.eis_enable) || (!st->eis.eis_triggered)) {
+		/* secondary cycle mode should be set all the time */
+		r = inv_plat_single_write(st, REG_LP_CONFIG, BIT_I2C_MST_CYCLE |
+							BIT_ACCEL_CYCLE |
+							BIT_GYRO_CYCLE);
+		if (r)
+			return r;
+		inv_set_gyro_sf(st);
+	}
+	inv_set_bank(st, BANK_SEL_2);
+	inv_plat_single_write(st, REG_ODR_ALIGN_EN, BIT_ODR_ALIGN_EN);
+	inv_set_bank(st, BANK_SEL_0);
+	if (st->chip_config.has_compass) {
+		if (st->chip_config.compass_enable)
+			r = st->slave_compass->resume(st);
+		else
+			r = st->slave_compass->suspend(st);
+		if (r)
+			return r;
+	}
+	if (st->chip_config.has_als) {
+		if (st->chip_config.als_enable)
+			r = st->slave_als->resume(st);
+		else
+			r = st->slave_als->suspend(st);
+		if (r)
+			return r;
+	}
+	if (st->chip_config.has_pressure) {
+		if (st->chip_config.pressure_enable)
+			r = st->slave_pressure->resume(st);
+		else
+			r = st->slave_pressure->suspend(st);
+		if (r)
+			return r;
+	}
+
+	/* secondary cycle mode should be set all the time */
+	w = BIT_I2C_MST_CYCLE;
+	if (st->chip_config.low_power_gyro_on)
+		w |= BIT_GYRO_CYCLE;
+	w |= BIT_ACCEL_CYCLE;
+	if (w != local.reg_lp_config) {
+		r = inv_plat_single_write(st, REG_LP_CONFIG, w);
+		if (r)
+			return r;
+		local.reg_lp_config = w;
+	}
+
+	return 0;
+}
+
+static int inv_setup_dmp_rate(struct inv_mpu_state *st)
+{
+	int i, result;
+	int div[SENSOR_NUM_MAX];
+	bool d_flag;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			if (!st->sensor[i].rate) {
+				pr_err("sensor %d rate is zero\n", i);
+				return -EINVAL;
+			}
+			pr_info(
+			"[Before]sensor %d rate [%d], running_rate %d\n",
+			i, st->sensor[i].rate,
+			st->eng_info[st->sensor[i].engine_base].running_rate);
+
+			div[i] =
+				st->eng_info[st->sensor[i].engine_base].
+				running_rate / st->sensor[i].rate;
+			if (!div[i])
+				div[i] = 1;
+			if (SENSOR_PRESSURE == i) {
+				if (st->eng_info[st->sensor[i].engine_base].running_rate
+						* 100 / div[i] > MAX_PRESSURE_RATE * 150)
+					div[i]++;
+			}
+			st->sensor[i].rate = st->eng_info
+				[st->sensor[i].engine_base].running_rate / div[i];
+
+			pr_info(
+			"sensor %d rate [%d] div [%d] running_rate [%d]\n",
+				i, st->sensor[i].rate, div[i],
+			st->eng_info[st->sensor[i].engine_base].running_rate);
+		}
+	}
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			st->cntl |= st->sensor[i].output;
+			st->sensor[i].dur =
+				st->eng_info[st->sensor[i].engine_base].dur *
+				div[i];
+			st->sensor[i].div = div[i];
+			pr_info("sensor %d div [%d] odr_addr [%02X] cntl [%04X]\n",
+				i, div[i], st->sensor[i].odr_addr, st->cntl);
+			result = inv_write_2bytes(st,
+					st->sensor[i].odr_addr, div[i] - 1);
+			if (result)
+				return result;
+			/* reset all data counter */
+			result = inv_write_2bytes(st,
+					st->sensor[i].counter_addr, 0);
+			if (result)
+				return result;
+		}
+	}
+
+	d_flag = 0;
+	for (i = 0; i < SENSOR_ACCURACY_NUM_MAX; i++) {
+		if (st->sensor_accuracy[i].on)
+			st->cntl2 |= st->sensor_accuracy[i].output;
+		d_flag |= st->sensor_accuracy[i].on;
+	}
+	d_flag |= st->chip_config.activity_eng_on;
+	d_flag |= st->chip_config.pick_up_enable;
+	d_flag |= st->chip_config.eis_enable;
+	if (d_flag)
+		st->cntl |= HEADER2_SET;
+
+	if (st->chip_config.step_indicator_on)
+		st->cntl |= PED_STEPIND_SET;
+	if (st->chip_config.step_detector_on)
+		st->cntl |= PED_STEPDET_SET;
+	if (st->chip_config.activity_eng_on) {
+		st->cntl2 |= ACT_RECOG_SET;
+		st->cntl2 |= SECOND_SEN_OFF_SET;
+	}
+	if (st->chip_config.pick_up_enable)
+		st->cntl2 |= FLIP_PICKUP_SET;
+
+	if (st->chip_config.eis_enable)
+		st->cntl2 |= FSYNC_SET;
+
+	if (!st->chip_config.dmp_event_int_on) {
+		result = inv_batchmode_setup(st);
+		if (result)
+			return result;
+	} else {
+		st->batch.on = false;
+	}
+
+	return 0;
+}
+
+static int inv_set_div(struct inv_mpu_state *st, int a_d, int g_d)
+{
+	int result;
+
+	result = inv_set_bank(st, BANK_SEL_2);
+	if (result)
+		return result;
+
+	if (st->chip_config.eis_enable)
+		inv_plat_single_write(st, REG_FSYNC_CONFIG, BIT_TRIGGER_EIS);
+	else
+		inv_plat_single_write(st, REG_FSYNC_CONFIG, 0);
+
+	if (local.reg_gyro_smplrt != g_d) {
+		result = inv_plat_single_write(st, REG_GYRO_SMPLRT_DIV, g_d);
+		if (result)
+			return result;
+		local.reg_gyro_smplrt = g_d;
+	}
+	result = inv_plat_single_write(st, REG_ACCEL_SMPLRT_DIV_2, a_d);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+static int inv_set_rate(struct inv_mpu_state *st)
+{
+	int g_d, a_d, result;
+
+	result = inv_setup_dmp_rate(st);
+	if (result)
+		return result;
+
+	g_d = st->eng_info[ENGINE_GYRO].divider - 1;
+	a_d = st->eng_info[ENGINE_ACCEL].divider - 1;
+	result = inv_set_div(st, a_d, g_d);
+
+	return result;
+}
+
+static int inv_set_fifo_size(struct inv_mpu_state *st)
+{
+	int result;
+	u8 cfg;
+
+	/* use one FIFO in DMP mode */
+	cfg = BIT_SINGLE_FIFO_CFG;
+	result = inv_plat_single_write(st, REG_FIFO_CFG, cfg);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+/*
+ *  inv_set_fake_secondary() - set fake secondary I2C such that
+ *                           I2C data in the same position.
+ */
+static int inv_set_fake_secondary(struct inv_mpu_state *st)
+{
+	int r;
+	u8 bytes, ind;
+
+	/* may need to saturate the master I2C counter like Scorpion did */
+	r = inv_set_bank(st, BANK_SEL_3);
+	if (r)
+		return r;
+	if (st->sec_set.delay_enable != local.reg_delay_enable) {
+		r = inv_plat_single_write(st, REG_I2C_MST_DELAY_CTRL,
+				st->sec_set.delay_enable);
+		if (r)
+			return r;
+		local.reg_delay_enable = st->sec_set.delay_enable;
+	}
+	if (st->sec_set.delay_time != local.reg_delay_time) {
+		r = inv_plat_single_write(st, REG_I2C_SLV4_CTRL,
+				st->sec_set.delay_time);
+		if (r)
+			return r;
+		local.reg_delay_time = st->sec_set.delay_time;
+	}
+	/* odr config is changed during slave setup */
+	r = inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG,
+			st->sec_set.odr_config);
+	if (r)
+		return r;
+	r = inv_set_bank(st, BANK_SEL_0);
+	if (r)
+		return r;
+
+	/*111, 110 */
+	if (st->chip_config.compass_enable && st->chip_config.als_enable)
+		return 0;
+	/* 100 */
+	if (st->chip_config.compass_enable &&
+		(!st->chip_config.als_enable) && (!st->chip_config.pressure_enable))
+		return 0;
+	r = inv_set_bank(st, BANK_SEL_3);
+	if (r)
+		return r;
+
+	if (st->chip_config.pressure_enable) {
+		/* 001 */
+		if ((!st->chip_config.compass_enable) &&
+			(!st->chip_config.als_enable)) {
+			r = inv_read_secondary(st, 0,
+				st->plat_data.aux_i2c_addr,
+				BMP280_DIG_T1_LSB_REG,
+				DATA_AKM_99_BYTES_DMP);
+			if (r)
+				return r;
+			r = inv_read_secondary(st, 2,
+				st->plat_data.aux_i2c_addr,
+				BMP280_DIG_T1_LSB_REG,
+				DATA_ALS_BYTES_DMP);
+			r = inv_set_bank(st, BANK_SEL_0);
+
+			return r;
+		}
+
+		if (st->chip_config.compass_enable &&
+			(!st->chip_config.als_enable)) {
+			/* 101 */
+			ind = 2;
+			if ((COMPASS_ID_AK09911 ==
+				st->plat_data.sec_slave_id) ||
+				(COMPASS_ID_AK09912 ==
+				st->plat_data.sec_slave_id) ||
+				(COMPASS_ID_AK09916 == st->plat_data.sec_slave_id))
+				bytes = DATA_ALS_BYTES_DMP;
+			else
+				bytes = DATA_ALS_BYTES_DMP +
+				DATA_AKM_99_BYTES_DMP -
+				DATA_AKM_89_BYTES_DMP;
+		} else {	/* 011 */
+			ind = 0;
+			bytes = DATA_AKM_99_BYTES_DMP;
+		}
+		r = inv_read_secondary(st, ind, st->plat_data.aux_i2c_addr,
+			BMP280_DIG_T1_LSB_REG, bytes);
+	} else {/* compass disabled; als enabled, pressure disabled 010 */
+		r = inv_read_secondary(st, 0, st->plat_data.read_only_i2c_addr,
+			APDS9900_AILTL_REG,
+			DATA_AKM_99_BYTES_DMP);
+	}
+	if (r)
+		return r;
+	r = inv_set_bank(st, BANK_SEL_0);
+
+	return r;
+}
+
+static int inv_set_ICM20628_secondary(struct inv_mpu_state *st)
+{
+	int rate, compass_rate, pressure_rate, als_rate, min_rate, base;
+	int mst_odr_config, d, delay;
+
+	if (st->chip_config.compass_enable)
+		compass_rate = st->chip_config.compass_rate;
+	else
+		compass_rate = 0;
+	if (st->chip_config.pressure_enable)
+		pressure_rate = st->sensor[SENSOR_PRESSURE].rate;
+	else
+		pressure_rate = 0;
+	if (st->chip_config.als_enable)
+		als_rate = max(st->sensor[SENSOR_ALS].rate,
+			       MPU_INIT_SENSOR_RATE);
+	else
+		als_rate = 0;
+	if (compass_rate)
+		rate = compass_rate;
+	else
+		rate = max(pressure_rate, als_rate);
+	mst_odr_config = 0;
+	min_rate = BASE_SAMPLE_RATE;
+	while (rate < min_rate) {
+		mst_odr_config++;
+		min_rate >>= 1;
+	}
+	base = BASE_SAMPLE_RATE / (1 << mst_odr_config);
+	if (base < rate) {
+		mst_odr_config--;
+		base = BASE_SAMPLE_RATE / (1 << mst_odr_config);
+	}
+	if (mst_odr_config < MIN_MST_ODR_CONFIG)
+		mst_odr_config = MIN_MST_ODR_CONFIG;
+	if (compass_rate) {
+		if (mst_odr_config > MAX_MST_ODR_CONFIG)
+			mst_odr_config = MAX_MST_ODR_CONFIG;
+	} else {
+		if (mst_odr_config > MAX_MST_NON_COMPASS_ODR_CONFIG)
+			mst_odr_config = MAX_MST_NON_COMPASS_ODR_CONFIG;
+	}
+
+	base = BASE_SAMPLE_RATE / (1 << mst_odr_config);
+
+	if ((!st->chip_config.gyro_enable) && (!st->chip_config.accel_enable)) {
+		st->eng_info[ENGINE_I2C].running_rate = base;
+		st->eng_info[ENGINE_I2C].divider = (1 << mst_odr_config);
+	}
+	pr_debug("%s compass_running_rate %d  base %d\n",
+		__func__, st->eng_info[ENGINE_I2C].running_rate, base);
+
+	inv_calc_engine_dur(&st->eng_info[ENGINE_I2C]);
+
+	d = 0;
+	if (d > 0)
+		d -= 1;
+	if (d > MAX_5_BIT_VALUE)
+		d = MAX_5_BIT_VALUE;
+
+	/* I2C_MST_DLY is set to slow down secondary I2C */
+	if (d)
+		delay = 0x1F;
+	else
+		delay = 0;
+
+	st->sec_set.delay_enable = delay;
+	st->sec_set.delay_time = d;
+	st->sec_set.odr_config = mst_odr_config;
+
+	pr_info("mst_odr_conf %X no modified\n", mst_odr_config);
+
+	return 0;
+}
+
+static int inv_set_master_delay(struct inv_mpu_state *st)
+{
+
+	if (!st->chip_config.slave_enable)
+		return 0;
+	inv_set_ICM20628_secondary(st);
+
+	return 0;
+}
+
+static void inv_enable_accel_cal_V3(struct inv_mpu_state *st, u8 enable)
+{
+	if (enable)
+		st->motion_event_cntl |= (ACCEL_CAL_EN);
+}
+
+static void inv_enable_gyro_cal_V3(struct inv_mpu_state *st, u8 enable)
+{
+	if (enable)
+		st->motion_event_cntl |= (GYRO_CAL_EN);
+}
+
+static void inv_enable_compass_cal_V3(struct inv_mpu_state *st, u8 enable)
+{
+	if (enable)
+		st->motion_event_cntl |= COMPASS_CAL_EN;
+}
+
+static int inv_set_wom(struct inv_mpu_state *st)
+{
+	int result;
+	u8 d[4] = { 0, 0, 0, 0 };
+
+	if (st->chip_config.wom_on)
+		d[3] = 1;
+
+	if (local.wom_on != st->chip_config.wom_on) {
+		result = mem_w(WOM_ENABLE, ARRAY_SIZE(d), d);
+		if (result)
+			return result;
+		local.wom_on = st->chip_config.wom_on;
+	}
+
+	inv_write_2bytes(st, DATA_RDY_STATUS, st->chip_config.gyro_enable |
+			(st->chip_config.accel_enable << 1) |
+			(st->chip_config.slave_enable << 3));
+
+	return 0;
+}
+
+static void inv_setup_events(struct inv_mpu_state *st)
+{
+	if (st->ped.engine_on)
+		st->motion_event_cntl |= (PEDOMETER_EN);
+	if (st->smd.on)
+		st->motion_event_cntl |= (SMD_EN);
+	if (st->ped.int_on)
+		st->motion_event_cntl |= (PEDOMETER_INT_EN);
+	if (st->chip_config.pick_up_enable)
+		st->motion_event_cntl |= (FLIP_PICKUP_EN);
+	if (st->chip_config.geomag_enable)
+		st->motion_event_cntl |= GEOMAG_RV_EN;
+	if (st->sensor[SENSOR_NINEQ].on)
+		st->motion_event_cntl |= NINE_AXIS_EN;
+	if (!st->chip_config.activity_eng_on)
+		st->motion_event_cntl |= BAC_ACCEL_ONLY_EN;
+}
+
+static int inv_setup_sensor_interrupt(struct inv_mpu_state *st)
+{
+	int i, ind, rate;
+
+	ind = -1;
+	rate = 0;
+
+	st->intr_cntl = 0;
+	if (st->batch.on) {
+		for (i = 0; i < SENSOR_NUM_MAX; i++) {
+			if (st->sensor[i].on)
+				st->intr_cntl |= st->sensor[i].output;
+		}
+	}
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			if (st->sensor[i].rate > rate) {
+				ind = i;
+				rate = st->sensor[i].rate;
+			}
+		}
+	}
+
+	if (ind != -1)
+		st->intr_cntl |= st->sensor[ind].output;
+	if (st->chip_config.step_detector_on)
+		st->intr_cntl |= PED_STEPDET_SET;
+	if (st->chip_config.activity_eng_on)
+		st->intr_cntl |= HEADER2_SET;
+	if (st->chip_config.pick_up_enable)
+		st->intr_cntl |= HEADER2_SET;
+	if (st->chip_config.eis_enable)
+		st->intr_cntl |= HEADER2_SET;
+
+	pr_debug("eis for Header2 %s\n",
+		st->chip_config.eis_enable == 1 ? "Enabled" : "Disabled");
+	return inv_write_2bytes(st, DATA_INTR_CTL, st->intr_cntl);
+}
+
+static int inv_mpu_reset_pickup(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = write_be32_to_mem(st, 0, FP_PICKUP_CNTR);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+static int inv_setup_dmp(struct inv_mpu_state *st)
+{
+	int result, i, tmp, min_diff, ind;
+
+	result = inv_setup_sensor_interrupt(st);
+	if (result)
+		return result;
+
+	i = 0;
+	ind = 0;
+	min_diff = accel_cal_para[0].freq;
+	while (i < ARRAY_SIZE(accel_cal_para)) {
+		tmp = abs(accel_cal_para[i].freq -
+				st->eng_info[ENGINE_ACCEL].running_rate);
+		if (tmp < min_diff) {
+			min_diff = tmp;
+			ind = i;
+		}
+		i++;
+	}
+	i = ind;
+		result = inv_write_2bytes(st, BAC_RATE,
+					accel_cal_para[i].bac_rate);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st,
+					accel_cal_para[i].bac_rate, FP_RATE);
+		if (result)
+			return result;
+
+		result = inv_write_2bytes(st,
+					ACCEL_CAL_RATE,
+					accel_cal_para[i].rate);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st,
+					accel_cal_para[i].alpha,
+					ACCEL_ALPHA_VAR);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st,
+					accel_cal_para[i].a,
+					ACCEL_A_VAR);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st,
+					accel_cal_para[i].gain,
+					ACCEL_ONLY_GAIN);
+		if (result)
+			return result;
+		local.accel_cal_ind = i;
+
+	i = 0;
+	min_diff = compass_cal_param[0];
+	while (i < ARRAY_SIZE(compass_cal_param)) {
+		tmp = abs(compass_cal_param[i] -
+			st->eng_info[ENGINE_I2C].running_rate);
+		if (tmp < min_diff) {
+			min_diff = tmp;
+			ind = i;
+		}
+		i++;
+	}
+
+	if ((st->eng_info[ENGINE_I2C].running_rate)) {
+		result =
+			inv_write_2bytes(st, CPASS_TIME_BUFFER,
+				compass_cal_param[ind]);
+		if (result)
+			return result;
+	}
+
+	if (st->chip_config.activity_eng_on) {
+		result = write_be32_to_mem(st, 0, BAC_STATE);
+		if (result)
+			return result;
+
+		result = write_be32_to_mem(st, 0, BAC_STATE_PREV);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_ACT_ON);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_ACT_OFF);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_STILL_S_F);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_RUN_S_F);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_DRIVE_S_F);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_WALK_S_F);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_SMD_S_F);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_BIKE_S_F);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_E1_SHORT);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_E2_SHORT);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_E3_SHORT);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 0, BAC_VAR_RUN);
+		if (result)
+			return result;
+		result = write_be32_to_mem(st, 1, BAC_TILT_INIT);
+		if (result)
+			return result;
+
+		local.activity_eng_on = st->chip_config.activity_eng_on;
+	}
+
+	inv_enable_accel_cal_V3(st, st->accel_cal_enable);
+	inv_enable_gyro_cal_V3(st, st->gyro_cal_enable);
+	inv_enable_compass_cal_V3(st, st->calib_compass_on);
+
+	if (st->ped.engine_on) {
+		result = write_be32_to_mem(st, 0, DMPRATE_CNTR);
+		if (result)
+			return result;
+		result = write_be16_to_mem(st, 0, PEDSTEP_IND);
+		if (result)
+			return result;
+	}
+
+	if (st->chip_config.pick_up_enable) {
+		result = inv_mpu_reset_pickup(st);
+		if (result)
+			return result;
+	}
+
+	inv_setup_events(st);
+
+	result = inv_set_wom(st);
+	if (result)
+		return result;
+
+	result = inv_write_2bytes(st, DATA_OUT_CTL1, st->cntl);
+	if (result)
+		return result;
+	result = inv_write_2bytes(st, DATA_OUT_CTL2, st->cntl2);
+	if (result)
+		return result;
+	result = inv_write_2bytes(st, MOTION_EVENT_CTL, st->motion_event_cntl);
+
+	if (st->chip_config.gyro_enable) {
+		if (st->eng_info[ENGINE_GYRO].running_rate ==
+			MPU_DEFAULT_DMP_FREQ)
+			result = write_be32_to_mem(st, st->gyro_sf, GYRO_SF);
+		else
+			result = write_be32_to_mem(st,
+						st->gyro_sf << 1, GYRO_SF);
+	}
+	pr_info("setup DMP  cntl [%04X] cntl2 [%04X] motion_event [%04X]",
+				st->cntl, st->cntl2, st->motion_event_cntl);
+
+	return result;
+}
+
+static int inv_get_accel_gyro_rate(int compass_rate)
+{
+	int i;
+
+	i = 0;
+	while ((i < ARRAY_SIZE(accel_gyro_rate)) &&
+		compass_rate > accel_gyro_rate[i])
+		i++;
+
+	return accel_gyro_rate[i];
+}
+
+static int inv_determine_engine(struct inv_mpu_state *st)
+{
+	int i;
+	bool a_en, g_en, c_en, p_en, data_on, ped_on;
+	int compass_rate, nineq_rate, accel_rate, gyro_rate;
+
+#define MIN_GYRO_RATE         112
+
+	a_en = false;
+	g_en = false;
+	c_en = false;
+	p_en = false;
+	ped_on = false;
+	data_on = false;
+	compass_rate = NINEQ_MIN_COMPASS_RATE;
+	nineq_rate = 0;
+	gyro_rate = MIN_GYRO_RATE;
+	accel_rate = PEDOMETER_FREQ;
+
+	st->chip_config.geomag_enable = 0;
+	if (st->sensor[SENSOR_NINEQ].on)
+		nineq_rate = max(nineq_rate, NINEQ_MIN_COMPASS_RATE);
+	if (st->sensor[SENSOR_GEOMAG].on) {
+		st->chip_config.geomag_enable = 1;
+		nineq_rate = max(nineq_rate, GEOMAG_MIN_COMPASS_RATE);
+	}
+	/* loop the streaming sensors to see which engine needs to be turned on
+	 */
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			data_on = true;
+			a_en |= st->sensor[i].a_en;
+			g_en |= st->sensor[i].g_en;
+			c_en |= st->sensor[i].c_en;
+			p_en |= st->sensor[i].p_en;
+			if (st->sensor[i].c_en)
+				compass_rate =
+					max(compass_rate, st->sensor[i].rate);
+			if (st->sensor[i].p_en)
+				compass_rate =
+					max(compass_rate, st->sensor[i].rate);
+		}
+	}
+	g_en |= st->secondary_gyro_on;
+
+	/* tilt and activity both uses activity engine */
+	st->chip_config.activity_eng_on = (st->chip_config.activity_on |
+					st->chip_config.tilt_enable);
+	/* step detector and step detector wake and pedometer in batch mode
+	 * all use step detector sensor in the base sensor of invensense
+	 */
+	if (st->step_detector_l_on ||
+		st->step_detector_wake_l_on || (st->ped.on && st->batch.timeout && st->ped.int_mode))
+		st->chip_config.step_detector_on = true;
+	else
+		st->chip_config.step_detector_on = false;
+	/* ped_on engine is on depends on the step detector and step indicator
+	 * and activity engine on
+	 */
+	if (st->chip_config.step_detector_on ||
+		st->chip_config.step_indicator_on ||
+		st->chip_config.activity_eng_on) {
+		ped_on = true;
+		data_on = true;
+	}
+	/* smd depends on ped engine */
+	if (st->smd.on)
+		ped_on = true;
+
+	/* pedometer interrupt is enabled when ped int mode */
+	if (st->ped.int_mode && st->ped.on)
+		st->ped.int_on = 1;
+	else
+		st->ped.int_on = 0;
+
+	if (st->ped.on || ped_on)
+		st->ped.engine_on = true;
+	else
+		st->ped.engine_on = false;
+	/* ped engine needs accel engine on */
+	if (st->ped.engine_on)
+		a_en = true;
+	/* pick up needs accel engine on */
+	if (st->chip_config.pick_up_enable)
+		a_en = true;
+	/* eis needs gyro engine. gyro rate is 225 by default.
+	 * eis_triggerred set to be false when it is turned false
+	 */
+	if (st->chip_config.eis_enable) {
+		g_en = true;
+		gyro_rate = MPU_DEFAULT_DMP_FREQ;
+		st->eis.frame_count = 0;
+		st->eis.fsync_delay = 0;
+		st->eis.gyro_counter = 0;
+		st->eis.voting_count = 0;
+		st->eis.voting_count_sub = 0;
+	} else {
+		st->eis.eis_triggered = false;
+	}
+
+	if (data_on)
+		st->chip_config.dmp_event_int_on = 0;
+	else
+		st->chip_config.dmp_event_int_on = 1;
+
+	if (st->chip_config.dmp_event_int_on)
+		st->chip_config.wom_on = 1;
+	else
+		st->chip_config.wom_on = 0;
+
+	if (compass_rate < nineq_rate)
+		compass_rate = nineq_rate;
+	st->chip_config.compass_rate = compass_rate;
+	if (st->sensor[SENSOR_SIXQ].on || st->sensor[SENSOR_NINEQ].on ||
+		st->sensor[SENSOR_PEDQ].on || st->sensor[SENSOR_GEOMAG].on) {
+		/* if 6 Q or 9 Q is on, set gyro/accel to default rate */
+		accel_rate = MPU_DEFAULT_DMP_FREQ;
+		gyro_rate = MPU_DEFAULT_DMP_FREQ;
+	} else {
+		/* determine the fastest accel engine rate when it is not
+		 * using default DMP frequency
+		 */
+		if (st->sensor[SENSOR_ACCEL].on) {
+			accel_rate = max(accel_rate,
+						st->sensor[SENSOR_ACCEL].rate);
+		}
+		if (st->sensor[SENSOR_GYRO].on)
+			gyro_rate = max(gyro_rate,
+					st->sensor[SENSOR_GYRO].rate);
+	}
+
+	if (compass_rate < MIN_COMPASS_RATE)
+		compass_rate = MIN_COMPASS_RATE;
+	st->ts_algo.clock_base = ENGINE_I2C;
+	if (c_en && (!g_en) && (!a_en)) {
+		a_en = true;
+		accel_rate = compass_rate;
+	}
+	if (g_en) {
+		/* gyro engine needs to be fastest */
+		if (a_en)
+			gyro_rate = max(gyro_rate, accel_rate);
+		if (c_en || p_en) {
+			if (gyro_rate < compass_rate)
+				gyro_rate =
+					inv_get_accel_gyro_rate(compass_rate);
+		}
+		accel_rate = gyro_rate;
+		compass_rate = gyro_rate;
+		st->ts_algo.clock_base = ENGINE_GYRO;
+		st->sensor[SENSOR_COMPASS].engine_base = ENGINE_GYRO;
+		st->sensor[SENSOR_COMPASS_CAL].engine_base = ENGINE_GYRO;
+	} else if (a_en) {
+		/* accel engine needs to be fastest if gyro engine is off */
+		if (c_en || p_en) {
+			if (accel_rate <= compass_rate)
+				accel_rate =
+					inv_get_accel_gyro_rate(compass_rate);
+		}
+		compass_rate = accel_rate;
+		gyro_rate = accel_rate;
+		st->ts_algo.clock_base = ENGINE_ACCEL;
+		st->sensor[SENSOR_COMPASS].engine_base = ENGINE_ACCEL;
+		st->sensor[SENSOR_COMPASS_CAL].engine_base = ENGINE_ACCEL;
+	}
+
+	st->eng_info[ENGINE_GYRO].running_rate = gyro_rate;
+	st->eng_info[ENGINE_ACCEL].running_rate = accel_rate;
+	st->eng_info[ENGINE_PRESSURE].running_rate = MPU_DEFAULT_DMP_FREQ;
+	st->eng_info[ENGINE_I2C].running_rate = compass_rate;
+	/* engine divider for pressure and compass is set later */
+	st->eng_info[ENGINE_GYRO].divider =
+		(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+		(MPU_DEFAULT_DMP_FREQ / st->eng_info[ENGINE_GYRO].running_rate);
+	st->eng_info[ENGINE_ACCEL].divider =
+		(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+		(MPU_DEFAULT_DMP_FREQ / st->eng_info[ENGINE_ACCEL].running_rate);
+	if (g_en)
+		st->eng_info[ENGINE_I2C].divider =
+		(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+			(MPU_DEFAULT_DMP_FREQ /
+				st->eng_info[ENGINE_GYRO].running_rate);
+	else
+		st->eng_info[ENGINE_I2C].divider =
+		(BASE_SAMPLE_RATE / MPU_DEFAULT_DMP_FREQ) *
+			(MPU_DEFAULT_DMP_FREQ /
+				st->eng_info[ENGINE_ACCEL].running_rate);
+
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++)
+		st->sensor_l[i].counter = 0;
+
+	inv_calc_engine_dur(&st->eng_info[ENGINE_GYRO]);
+	inv_calc_engine_dur(&st->eng_info[ENGINE_ACCEL]);
+
+	if (st->debug_determine_engine_on)
+		return 0;
+
+	st->chip_config.gyro_enable = g_en;
+	st->gyro_cal_enable = g_en;
+
+	st->chip_config.accel_enable = a_en;
+	st->accel_cal_enable = a_en;
+
+	st->chip_config.compass_enable = c_en;
+	st->calib_compass_on = c_en;
+
+	st->chip_config.pressure_enable = p_en;
+	st->chip_config.dmp_on = 1;
+	pr_info("gen: %d aen: %d cen: %d grate: %d arate: %d\n",
+				g_en, a_en, c_en, gyro_rate, accel_rate);
+	if (st->sensor[SENSOR_ALS].on || st->secondary_prox_on)
+		st->chip_config.als_enable = 1;
+	else
+		st->chip_config.als_enable = 0;
+
+	if (c_en || st->chip_config.als_enable || p_en)
+		st->chip_config.slave_enable = 1;
+	else
+		st->chip_config.slave_enable = 0;
+
+	/* setting up accel accuracy output */
+	if (st->sensor[SENSOR_ACCEL].on || st->sensor[SENSOR_NINEQ].on ||
+				st->sensor[SENSOR_SIXQ].on)
+		st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].on = true;
+	else
+		st->sensor_accuracy[SENSOR_ACCEL_ACCURACY].on = false;
+
+	if (st->sensor[SENSOR_GYRO].on || st->sensor[SENSOR_NINEQ].on ||
+				st->sensor[SENSOR_SIXQ].on)
+		st->sensor_accuracy[SENSOR_GYRO_ACCURACY].on = true;
+	else
+		st->sensor_accuracy[SENSOR_GYRO_ACCURACY].on = false;
+
+	/* Setting up accurcy outpu of compass */
+	if (st->sensor[SENSOR_COMPASS].on || st->sensor[SENSOR_COMPASS_CAL].on
+		|| st->sensor[SENSOR_NINEQ].on)
+		st->sensor_accuracy[SENSOR_COMPASS_ACCURACY].on = true;
+	else
+		st->sensor_accuracy[SENSOR_COMPASS_ACCURACY].on = false;
+
+	st->cntl = 0;
+	st->cntl2 = 0;
+	st->motion_event_cntl = 0;
+	st->intr_cntl = 0;
+	st->send_raw_compass = false;
+
+	inv_set_master_delay(st);
+
+	return 0;
+}
+
+/*
+ *  set_inv_enable() - enable function.
+ */
+int set_inv_enable(struct iio_dev *indio_dev)
+{
+	int result;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	u8 w;
+
+	result = inv_switch_power_in_lp(st, true);
+	if (result)
+		return result;
+
+	result = inv_stop_dmp(st);
+	if (result)
+		return result;
+
+	inv_determine_engine(st);
+	if (!st->secondary_switch) {
+		result = inv_set_rate(st);
+		if (result) {
+			pr_err("inv_set_rate error\n");
+			return result;
+		}
+	}
+	if (!st->secondary_switch) {
+		result = inv_setup_dmp(st);
+		if (result) {
+			pr_err("setup dmp error\n");
+			return result;
+		}
+	}
+	result = inv_turn_on_engine(st);
+	if (result) {
+		pr_err("inv_turn_on_engine error\n");
+		return result;
+	}
+	if (!st->secondary_switch) {
+		result = inv_set_fifo_size(st);
+		if (result) {
+			pr_err("inv_set_fifo_size error\n");
+			return result;
+		}
+	}
+	if ((!st->secondary_switch) || (st->secondary_switch &&
+			(st->secondary_switch_data != SENCONDARY_GYRO_OFF) &&
+			(st->secondary_switch_data != SENCONDARY_GYRO_ON))) {
+		result = inv_set_fake_secondary(st);
+		if (result)
+			return result;
+	}
+	if (!st->secondary_switch) {
+		result = inv_reset_fifo(st, false);
+		if (result)
+			return result;
+	} else {
+		/* Recover only REG_USER_CTRL */
+		w = BIT_FIFO_EN;
+		w |= BIT_DMP_EN;
+		if (st->chip_config.slave_enable && (!st->poke_mode_on))
+			w |= BIT_I2C_MST_EN;
+		result = inv_plat_single_write(st, REG_USER_CTRL, w | st->i2c_dis);
+		if (result)
+			return result;
+	}
+	result = inv_switch_power_in_lp(st, false);
+	if ((!st->chip_config.gyro_enable) &&
+		(!st->chip_config.accel_enable) &&
+		(!st->chip_config.slave_enable) &&
+		(!st->chip_config.pressure_enable)) {
+		inv_set_power(st, false);
+
+		return 0;
+	}
+
+	return result;
+}
+
+static int inv_set_flip_pickup_gesture_params_V3(struct inv_mpu_state *st)
+{
+	int var_error_alpha;
+	int still_threshold;
+	int middle_still_threshold;
+	int not_still_threshold;
+	int vibration_rejection_threshold;
+	int maximum_pickup_time_threshold;
+	int pickup_timeout_threshold;
+	int still_consistency_count_threshold;
+	int motion_consistency_count_threshold;
+	int vibration_count_threshold;
+	int steady_tilt_threshold;
+	int steady_tilt_upper_threshold;
+	int accel_z_flat_threshold_minus;
+	int accel_z_flat_threshold_plus;
+	int device_in_pocket_threshold;
+	int result;
+
+	var_error_alpha = 107374182L;
+	still_threshold = 4L;
+	middle_still_threshold = 10L;
+	not_still_threshold = 40L;
+	vibration_rejection_threshold = 65100L;
+	maximum_pickup_time_threshold = 30L;
+	pickup_timeout_threshold = 150L;
+	still_consistency_count_threshold = 80;
+	motion_consistency_count_threshold = 10;
+	vibration_count_threshold = 3;
+	steady_tilt_threshold = 6710886L;
+	steady_tilt_upper_threshold = 140928614L;
+	accel_z_flat_threshold_minus = 60397978L;
+	accel_z_flat_threshold_plus = 6710886L;
+	device_in_pocket_threshold = 100L;
+
+	result = write_be32_to_mem(st, var_error_alpha, FP_VAR_ALPHA);
+	result += write_be32_to_mem(st, still_threshold, FP_STILL_TH);
+	result += write_be32_to_mem(st, middle_still_threshold,
+				FP_MID_STILL_TH);
+	result += write_be32_to_mem(st, not_still_threshold, FP_NOT_STILL_TH);
+	result += write_be32_to_mem(st, vibration_rejection_threshold,
+				FP_VIB_REJ_TH);
+	result += write_be32_to_mem(st, maximum_pickup_time_threshold,
+				FP_MAX_PICKUP_T_TH);
+	result += write_be32_to_mem(st, pickup_timeout_threshold,
+				FP_PICKUP_TIMEOUT_TH);
+	result += write_be32_to_mem(st, still_consistency_count_threshold,
+				FP_STILL_CONST_TH);
+	result += write_be32_to_mem(st, motion_consistency_count_threshold,
+				FP_MOTION_CONST_TH);
+	result += write_be32_to_mem(st, vibration_count_threshold,
+				FP_VIB_COUNT_TH);
+	result += write_be32_to_mem(st, steady_tilt_threshold,
+				FP_STEADY_TILT_TH);
+	result += write_be32_to_mem(st, steady_tilt_upper_threshold,
+				FP_STEADY_TILT_UP_TH);
+	result += write_be32_to_mem(st, accel_z_flat_threshold_minus,
+				FP_Z_FLAT_TH_MINUS);
+	result += write_be32_to_mem(st, accel_z_flat_threshold_plus,
+				FP_Z_FLAT_TH_PLUS);
+	result += write_be32_to_mem(st, device_in_pocket_threshold,
+				FP_DEV_IN_POCKET_TH);
+	return result;
+}
+
+int inv_write_compass_matrix(struct inv_mpu_state *st, int *adj)
+{
+	int addr[] = {CPASS_MTX_00, CPASS_MTX_01, CPASS_MTX_02,
+			CPASS_MTX_10, CPASS_MTX_11, CPASS_MTX_12,
+			CPASS_MTX_20, CPASS_MTX_21, CPASS_MTX_22};
+	int r, i;
+
+	for (i = 0; i < 9; i++) {
+		r = write_be32_to_mem(st, adj[i], addr[i]);
+		if (r)
+			return r;
+	}
+
+	return 0;
+}
+
+static int inv_compass_dmp_cal(struct inv_mpu_state *st)
+{
+	s8 *compass_m, *m;
+	s8 trans[NINE_ELEM];
+	s32 tmp_m[NINE_ELEM];
+	int i, j, k;
+	int sens[THREE_AXES];
+	int *adj;
+	int scale, shift, r;
+
+	compass_m = st->plat_data.secondary_orientation;
+	m = st->plat_data.orientation;
+	for (i = 0; i < THREE_AXES; i++)
+		for (j = 0; j < THREE_AXES; j++)
+			trans[THREE_AXES * j + i] = m[THREE_AXES * i + j];
+
+	adj = st->current_compass_matrix;
+	st->slave_compass->get_scale(st, &scale);
+
+	if ((COMPASS_ID_AK8975 == st->plat_data.sec_slave_id) ||
+		(COMPASS_ID_AK8972 == st->plat_data.sec_slave_id) ||
+		(COMPASS_ID_AK8963 == st->plat_data.sec_slave_id) ||
+		(COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) ||
+		(COMPASS_ID_AK09916 == st->plat_data.sec_slave_id))
+		shift = AK89XX_SHIFT;
+	else
+		shift = AK99XX_SHIFT;
+
+	for (i = 0; i < THREE_AXES; i++) {
+		sens[i] = st->chip_info.compass_sens[i] + 128;
+		sens[i] = inv_q30_mult(sens[i] << shift, scale);
+	}
+
+	for (i = 0; i < NINE_ELEM; i++) {
+		adj[i] = compass_m[i] * sens[i % THREE_AXES];
+		tmp_m[i] = 0;
+	}
+	for (i = 0; i < THREE_AXES; i++)
+		for (j = 0; j < THREE_AXES; j++)
+			for (k = 0; k < THREE_AXES; k++)
+				tmp_m[THREE_AXES * i + j] +=
+					trans[THREE_AXES * i + k] *
+					adj[THREE_AXES * k + j];
+
+	for (i = 0; i < NINE_ELEM; i++)
+		st->final_compass_matrix[i] = adj[i];
+
+	r = inv_write_compass_matrix(st, tmp_m);
+
+	return 0;
+}
+
+static int inv_write_gyro_sf(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = write_be32_to_mem(st, st->gyro_sf, GYRO_SF);
+
+	return result;
+}
+
+int inv_write_accel_sf(struct inv_mpu_state *st)
+{
+	int result;
+
+	result = write_be32_to_mem(st,
+		(DMP_ACCEL_SCALE_2G << st->chip_config.accel_fs), ACC_SCALE);
+	if (result)
+		return result;
+	result = write_be32_to_mem(st,
+		(DMP_ACCEL_SCALE2_2G >> st->chip_config.accel_fs), ACC_SCALE2);
+
+	return result;
+}
+
+int inv_setup_dmp_firmware(struct inv_mpu_state *st)
+{
+	int result;
+	u8 v[2] = {0, 0};
+
+	result = mem_w(DATA_OUT_CTL1, 2, v);
+	if (result)
+		return result;
+	result = mem_w(DATA_OUT_CTL2, 2, v);
+	if (result)
+		return result;
+	result = mem_w(MOTION_EVENT_CTL, 2, v);
+	if (result)
+		return result;
+	result = write_be32_to_mem(st, 12000, SMD_VAR_TH);
+	if (result)
+		return result;
+
+	result = inv_write_accel_sf(st);
+	if (result)
+		return result;
+	result = inv_write_gyro_sf(st);
+	if (result)
+		return result;
+
+	if (st->chip_config.has_compass) {
+		result = inv_compass_dmp_cal(st);
+		if (result)
+			return result;
+	}
+	result = inv_set_flip_pickup_gesture_params_V3(st);
+
+	return result;
+}
+
+static int inv_save_interrupt_config(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_read(st, REG_INT_ENABLE, 1, &st->int_en);
+
+	return res;
+}
+
+int inv_stop_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_save_interrupt_config(st);
+	if (res)
+		return res;
+
+	res = inv_plat_single_write(st, REG_INT_ENABLE, 0);
+
+	return res;
+}
+
+int inv_restore_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	res = inv_plat_single_write(st, REG_INT_ENABLE, st->int_en);
+
+	return res;
+}
+
+int inv_stop_stream_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+	int i;
+	u16 cntl = st->intr_cntl;
+
+	/* keep streaming if any gesture reported by FIFO data is enabled */
+	if (st->chip_config.tilt_enable ||
+			st->chip_config.pick_up_enable ||
+			st->step_detector_l_on ||
+			st->step_detector_wake_l_on ||
+			st->chip_config.activity_on)
+		return 0;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		cntl &= ~st->sensor[i].output;
+
+	res = inv_switch_power_in_lp(st, true);
+	if (res)
+		return res;
+	res = inv_write_2bytes(st, DATA_INTR_CTL, cntl);
+	if (res)
+		return res;
+	res = inv_switch_power_in_lp(st, false);
+
+	return res;
+}
+
+int inv_restore_stream_interrupt(struct inv_mpu_state *st)
+{
+	int res;
+
+	/* skip as did nothing in inv_stop_stream_interrupt() */
+	if (st->chip_config.tilt_enable ||
+			st->chip_config.pick_up_enable ||
+			st->step_detector_l_on ||
+			st->step_detector_wake_l_on ||
+			st->chip_config.activity_on)
+		return 0;
+
+	res = inv_switch_power_in_lp(st, true);
+	if (res)
+		return res;
+	res = inv_write_2bytes(st, DATA_INTR_CTL, st->intr_cntl);
+	if (res)
+		return res;
+	res = inv_switch_power_in_lp(st, false);
+
+	return res;
+}
+
+int inv_read_offset_regs(struct inv_mpu_state *st, s16 accel[3], s16 gyro[3])
+{
+	int res = 0;
+	u8 data[2];
+
+	/* accel */
+	res = inv_set_bank(st, BANK_SEL_1);
+	if (res)
+		goto restore_bank;
+
+	res = inv_plat_read(st, REG_XA_OFFS_H, 2, data);
+	if (res)
+		goto restore_bank;
+	accel[0] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_YA_OFFS_H, 2, data);
+	if (res)
+		goto restore_bank;
+	accel[1] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_ZA_OFFS_H, 2, data);
+	if (res)
+		goto restore_bank;
+	accel[2] = (data[0] << 8) | data[1];
+
+	pr_info("read accel offset regs: %d, %d, %d\n",
+			accel[0], accel[1], accel[2]);
+
+	/* gyro */
+	res = inv_set_bank(st, BANK_SEL_2);
+	if (res)
+		goto restore_bank;
+
+	res = inv_plat_read(st, REG_XG_OFFS_USR_H, 2, data);
+	if (res)
+		goto restore_bank;
+	gyro[0] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_YG_OFFS_USR_H, 2, data);
+	if (res)
+		goto restore_bank;
+	gyro[1] = (data[0] << 8) | data[1];
+
+	res = inv_plat_read(st, REG_ZG_OFFS_USR_H, 2, data);
+	if (res)
+		goto restore_bank;
+	gyro[2] = (data[0] << 8) | data[1];
+
+	pr_info("read gyro offset regs: %d, %d, %d\n",
+			gyro[0], gyro[1], gyro[2]);
+
+restore_bank:
+	inv_set_bank(st, BANK_SEL_0);
+
+	return res;
+}
+
+int inv_write_offset_regs(struct inv_mpu_state *st, const s16 accel[3], const s16 gyro[3])
+{
+	int res = 0;
+
+	/* accel */
+	res = inv_set_bank(st, BANK_SEL_1);
+	if (res)
+		goto restore_bank;
+
+	res = inv_plat_single_write(st, REG_XA_OFFS_H,
+			(accel[0] >> 8) & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_XA_OFFS_H + 1,
+			accel[0] & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_YA_OFFS_H,
+			(accel[1] >> 8) & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_YA_OFFS_H + 1,
+			accel[1] & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_ZA_OFFS_H,
+			(accel[2] >> 8) & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_ZA_OFFS_H + 1,
+			accel[2] & 0xff);
+	if (res)
+		goto restore_bank;
+
+	pr_info("write accel offset regs: %d, %d, %d\n",
+			accel[0], accel[1], accel[2]);
+
+	/* gyro */
+	res = inv_set_bank(st, BANK_SEL_2);
+	if (res)
+		goto restore_bank;
+
+	res = inv_plat_single_write(st, REG_XG_OFFS_USR_H,
+			(gyro[0] >> 8) & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_XG_OFFS_USR_H + 1,
+			gyro[0] & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_YG_OFFS_USR_H,
+			(gyro[1] >> 8) & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_YG_OFFS_USR_H + 1,
+			gyro[1] & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_ZG_OFFS_USR_H,
+			(gyro[2] >> 8) & 0xff);
+	if (res)
+		goto restore_bank;
+	res = inv_plat_single_write(st, REG_ZG_OFFS_USR_H + 1,
+			gyro[2] & 0xff);
+	if (res)
+		goto restore_bank;
+
+	pr_info("write gyro offset regs: %d, %d, %d\n",
+			gyro[0], gyro[1], gyro[2]);
+
+restore_bank:
+	inv_set_bank(st, BANK_SEL_0);
+
+	return res;
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_slave_als.c b/drivers/iio/imu/inv_mpu/icm20648/inv_slave_als.c
new file mode 100644
index 000000000000..8a68f80777f0
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_slave_als.c
@@ -0,0 +1,288 @@
+/*
+* Copyright (C) 2017-2017 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/* AVAGO APDS-9930 */
+#define APDS9930_ENABLE_REG     0x00
+#define APDS9930_ATIME_REG      0x01
+#define APDS9930_PTIME_REG      0x02
+#define APDS9930_WTIME_REG      0x03
+#define APDS9930_AILTL_REG      0x04
+#define APDS9930_AILTH_REG      0x05
+#define APDS9930_AIHTL_REG      0x06
+#define APDS9930_AIHTH_REG      0x07
+#define APDS9930_PILTL_REG      0x08
+#define APDS9930_PILTH_REG      0x09
+#define APDS9930_PIHTL_REG      0x0A
+#define APDS9930_PIHTH_REG      0x0B
+#define APDS9930_PERS_REG       0x0C
+#define APDS9930_CONFIG_REG     0x0D
+#define APDS9930_PPCOUNT_REG    0x0E
+#define APDS9930_CONTROL_REG    0x0F
+#define APDS9930_REV_REG        0x11
+#define APDS9930_ID_REG         0x12
+#define APDS9930_STATUS_REG     0x13
+#define APDS9930_CDATAL_REG     0x14
+#define APDS9930_CDATAH_REG     0x15
+#define APDS9930_IRDATAL_REG    0x16
+#define APDS9930_IRDATAH_REG    0x17
+#define APDS9930_PDATAL_REG     0x18
+#define APDS9930_PDATAH_REG     0x19
+
+#define LIGHT_SENSOR_RATE_SCALE  100
+
+#define CMD_BYTE                0x80
+#define CMD_WORD                0xA0
+#define CMD_SPECIAL             0xE0
+#define DATA_ALS_ID             0x39
+#define DATA_ATIME              0xDB
+#define DATA_PPCOUNT            0x08
+#define DATA_CONFIG             0x00
+#define DATA_CONTROL            0x20
+#define DATA_ENABLE             0x03
+
+#define GA                      49
+#define B                       186
+#define C                       74
+#define D                       129
+#define CALC_RESOL              100
+#define DF                      52
+#define AGAIN                   1
+#define MIN_ATIME               273
+#define PON                     1
+#define AEN                     0x2
+#define PEN                     0x4
+#define WEN                     0x8
+
+#define ALS_89XX_BYTES          9
+#define ALS_99XX_BYTES          8
+
+static bool secondary_resume_state;
+
+static int setup_apds9930_avago(struct inv_mpu_state *st)
+{
+	int result;
+	u8 addr;
+	u8 d[1];
+
+	addr = st->plat_data.read_only_i2c_addr;
+	result = inv_execute_read_secondary(st, 2, addr,
+					    CMD_BYTE | APDS9930_ID_REG, 1, d);
+	if (result)
+		return result;
+
+	if (d[0] != DATA_ALS_ID) {
+		pr_info("APDS9930 not found. Addr:0x%02X, ID:0x%02X (expected:0x%02X)\n",
+				addr, d[0], DATA_ALS_ID);
+		return -ENXIO;
+	}
+	pr_info("APDS9930 found. Addr:0x%02X, ID:0x%02X\n", addr, d[0]);
+
+	/* power off the chip to setup */
+	result = inv_execute_write_secondary(st, 2, addr,
+					     CMD_BYTE | APDS9930_ENABLE_REG,
+					     0x0);
+	if (result)
+		return result;
+
+	/* Write Atime, multiples of 50ms */
+	result = inv_execute_write_secondary(st, 2, addr,
+					     CMD_BYTE | APDS9930_ATIME_REG,
+					     DATA_ATIME);
+	if (result)
+		return result;
+
+	/* Leave PTIME register at reset value of 0xFF */
+	/* Leave WTIME register at reset value of 0xFF */
+
+	/* write  config register register */
+	result = inv_execute_write_secondary(st, 2, addr,
+					     CMD_BYTE | APDS9930_CONFIG_REG,
+					     DATA_CONFIG);
+	if (result)
+		return result;
+
+	/* write pp count register */
+	result = inv_execute_write_secondary(st, 2, addr,
+					     CMD_BYTE | APDS9930_PPCOUNT_REG,
+					     DATA_PPCOUNT);
+	if (result)
+		return result;
+	/* write control register */
+	result = inv_execute_write_secondary(st, 2, addr,
+					     CMD_BYTE | APDS9930_CONTROL_REG,
+					     DATA_CONTROL);
+
+	return result;
+}
+
+static int resume_apds9930_avago(struct inv_mpu_state *st)
+{
+	int result, start, bytes;
+	u8 addr;
+	u8 d[1];
+
+	addr = st->plat_data.read_only_i2c_addr;
+
+	/* setup the secondary bus to default speed */
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG,
+				       MIN_MST_ODR_CONFIG);
+	if (result)
+		return result;
+
+	/* clear up the ctrl register to avoid interference of setup */
+	if (!st->chip_config.compass_enable) {
+		result = inv_plat_single_write(st, st->slv_reg[0].ctrl, 0);
+		if (result)
+			return result;
+	}
+
+	/* enable ALS only and power on */
+	result = inv_execute_write_secondary(st, 2, addr,
+					     CMD_BYTE | APDS9930_ENABLE_REG,
+					     PON | AEN | PEN | WEN);
+	if (result)
+		return result;
+	if (st->chip_config.compass_enable &&
+	    ((st->plat_data.sec_slave_id == COMPASS_ID_AK8975) ||
+	     (st->plat_data.sec_slave_id == COMPASS_ID_AK8963))) {
+		start = APDS9930_ID_REG;
+		bytes = ALS_89XX_BYTES;
+	} else {
+		start = APDS9930_STATUS_REG;
+		bytes = ALS_99XX_BYTES;
+	}
+	/* dummy read */
+	result = inv_execute_read_secondary(st, 2, addr,
+					    CMD_WORD | start, 1, d);
+
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+	result = inv_read_secondary(st, 2, addr, CMD_WORD | start, bytes);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	secondary_resume_state = true;
+
+	return result;
+}
+
+static int suspend_apds9930_avago(struct inv_mpu_state *st)
+{
+	int result;
+	u8 addr;
+
+	if (!secondary_resume_state)
+		return 0;
+
+	addr = st->plat_data.read_only_i2c_addr;
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG,
+				       MIN_MST_ODR_CONFIG);
+	if (result)
+		return result;
+	if (!st->chip_config.compass_enable) {
+		result = inv_plat_single_write(st, st->slv_reg[0].ctrl, 0);
+		if (result)
+			return result;
+	}
+	/* disable 9930 */
+	result = inv_execute_write_secondary(st, 2, addr,
+					     CMD_BYTE | APDS9930_ENABLE_REG, 0);
+	if (result)
+		return result;
+
+	/* slave 2 is disabled */
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_SLV2_CTRL, 0);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	secondary_resume_state = false;
+
+	return result;
+}
+
+static int read_data_apds9930_avago(struct inv_mpu_state *st, s16 *o)
+{
+	u8 *d;
+	u16 c0data, c1data;
+	int lux1, lux2;
+
+	d = st->fifo_data;
+
+	c0data = ((d[2] << 8) | d[1]);
+	c1data = ((d[4] << 8) | d[3]);
+#if 1
+	lux1 = ((1000 * c0data) - (2005 * c1data))
+	    / (71 * 8);
+	if (lux1 < 0)
+		lux1 = 0;
+	lux2 = ((604 * c0data) - (1090 * c1data))
+	    / (71 * 8);
+	if (lux2 < 0)
+		lux2 = 0;
+	if (lux1 < lux2)
+		lux1 = lux2;
+#else
+	lux1 = ((1000 * c0data) - (2005 * c1data)) / 71;
+	if (lux1 < 0)
+		lux1 = 0;
+	lux2 = ((604 * c0data) - (1090 * c1data)) / 71;
+	if (lux2 < 0)
+		lux2 = 0;
+	if (lux1 < lux2)
+		lux1 = lux2;
+#endif
+
+	o[0] = lux1;
+	o[1] = (short)((d[6] << 8) | d[5]);
+	o[2] = 0;
+
+	return 0;
+}
+
+static struct inv_mpu_slave slave_apds9930 = {
+	.suspend = suspend_apds9930_avago,
+	.resume = resume_apds9930_avago,
+	.setup = setup_apds9930_avago,
+	.read_data = read_data_apds9930_avago,
+	.rate_scale = LIGHT_SENSOR_RATE_SCALE,
+};
+
+int inv_mpu_setup_als_slave(struct inv_mpu_state *st)
+{
+	switch (st->plat_data.read_only_slave_id) {
+	case ALS_ID_APDS_9930:
+	case ALS_ID_TSL_2772:
+		st->slave_als = &slave_apds9930;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return st->slave_als->setup(st);
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_slave_compass.c b/drivers/iio/imu/inv_mpu/icm20648/inv_slave_compass.c
new file mode 100644
index 000000000000..633a5e4e40c2
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_slave_compass.c
@@ -0,0 +1,640 @@
+/*
+* Copyright (C) 2017-2019 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/* AKM definitions */
+#define REG_AKM_ID			0x00
+#define REG_AKM_INFO			0x01
+#define REG_AKM_STATUS			0x02
+#define REG_AKM_MEASURE_DATA		0x03
+#define REG_AKM_MODE			0x0A
+#define REG_AKM_ST_CTRL			0x0C
+#define REG_AKM_SENSITIVITY		0x10
+#define REG_AKM8963_CNTL1		0x0A
+
+/* AK09911 register definition */
+#define REG_AK09911_DMP_READ		0x3
+#define REG_AK09911_STATUS1		0x10
+#define REG_AK09911_CNTL2		0x31
+#define REG_AK09911_SENSITIVITY		0x60
+#define REG_AK09911_MEASURE_DATA	0x11
+
+/* AK09912 register definition */
+#define REG_AK09912_DMP_READ		0x3
+#define REG_AK09912_STATUS1		0x10
+#define REG_AK09912_CNTL1		0x30
+#define REG_AK09912_CNTL2		0x31
+#define REG_AK09912_SENSITIVITY		0x60
+#define REG_AK09912_MEASURE_DATA	0x11
+
+/* AK09916 register definition */
+#define REG_AK09916_DMP_READ		0x3
+#define REG_AK09916_STATUS1		0x10
+#define REG_AK09916_CNTL2		0x31
+#define REG_AK09916_MEASURE_DATA	0x11
+
+#define DATA_AKM_ID			0x48
+#define DATA_AKM_MODE_PD		0x00
+#define DATA_AKM_MODE_SM		0x01
+#define DATA_AKM_MODE_ST		0x08
+#define DATA_AK09911_MODE_ST		0x10
+#define DATA_AK09912_MODE_ST		0x10
+#define DATA_AK09916_MODE_ST		0x10
+#define DATA_AKM_MODE_FR		0x0F
+#define DATA_AK09911_MODE_FR		0x1F
+#define DATA_AK09912_MODE_FR		0x1F
+#define DATA_AKM_SELF_TEST		0x40
+#define DATA_AKM_DRDY			0x01
+#define DATA_AKM8963_BIT		0x10
+#define DATA_AKM_STAT_MASK		0x0C
+
+/* 0.3 uT * (1 << 30) */
+#define DATA_AKM8975_SCALE		322122547
+/* 0.6 uT * (1 << 30) */
+#define DATA_AKM8972_SCALE		644245094
+/* 0.6 uT * (1 << 30) */
+#define DATA_AKM8963_SCALE0		644245094
+/* 0.15 uT * (1 << 30) */
+#define DATA_AKM8963_SCALE1		161061273
+/* 0.6 uT * (1 << 30) */
+#define DATA_AK09911_SCALE		644245094
+/* 0.15 uT * (1 << 30) */
+#define DATA_AK09912_SCALE		161061273
+/* 0.15 uT * (1 << 30) */
+#define DATA_AK09916_SCALE		161061273
+#define DATA_MLX_SCALE			(4915 * (1L << 15))
+#define DATA_MLX_SCALE_EMPIRICAL	(26214 * (1L << 15))
+
+#define DATA_AKM8963_SCALE_SHIFT	4
+#define DATA_AKM_MIN_READ_TIME		(9 * NSEC_PER_MSEC)
+
+/* AK09912C NSF */
+/* 0:disable, 1:Low, 2:Middle, 3:High */
+#define DATA_AK9912_NSF			1
+#define DATA_AK9912_NSF_SHIFT		5
+
+#define DEF_ST_COMPASS_WAIT_MIN		(10 * 1000)
+#define DEF_ST_COMPASS_WAIT_MAX		(15 * 1000)
+#define DEF_ST_COMPASS_TRY_TIMES	10
+#define DEF_ST_COMPASS_8963_SHIFT	2
+#define X	0
+#define Y	1
+#define Z	2
+
+/* milliseconds between each access */
+#define AKM_RATE_SCALE			10
+#define MLX_RATE_SCALE			50
+
+static const short AKM8975_ST_Lower[3] = { -100, -100, -1000 };
+static const short AKM8975_ST_Upper[3] = { 100, 100, -300 };
+
+static const short AKM8972_ST_Lower[3] = { -50, -50, -500 };
+static const short AKM8972_ST_Upper[3] = { 50, 50, -100 };
+
+static const short AKM8963_ST_Lower[3] = { -200, -200, -3200 };
+static const short AKM8963_ST_Upper[3] = { 200, 200, -800 };
+
+static const short AK09911_ST_Lower[3] = { -30, -30, -400 };
+static const short AK09911_ST_Upper[3] = { 30, 30, -50 };
+
+static const short AK09912_ST_Lower[3] = { -200, -200, -1600 };
+static const short AK09912_ST_Upper[3] = { 200, 200, -400 };
+
+static const short AK09916_ST_Lower[3] = { -200, -200, -1000 };
+static const short AK09916_ST_Upper[3] = { 200, 200, -200 };
+
+static bool secondary_resume_state;
+/*
+ *  inv_setup_compass_akm() - Configure akm series compass.
+ */
+static int inv_setup_compass_akm(struct inv_mpu_state *st)
+{
+	int result;
+	u8 data[4];
+	u8 sens, mode, cmd, addr;
+
+	addr = st->plat_data.secondary_i2c_addr;
+
+	result = inv_execute_read_secondary(st, 0, addr, REG_AKM_ID, 1, data);
+	if (result) {
+		pr_info("%s: read secondary failed\n", __func__);
+		return result;
+	}
+	if (data[0] != DATA_AKM_ID) {
+		pr_info
+	("%s: DATA_AKM_ID check failed data[0] [%x] ID [%x] Addr [0x%X]\n",
+		__func__, data[0], DATA_AKM_ID, addr);
+		return -ENXIO;
+	}
+
+	/* set AKM register for mode control */
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		mode = REG_AK09911_CNTL2;
+	else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+		mode = REG_AK09912_CNTL2;
+	else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+		mode = REG_AK09916_CNTL2;
+	else
+		mode = REG_AKM_MODE;
+
+	/* AK09916 not have Fuse ROM */
+	if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id) {
+		/* set dummy sens which should be utilized
+		 * in the same manner as AK09912 to make no adjustment. */
+		st->chip_info.compass_sens[0] = 128;
+		st->chip_info.compass_sens[1] = 128;
+		st->chip_info.compass_sens[2] = 128;
+		goto skip_akm_fuse_rom_read;
+	}
+
+	/* set AKM to Fuse ROM access mode */
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id) {
+		sens = REG_AK09911_SENSITIVITY;
+		cmd = DATA_AK09911_MODE_FR;
+	} else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		sens = REG_AK09912_SENSITIVITY;
+		cmd = DATA_AK09912_MODE_FR;
+	} else {
+		sens = REG_AKM_SENSITIVITY;
+		cmd = DATA_AKM_MODE_FR;
+	}
+	inv_set_bank(st, BANK_SEL_3);
+	result = inv_read_secondary(st, 0, addr, sens, THREE_AXES);
+	if (result)
+		return result;
+	result = inv_write_secondary(st, 1, addr, mode, cmd);
+	if (result)
+		return result;
+
+	if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		result = inv_write_secondary(st, 2, addr, REG_AK09912_CNTL1,
+				DATA_AK9912_NSF <<
+				DATA_AK9912_NSF_SHIFT);
+		if (result)
+			return result;
+	}
+	inv_set_bank(st, BANK_SEL_0);
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis |
+			BIT_I2C_MST_EN);
+	msleep(SECONDARY_INIT_WAIT);
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_EXT_SLV_SENS_DATA_00, THREE_AXES,
+			st->chip_info.compass_sens);
+	if (result)
+		return result;
+	result = inv_execute_write_secondary(st, 0, addr, mode,
+			DATA_AKM_MODE_PD);
+	if (result)
+		return result;
+
+skip_akm_fuse_rom_read:
+	pr_debug("%s senx=%d, seny=%d, senz=%d\n",
+		st->hw->name,
+		st->chip_info.compass_sens[0],
+		st->chip_info.compass_sens[1], st->chip_info.compass_sens[2]);
+
+	/* output data for slave 1 is fixed, single measure mode */
+	st->slave_compass->scale = 1;
+	if (COMPASS_ID_AK8975 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AKM8975_ST_Upper;
+		st->slave_compass->st_lower = AKM8975_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else if (COMPASS_ID_AK8972 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AKM8972_ST_Upper;
+		st->slave_compass->st_lower = AKM8972_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else if (COMPASS_ID_AK8963 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AKM8963_ST_Upper;
+		st->slave_compass->st_lower = AKM8963_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM |
+			(st->slave_compass->scale << DATA_AKM8963_SCALE_SHIFT);
+	} else if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AK09911_ST_Upper;
+		st->slave_compass->st_lower = AK09911_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AK09912_ST_Upper;
+		st->slave_compass->st_lower = AK09912_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id) {
+		st->slave_compass->st_upper = AK09916_ST_Upper;
+		st->slave_compass->st_lower = AK09916_ST_Lower;
+		data[0] = DATA_AKM_MODE_SM;
+	} else {
+		return -EINVAL;
+	}
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+	result = inv_write_secondary(st, 1, addr, mode, data[0]);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_SLV2_CTRL, 0);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+static int inv_akm_read_data(struct inv_mpu_state *st, short *o)
+{
+	int result;
+	int i;
+	u8 d[DATA_AKM_99_BYTES_DMP - 1];
+	u8 *sens;
+
+	sens = st->chip_info.compass_sens;
+	result = 0;
+	for (i = 0; i < 6; i++)
+		d[1 + i] = st->fifo_data[i];
+	for (i = 0; i < 3; i++)
+		o[i] = (short)((d[i * 2 + 1] << 8) | d[i * 2 + 2]);
+
+	return result;
+}
+
+static int inv_check_akm_self_test(struct inv_mpu_state *st)
+{
+	int result;
+	u8 data[6], mode, addr;
+	u8 counter, cntl;
+	short x, y, z;
+	u8 *sens;
+	int shift;
+	u8 slv_ctrl[2];
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	u8 odr_cfg;
+#endif
+	addr = st->plat_data.secondary_i2c_addr;
+	sens = st->chip_info.compass_sens;
+
+	/* back up registers */
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+	/* SLV0_CTRL */
+	result = inv_plat_read(st, REG_I2C_SLV0_CTRL, 1, &slv_ctrl[0]);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_SLV0_CTRL, 0);
+	if (result)
+		return result;
+	/* SLV1_CTRL */
+	result = inv_plat_read(st, REG_I2C_SLV1_CTRL, 1, &slv_ctrl[1]);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_SLV1_CTRL, 0);
+	if (result)
+		return result;
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	/* I2C_MST ODR */
+	result = inv_plat_read(st, REG_I2C_MST_ODR_CONFIG, 1, &odr_cfg);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG, 0);
+	if (result)
+		return result;
+#endif
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		mode = REG_AK09911_CNTL2;
+	else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+		mode = REG_AK09912_CNTL2;
+	else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+		mode = REG_AK09916_CNTL2;
+	else
+		mode = REG_AKM_MODE;
+	/* set to power down mode */
+	result = inv_execute_write_secondary(st, 0, addr, mode,
+			DATA_AKM_MODE_PD);
+	if (result)
+		goto AKM_fail;
+
+	/* write 1 to ASTC register */
+	if ((COMPASS_ID_AK09911 != st->plat_data.sec_slave_id) &&
+		(COMPASS_ID_AK09912 != st->plat_data.sec_slave_id) &&
+		(COMPASS_ID_AK09916 != st->plat_data.sec_slave_id)) {
+		result = inv_execute_write_secondary(st, 0, addr,
+				REG_AKM_ST_CTRL,
+				DATA_AKM_SELF_TEST);
+		if (result)
+			goto AKM_fail;
+	}
+	/* set self test mode */
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		result = inv_execute_write_secondary(st, 0, addr, mode,
+				DATA_AK09911_MODE_ST);
+	else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+		result = inv_execute_write_secondary(st, 0, addr, mode,
+				DATA_AK09912_MODE_ST);
+	else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+		result = inv_execute_write_secondary(st, 0, addr, mode,
+				DATA_AK09916_MODE_ST);
+	else
+		result = inv_execute_write_secondary(st, 0, addr, mode,
+				DATA_AKM_MODE_ST);
+
+	if (result)
+		goto AKM_fail;
+	counter = DEF_ST_COMPASS_TRY_TIMES;
+	while (counter > 0) {
+		usleep_range(DEF_ST_COMPASS_WAIT_MIN, DEF_ST_COMPASS_WAIT_MAX);
+		if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+			result = inv_execute_read_secondary(st, 0, addr,
+					REG_AK09911_STATUS1,
+					1, data);
+		else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+			result = inv_execute_read_secondary(st, 0, addr,
+					REG_AK09912_STATUS1,
+					1, data);
+		else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+			result = inv_execute_read_secondary(st, 0, addr,
+					REG_AK09916_STATUS1,
+					1, data);
+		else
+			result = inv_execute_read_secondary(st, 0, addr,
+					REG_AKM_STATUS, 1,
+					data);
+		if (result)
+			goto AKM_fail;
+		if ((data[0] & DATA_AKM_DRDY) == 0)
+			counter--;
+		else
+			counter = 0;
+	}
+	if ((data[0] & DATA_AKM_DRDY) == 0) {
+		result = -EINVAL;
+		goto AKM_fail;
+	}
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id) {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AK09911_MEASURE_DATA,
+				BYTES_PER_SENSOR, data);
+	} else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AK09912_MEASURE_DATA,
+				BYTES_PER_SENSOR, data);
+	} else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id) {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AK09916_MEASURE_DATA,
+				BYTES_PER_SENSOR, data);
+	} else {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AKM_MEASURE_DATA,
+				BYTES_PER_SENSOR, data);
+	}
+	if (result)
+		goto AKM_fail;
+
+	x = le16_to_cpup((__le16 *) (&data[0]));
+	y = le16_to_cpup((__le16 *) (&data[2]));
+	z = le16_to_cpup((__le16 *) (&data[4]));
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		shift = 7;
+	else
+		shift = 8;
+	x = ((x * (sens[0] + 128)) >> shift);
+	y = ((y * (sens[1] + 128)) >> shift);
+	z = ((z * (sens[2] + 128)) >> shift);
+	if (COMPASS_ID_AK8963 == st->plat_data.sec_slave_id) {
+		result = inv_execute_read_secondary(st, 0, addr,
+				REG_AKM8963_CNTL1, 1,
+				&cntl);
+		if (result)
+			goto AKM_fail;
+		if (0 == (cntl & DATA_AKM8963_BIT)) {
+			x <<= DEF_ST_COMPASS_8963_SHIFT;
+			y <<= DEF_ST_COMPASS_8963_SHIFT;
+			z <<= DEF_ST_COMPASS_8963_SHIFT;
+		}
+	}
+
+	pr_debug("lowerx=%d, upperx=%d, x=%d\n",
+		st->slave_compass->st_lower[X],
+		st->slave_compass->st_upper[X], x);
+	pr_debug("lowery=%d, uppery=%d, y=%d\n",
+		st->slave_compass->st_lower[Y],
+		st->slave_compass->st_upper[Y], y);
+	pr_debug("lowerz=%d, upperz=%d, z=%d\n",
+		st->slave_compass->st_lower[Z],
+		st->slave_compass->st_upper[Z], z);
+
+	result = -EINVAL;
+	if (x > st->slave_compass->st_upper[X] ||
+		x < st->slave_compass->st_lower[X])
+		goto AKM_fail;
+	if (y > st->slave_compass->st_upper[Y] ||
+		y < st->slave_compass->st_lower[Y])
+		goto AKM_fail;
+	if (z > st->slave_compass->st_upper[Z] ||
+		z < st->slave_compass->st_lower[Z])
+		goto AKM_fail;
+	result = 0;
+AKM_fail:
+	/*write 0 to ASTC register */
+	if ((COMPASS_ID_AK09911 != st->plat_data.sec_slave_id) &&
+		(COMPASS_ID_AK09912 != st->plat_data.sec_slave_id) &&
+		(COMPASS_ID_AK09916 != st->plat_data.sec_slave_id)) {
+		result |= inv_execute_write_secondary(st, 0, addr,
+				REG_AKM_ST_CTRL, 0);
+	}
+	/*set to power down mode */
+	result |= inv_execute_write_secondary(st, 0, addr, mode,
+			DATA_AKM_MODE_PD);
+
+	/* restore registers */
+	result |= inv_set_bank(st, BANK_SEL_3);
+	result |= inv_plat_single_write(st, REG_I2C_SLV0_CTRL, slv_ctrl[0]);
+	result |= inv_plat_single_write(st, REG_I2C_SLV1_CTRL, slv_ctrl[1]);
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	result |= inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG, odr_cfg);
+#endif
+	result |= inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+/*
+ *  inv_write_akm_scale() - Configure the akm scale range.
+ */
+static int inv_write_akm_scale(struct inv_mpu_state *st, int data)
+{
+	char d, en;
+	int result;
+
+	if (COMPASS_ID_AK8963 != st->plat_data.sec_slave_id)
+		return 0;
+	en = !!data;
+	if (st->slave_compass->scale == en)
+		return 0;
+	d = (DATA_AKM_MODE_SM | (en << DATA_AKM8963_SCALE_SHIFT));
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+	result = inv_plat_single_write(st, REG_I2C_SLV1_DO, d);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+	if (result)
+		return result;
+	st->slave_compass->scale = en;
+
+	return 0;
+}
+
+/*
+ *  inv_read_akm_scale() - show AKM scale.
+ */
+static int inv_read_akm_scale(struct inv_mpu_state *st, int *scale)
+{
+	if (COMPASS_ID_AK8975 == st->plat_data.sec_slave_id)
+		*scale = DATA_AKM8975_SCALE;
+	else if (COMPASS_ID_AK8972 == st->plat_data.sec_slave_id)
+		*scale = DATA_AKM8972_SCALE;
+	else if (COMPASS_ID_AK8963 == st->plat_data.sec_slave_id)
+		if (st->slave_compass->scale)
+			*scale = DATA_AKM8963_SCALE1;
+		else
+			*scale = DATA_AKM8963_SCALE0;
+	else if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id)
+		*scale = DATA_AK09911_SCALE;
+	else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id)
+		*scale = DATA_AK09912_SCALE;
+	else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id)
+		*scale = DATA_AK09916_SCALE;
+	else
+		return -EINVAL;
+
+	return IIO_VAL_INT;
+}
+
+static int inv_suspend_akm(struct inv_mpu_state *st)
+{
+	int result;
+
+	if (!secondary_resume_state)
+		return 0;
+
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+
+	/* slave 0 is disabled */
+	result = inv_plat_single_write(st, REG_I2C_SLV0_CTRL, 0);
+	if (result)
+		return result;
+	/* slave 1 is disabled */
+	result = inv_plat_single_write(st, REG_I2C_SLV1_CTRL, 0);
+	if (result)
+		return result;
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	secondary_resume_state = false;
+
+	return result;
+}
+
+static int inv_resume_akm(struct inv_mpu_state *st)
+{
+	int result;
+	u8 reg_addr, bytes;
+
+	if (secondary_resume_state)
+		return 0;
+
+	result = inv_set_bank(st, BANK_SEL_3);
+	if (result)
+		return result;
+
+	/* slave 0 is used to read data from compass */
+	/*read mode */
+	result = inv_plat_single_write(st, REG_I2C_SLV0_ADDR,
+			INV_MPU_BIT_I2C_READ |
+			st->plat_data.secondary_i2c_addr);
+	if (result)
+		return result;
+	/* AKM status register address is 1 */
+	if (COMPASS_ID_AK09911 == st->plat_data.sec_slave_id) {
+		reg_addr = REG_AK09911_DMP_READ;
+		bytes = DATA_AKM_99_BYTES_DMP;
+	} else if (COMPASS_ID_AK09912 == st->plat_data.sec_slave_id) {
+		reg_addr = REG_AK09912_DMP_READ;
+		bytes = DATA_AKM_99_BYTES_DMP;
+	} else if (COMPASS_ID_AK09916 == st->plat_data.sec_slave_id) {
+		reg_addr = REG_AK09916_DMP_READ;
+		bytes = DATA_AKM_99_BYTES_DMP;
+	} else {
+		reg_addr = REG_AKM_INFO;
+		bytes = DATA_AKM_89_BYTES_DMP;
+	}
+	result = inv_plat_single_write(st, REG_I2C_SLV0_REG, reg_addr);
+	if (result)
+		return result;
+
+	/* slave 0 is enabled, read 10 or 8 bytes from here, swap bytes */
+	result = inv_plat_single_write(st, REG_I2C_SLV0_CTRL,
+			INV_MPU_BIT_GRP |
+			INV_MPU_BIT_BYTE_SW |
+			INV_MPU_BIT_SLV_EN | bytes);
+	if (result)
+		return result;
+	/* slave 1 is enabled, write byte length is 1 */
+	result = inv_plat_single_write(st, REG_I2C_SLV1_CTRL,
+			INV_MPU_BIT_SLV_EN | 1);
+	if (result)
+		return result;
+
+	result = inv_set_bank(st, BANK_SEL_0);
+
+	secondary_resume_state = true;
+
+	return result;
+}
+
+static struct inv_mpu_slave slave_akm = {
+	.suspend = inv_suspend_akm,
+	.resume = inv_resume_akm,
+	.get_scale = inv_read_akm_scale,
+	.set_scale = inv_write_akm_scale,
+	.self_test = inv_check_akm_self_test,
+	.setup = inv_setup_compass_akm,
+	.read_data = inv_akm_read_data,
+	.rate_scale = AKM_RATE_SCALE,
+	.min_read_time = DATA_AKM_MIN_READ_TIME,
+};
+
+int inv_mpu_setup_compass_slave(struct inv_mpu_state *st)
+{
+	switch (st->plat_data.sec_slave_id) {
+	case COMPASS_ID_AK8975:
+	case COMPASS_ID_AK8972:
+	case COMPASS_ID_AK8963:
+	case COMPASS_ID_AK09911:
+	case COMPASS_ID_AK09912:
+	case COMPASS_ID_AK09916:
+		st->slave_compass = &slave_akm;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return st->slave_compass->setup(st);
+}
diff --git a/drivers/iio/imu/inv_mpu/icm20648/inv_slave_pressure.c b/drivers/iio/imu/inv_mpu/icm20648/inv_slave_pressure.c
new file mode 100644
index 000000000000..7ca2420de9c5
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/icm20648/inv_slave_pressure.c
@@ -0,0 +1,521 @@
+/*
+* Copyright (C) 2017-2018 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include "../inv_mpu_iio.h"
+
+/* Constants */
+#define SHIFT_RIGHT_4_POSITION				 4
+#define SHIFT_LEFT_2_POSITION                2
+#define SHIFT_LEFT_4_POSITION                4
+#define SHIFT_LEFT_5_POSITION                5
+#define SHIFT_LEFT_8_POSITION                8
+#define SHIFT_LEFT_12_POSITION               12
+#define SHIFT_LEFT_16_POSITION               16
+
+/* Sensor Specific constants */
+#define BMP280_SLEEP_MODE                    0x00
+#define BMP280_FORCED_MODE                   0x01
+#define BMP280_NORMAL_MODE                   0x03
+#define BMP280_SOFT_RESET                    0xB6
+
+#define BMP280_DELAYTIME_MS_NONE             0
+#define BMP280_DELAYTIME_MS_5                5
+#define BMP280_DELAYTIME_MS_6                6
+#define BMP280_DELAYTIME_MS_8                8
+#define BMP280_DELAYTIME_MS_12               12
+#define BMP280_DELAYTIME_MS_22               22
+#define BMP280_DELAYTIME_MS_38               38
+
+#define BMP280_OVERSAMPLING_SKIPPED          0x00
+#define BMP280_OVERSAMPLING_1X               0x01
+#define BMP280_OVERSAMPLING_2X               0x02
+#define BMP280_OVERSAMPLING_4X               0x03
+#define BMP280_OVERSAMPLING_8X               0x04
+#define BMP280_OVERSAMPLING_16X              0x05
+
+#define BMP280_ULTRALOWPOWER_MODE            0x00
+#define BMP280_LOWPOWER_MODE	             0x01
+#define BMP280_STANDARDRESOLUTION_MODE       0x02
+#define BMP280_HIGHRESOLUTION_MODE           0x03
+#define BMP280_ULTRAHIGHRESOLUTION_MODE      0x04
+
+#define BMP280_ULTRALOWPOWER_OSRS_P          BMP280_OVERSAMPLING_1X
+#define BMP280_ULTRALOWPOWER_OSRS_T          BMP280_OVERSAMPLING_1X
+
+#define BMP280_LOWPOWER_OSRS_P	             BMP280_OVERSAMPLING_2X
+#define BMP280_LOWPOWER_OSRS_T	             BMP280_OVERSAMPLING_1X
+
+#define BMP280_STANDARDRESOLUTION_OSRS_P     BMP280_OVERSAMPLING_4X
+#define BMP280_STANDARDRESOLUTION_OSRS_T     BMP280_OVERSAMPLING_1X
+
+#define BMP280_HIGHRESOLUTION_OSRS_P         BMP280_OVERSAMPLING_8X
+#define BMP280_HIGHRESOLUTION_OSRS_T         BMP280_OVERSAMPLING_1X
+
+#define BMP280_ULTRAHIGHRESOLUTION_OSRS_P    BMP280_OVERSAMPLING_16X
+#define BMP280_ULTRAHIGHRESOLUTION_OSRS_T    BMP280_OVERSAMPLING_2X
+
+#define BMP280_FILTERCOEFF_OFF               0x00
+#define BMP280_FILTERCOEFF_2                 0x01
+#define BMP280_FILTERCOEFF_4                 0x02
+#define BMP280_FILTERCOEFF_8                 0x03
+#define BMP280_FILTERCOEFF_16                0x04
+
+/*calibration parameters */
+#define BMP280_DIG_T1_LSB_REG                0x88
+#define BMP280_DIG_T1_MSB_REG                0x89
+#define BMP280_DIG_T2_LSB_REG                0x8A
+#define BMP280_DIG_T2_MSB_REG                0x8B
+#define BMP280_DIG_T3_LSB_REG                0x8C
+#define BMP280_DIG_T3_MSB_REG                0x8D
+#define BMP280_DIG_P1_LSB_REG                0x8E
+#define BMP280_DIG_P1_MSB_REG                0x8F
+#define BMP280_DIG_P2_LSB_REG                0x90
+#define BMP280_DIG_P2_MSB_REG                0x91
+#define BMP280_DIG_P3_LSB_REG                0x92
+#define BMP280_DIG_P3_MSB_REG                0x93
+#define BMP280_DIG_P4_LSB_REG                0x94
+#define BMP280_DIG_P4_MSB_REG                0x95
+#define BMP280_DIG_P5_LSB_REG                0x96
+#define BMP280_DIG_P5_MSB_REG                0x97
+#define BMP280_DIG_P6_LSB_REG                0x98
+#define BMP280_DIG_P6_MSB_REG                0x99
+#define BMP280_DIG_P7_LSB_REG                0x9A
+#define BMP280_DIG_P7_MSB_REG                0x9B
+#define BMP280_DIG_P8_LSB_REG                0x9C
+#define BMP280_DIG_P8_MSB_REG                0x9D
+#define BMP280_DIG_P9_LSB_REG                0x9E
+#define BMP280_DIG_P9_MSB_REG                0x9F
+
+#define BMP280_CHIPID_REG                    0xD0	/*Chip ID Register */
+#define BMP280_RESET_REG                     0xE0	/*Softreset Register */
+#define BMP280_STATUS_REG                    0xF3	/*Status Register */
+#define BMP280_CTRLMEAS_REG                  0xF4  /*Ctrl Measure Register */
+#define BMP280_CONFIG_REG                    0xF5  /*Configuration Register */
+#define BMP280_PRESSURE_MSB_REG              0xF7   /*Pressure MSB Register */
+#define BMP280_PRESSURE_LSB_REG              0xF8   /*Pressure LSB Register */
+#define BMP280_PRESSURE_XLSB_REG             0xF9  /*Pressure XLSB Register */
+#define BMP280_TEMPERATURE_MSB_REG           0xFA  /*Temperature MSB Reg */
+#define BMP280_TEMPERATURE_LSB_REG           0xFB  /*Temperature LSB Reg */
+#define BMP280_TEMPERATURE_XLSB_REG          0xFC  /*Temperature XLSB Reg */
+
+/* Status Register */
+#define BMP280_STATUS_REG_MEASURING__POS           3
+#define BMP280_STATUS_REG_MEASURING__MSK           0x08
+#define BMP280_STATUS_REG_MEASURING__LEN           1
+#define BMP280_STATUS_REG_MEASURING__REG           BMP280_STATUS_REG
+
+#define BMP280_STATUS_REG_IMUPDATE__POS            0
+#define BMP280_STATUS_REG_IMUPDATE__MSK            0x01
+#define BMP280_STATUS_REG_IMUPDATE__LEN            1
+#define BMP280_STATUS_REG_IMUPDATE__REG            BMP280_STATUS_REG
+
+/* Control Measurement Register */
+#define BMP280_CTRLMEAS_REG_OSRST__POS             5
+#define BMP280_CTRLMEAS_REG_OSRST__MSK             0xE0
+#define BMP280_CTRLMEAS_REG_OSRST__LEN             3
+#define BMP280_CTRLMEAS_REG_OSRST__REG             BMP280_CTRLMEAS_REG
+
+#define BMP280_CTRLMEAS_REG_OSRSP__POS             2
+#define BMP280_CTRLMEAS_REG_OSRSP__MSK             0x1C
+#define BMP280_CTRLMEAS_REG_OSRSP__LEN             3
+#define BMP280_CTRLMEAS_REG_OSRSP__REG             BMP280_CTRLMEAS_REG
+
+#define BMP280_CTRLMEAS_REG_MODE__POS              0
+#define BMP280_CTRLMEAS_REG_MODE__MSK              0x03
+#define BMP280_CTRLMEAS_REG_MODE__LEN              2
+#define BMP280_CTRLMEAS_REG_MODE__REG              BMP280_CTRLMEAS_REG
+
+/* Configuation Register */
+#define BMP280_CONFIG_REG_TSB__POS                 5
+#define BMP280_CONFIG_REG_TSB__MSK                 0xE0
+#define BMP280_CONFIG_REG_TSB__LEN                 3
+#define BMP280_CONFIG_REG_TSB__REG                 BMP280_CONFIG_REG
+
+#define BMP280_CONFIG_REG_FILTER__POS              2
+#define BMP280_CONFIG_REG_FILTER__MSK              0x1C
+#define BMP280_CONFIG_REG_FILTER__LEN              3
+#define BMP280_CONFIG_REG_FILTER__REG              BMP280_CONFIG_REG
+
+#define BMP280_CONFIG_REG_SPI3WEN__POS             0
+#define BMP280_CONFIG_REG_SPI3WEN__MSK             0x01
+#define BMP280_CONFIG_REG_SPI3WEN__LEN             1
+#define BMP280_CONFIG_REG_SPI3WEN__REG             BMP280_CONFIG_REG
+
+/* Data Register */
+#define BMP280_PRESSURE_XLSB_REG_DATA__POS         4
+#define BMP280_PRESSURE_XLSB_REG_DATA__MSK         0xF0
+#define BMP280_PRESSURE_XLSB_REG_DATA__LEN         4
+#define BMP280_PRESSURE_XLSB_REG_DATA__REG         BMP280_PRESSURE_XLSB_REG
+
+#define BMP280_TEMPERATURE_XLSB_REG_DATA__POS      4
+#define BMP280_TEMPERATURE_XLSB_REG_DATA__MSK      0xF0
+#define BMP280_TEMPERATURE_XLSB_REG_DATA__LEN      4
+#define BMP280_TEMPERATURE_XLSB_REG_DATA__REG      BMP280_TEMPERATURE_XLSB_REG
+
+#define BMP280_RATE_SCALE  35
+#define DATA_BMP280_MIN_READ_TIME            (32 * NSEC_PER_MSEC)
+#define BMP280_DATA_BYTES                6
+#define DATA_BMP280_ID                   0x58
+static int odr_config[] = { 166, 15, 8, 4, 2, 1 };
+
+/** this structure holds all device specific calibration parameters */
+struct bmp280_calibration_param_t {
+	u32 dig_T1;
+	s32 dig_T2;
+	s32 dig_T3;
+	u32 dig_P1;
+	s32 dig_P2;
+	s32 dig_P3;
+	s32 dig_P4;
+	s32 dig_P5;
+	s32 dig_P6;
+	s32 dig_P7;
+	s32 dig_P8;
+	s32 dig_P9;
+
+	s32 t_fine;
+};
+/** BMP280 image registers data structure */
+struct bmp280_t {
+	struct bmp280_calibration_param_t cal_param;
+
+	u8 chip_id;
+	u8 dev_addr;
+
+	u8 waittime;
+
+	u8 osrs_t;
+	u8 osrs_p;
+};
+static struct bmp280_t bmp280;
+static bool secondary_resume_state;
+static int curr_t_sb;
+
+static int bmp280_get_calib_param(struct inv_mpu_state *st)
+{
+	u8 d[24];
+	int r;
+
+	r = inv_execute_read_secondary(st, 3,
+				       st->plat_data.aux_i2c_addr,
+				       BMP280_DIG_T1_LSB_REG, 12, d);
+	if (r)
+		return r;
+	r = inv_execute_read_secondary(st, 3,
+				       st->plat_data.aux_i2c_addr,
+				       BMP280_DIG_T1_LSB_REG + 12, 12, &d[12]);
+	if (r)
+		return r;
+
+	bmp280.cal_param.dig_T1 = (u16) ((((u16) ((u8) d[1])) <<
+					  SHIFT_LEFT_8_POSITION) | d[0]);
+	bmp280.cal_param.dig_T2 = (s16) ((((s16) ((s8) d[3])) <<
+					  SHIFT_LEFT_8_POSITION) | d[2]);
+	bmp280.cal_param.dig_T3 = (s16) ((((s16) ((s8) d[5])) <<
+					  SHIFT_LEFT_8_POSITION) | d[4]);
+	bmp280.cal_param.dig_P1 = (u16) ((((u16) ((u8) d[7])) <<
+					  SHIFT_LEFT_8_POSITION) | d[6]);
+	bmp280.cal_param.dig_P2 = (s16) ((((s16) ((s8) d[9])) <<
+					  SHIFT_LEFT_8_POSITION) | d[8]);
+	bmp280.cal_param.dig_P3 = (s16) ((((s16) ((s8) d[11])) <<
+					  SHIFT_LEFT_8_POSITION) | d[10]);
+	bmp280.cal_param.dig_P4 = (s16) ((((s16) ((s8) d[13])) <<
+					  SHIFT_LEFT_8_POSITION) | d[12]);
+	bmp280.cal_param.dig_P5 = (s16) ((((s16) ((s8) d[15])) <<
+					  SHIFT_LEFT_8_POSITION) | d[14]);
+	bmp280.cal_param.dig_P6 = (s16) ((((s16) ((s8) d[17])) <<
+					  SHIFT_LEFT_8_POSITION) | d[16]);
+	bmp280.cal_param.dig_P7 = (s16) ((((s16) ((s8) d[19])) <<
+					  SHIFT_LEFT_8_POSITION) | d[18]);
+	bmp280.cal_param.dig_P8 = (s16) ((((s16) ((s8) d[21])) <<
+					  SHIFT_LEFT_8_POSITION) | d[20]);
+	bmp280.cal_param.dig_P9 = (s16) ((((s16) ((s8) d[23])) <<
+					  SHIFT_LEFT_8_POSITION) | d[22]);
+
+	return 0;
+}
+
+static int inv_setup_bmp280(struct inv_mpu_state *st)
+{
+	int r;
+	u8 d[1], addr;
+
+	addr = st->plat_data.aux_i2c_addr;
+	/* issue soft reset */
+	r = inv_execute_write_secondary(st, 3, addr,
+					BMP280_RESET_REG, BMP280_SOFT_RESET);
+	if (r)
+		return r;
+
+	msleep(100);
+
+	r = inv_execute_read_secondary(st, 3, addr, BMP280_CHIPID_REG, 1, d);
+	if (r)
+		return r;
+	if (d[0] != DATA_BMP280_ID) {
+		pr_info("BMP280 not found. Addr:0x%02X, ID:0x%02X (expected:0x%02X)\n",
+				addr, d[0], DATA_BMP280_ID);
+		return -ENXIO;
+	}
+	pr_info("BMP280 found. Addr:0x%02X, ID:0x%02X\n", addr, d[0]);
+
+	/* set pressure as ultra high resolution */
+	bmp280.osrs_t = BMP280_ULTRAHIGHRESOLUTION_OSRS_T;
+	bmp280.osrs_p = BMP280_ULTRAHIGHRESOLUTION_OSRS_P;
+
+	r = bmp280_get_calib_param(st);
+
+	return r;
+}
+
+static int inv_check_bmp280_self_test(struct inv_mpu_state *st)
+{
+	return 0;
+}
+
+static int inv_write_bmp280_scale(struct inv_mpu_state *st, int data)
+{
+	return 0;
+}
+
+static int inv_read_bmp280_scale(struct inv_mpu_state *st, int *scale)
+{
+	return 0;
+}
+
+static int inv_resume_bmp280(struct inv_mpu_state *st)
+{
+	int r, rate, i;
+	u8 d, addr;
+
+	rate = st->sensor[SENSOR_PRESSURE].rate;
+	i = 0;
+	while (rate < odr_config[i])
+		i++;
+
+	r = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (r)
+		return r;
+	curr_t_sb = i;
+
+	addr = st->plat_data.aux_i2c_addr;
+	r = inv_set_bank(st, BANK_SEL_3);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG,
+				  MIN_MST_ODR_CONFIG);
+	if (r)
+		return r;
+	if (!st->chip_config.compass_enable) {
+		r = inv_plat_single_write(st, st->slv_reg[0].ctrl, 0);
+		if (r)
+			return r;
+	}
+	if (!st->chip_config.als_enable) {
+		r = inv_plat_single_write(st, st->slv_reg[2].ctrl, 0);
+		if (r)
+			return r;
+	}
+
+	/* set IIR filter as 4 */
+	d = (i << SHIFT_LEFT_5_POSITION) |
+	    (BMP280_FILTERCOEFF_16 << SHIFT_LEFT_2_POSITION);
+	r = inv_execute_write_secondary(st, 3, addr,
+					BMP280_CONFIG_REG_FILTER__REG, d);
+	if (r)
+		return r;
+
+	d = (bmp280.osrs_t << SHIFT_LEFT_5_POSITION) +
+	    (bmp280.osrs_p << SHIFT_LEFT_2_POSITION) + BMP280_NORMAL_MODE;
+	r = inv_execute_write_secondary(st, 3, addr, BMP280_CTRLMEAS_REG, d);
+	if (r)
+		return r;
+	r = inv_set_bank(st, BANK_SEL_3);
+	if (r)
+		return r;
+
+	/* slave 3 is used to read data from pressure sensor */
+	/*read mode */
+	r = inv_read_secondary(st, 3, addr, BMP280_PRESSURE_MSB_REG,
+			       BMP280_DATA_BYTES);
+	if (r)
+		return r;
+	r = inv_set_bank(st, BANK_SEL_0);
+
+	secondary_resume_state = true;
+
+	return r;
+}
+
+static int inv_suspend_bmp280(struct inv_mpu_state *st)
+{
+	int r;
+
+	if (!secondary_resume_state)
+		return 0;
+	r = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (r)
+		return r;
+
+	r = inv_set_bank(st, BANK_SEL_3);
+	if (r)
+		return r;
+	r = inv_plat_single_write(st, REG_I2C_MST_ODR_CONFIG,
+				  MIN_MST_ODR_CONFIG);
+	if (r)
+		return r;
+	if (!st->chip_config.compass_enable) {
+		r = inv_plat_single_write(st, st->slv_reg[0].ctrl, 0);
+		if (r)
+			return r;
+	}
+	if (!st->chip_config.als_enable) {
+		r = inv_plat_single_write(st, st->slv_reg[2].ctrl, 0);
+		if (r)
+			return r;
+	}
+	/* make pressure into sleep mode */
+	r = inv_execute_write_secondary(st, 3, st->plat_data.aux_i2c_addr,
+					BMP280_CTRLMEAS_REG, 0);
+	if (r)
+		return r;
+	r = inv_set_bank(st, BANK_SEL_3);
+	if (r)
+		return r;
+
+	/* slave 3 is disabled */
+	r = inv_plat_single_write(st, REG_I2C_SLV3_CTRL, 0);
+	if (r)
+		return r;
+	r = inv_set_bank(st, BANK_SEL_0);
+
+	secondary_resume_state = false;
+
+	return r;
+}
+
+static s32 bmp280_compensate_T_int32(s32 adc_t)
+{
+	s32 v_x1_u32r = 0;
+	s32 v_x2_u32r = 0;
+	s32 temperature = 0;
+
+	v_x1_u32r = ((((adc_t >> 3) - ((s32)
+				       bmp280.cal_param.dig_T1 << 1))) *
+		     ((s32) bmp280.cal_param.dig_T2)) >> 11;
+	v_x2_u32r = (((((adc_t >> 4) -
+			((s32) bmp280.cal_param.dig_T1)) * ((adc_t >> 4) -
+							    ((s32) bmp280.
+							     cal_param.
+							     dig_T1))) >> 12) *
+		     ((s32) bmp280.cal_param.dig_T3)) >> 14;
+	bmp280.cal_param.t_fine = v_x1_u32r + v_x2_u32r;
+	temperature = (bmp280.cal_param.t_fine * 5 + 128) >> 8;
+
+	return temperature;
+}
+
+static u32 bmp280_compensate_P_int32(s32 adc_p)
+{
+	s32 v_x1_u32r = 0;
+	s32 v_x2_u32r = 0;
+	u32 pressure = 0;
+
+	v_x1_u32r = (((s32) bmp280.cal_param.t_fine) >> 1) - (s32) 64000;
+	v_x2_u32r = (((v_x1_u32r >> 2) * (v_x1_u32r >> 2)) >> 11) *
+	    ((s32) bmp280.cal_param.dig_P6);
+	v_x2_u32r = v_x2_u32r + ((v_x1_u32r *
+				  ((s32) bmp280.cal_param.dig_P5)) << 1);
+	v_x2_u32r = (v_x2_u32r >> 2) + (((s32) bmp280.cal_param.dig_P4) << 16);
+	v_x1_u32r = (((bmp280.cal_param.dig_P3 * (((v_x1_u32r >> 2) *
+						   (v_x1_u32r >> 2)) >> 13)) >>
+		      3) +
+		     ((((s32) bmp280.cal_param.dig_P2) *
+		       v_x1_u32r) >> 1)) >> 18;
+	v_x1_u32r =
+	    ((((32768 + v_x1_u32r)) * ((s32) bmp280.cal_param.dig_P1)) >> 15);
+	/* Avoid exception caused by division by zero */
+	if (v_x1_u32r == 0)
+		return 0;
+	pressure = (((u32) (((s32) 1048576) - adc_p) -
+		     (v_x2_u32r >> 12))) * 3125;
+	if (pressure < 0x80000000)
+		pressure = (pressure << 1) / ((u32) v_x1_u32r);
+	else
+		pressure = (pressure / (u32) v_x1_u32r) * 2;
+	v_x1_u32r = (((s32) bmp280.cal_param.dig_P9) *
+		     ((s32) (((pressure >> 3) * (pressure >> 3)) >> 13)))
+	    >> 12;
+	v_x2_u32r = (((s32) (pressure >> 2)) *
+		     ((s32) bmp280.cal_param.dig_P8)) >> 13;
+	pressure = (u32) ((s32) pressure +
+			  ((v_x1_u32r + v_x2_u32r +
+			    bmp280.cal_param.dig_P7) >> 4));
+
+	return pressure;
+}
+
+static int inv_bmp280_read_data(struct inv_mpu_state *st, short *o)
+{
+	int r;
+	u8 *d;
+	s32 upressure, utemperature;
+
+	d = st->fifo_data;
+	/* pressure */
+	upressure = (s32) ((((s32) (d[0]))
+			    << SHIFT_LEFT_12_POSITION) | (((u32) (d[1]))
+							  <<
+							  SHIFT_LEFT_4_POSITION)
+			   | ((u32) d[2] >> SHIFT_RIGHT_4_POSITION));
+
+	/* Temperature */
+	utemperature = (s32) ((((s32) (d[3])) << SHIFT_LEFT_12_POSITION) |
+			      (((u32) (d[4])) << SHIFT_LEFT_4_POSITION)
+			      | ((u32) d[5] >> SHIFT_RIGHT_4_POSITION));
+
+	bmp280_compensate_T_int32(utemperature);
+	r = bmp280_compensate_P_int32(upressure);
+	r *= 100; /* Pa x 100 */
+	o[0] = 0;
+	o[1] = (r >> 16);
+	o[2] = (r & 0xffff);
+
+	return 0;
+}
+
+static struct inv_mpu_slave slave_bmp280 = {
+	.suspend = inv_suspend_bmp280,
+	.resume = inv_resume_bmp280,
+	.get_scale = inv_read_bmp280_scale,
+	.set_scale = inv_write_bmp280_scale,
+	.self_test = inv_check_bmp280_self_test,
+	.setup = inv_setup_bmp280,
+	.read_data = inv_bmp280_read_data,
+	.rate_scale = BMP280_RATE_SCALE,
+	.min_read_time = DATA_BMP280_MIN_READ_TIME,
+};
+
+int inv_mpu_setup_pressure_slave(struct inv_mpu_state *st)
+{
+	switch (st->plat_data.aux_slave_id) {
+	case PRESSURE_ID_BMP280:
+		st->slave_pressure = &slave_bmp280;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return st->slave_pressure->setup(st);
+}
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_common.c b/drivers/iio/imu/inv_mpu/inv_mpu_common.c
new file mode 100644
index 000000000000..94d46f832c14
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_common.c
@@ -0,0 +1,1238 @@
+/*
+ * Copyright (C) 2012-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+#include "inv_mpu_iio.h"
+#ifdef CONFIG_RTC_INTF_ALARM
+#include <linux/android_alarm.h>
+#endif
+#include <linux/export.h>
+#include <linux/version.h>
+
+#ifdef CONFIG_RTC_INTF_ALARM
+s64 get_time_ns(void)
+{
+	struct timespec ts;
+
+	/* get_monotonic_boottime(&ts); */
+
+	/* Workaround for some platform on which monotonic clock and
+	 * Android SystemClock has a gap.
+	 * Use ktime_to_timespec(alarm_get_elapsed_realtime()) instead of
+	 * get_monotonic_boottime() for these platform
+	 */
+
+	ts = ktime_to_timespec(alarm_get_elapsed_realtime());
+
+	return timespec_to_ns(&ts);
+}
+#else
+s64 get_time_ns(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 19, 0)
+	/* kernel ~4.18 */
+	struct timespec ts;
+	get_monotonic_boottime(&ts);
+	return timespec_to_ns(&ts);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+	/* kernel 4.19~5.2 */
+	return ktime_get_boot_ns();
+#else
+	/* kernel 5.3~ */
+	return ktime_get_boottime_ns();
+#endif
+}
+
+#endif
+
+#ifdef ACCEL_BIAS_TEST
+int inv_get_3axis_average(s16 src[], s16 dst[], s16 reset)
+{
+#define BUFFER_SIZE 200
+	static s16 buffer[BUFFER_SIZE][3];
+	static s16 current_position;
+	static s16 ready;
+	int sum[3] = {0,};
+	int i;
+
+	if (reset) {
+		current_position = 0;
+		ready = 0;
+	}
+	buffer[current_position][0] = src[0];
+	buffer[current_position][1] = src[1];
+	buffer[current_position][2] = src[2];
+	current_position++;
+	if (current_position == BUFFER_SIZE) {
+		ready = 1;
+		current_position = 0;
+	}
+	if (ready) {
+		for (i = 0; i < BUFFER_SIZE; i++) {
+			sum[0] += buffer[i][0];
+			sum[1] += buffer[i][1];
+			sum[2] += buffer[i][2];
+		}
+		dst[0] = sum[0]/BUFFER_SIZE;
+		dst[1] = sum[1]/BUFFER_SIZE;
+		dst[2] = sum[2]/BUFFER_SIZE;
+		return 1;
+	}
+	return 0;
+}
+#endif
+
+int inv_q30_mult(int a, int b)
+{
+#define DMP_MULTI_SHIFT                 30
+	u64 temp;
+	int result;
+
+	temp = ((u64)a) * b;
+	result = (int)(temp >> DMP_MULTI_SHIFT);
+
+	return result;
+}
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) || \
+					defined(CONFIG_INV_MPU_IIO_ICM20690)
+/* inv_read_secondary(): set secondary registers for reading.
+ * ICM20648: The chip must be set as bank 3 before calling.
+ */
+int inv_read_secondary(struct inv_mpu_state *st, int ind, int addr,
+		       int reg, int len)
+{
+	int result;
+
+	/* I2C address */
+	result = inv_plat_single_write(st, st->slv_reg[ind].addr,
+				       INV_MPU_BIT_I2C_READ | addr);
+	if (result)
+		return result;
+	/* Register address */
+	result = inv_plat_single_write(st, st->slv_reg[ind].reg, reg);
+	if (result)
+		return result;
+	/* Enable SLV channel */
+	result = inv_plat_single_write(st, st->slv_reg[ind].ctrl,
+				       INV_MPU_BIT_SLV_EN | len);
+
+	return result;
+}
+
+int inv_execute_read_secondary(struct inv_mpu_state *st, int ind, int addr,
+			       int reg, int len, u8 *d)
+{
+	int result;
+
+	inv_set_bank(st, BANK_SEL_3);
+	result = inv_read_secondary(st, ind, addr, reg, len);
+	if (result)
+		return result;
+
+	inv_set_bank(st, BANK_SEL_0);
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis |
+				       BIT_I2C_MST_EN);
+	if (result)
+		return result;
+	msleep(SECONDARY_INIT_WAIT);
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (result)
+		return result;
+	result = inv_plat_read(st, REG_EXT_SLV_SENS_DATA_00, len, d);
+	if (result)
+		return result;
+
+	/* Disable SLV channel */
+	inv_set_bank(st, BANK_SEL_3);
+	result = inv_plat_single_write(st, st->slv_reg[ind].ctrl, 0);
+	inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+/* inv_write_secondary(): set secondary registers for writing.
+ * ICM20648: The chip must be set as bank 3 before calling.
+ */
+int inv_write_secondary(struct inv_mpu_state *st, int ind, int addr,
+			int reg, int v)
+{
+	int result;
+
+	/* I2C address */
+	result = inv_plat_single_write(st, st->slv_reg[ind].addr, addr);
+	if (result)
+		return result;
+	/* Register address */
+	result = inv_plat_single_write(st, st->slv_reg[ind].reg, reg);
+	if (result)
+		return result;
+	/* Output data */
+	result = inv_plat_single_write(st, st->slv_reg[ind].d0, v);
+	if (result)
+		return result;
+	/* Enable SLV channel */
+	result = inv_plat_single_write(st, st->slv_reg[ind].ctrl,
+				       INV_MPU_BIT_SLV_EN | 1);
+
+	return result;
+}
+
+int inv_execute_write_secondary(struct inv_mpu_state *st, int ind, int addr,
+				int reg, int v)
+{
+	int result;
+
+	inv_set_bank(st, BANK_SEL_3);
+	result = inv_write_secondary(st, ind, addr, reg, v);
+	if (result)
+		return result;
+
+	inv_set_bank(st, BANK_SEL_0);
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis |
+				       BIT_I2C_MST_EN);
+	if (result)
+		return result;
+	msleep(SECONDARY_INIT_WAIT);
+	result = inv_plat_single_write(st, REG_USER_CTRL, st->i2c_dis);
+	if (result)
+		return result;
+
+	/* Disable SLV channel */
+	inv_set_bank(st, BANK_SEL_3);
+	result = inv_plat_single_write(st, st->slv_reg[ind].ctrl, 0);
+	inv_set_bank(st, BANK_SEL_0);
+
+	return result;
+}
+
+int inv_set_bank(struct inv_mpu_state *st, u8 bank)
+{
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	int r;
+
+	r = inv_plat_single_write(st, REG_BANK_SEL, bank);
+
+	return r;
+#else
+	return 0;
+#endif
+}
+#endif
+
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+/**
+ *  inv_write_cntl() - Write control word to designated address.
+ *  @st:	Device driver instance.
+ *  @wd:        control word.
+ *  @en:	enable/disable.
+ *  @cntl:	control address to be written.
+ */
+int inv_write_cntl(struct inv_mpu_state *st, u16 wd, bool en, int cntl)
+{
+	int result;
+	u8 reg[2], d_out[2];
+
+	result = mem_r(cntl, 2, d_out);
+	if (result)
+		return result;
+	reg[0] = ((wd >> 8) & 0xff);
+	reg[1] = (wd & 0xff);
+	if (!en) {
+		d_out[0] &= ~reg[0];
+		d_out[1] &= ~reg[1];
+	} else {
+		d_out[0] |= reg[0];
+		d_out[1] |= reg[1];
+	}
+	result = mem_w(cntl, 2, d_out);
+
+	return result;
+}
+#endif
+
+int inv_set_power(struct inv_mpu_state *st, bool power_on)
+{
+#if defined(CONFIG_INV_MPU_IIO_ICM42600)
+	if ((!power_on) == st->chip_config.is_asleep)
+		return 0;
+	st->chip_config.is_asleep = !power_on;
+#else
+	u8 d;
+	int r;
+
+	if ((!power_on) == st->chip_config.is_asleep)
+		return 0;
+
+	d = BIT_CLK_PLL;
+	if (!power_on)
+		d |= BIT_SLEEP;
+
+	r = inv_plat_single_write(st, REG_PWR_MGMT_1, d);
+	if (r)
+		return r;
+
+	if (power_on)
+		usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+
+	st->chip_config.is_asleep = !power_on;
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(inv_set_power);
+
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+static int inv_lp_en_on_mode(struct inv_mpu_state *st, bool on)
+{
+	int r = 0;
+	u8 w;
+
+	if ((!st->chip_config.is_asleep) &&
+	    ((!on) == st->chip_config.lp_en_set))
+		return 0;
+
+	w = BIT_CLK_PLL;
+	if ((!on) && (!st->eis.eis_triggered))
+		w |= BIT_LP_EN;
+	r = inv_plat_single_write(st, REG_PWR_MGMT_1, w);
+	if (on)
+		usleep_range(70, 100);
+	st->chip_config.is_asleep = 0;
+	st->chip_config.lp_en_set = (!on);
+	return r;
+}
+#endif
+#if defined(CONFIG_INV_MPU_IIO_ICM20602) \
+	|| defined(CONFIG_INV_MPU_IIO_ICM20689) \
+	|| defined(CONFIG_INV_MPU_IIO_ICM20690) \
+	|| defined(CONFIG_INV_MPU_IIO_IAM20680)
+int inv_set_accel_config2(struct inv_mpu_state *st, bool cycle_mode)
+{
+	int cycle_freq[] = {275, 192, 111, 59};
+	int cont_freq[] = {219, 219, 99, 45, 22, 11, 6};
+	int i, r, rate;
+	u8 v;
+
+	v = 0;
+#ifdef CONFIG_INV_MPU_IIO_ICM20690
+	v |= BIT_FIFO_SIZE_1K;
+#endif
+	if (cycle_mode) {
+		rate = (st->eng_info[ENGINE_ACCEL].running_rate << 1);
+		i = ARRAY_SIZE(cycle_freq) - 1;
+		while (i > 0) {
+			if (rate < cycle_freq[i])
+				break;
+			i--;
+		}
+		r = inv_plat_single_write(st, REG_ACCEL_CONFIG_2, v |
+								(i << 4) | 7);
+		if (r)
+			return r;
+		st->accel_lp_mode = 1;
+	} else {
+		rate = (st->eng_info[ENGINE_ACCEL].running_rate >> 1);
+		for (i = 1; i < ARRAY_SIZE(cont_freq); i++) {
+			if (rate >= cont_freq[i])
+				break;
+		}
+		if (i > 6)
+			i = 6;
+		r = inv_plat_single_write(st, REG_ACCEL_CONFIG_2, v | i);
+		if (r)
+			return r;
+		st->accel_lp_mode = 0;
+	}
+
+	return 0;
+}
+static int inv_lp_en_on_mode(struct inv_mpu_state *st, bool on)
+{
+	int r = 0;
+	bool cond_check;
+
+	if ((!st->chip_config.is_asleep) &&
+			((!on) == st->chip_config.lp_en_set))
+		return 0;
+
+	/* will set LP mode ? */
+	cond_check = (!on) && st->cycle_on;
+
+	/* wake up */
+	if (st->chip_config.is_asleep) {
+		r = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_CLK_PLL);
+		if (r)
+			return r;
+		usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+		inv_set_accel_config2(st, false);
+		st->chip_config.is_asleep = 0;
+		st->chip_config.lp_en_set = false;
+	}
+
+	/* set power mode */
+	if (st->chip_config.lp_en_set && !cond_check) {
+		/* LP -> LN */
+		r = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_CLK_PLL);
+		if (r)
+			return r;
+		usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+		inv_set_accel_config2(st, false);
+		st->chip_config.lp_en_set = false;
+	} else if (!st->chip_config.lp_en_set && cond_check) {
+		/* LN -> LP */
+		inv_set_accel_config2(st, true);
+		r = inv_plat_single_write(st, REG_PWR_MGMT_1,
+				BIT_CLK_PLL | BIT_LP_EN);
+		if (r)
+			return r;
+		usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+		st->chip_config.lp_en_set = true;
+	}
+
+	return r;
+}
+#endif
+#ifdef CONFIG_INV_MPU_IIO_ICM20608D
+int inv_set_accel_config2(struct inv_mpu_state *st, bool cycle_mode)
+{
+	int cycle_freq[] = {442, 236, 122, 61};
+	int cont_freq[] = {219, 219, 99, 45, 22, 11, 6};
+	int i, r, rate;
+
+	if (cycle_mode) {
+		rate = (st->eng_info[ENGINE_ACCEL].running_rate << 1);
+		i = ARRAY_SIZE(cycle_freq) - 1;
+		while (i > 0) {
+			if (rate < cycle_freq[i])
+				break;
+			i--;
+		}
+		r = inv_plat_single_write(st, REG_ACCEL_CONFIG_2, (i << 4) | 7);
+		if (r)
+			return r;
+	} else {
+		rate = (st->eng_info[ENGINE_ACCEL].running_rate >> 1);
+		for (i = 1; i < ARRAY_SIZE(cont_freq); i++) {
+			if (rate >= cont_freq[i])
+				break;
+		}
+		if (i > 6)
+			i = 6;
+		r = inv_plat_single_write(st, REG_ACCEL_CONFIG_2, i);
+		if (r)
+			return r;
+	}
+
+	return 0;
+}
+static int inv_lp_en_on_mode(struct inv_mpu_state *st, bool on)
+{
+	int r = 0;
+	u8 w;
+	bool cond_check;
+
+	cond_check = (!on) && (!st->chip_config.eis_enable)
+					   && (!st->chip_config.gyro_enable);
+
+	w = BIT_CLK_PLL;
+	r = inv_plat_single_write(st, REG_PWR_MGMT_1, w);
+	if (r)
+		return r;
+	usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+	inv_set_accel_config2(st, cond_check);
+
+	if (cond_check)
+		w |= BIT_LP_EN;
+	r = inv_plat_single_write(st, REG_PWR_MGMT_1, w);
+	st->chip_config.is_asleep = 0;
+
+	return r;
+}
+#endif
+
+#if defined(CONFIG_INV_MPU_IIO_ICM42600)
+int inv_set_accel_config2(struct inv_mpu_state *st, bool on)
+{
+	/* dummy */
+	return 0;
+}
+static int inv_lp_en_on_mode(struct inv_mpu_state *st, bool on)
+{
+	/* dummy */
+	return 0;
+}
+#endif
+
+static int inv_lp_en_off_mode(struct inv_mpu_state *st, bool on)
+{
+	int r;
+
+	if (!st->chip_config.is_asleep)
+		return 0;
+
+#if !defined(CONFIG_INV_MPU_IIO_ICM42600)
+	r = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_CLK_PLL);
+	usleep_range(REG_UP_TIME_USEC, REG_UP_TIME_USEC + 1);
+#endif
+	st->chip_config.is_asleep = 0;
+#if defined(CONFIG_INV_MPU_IIO_ICM20602) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20689) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20690) || \
+	defined(CONFIG_INV_MPU_IIO_IAM20680) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20608D)
+	inv_set_accel_config2(st, false);
+#endif
+	return r;
+}
+
+int inv_switch_power_in_lp(struct inv_mpu_state *st, bool on)
+{
+	int r;
+
+#if defined(CONFIG_INV_MPU_IIO_ICM42600)
+	/* nothing to do, dummy */
+	return 0;
+#endif
+	if (st->chip_config.lp_en_mode_off)
+		r = inv_lp_en_off_mode(st, on);
+	else
+		r = inv_lp_en_on_mode(st, on);
+
+	return r;
+}
+EXPORT_SYMBOL_GPL(inv_switch_power_in_lp);
+
+int write_be16_to_mem(struct inv_mpu_state *st, u16 data, int addr)
+{
+	u8 d[2];
+
+	d[0] = (data >> 8) & 0xff;
+	d[1] = data & 0xff;
+
+	return mem_w(addr, sizeof(d), d);
+}
+
+int write_be32_to_mem(struct inv_mpu_state *st, u32 data, int addr)
+{
+	cpu_to_be32s(&data);
+	return mem_w(addr, sizeof(data), (u8 *)&data);
+}
+
+int read_be16_from_mem(struct inv_mpu_state *st, u16 *o, int addr)
+{
+	int result;
+	u8 d[2];
+
+	result = mem_r(addr, 2, (u8 *) &d);
+	*o = d[0] << 8 | d[1];
+
+	return result;
+}
+
+int read_be32_from_mem(struct inv_mpu_state *st, u32 *o, int addr)
+{
+	int result;
+	u32 d = 0;
+
+	result = mem_r(addr, 4, (u8 *) &d);
+	*o = be32_to_cpup((__be32 *)(&d));
+
+	return result;
+}
+
+int be32_to_int(u8 *d)
+{
+	return (d[0] << 24) | (d[1] << 16) | (d[2] << 8) | d[3];
+}
+
+u32 inv_get_cntr_diff(u32 curr_counter, u32 prev)
+{
+	u32 diff;
+
+	if (curr_counter > prev)
+		diff = curr_counter - prev;
+	else
+		diff = 0xffffffff - prev + curr_counter + 1;
+
+	return diff;
+}
+
+int inv_write_2bytes(struct inv_mpu_state *st, int addr, int data)
+{
+	u8 d[2];
+
+	if (data < 0 || data > USHRT_MAX)
+		return -EINVAL;
+
+	d[0] = (u8) ((data >> 8) & 0xff);
+	d[1] = (u8) (data & 0xff);
+
+	return mem_w(addr, ARRAY_SIZE(d), d);
+}
+
+
+
+int inv_process_eis(struct inv_mpu_state *st, u16 delay)
+{
+	int tmp1, tmp2, tmp3;
+
+	switch (st->eis.voting_state) {
+	case 0:
+		st->eis.gyro_counter_s[0] = st->eis.gyro_counter;
+		st->eis.fsync_delay_s[0] = delay - st->eis.fsync_delay;
+		st->eis.voting_count = 1;
+		st->eis.voting_count_sub = 0;
+		st->eis.voting_state = 1;
+		break;
+	case 1:
+		if (abs(st->eis.gyro_counter_s[0] -
+						st->eis.gyro_counter) <= 1) {
+			st->eis.voting_count++;
+		} else {
+			st->eis.gyro_counter_s[2] = st->eis.gyro_counter;
+			st->eis.voting_count_sub++;
+			st->eis.voting_state = 2;
+		}
+		if (st->eis.voting_count > 5)
+			st->eis.voting_state = 3;
+		break;
+	case 2:
+		tmp1 = abs(st->eis.gyro_counter_s[0] - st->eis.gyro_counter);
+		tmp2 = abs(st->eis.gyro_counter_s[2] - st->eis.gyro_counter);
+
+		if ((tmp1 < tmp2) && (tmp1 <= 1))
+			st->eis.voting_count++;
+		else
+			st->eis.voting_count_sub++;
+		if (st->eis.voting_count > 5) {
+			st->eis.voting_state = 3;
+			st->eis.voting_count = 0;
+			st->eis.voting_count_sub = 0;
+		}
+
+		if (st->eis.voting_count_sub > 5) {
+			st->eis.gyro_counter_s[0] = st->eis.gyro_counter;
+			st->eis.fsync_delay_s[0] = delay - st->eis.fsync_delay;
+			st->eis.voting_state = 1;
+			st->eis.voting_count = 1;
+			st->eis.voting_count_sub = 0;
+		}
+		break;
+	case 3:
+		tmp1 = abs(st->eis.gyro_counter_s[0] - st->eis.gyro_counter);
+		if (tmp1 == 1) {
+			st->eis.gyro_counter_s[1] = st->eis.gyro_counter;
+			st->eis.fsync_delay_s[1] = delay - st->eis.fsync_delay;
+			st->eis.voting_state = 4;
+			st->eis.voting_count_sub = 1;
+			st->eis.voting_count = 1;
+		}
+		break;
+	case 4:
+		if (st->eis.gyro_counter == st->eis.gyro_counter_s[0]) {
+			tmp1 = delay - st->eis.fsync_delay;
+			tmp2 = abs(tmp1 - st->eis.fsync_delay_s[0]);
+			if (tmp2 < 3) {
+				st->eis.voting_count++;
+			} else {
+				st->eis.fsync_delay_s[2] = tmp1;
+				st->eis.voting_count_sub = 1;
+				st->eis.voting_state = 5;
+			}
+			if (st->eis.voting_count > 5) {
+				st->eis.voting_count = 1;
+				st->eis.voting_state = 6;
+			}
+		}
+		break;
+	case 5:
+		if (st->eis.gyro_counter == st->eis.gyro_counter_s[0]) {
+			tmp1 = delay - st->eis.fsync_delay;
+
+			tmp2 = abs(tmp1 - st->eis.fsync_delay_s[0]);
+			tmp3 = abs(tmp1 - st->eis.fsync_delay_s[2]);
+			if ((tmp2 < tmp3) && (tmp2 < 3))
+				st->eis.voting_count++;
+			else
+				st->eis.voting_count_sub++;
+			if ((st->eis.voting_count > 5) &&
+					(st->eis.voting_count_sub
+					< st->eis.voting_count)) {
+				st->eis.voting_state = 6;
+				st->eis.voting_count = 1;
+			} else if (st->eis.voting_count_sub > 5) {
+				st->eis.fsync_delay_s[0] = tmp1;
+				st->eis.voting_state = 4;
+				st->eis.voting_count = 1;
+			}
+
+		}
+		break;
+	case 6:
+		if (st->eis.gyro_counter == st->eis.gyro_counter_s[1]) {
+			tmp1 = delay - st->eis.fsync_delay;
+			tmp2 = abs(tmp1 - st->eis.fsync_delay_s[1]);
+			if (tmp2 < 3) {
+				st->eis.voting_count++;
+			} else {
+				st->eis.fsync_delay_s[2] = tmp1;
+				st->eis.voting_count_sub = 1;
+				st->eis.voting_count = 1;
+				st->eis.voting_state = 7;
+			}
+			if (st->eis.voting_count > 5)
+				st->eis.voting_state = 8;
+		}
+		break;
+	case 7:
+		if (st->eis.gyro_counter == st->eis.gyro_counter_s[1]) {
+			tmp1 = delay - st->eis.fsync_delay;
+
+			tmp2 = abs(tmp1 - st->eis.fsync_delay_s[1]);
+			tmp3 = abs(tmp1 - st->eis.fsync_delay_s[2]);
+			if ((tmp2 < tmp3) && (tmp2 < 3))
+				st->eis.voting_count++;
+			else
+				st->eis.voting_count_sub++;
+			if ((st->eis.voting_count > 5) &&
+					(st->eis.voting_count_sub
+					< st->eis.voting_count)) {
+				st->eis.voting_state = 8;
+			} else if (st->eis.voting_count_sub > 5) {
+				st->eis.fsync_delay_s[1] = tmp1;
+				st->eis.voting_state = 6;
+				st->eis.voting_count = 1;
+			}
+
+		}
+		break;
+	default:
+		break;
+	}
+
+	pr_debug("de= %d gc= %d\n", delay, st->eis.gyro_counter);
+	st->eis.fsync_delay = delay;
+	st->eis.gyro_counter = 0;
+
+	pr_debug("state=%d g1= %d d1= %d g2= %d d2= %d\n",
+			st->eis.voting_state,
+			st->eis.gyro_counter_s[0],
+			st->eis.fsync_delay_s[0],
+			st->eis.gyro_counter_s[1],
+			st->eis.fsync_delay_s[1]);
+
+	return 0;
+}
+
+#if defined(CONFIG_INV_MPU_IIO_ICM42600)
+int inv_rate_convert(struct inv_mpu_state *st, int ind, int data)
+{
+	int out_hz;
+
+	if (data > 500)
+		out_hz = 1000;
+	else if (data > 200)
+		out_hz = 500;
+	else if (data > 100)
+		out_hz = 200;
+	else if (data > 50)
+		out_hz = 100;
+	else if (data > 25)
+		out_hz = 50;
+	else if (data > 12)
+		out_hz = 25;
+	else if (data > 6)
+		out_hz = 12;
+	else if (data > 3)
+		out_hz = 6;
+	else
+		out_hz = 3;
+
+	return out_hz;
+}
+#else
+int inv_rate_convert(struct inv_mpu_state *st, int ind, int data)
+{
+	int t, out, out1, out2;
+	int base_freq;
+
+	if (data <= MPU_DEFAULT_DMP_FREQ)
+		base_freq = MPU_DEFAULT_DMP_FREQ;
+	else
+		base_freq = BASE_SAMPLE_RATE;
+
+	t = base_freq / data;
+	if (!t)
+		t = 1;
+	out1 = base_freq / (t + 1);
+	out2 = base_freq / t;
+	if ((data - out1) * INV_ODR_BUFFER_MULTI < data)
+		out = out1;
+	else
+		out = out2;
+
+	return out;
+}
+#endif
+
+static void inv_check_wake_non_wake(struct inv_mpu_state *st,
+			enum SENSOR_L wake, enum SENSOR_L non_wake)
+{
+	int tmp_rate;
+
+	if (!st->sensor_l[wake].on && !st->sensor_l[non_wake].on)
+		return;
+
+	tmp_rate = 0;
+	if (st->sensor_l[wake].on)
+		tmp_rate = st->sensor_l[wake].rate;
+	if (st->sensor_l[non_wake].on)
+		tmp_rate = max(tmp_rate, st->sensor_l[non_wake].rate);
+	st->sensor_l[wake].rate = tmp_rate;
+	st->sensor_l[non_wake].rate = tmp_rate;
+}
+
+static void inv_check_wake_non_wake_divider(struct inv_mpu_state *st,
+			enum SENSOR_L wake, enum SENSOR_L non_wake)
+{
+	if (st->sensor_l[wake].on && st->sensor_l[non_wake].on)
+		st->sensor_l[non_wake].div = 0xffff;
+
+}
+
+#if defined(CONFIG_INV_MPU_IIO_ICM20602) \
+	|| defined(CONFIG_INV_MPU_IIO_ICM20689) \
+	|| defined(CONFIG_INV_MPU_IIO_ICM20690) \
+	|| defined(CONFIG_INV_MPU_IIO_IAM20680)
+int inv_check_sensor_on(struct inv_mpu_state *st)
+{
+	int max_rate;
+	int i;
+	enum SENSOR_L wake[] = {SENSOR_L_GYRO_WAKE, SENSOR_L_ACCEL_WAKE,
+					SENSOR_L_MAG_WAKE};
+	enum SENSOR_L non_wake[] = {SENSOR_L_GYRO, SENSOR_L_ACCEL,
+					SENSOR_L_MAG};
+
+	/* initialize rates */
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].rate = GESTURE_ACCEL_RATE;
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].on = false;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE;
+
+	/* set GESTURE_ACCEL on to support gestures at HAL */
+	if (st->step_detector_l_on
+			|| st->step_detector_wake_l_on
+			|| st->step_counter_l_on
+			|| st->step_counter_wake_l_on
+			|| st->chip_config.pick_up_enable
+			|| st->chip_config.tilt_enable
+			|| st->chip_config.stationary_detect_enable
+			|| st->chip_config.motion_detect_enable)
+		st->sensor_l[SENSOR_L_GESTURE_ACCEL].on = true;
+	else
+		st->sensor_l[SENSOR_L_GESTURE_ACCEL].on = false;
+
+	/* set wake_on according to enabled sensors */
+	st->chip_config.wake_on = false;
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on && st->sensor_l[i].rate) {
+			st->sensor[st->sensor_l[i].base].on = true;
+			st->chip_config.wake_on |= st->sensor_l[i].wake_on;
+		}
+	}
+
+	/* only gesture accel is enabled? */
+	if (st->sensor_l[SENSOR_L_GESTURE_ACCEL].on &&
+			(!st->sensor_l[SENSOR_L_ACCEL].on &&
+				!st->sensor_l[SENSOR_L_ACCEL_WAKE].on) &&
+			(!st->sensor[SENSOR_GYRO].on) &&
+			(!st->sensor[SENSOR_COMPASS].on))
+		st->gesture_only_on = true;
+	else
+		st->gesture_only_on = false;
+
+	/* update rate to user side for sensors which are affected by gesture */
+	if (st->sensor_l[SENSOR_L_GESTURE_ACCEL].on) {
+		for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+			if (st->sensor_l[i].on &&
+					st->sensor_l[SENSOR_L_GESTURE_ACCEL].base ==
+					st->sensor_l[i].base) {
+				st->sensor_l[i].rate =
+					max(st->sensor_l[i].rate,
+							st->sensor_l[SENSOR_L_GESTURE_ACCEL].rate);
+			}
+		}
+	}
+
+	/* set rate for each sensor */
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on) {
+			st->sensor[st->sensor_l[i].base].rate =
+			    max(st->sensor[st->sensor_l[i].base].rate,
+							st->sensor_l[i].rate);
+		}
+	}
+	max_rate = MPU_INIT_SENSOR_RATE;
+	if (st->chip_config.eis_enable) {
+		max_rate = ESI_GYRO_RATE;
+		st->sensor_l[SENSOR_L_EIS_GYRO].rate = ESI_GYRO_RATE;
+	}
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			max_rate = max(max_rate, st->sensor[i].rate);
+	}
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on)
+			st->sensor[i].rate = max_rate;
+	}
+
+	/* set rate for corresponding wake-up and non wake-up sensors */
+	for (i = 0; i < ARRAY_SIZE(wake); i++)
+		inv_check_wake_non_wake(st, wake[i], non_wake[i]);
+
+	/* calculate decimation rate for each sensor */
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on) {
+			if (st->sensor_l[i].rate)
+				st->sensor_l[i].div =
+				    st->sensor[st->sensor_l[i].base].rate
+							/ st->sensor_l[i].rate;
+			else
+				st->sensor_l[i].div = 0xffff;
+			pr_debug("sensor= %d, div= %d\n",
+						i, st->sensor_l[i].div);
+		}
+	}
+
+	/* set decimation rate for corresponding wake-up and non wake-up sensors */
+	for (i = 0; i < ARRAY_SIZE(wake); i++)
+		inv_check_wake_non_wake_divider(st, wake[i], non_wake[i]);
+
+	return 0;
+}
+#elif defined(CONFIG_INV_MPU_IIO_ICM42600)
+int inv_check_sensor_on(struct inv_mpu_state *st)
+{
+	int i;
+	enum SENSOR_L wake[] = {SENSOR_L_GYRO_WAKE, SENSOR_L_ACCEL_WAKE,
+					SENSOR_L_MAG_WAKE};
+	enum SENSOR_L non_wake[] = {SENSOR_L_GYRO, SENSOR_L_ACCEL,
+					SENSOR_L_MAG};
+
+	/* initialize rates */
+	st->sensor_l[SENSOR_L_GESTURE_ACCEL].rate = GESTURE_ACCEL_RATE;
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].on = false;
+
+#if defined(SUPPORT_ACCEL_LPM)
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE_LPM;
+	st->sensor[SENSOR_GYRO].rate = MPU_INIT_SENSOR_RATE_LNM;
+#else
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE_LNM;
+#endif /* SUPPORT_ACCEL_LPM */
+
+	/* set GESTURE_ACCEL on to support gestures at HAL */
+	if ((!st->apex_supported &&
+				(st->step_detector_wake_l_on
+				 || st->step_counter_l_on
+				 || st->step_counter_wake_l_on
+				 || st->chip_config.pick_up_enable
+				 || st->chip_config.tilt_enable))
+			|| st->chip_config.stationary_detect_enable
+			||st->chip_config.motion_detect_enable)
+		st->sensor_l[SENSOR_L_GESTURE_ACCEL].on = true;
+	else
+		st->sensor_l[SENSOR_L_GESTURE_ACCEL].on = false;
+
+	/* set wake_on according to enabled sensors */
+	st->chip_config.wake_on = false;
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on && st->sensor_l[i].rate) {
+			st->sensor[st->sensor_l[i].base].on = true;
+			st->chip_config.wake_on |= st->sensor_l[i].wake_on;
+		}
+	}
+	/* set wake_on when DMP/HW wake-up gestures are enabled */
+	if (st->step_detector_wake_l_on ||
+			st->step_counter_wake_l_on ||
+			st->chip_config.pick_up_enable ||
+			st->chip_config.tilt_enable ||
+			st->chip_config.tap_enable)
+		st->chip_config.wake_on = true;
+
+	/* only gesture accel is enabled? */
+	if (st->sensor_l[SENSOR_L_GESTURE_ACCEL].on &&
+			(!st->sensor_l[SENSOR_L_ACCEL].on &&
+				!st->sensor_l[SENSOR_L_ACCEL_WAKE].on) &&
+			(!st->sensor[SENSOR_GYRO].on) &&
+			(!st->sensor[SENSOR_COMPASS].on))
+		st->gesture_only_on = true;
+	else
+		st->gesture_only_on = false;
+
+	/* update rate to user side for sensors which are affected by gesture */
+	if (st->sensor_l[SENSOR_L_GESTURE_ACCEL].on) {
+		for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+			if (st->sensor_l[i].on &&
+					st->sensor_l[SENSOR_L_GESTURE_ACCEL].base ==
+					st->sensor_l[i].base) {
+				st->sensor_l[i].rate =
+					max(st->sensor_l[i].rate,
+							st->sensor_l[SENSOR_L_GESTURE_ACCEL].rate);
+			}
+		}
+	}
+
+	/* set rate for each sensor */
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on) {
+			st->sensor[st->sensor_l[i].base].rate =
+			    max(st->sensor[st->sensor_l[i].base].rate,
+							st->sensor_l[i].rate);
+		}
+	}
+	if (st->chip_config.eis_enable)
+		st->sensor_l[SENSOR_L_EIS_GYRO].rate = ESI_GYRO_RATE;
+	if (st->sensor_l[SENSOR_L_GESTURE_ACCEL].on) {
+		st->sensor[SENSOR_ACCEL].rate =
+			max(st->sensor[SENSOR_ACCEL].rate,
+			st->sensor_l[SENSOR_L_GESTURE_ACCEL].rate);
+	}
+	if (inv_get_apex_enabled(st)) {
+		st->sensor[SENSOR_ACCEL].rate =
+			max(st->sensor[SENSOR_ACCEL].rate,
+			inv_get_apex_odr(st));
+	}
+
+	/* set rate for corresponding wake-up and non wake-up sensors */
+	for (i = 0; i < ARRAY_SIZE(wake); i++)
+		inv_check_wake_non_wake(st, wake[i], non_wake[i]);
+
+	/* calculate decimation rate for each sensor */
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on) {
+			if (st->sensor_l[i].rate)
+				st->sensor_l[i].div =
+				    st->sensor[st->sensor_l[i].base].rate
+							/ st->sensor_l[i].rate;
+			else
+				st->sensor_l[i].div = 0xffff;
+			pr_debug("sensor= %d, div= %d\n",
+						i, st->sensor_l[i].div);
+		}
+	}
+
+	/* set decimation rate for corresponding wake-up and non wake-up sensors */
+	for (i = 0; i < ARRAY_SIZE(wake); i++)
+		inv_check_wake_non_wake_divider(st, wake[i], non_wake[i]);
+
+	return 0;
+}
+#else /* ICM20608D/ICM20648 */
+static void inv_do_check_sensor_on(struct inv_mpu_state *st,
+				enum SENSOR_L *wake,
+				enum SENSOR_L *non_wake, int sensor_size)
+{
+	int i;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].on = false;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++)
+		st->sensor[i].rate = MPU_INIT_SENSOR_RATE;
+
+	st->chip_config.wake_on = false;
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on && st->sensor_l[i].rate) {
+			st->sensor[st->sensor_l[i].base].on = true;
+			st->chip_config.wake_on |= st->sensor_l[i].wake_on;
+		}
+	}
+
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on) {
+			st->sensor[st->sensor_l[i].base].rate =
+			    max(st->sensor[st->sensor_l[i].base].rate,
+				st->sensor_l[i].rate);
+		}
+	}
+	for (i = 0; i < sensor_size; i++)
+		inv_check_wake_non_wake(st, wake[i], non_wake[i]);
+
+	for (i = 0; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on) {
+			if (st->sensor_l[i].rate)
+				st->sensor_l[i].div =
+				    st->sensor[st->sensor_l[i].base].rate
+				    / st->sensor_l[i].rate;
+			else
+				st->sensor_l[i].div = 0xffff;
+		}
+	}
+	for (i = 0; i < sensor_size; i++)
+		inv_check_wake_non_wake_divider(st, wake[i], non_wake[i]);
+
+	if (st->step_detector_wake_l_on ||
+			st->step_counter_wake_l_on ||
+			st->chip_config.pick_up_enable ||
+			st->chip_config.tilt_enable ||
+			st->smd.on)
+		st->chip_config.wake_on = true;
+
+}
+#endif
+
+#if defined(CONFIG_INV_MPU_IIO_ICM20608D)
+int inv_check_sensor_on(struct inv_mpu_state *st)
+{
+	enum SENSOR_L wake[] = {SENSOR_L_GYRO_WAKE, SENSOR_L_ACCEL_WAKE,
+				SENSOR_L_SIXQ_WAKE, SENSOR_L_PEDQ_WAKE,
+				SENSOR_L_GYRO_CAL_WAKE};
+	enum SENSOR_L non_wake[] = {SENSOR_L_GYRO, SENSOR_L_ACCEL,
+				SENSOR_L_SIXQ, SENSOR_L_PEDQ,
+				SENSOR_L_GYRO_CAL};
+
+	inv_do_check_sensor_on(st, wake, non_wake, ARRAY_SIZE(wake));
+
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_INV_MPU_IIO_ICM20648)
+int inv_check_sensor_on(struct inv_mpu_state *st)
+{
+	enum SENSOR_L wake[] = {SENSOR_L_GYRO_WAKE, SENSOR_L_ACCEL_WAKE,
+				SENSOR_L_MAG_WAKE, SENSOR_L_ALS_WAKE,
+				SENSOR_L_SIXQ_WAKE, SENSOR_L_PEDQ_WAKE,
+				SENSOR_L_NINEQ_WAKE, SENSOR_L_GEOMAG_WAKE,
+				SENSOR_L_PRESSURE_WAKE,
+				SENSOR_L_GYRO_CAL_WAKE,
+				SENSOR_L_MAG_CAL_WAKE};
+	enum SENSOR_L non_wake[] = {SENSOR_L_GYRO, SENSOR_L_ACCEL,
+					SENSOR_L_MAG, SENSOR_L_ALS,
+					SENSOR_L_SIXQ, SENSOR_L_PEDQ,
+					SENSOR_L_NINEQ, SENSOR_L_GEOMAG,
+					SENSOR_L_PRESSURE,
+					SENSOR_L_GYRO_CAL,
+					SENSOR_L_MAG_CAL};
+
+	inv_do_check_sensor_on(st, wake, non_wake, ARRAY_SIZE(wake));
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+static bool any_wakeup_streaming_enabled(struct inv_mpu_state *st)
+{
+	int i;
+
+	for (i = SENSOR_L_ACCEL_WAKE; i < SENSOR_L_NUM_MAX; i++) {
+		if (st->sensor_l[i].on)
+			return true;
+	}
+	return false;
+}
+
+static int set_interrupt_for_suspend(struct inv_mpu_state *st)
+{
+	if (any_wakeup_streaming_enabled(st)) {
+		/* wakeup streaming sensor is enabled */
+		/* do nothing */
+	} else if (!st->chip_config.wake_on) {
+		/* no wakeup gesture is enabled, disable all interrupts */
+		inv_stop_interrupt(st);
+	} else {
+		/* wakeup gesture is enabled, stop streaming interrupts */
+		inv_stop_stream_interrupt(st);
+	}
+
+	return 0;
+}
+
+static int restore_interrupt_for_suspend(struct inv_mpu_state *st)
+{
+	if (any_wakeup_streaming_enabled(st)) {
+		/* wakeup streaming sensor is enabled */
+		/* do nothing */
+	} else if (!st->chip_config.wake_on) {
+		/* no wakeup gesture is enabled, do the opposite of suspend */
+		inv_restore_interrupt(st);
+	} else {
+		/* reenable streaming interrupts */
+		inv_restore_stream_interrupt(st);
+	}
+
+	return 0;
+}
+
+int inv_mpu_suspend(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	/* add code according to different request Start */
+	dev_info(st->dev, "%s suspend\n", st->hw->name);
+	mutex_lock(&indio_dev->mlock);
+
+	st->resume_state = false;
+
+	set_interrupt_for_suspend(st);
+
+	if (st->chip_config.wake_on)
+		enable_irq_wake(st->irq);
+
+	mutex_unlock(&indio_dev->mlock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(inv_mpu_suspend);
+
+/*
+ * inv_mpu_complete(): complete method for this driver.
+ *    This method can be modified according to the request of different
+ *    customers. It basically undo everything suspend is doing
+ *    and recover the chip to what it was before suspend. We use complete to
+ *    make sure that alarm clock resume is finished. If we use resume, the
+ *    alarm clock may not resume yet and get incorrect clock reading.
+ */
+void inv_mpu_complete(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	dev_info(st->dev, "%s resume\n", st->hw->name);
+	if (st->resume_state)
+		return;
+
+	mutex_lock(&indio_dev->mlock);
+
+	if (st->chip_config.wake_on)
+		disable_irq_wake(st->irq);
+
+	restore_interrupt_for_suspend(st);
+
+	/* resume state is used to synchronize read_fifo such that it won't
+	 * proceed unless resume is finished.
+	 */
+	st->resume_state = true;
+	/* resume flag is indicating that current clock reading is from resume,
+	 * it has up to 1 second drift and should do proper processing
+	 */
+	st->ts_algo.resume_flag  = true;
+	mutex_unlock(&indio_dev->mlock);
+	wake_up_interruptible(&st->wait_queue);
+}
+EXPORT_SYMBOL_GPL(inv_mpu_complete);
+#endif
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_dts.c b/drivers/iio/imu/inv_mpu/inv_mpu_dts.c
new file mode 100644
index 000000000000..6bb8f01a391e
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_dts.c
@@ -0,0 +1,345 @@
+/*
+ * Copyright (C) 2012-2017 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/of_gpio.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/export.h>
+
+#include <linux/iio/imu/mpu.h>
+#include "inv_mpu_dts.h"
+#include "inv_mpu_iio.h"
+
+#ifdef CONFIG_OF
+
+static int inv_mpu_power_on(struct mpu_platform_data *pdata)
+{
+	int err;
+
+	if (!IS_ERR(pdata->vdd_ana)) {
+		err = regulator_enable(pdata->vdd_ana);
+		if (err)
+			return err;
+	}
+	if (!IS_ERR(pdata->vdd_i2c)) {
+		err = regulator_enable(pdata->vdd_i2c);
+		if (err)
+			goto error_disable_vdd_ana;
+	}
+
+	return 0;
+
+error_disable_vdd_ana:
+	regulator_disable(pdata->vdd_ana);
+	return err;
+}
+
+static int inv_mpu_power_off(struct mpu_platform_data *pdata)
+{
+	if (!IS_ERR(pdata->vdd_ana))
+		regulator_disable(pdata->vdd_ana);
+	if (!IS_ERR(pdata->vdd_i2c))
+		regulator_disable(pdata->vdd_i2c);
+
+	return 0;
+}
+
+static int inv_parse_orientation_matrix(struct device *dev, s8 *orient)
+{
+	int rc, i;
+	struct device_node *np = dev->of_node;
+	u32 temp_val, temp_val2;
+
+	for (i = 0; i < 9; i++)
+		orient[i] = 0;
+
+	/* parsing axis x orientation matrix */
+	rc = of_property_read_u32(np, "axis_map_x", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read axis_map_x\n");
+		return rc;
+	}
+	rc = of_property_read_u32(np, "negate_x", &temp_val2);
+	if (rc) {
+		dev_err(dev, "Unable to read negate_x\n");
+		return rc;
+	}
+	if (temp_val2)
+		orient[temp_val] = -1;
+	else
+		orient[temp_val] = 1;
+
+	/* parsing axis y orientation matrix */
+	rc = of_property_read_u32(np, "axis_map_y", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read axis_map_y\n");
+		return rc;
+	}
+	rc = of_property_read_u32(np, "negate_y", &temp_val2);
+	if (rc) {
+		dev_err(dev, "Unable to read negate_y\n");
+		return rc;
+	}
+	if (temp_val2)
+		orient[3 + temp_val] = -1;
+	else
+		orient[3 + temp_val] = 1;
+
+	/* parsing axis z orientation matrix */
+	rc = of_property_read_u32(np, "axis_map_z", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read axis_map_z\n");
+		return rc;
+	}
+	rc = of_property_read_u32(np, "negate_z", &temp_val2);
+	if (rc) {
+		dev_err(dev, "Unable to read negate_z\n");
+		return rc;
+	}
+	if (temp_val2)
+		orient[6 + temp_val] = -1;
+	else
+		orient[6 + temp_val] = 1;
+
+	return 0;
+}
+
+static int inv_parse_secondary_orientation_matrix(struct device *dev,
+						  s8 *orient)
+{
+	int rc, i;
+	struct device_node *np = dev->of_node;
+	u32 temp_val, temp_val2;
+
+	for (i = 0; i < 9; i++)
+		orient[i] = 0;
+
+	/* parsing axis x orientation matrix */
+	rc = of_property_read_u32(np, "inven,secondary_axis_map_x", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read secondary axis_map_x\n");
+		return rc;
+	}
+	rc = of_property_read_u32(np, "inven,secondary_negate_x", &temp_val2);
+	if (rc) {
+		dev_err(dev, "Unable to read secondary negate_x\n");
+		return rc;
+	}
+	if (temp_val2)
+		orient[temp_val] = -1;
+	else
+		orient[temp_val] = 1;
+
+	/* parsing axis y orientation matrix */
+	rc = of_property_read_u32(np, "inven,secondary_axis_map_y", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read secondary axis_map_y\n");
+		return rc;
+	}
+	rc = of_property_read_u32(np, "inven,secondary_negate_y", &temp_val2);
+	if (rc) {
+		dev_err(dev, "Unable to read secondary negate_y\n");
+		return rc;
+	}
+	if (temp_val2)
+		orient[3 + temp_val] = -1;
+	else
+		orient[3 + temp_val] = 1;
+
+	/* parsing axis z orientation matrix */
+	rc = of_property_read_u32(np, "inven,secondary_axis_map_z", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read secondary axis_map_z\n");
+		return rc;
+	}
+	rc = of_property_read_u32(np, "inven,secondary_negate_z", &temp_val2);
+	if (rc) {
+		dev_err(dev, "Unable to read secondary negate_z\n");
+		return rc;
+	}
+	if (temp_val2)
+		orient[6 + temp_val] = -1;
+	else
+		orient[6 + temp_val] = 1;
+
+	return 0;
+}
+
+static int inv_parse_secondary(struct device *dev,
+			       struct mpu_platform_data *pdata)
+{
+	int rc;
+	struct device_node *np = dev->of_node;
+	u32 temp_val;
+	const char *name;
+
+	if (of_property_read_string(np, "inven,secondary_type", &name)) {
+		dev_err(dev, "Missing secondary type.\n");
+		return -EINVAL;
+	}
+	if (!strcmp(name, "compass")) {
+		pdata->sec_slave_type = SECONDARY_SLAVE_TYPE_COMPASS;
+	} else if (!strcmp(name, "none")) {
+		pdata->sec_slave_type = SECONDARY_SLAVE_TYPE_NONE;
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+
+	if (of_property_read_string(np, "inven,secondary_name", &name)) {
+		dev_err(dev, "Missing secondary name.\n");
+		return -EINVAL;
+	}
+	if (!strcmp(name, "ak8963"))
+		pdata->sec_slave_id = COMPASS_ID_AK8963;
+	else if (!strcmp(name, "ak8975"))
+		pdata->sec_slave_id = COMPASS_ID_AK8975;
+	else if (!strcmp(name, "ak8972"))
+		pdata->sec_slave_id = COMPASS_ID_AK8972;
+	else if (!strcmp(name, "ak09911"))
+		pdata->sec_slave_id = COMPASS_ID_AK09911;
+	else if (!strcmp(name, "ak09912"))
+		pdata->sec_slave_id = COMPASS_ID_AK09912;
+	else if (!strcmp(name, "ak09915"))
+		pdata->sec_slave_id = COMPASS_ID_AK09915;
+	else if (!strcmp(name, "ak09916"))
+		pdata->sec_slave_id = COMPASS_ID_AK09916;
+	else
+		return -EINVAL;
+	rc = of_property_read_u32(np, "inven,secondary_reg", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read secondary register\n");
+		return rc;
+	}
+	pdata->secondary_i2c_addr = temp_val;
+	rc = inv_parse_secondary_orientation_matrix(dev,
+						    pdata->
+						    secondary_orientation);
+
+	return rc;
+}
+
+static int inv_parse_aux(struct device *dev, struct mpu_platform_data *pdata)
+{
+	int rc;
+	struct device_node *np = dev->of_node;
+	u32 temp_val;
+	const char *name;
+
+	if (of_property_read_string(np, "inven,aux_type", &name)) {
+		dev_err(dev, "Missing aux type.\n");
+		return -EINVAL;
+	}
+	if (!strcmp(name, "pressure")) {
+		pdata->aux_slave_type = SECONDARY_SLAVE_TYPE_PRESSURE;
+	} else if (!strcmp(name, "none")) {
+		pdata->aux_slave_type = SECONDARY_SLAVE_TYPE_NONE;
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+
+	if (of_property_read_string(np, "inven,aux_name", &name)) {
+		dev_err(dev, "Missing aux name.\n");
+		return -EINVAL;
+	}
+	if (!strcmp(name, "bmp280"))
+		pdata->aux_slave_id = PRESSURE_ID_BMP280;
+	else
+		return -EINVAL;
+
+	rc = of_property_read_u32(np, "inven,aux_reg", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read aux register\n");
+		return rc;
+	}
+	pdata->aux_i2c_addr = temp_val;
+
+	return 0;
+}
+
+static int inv_parse_readonly_secondary(struct device *dev,
+				 	struct mpu_platform_data *pdata)
+{
+	int rc;
+	struct device_node *np = dev->of_node;
+	u32 temp_val;
+	const char *name;
+
+	if (of_property_read_string(np, "inven,read_only_slave_type", &name)) {
+		dev_err(dev, "Missing read only slave type type.\n");
+		return -EINVAL;
+	}
+	if (!strcmp(name, "als")) {
+		pdata->read_only_slave_type = SECONDARY_SLAVE_TYPE_ALS;
+	} else if (!strcmp(name, "none")) {
+		pdata->read_only_slave_type = SECONDARY_SLAVE_TYPE_NONE;
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+
+	if (of_property_read_string(np, "inven,read_only_slave_name", &name)) {
+		dev_err(dev, "Missing read only slave type name.\n");
+		return -EINVAL;
+	}
+	if (!strcmp(name, "apds9930"))
+		pdata->read_only_slave_id = ALS_ID_APDS_9930;
+	else
+		return -EINVAL;
+
+	rc = of_property_read_u32(np, "inven,read_only_slave_reg", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read read only slave reg register\n");
+		return rc;
+	}
+	pdata->read_only_i2c_addr = temp_val;
+
+	return 0;
+}
+
+int invensense_mpu_parse_dt(struct device *dev, struct mpu_platform_data *pdata)
+{
+	int rc;
+
+	rc = inv_parse_orientation_matrix(dev, pdata->orientation);
+	if (rc)
+		return rc;
+	rc = inv_parse_secondary(dev, pdata);
+	if (rc)
+		return rc;
+	inv_parse_aux(dev, pdata);
+
+	inv_parse_readonly_secondary(dev, pdata);
+
+	pdata->vdd_ana = regulator_get(dev, "inven,vdd_ana");
+	if (IS_ERR(pdata->vdd_ana)) {
+		rc = PTR_ERR(pdata->vdd_ana);
+		dev_warn(dev, "regulator get failed vdd_ana-supply rc=%d\n", rc);
+	}
+	pdata->vdd_i2c = regulator_get(dev, "inven,vcc_i2c");
+	if (IS_ERR(pdata->vdd_i2c)) {
+		rc = PTR_ERR(pdata->vdd_i2c);
+		dev_warn(dev, "regulator get failed vcc-i2c-supply rc=%d\n", rc);
+	}
+	pdata->power_on = inv_mpu_power_on;
+	pdata->power_off = inv_mpu_power_off;
+	dev_dbg(dev, "parse dt complete\n");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(invensense_mpu_parse_dt);
+
+#endif /* CONFIG_OF */
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_dts.h b/drivers/iio/imu/inv_mpu/inv_mpu_dts.h
new file mode 100644
index 000000000000..90966febb930
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_dts.h
@@ -0,0 +1,25 @@
+/*
+* Copyright (C) 2012-2017 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+
+#ifndef _INV_MPU_DTS_H_
+#define _INV_MPU_DTS_H_
+
+#include <linux/kernel.h>
+#include <linux/iio/imu/mpu.h>
+
+#ifdef CONFIG_OF
+int invensense_mpu_parse_dt(struct device *dev,
+			    struct mpu_platform_data *pdata);
+#endif
+
+#endif /* #ifndef _INV_MPU_DTS_H_ */
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu/inv_mpu_i2c.c
new file mode 100644
index 000000000000..bf0ad65b5a8a
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_i2c.c
@@ -0,0 +1,552 @@
+/*
+* Copyright (C) 2012-2020 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/of_device.h>
+
+#include "inv_mpu_iio.h"
+#include "inv_mpu_dts.h"
+
+#define CONFIG_DYNAMIC_DEBUG_I2C 0
+
+/**
+ *  inv_i2c_read_base() - Read one or more bytes from the device registers.
+ *  @st:	Device driver instance.
+ *  @i2c_addr:  i2c address of device.
+ *  @reg:	First device register to be read from.
+ *  @length:	Number of bytes to read.
+ *  @data:	Data read from device.
+ *  NOTE:This is not re-implementation of i2c_smbus_read because i2c
+ *       address could be specified in this case. We could have two different
+ *       i2c address due to secondary i2c interface.
+ */
+int inv_i2c_read_base(struct inv_mpu_state *st, u16 i2c_addr,
+						u8 reg, u16 length, u8 *data)
+{
+	struct i2c_msg msgs[2];
+	int res;
+
+	if (!data)
+		return -EINVAL;
+
+	msgs[0].addr = i2c_addr;
+	msgs[0].flags = 0;	/* write */
+	msgs[0].buf = &reg;
+	msgs[0].len = 1;
+
+	msgs[1].addr = i2c_addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].buf = data;
+	msgs[1].len = length;
+
+	res = i2c_transfer(st->sl_handle, msgs, 2);
+
+	if (res < 2) {
+		if (res >= 0)
+			res = -EIO;
+	} else
+		res = 0;
+
+	return res;
+}
+
+/**
+ *  inv_i2c_single_write_base() - Write a byte to a device register.
+ *  @st:	Device driver instance.
+ *  @i2c_addr:  I2C address of the device.
+ *  @reg:	Device register to be written to.
+ *  @data:	Byte to write to device.
+ *  NOTE:This is not re-implementation of i2c_smbus_write because i2c
+ *       address could be specified in this case. We could have two different
+ *       i2c address due to secondary i2c interface.
+ */
+int inv_i2c_single_write_base(struct inv_mpu_state *st,
+						u16 i2c_addr, u8 reg, u8 data)
+{
+	u8 tmp[2];
+	struct i2c_msg msg;
+	int res;
+
+	tmp[0] = reg;
+	tmp[1] = data;
+
+	msg.addr = i2c_addr;
+	msg.flags = 0;		/* write */
+	msg.buf = tmp;
+	msg.len = 2;
+
+	res = i2c_transfer(st->sl_handle, &msg, 1);
+	if (res < 1) {
+		if (res == 0)
+			res = -EIO;
+		return res;
+	} else
+		return 0;
+}
+
+static int inv_i2c_single_write(struct inv_mpu_state *st, u8 reg, u8 data)
+{
+	return inv_i2c_single_write_base(st, st->i2c_addr, reg, data);
+}
+
+static int inv_i2c_read(struct inv_mpu_state *st, u8 reg, int len, u8 *data)
+{
+	return inv_i2c_read_base(st, st->i2c_addr, reg, len, data);
+}
+
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20608D)
+static int _memory_write(struct inv_mpu_state *st, u8 mpu_addr, u16 mem_addr,
+						u32 len, u8 const *data)
+{
+	u8 bank[2];
+	u8 addr[2];
+	u8 buf[513];
+
+	struct i2c_msg msgs[3];
+	int res;
+
+	if (!data || !st)
+		return -EINVAL;
+
+	if (len >= (sizeof(buf) - 1))
+		return -ENOMEM;
+
+	bank[0] = REG_MEM_BANK_SEL;
+	bank[1] = mem_addr >> 8;
+
+	addr[0] = REG_MEM_START_ADDR;
+	addr[1] = mem_addr & 0xFF;
+
+	buf[0] = REG_MEM_R_W;
+	memcpy(buf + 1, data, len);
+
+	/* write message */
+	msgs[0].addr = mpu_addr;
+	msgs[0].flags = 0;
+	msgs[0].buf = bank;
+	msgs[0].len = sizeof(bank);
+
+	msgs[1].addr = mpu_addr;
+	msgs[1].flags = 0;
+	msgs[1].buf = addr;
+	msgs[1].len = sizeof(addr);
+
+	msgs[2].addr = mpu_addr;
+	msgs[2].flags = 0;
+	msgs[2].buf = (u8 *) buf;
+	msgs[2].len = len + 1;
+
+#if CONFIG_DYNAMIC_DEBUG_I2C
+	{
+		char *write = 0;
+		pr_debug("%s WM%02X%02X%02X%s%s - %d\n", st->hw->name,
+			mpu_addr, bank[1], addr[1],
+			wr_pr_debug_begin(data, len, write),
+			wr_pr_debug_end(write), len);
+	}
+#endif
+
+	res = i2c_transfer(st->sl_handle, msgs, 3);
+	if (res != 3) {
+		if (res >= 0)
+			res = -EIO;
+		return res;
+	} else {
+		return 0;
+	}
+}
+
+static int inv_i2c_mem_write(struct inv_mpu_state *st, u8 mpu_addr, u16 mem_addr,
+						u32 len, u8 const *data)
+{
+	int r, i, j;
+#define DMP_MEM_CMP_SIZE 16
+	u8 w[DMP_MEM_CMP_SIZE];
+	bool retry;
+
+	j = 0;
+	retry = true;
+	while ((j < 3) && retry) {
+		retry = false;
+		r = _memory_write(st, mpu_addr, mem_addr, len, data);
+		if (len < DMP_MEM_CMP_SIZE) {
+			r = mem_r(mem_addr, len, w);
+			for (i = 0; i < len; i++) {
+				if (data[i] != w[i]) {
+					pr_debug
+				("error write=%x, len=%d,data=%x, w=%x, i=%d\n",
+					mem_addr, len, data[i], w[i], i);
+					retry = true;
+				}
+			}
+		}
+		j++;
+	}
+
+	return r;
+}
+
+static int inv_i2c_mem_read(struct inv_mpu_state *st, u8 mpu_addr, u16 mem_addr,
+						u32 len, u8 *data)
+{
+	u8 bank[2];
+	u8 addr[2];
+	u8 buf;
+
+	struct i2c_msg msgs[4];
+	int res;
+
+	if (!data || !st)
+		return -EINVAL;
+
+	bank[0] = REG_MEM_BANK_SEL;
+	bank[1] = mem_addr >> 8;
+
+	addr[0] = REG_MEM_START_ADDR;
+	addr[1] = mem_addr & 0xFF;
+
+	buf = REG_MEM_R_W;
+
+	/* write message */
+	msgs[0].addr = mpu_addr;
+	msgs[0].flags = 0;
+	msgs[0].buf = bank;
+	msgs[0].len = sizeof(bank);
+
+	msgs[1].addr = mpu_addr;
+	msgs[1].flags = 0;
+	msgs[1].buf = addr;
+	msgs[1].len = sizeof(addr);
+
+	msgs[2].addr = mpu_addr;
+	msgs[2].flags = 0;
+	msgs[2].buf = &buf;
+	msgs[2].len = 1;
+
+	msgs[3].addr = mpu_addr;
+	msgs[3].flags = I2C_M_RD;
+	msgs[3].buf = data;
+	msgs[3].len = len;
+
+	res = i2c_transfer(st->sl_handle, msgs, 4);
+	if (res != 4) {
+		if (res >= 0)
+			res = -EIO;
+	} else
+		res = 0;
+
+#if CONFIG_DYNAMIC_DEBUG_I2C
+	{
+		char *read = 0;
+		pr_debug("%s RM%02X%02X%02X%02X - %s%s\n", st->hw->name,
+			mpu_addr, bank[1], addr[1], len,
+			wr_pr_debug_begin(data, len, read),
+			wr_pr_debug_end(read));
+	}
+#endif
+
+	return res;
+}
+#endif
+
+/*
+ *  inv_mpu_probe() - probe function.
+ */
+static int inv_mpu_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct inv_mpu_state *st;
+	struct iio_dev *indio_dev;
+	int result;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENOSYS;
+		pr_err("I2c function error\n");
+		goto out_no_free;
+	}
+
+	indio_dev = iio_device_alloc(sizeof(*st));
+	if (indio_dev == NULL) {
+		pr_err("memory allocation failed\n");
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	st = iio_priv(indio_dev);
+	st->client = client;
+	st->sl_handle = client->adapter;
+	st->i2c_addr = client->addr;
+	st->write = inv_i2c_single_write;
+	st->read = inv_i2c_read;
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20608D)
+	st->mem_write = inv_i2c_mem_write;
+	st->mem_read = inv_i2c_mem_read;
+#endif
+	st->dev = &client->dev;
+	st->irq = client->irq;
+	st->bus_type = BUS_I2C;
+	i2c_set_clientdata(client, indio_dev);
+	indio_dev->dev.parent = &client->dev;
+	indio_dev->name = id->name;
+
+#ifdef CONFIG_OF
+	result = invensense_mpu_parse_dt(st->dev, &st->plat_data);
+	if (result)
+		goto out_free;
+#else
+	if (dev_get_platdata(st->dev) == NULL) {
+		result = -ENODEV;
+		goto out_free;
+	}
+	st->plat_data = *(struct mpu_platform_data *)dev_get_platdata(st->dev);
+#endif
+	/* Power on device */
+	if (st->plat_data.power_on) {
+		result = st->plat_data.power_on(&st->plat_data);
+		if (result < 0) {
+			dev_err(st->dev, "power_on failed: %d\n", result);
+			goto out_free;
+		}
+		pr_info("%s: power on here.\n", __func__);
+	}
+	pr_info("%s: power on.\n", __func__);
+
+	msleep(100);
+
+	/* power is turned on inside check chip type */
+	result = inv_check_chip_type(indio_dev, id->name);
+	if (result)
+		goto out_free;
+
+	result = inv_mpu_configure_ring(indio_dev);
+	if (result) {
+		pr_err("configure ring buffer fail\n");
+		goto out_free;
+	}
+
+	result = iio_device_register(indio_dev);
+	if (result) {
+		pr_err("IIO device register fail\n");
+		goto out_unreg_ring;
+	}
+
+	result = inv_create_dmp_sysfs(indio_dev);
+	if (result) {
+		pr_err("create dmp sysfs failed\n");
+		goto out_unreg_iio;
+	}
+	init_waitqueue_head(&st->wait_queue);
+	st->resume_state = true;
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_init(&st->wake_lock, WAKE_LOCK_SUSPEND, "inv_mpu");
+#else
+	st->wake_lock = wakeup_source_create("inv_mpu");
+	wakeup_source_add(st->wake_lock);
+	if (st->wake_lock)
+		pr_info("wakeup_source is created successfully\n");
+	else
+		pr_info("failed to create wakeup_source\n");
+#endif
+	dev_info(st->dev, "%s ma-kernel-%s is ready to go!\n",
+				indio_dev->name, INVENSENSE_DRIVER_VERSION);
+
+#ifdef SENSOR_DATA_FROM_REGISTERS
+	pr_info("Data read from registers\n");
+#else
+	pr_info("Data read from FIFO\n");
+#endif
+#ifdef TIMER_BASED_BATCHING
+	pr_info("Timer based batching\n");
+#endif
+
+	return 0;
+
+out_unreg_iio:
+	iio_device_unregister(indio_dev);
+out_unreg_ring:
+	inv_mpu_unconfigure_ring(indio_dev);
+out_free:
+	iio_device_free(indio_dev);
+out_no_free:
+	dev_err(&client->dev, "%s failed %d\n", __func__, result);
+	return result;
+}
+
+static void inv_mpu_shutdown(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&indio_dev->mlock);
+	inv_switch_power_in_lp(st, true);
+	dev_dbg(st->dev, "Shutting down %s...\n", st->hw->name);
+
+	/* reset to make sure previous state are not there */
+#if defined(CONFIG_INV_MPU_IIO_ICM42600)
+	result = inv_plat_single_write(st, REG_CHIP_CONFIG_REG, BIT_SOFT_RESET);
+#else
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_H_RESET);
+#endif
+	if (result)
+		dev_err(st->dev, "Failed to reset %s\n",
+			st->hw->name);
+	msleep(POWER_UP_TIME);
+	/* turn off power to ensure gyro engine is off */
+	result = inv_set_power(st, false);
+	if (result)
+		dev_err(st->dev, "Failed to turn off %s\n",
+			st->hw->name);
+	inv_switch_power_in_lp(st, false);
+	mutex_unlock(&indio_dev->mlock);
+}
+
+/*
+ *  inv_mpu_remove() - remove function.
+ */
+static int inv_mpu_remove(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+#ifndef CONFIG_HAS_WAKELOCK
+	if (st->wake_lock)
+		wakeup_source_destroy(st->wake_lock);
+#endif
+	if (st->aux_dev)
+		i2c_unregister_device(st->aux_dev);
+	iio_device_unregister(indio_dev);
+	inv_mpu_unconfigure_ring(indio_dev);
+	iio_device_free(indio_dev);
+	dev_info(st->dev, "inv-mpu-iio module removed.\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int inv_mpu_i2c_suspend(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+
+	return inv_mpu_suspend(indio_dev);
+}
+
+static void inv_mpu_i2c_complete(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+
+	inv_mpu_complete(indio_dev);
+}
+#endif
+
+static const struct dev_pm_ops inv_mpu_i2c_pmops = {
+#ifdef CONFIG_PM_SLEEP
+	.suspend = inv_mpu_i2c_suspend,
+	.complete = inv_mpu_i2c_complete,
+#endif
+};
+
+/* device id table is used to identify what device can be
+ * supported by this driver
+ */
+static const struct i2c_device_id inv_mpu_id[] = {
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	{"icm20648", ICM20648},
+#else
+	{"icm20608d", ICM20608D},
+	{"icm20789", ICM20789},
+	{"icm20689", ICM20689},
+	{"icm20690", ICM20690},
+	{"icm20602", ICM20602},
+	{"iam20680", IAM20680},
+	{"icm42600", ICM42600},
+	{"icm42686", ICM42686},
+	{"icm40609d", ICM40609D},
+#endif
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, inv_mpu_id);
+
+static const struct of_device_id inv_mpu_of_match[] = {
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	{
+		.compatible = "invensense,icm20648",
+		.data = (void *)ICM20648,
+	},
+#else
+	{
+		.compatible = "invensense,icm20608d",
+		.data = (void *)ICM20608D,
+	}, {
+		.compatible = "invensense,icm20789",
+		.data = (void *)ICM20789,
+	}, {
+		.compatible = "invensense,icm20689",
+		.data = (void *)ICM20689,
+	}, {
+		.compatible = "invensense,icm20690",
+		.data = (void *)ICM20690,
+	}, {
+		.compatible = "invensense,icm20602",
+		.data = (void *)ICM20602,
+	}, {
+		.compatible = "invensense,iam20680",
+		.data = (void *)IAM20680,
+	}, {
+		.compatible = "invensense,icm42600",
+		.data = (void *)ICM42600,
+	}, {
+		.compatible = "invensense,icm42686",
+		.data = (void *)ICM42686,
+	}, {
+		.compatible = "invensense,icm40609d",
+		.data = (void *)ICM40609D,
+	},
+#endif
+	{ }
+};
+MODULE_DEVICE_TABLE(of, inv_mpu_of_match);
+
+static struct i2c_driver inv_mpu_driver = {
+	.probe = inv_mpu_probe,
+	.remove = inv_mpu_remove,
+	.shutdown = inv_mpu_shutdown,
+	.id_table = inv_mpu_id,
+	.driver = {
+		.owner = THIS_MODULE,
+		.of_match_table = inv_mpu_of_match,
+		.name = "inv-mpu-iio-i2c",
+		.pm = &inv_mpu_i2c_pmops,
+	},
+};
+module_i2c_driver(inv_mpu_driver);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense I2C device driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_iio.h b/drivers/iio/imu/inv_mpu/inv_mpu_iio.h
new file mode 100644
index 000000000000..8000d748e2f0
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_iio.h
@@ -0,0 +1,1215 @@
+/*
+ * Copyright (C) 2012-2020 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _INV_MPU_IIO_H_
+#define _INV_MPU_IIO_H_
+
+#include <linux/i2c.h>
+#include <linux/kfifo.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/iio/imu/mpu.h>
+#include <linux/interrupt.h>
+#include <linux/semaphore.h>
+#ifdef CONFIG_HAS_WAKELOCK
+#include <linux/wakelock.h>
+#else
+#include <linux/pm_wakeup.h>
+#endif
+#include <linux/wait.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/trigger_consumer.h>
+
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+#include "icm20648/dmp3Default.h"
+#endif
+#ifdef CONFIG_INV_MPU_IIO_ICM20608D
+#include "icm20608d/dmp3Default_20608D.h"
+#endif
+
+#if defined(CONFIG_INV_MPU_IIO_ICM20648)
+#include "icm20648/inv_mpu_iio_reg_20648.h"
+#elif defined(CONFIG_INV_MPU_IIO_ICM20602)
+#include "icm20602/inv_mpu_iio_reg_20602.h"
+#elif defined(CONFIG_INV_MPU_IIO_ICM20608D)
+#include "icm20608d/inv_mpu_iio_reg_20608.h"
+#elif defined(CONFIG_INV_MPU_IIO_ICM20689)
+#include "iam20680/inv_mpu_iio_reg_20680.h"
+#elif defined(CONFIG_INV_MPU_IIO_ICM20690)
+#include "icm20690/inv_mpu_iio_reg_20690.h"
+#elif defined(CONFIG_INV_MPU_IIO_IAM20680)
+#include "iam20680/inv_mpu_iio_reg_20680.h"
+#elif defined(CONFIG_INV_MPU_IIO_ICM42600)
+#include "icm42600/inv_mpu_iio_reg_42600.h"
+#endif
+
+#define INVENSENSE_DRIVER_VERSION		"9.2.1-test2"
+
+/* #define DEBUG */
+
+/* #define ACCEL_BIAS_TEST */
+
+/* #define BIAS_CONFIDENCE_HIGH 1 */
+
+#define MAX_FIFO_READ_SIZE       128
+#define MAX_DMP_READ_SIZE        16
+
+/* data header defines */
+#define WAKE_HDR                 0x8000
+
+#define ACCEL_HDR                1
+#define GYRO_HDR                 2
+#define COMPASS_HDR              3
+#define ALS_HDR                  4
+#define SIXQUAT_HDR              5
+#define NINEQUAT_HDR             6
+#define PEDQUAT_HDR              7
+#define GEOMAG_HDR               8
+#define PRESSURE_HDR             9
+#define GYRO_CALIB_HDR           10
+#define COMPASS_CALIB_HDR        11
+#define STEP_COUNTER_HDR         12
+#define STEP_DETECTOR_HDR        13
+#define STEP_COUNT_HDR           14
+#define ACTIVITY_HDR             15
+#define PICK_UP_HDR              16
+#define EMPTY_MARKER             17
+#define END_MARKER               18
+#define COMPASS_ACCURACY_HDR     19
+#define ACCEL_ACCURACY_HDR       20
+#define GYRO_ACCURACY_HDR        21
+#define EIS_GYRO_HDR             36
+#define EIS_CALIB_HDR            37
+#define LPQ_HDR                  38
+#define TAP_HDR                  40
+
+#define ACCEL_WAKE_HDR           (ACCEL_HDR | WAKE_HDR)
+#define GYRO_WAKE_HDR            (GYRO_HDR | WAKE_HDR)
+#define COMPASS_WAKE_HDR         (COMPASS_HDR | WAKE_HDR)
+#define ALS_WAKE_HDR             (ALS_HDR | WAKE_HDR)
+#define SIXQUAT_WAKE_HDR         (SIXQUAT_HDR | WAKE_HDR)
+#define NINEQUAT_WAKE_HDR        (NINEQUAT_HDR | WAKE_HDR)
+#define PEDQUAT_WAKE_HDR         (PEDQUAT_HDR | WAKE_HDR)
+#define GEOMAG_WAKE_HDR          (GEOMAG_HDR | WAKE_HDR)
+#define PRESSURE_WAKE_HDR        (PRESSURE_HDR | WAKE_HDR)
+#define GYRO_CALIB_WAKE_HDR      (GYRO_CALIB_HDR | WAKE_HDR)
+#define COMPASS_CALIB_WAKE_HDR   (COMPASS_CALIB_HDR | WAKE_HDR)
+#define STEP_COUNTER_WAKE_HDR    (STEP_COUNTER_HDR | WAKE_HDR)
+#define STEP_DETECTOR_WAKE_HDR   (STEP_DETECTOR_HDR | WAKE_HDR)
+#define TAP_WAKE_HDR             (TAP_HDR | WAKE_HDR)
+
+/* init parameters */
+#define MPU_INIT_SMD_THLD        1500
+/* default FSR for gyro
+ * note: 4000dps is supported only by icm42686.
+ * 0:250dps, 1:500dps, 2:1000dps, 3:2000dps, 4:4000dps
+ */
+#define MPU_INIT_GYRO_SCALE      3
+/* default FSR for accel
+ * note: 32g is supported by only by icm42686. 2g is not supported by icm42686.
+ * 0:2g, 1:4g, 2:8g, 3:16g, 4:32g
+ */
+#define MPU_INIT_ACCEL_SCALE     1
+#define MPU_INIT_PED_INT_THRESH  2
+#define MPU_INIT_PED_STEP_THRESH 6
+#define MPU_4X_TS_GYRO_SHIFT      (3160000 / 2)
+#define DMP_START_ADDR_20648     0x1000
+#define DMP_START_ADDR_20608D    0x4B0
+#define MAX_WR_SZ                PAGE_SIZE
+#define WOM_DELAY_THRESHOLD      200
+#define STATIONARY_DELAY_THRESHOLD 12000 /* 60s */
+#define INV_ODR_BUFFER_MULTI     20
+
+#define COVARIANCE_SIZE          14
+#define ACCEL_COVARIANCE_SIZE  (COVARIANCE_SIZE * sizeof(int))
+
+enum inv_bus_type {
+	BUS_I2C = 0,
+	BUS_SPI,
+};
+
+struct inv_mpu_state;
+
+enum INV_ENGINE {
+	ENGINE_GYRO = 0,
+	ENGINE_ACCEL,
+	ENGINE_PRESSURE,
+	ENGINE_I2C,
+	ENGINE_NUM_MAX,
+};
+
+/**
+ *  struct inv_hw_s - Other important hardware information.
+ *  @num_reg:	Number of registers on device.
+ *  @name:      name of the chip
+ */
+struct inv_hw_s {
+	u8 num_reg;
+	u8 *name;
+};
+
+/**
+ *  struct inv_sensor - information for each sensor.
+ *  @ts: this sensors timestamp.
+ *  @ts_adj: sensor timestamp adjustment.
+ *  @previous_ts: previous timestamp for this sensor.
+ *  @dur: duration between samples in ns.
+ *  @rate:  sensor data rate.
+ *  @sample_size: number of bytes for the sensor.
+ *  @odr_addr: output data rate address in DMP.
+ *  @counter_addr: output counter address in DMP.
+ *  @output: output on/off control word.
+ *  @time_calib: calibrate timestamp.
+ *  @sample_calib: calibrate bytes accumulated.
+ *  @div:         divider in DMP mode.
+ *  @calib_flag:  calibrate flag used to improve the accuracy of estimation.
+ *  @on:    sensor on/off.
+ *  @a_en:  accel engine requirement.
+ *  @g_en:  gyro engine requirement.
+ *  @c_en:  compass_engine requirement.
+ *  @p_en:  pressure engine requirement.
+ *  @engine_base: engine base for this sensor.
+ *  @count: number of samples in one session.
+ *  @send: decide whether to send this sample or not.
+ */
+struct inv_sensor {
+	u64 ts;
+	s64 ts_adj;
+	u64 previous_ts;
+	int dur;
+	int rate;
+	u8 sample_size;
+	int odr_addr;
+	int counter_addr;
+	u16 output;
+	u64 time_calib;
+	u32 sample_calib;
+	int div;
+	bool calib_flag;
+	bool on;
+	bool a_en;
+	bool g_en;
+	bool c_en;
+	bool p_en;
+	enum INV_ENGINE engine_base;
+	int count;
+	bool send;
+};
+
+/**
+ *  struct inv_sensor - information for each sensor.
+ *  @sample_size: number of bytes for the sensor.
+ *  @output: output on/off control word.
+ *  @on:    sensor on/off.
+ *  @header: accuracy header for communicate with HAL
+ *dd  @count: number of samples in one session.
+ */
+struct inv_sensor_accuracy {
+	u16 output;
+	u8 sample_size;
+	bool on;
+	u16 header;
+};
+
+enum SENSOR_ACCURACY {
+	SENSOR_ACCEL_ACCURACY = 0,
+	SENSOR_GYRO_ACCURACY,
+	SENSOR_COMPASS_ACCURACY,
+	SENSOR_ACCURACY_NUM_MAX,
+};
+
+enum SENSOR_L {
+	SENSOR_L_ACCEL = 0,
+	SENSOR_L_GYRO,
+	SENSOR_L_MAG,
+	SENSOR_L_ALS,
+	SENSOR_L_SIXQ,
+	SENSOR_L_THREEQ,
+	SENSOR_L_NINEQ,
+	SENSOR_L_PEDQ,
+	SENSOR_L_GEOMAG,
+	SENSOR_L_PRESSURE,
+	SENSOR_L_GYRO_CAL,
+	SENSOR_L_MAG_CAL,
+	SENSOR_L_EIS_GYRO,
+	/*wake sensors */
+	SENSOR_L_ACCEL_WAKE = 13,
+	SENSOR_L_GYRO_WAKE,
+	SENSOR_L_MAG_WAKE,
+	SENSOR_L_ALS_WAKE,
+	SENSOR_L_SIXQ_WAKE,
+	SENSOR_L_NINEQ_WAKE,
+	SENSOR_L_PEDQ_WAKE,
+	SENSOR_L_GEOMAG_WAKE,
+	SENSOR_L_PRESSURE_WAKE,
+	SENSOR_L_GYRO_CAL_WAKE,
+	SENSOR_L_MAG_CAL_WAKE,
+	SENSOR_L_GESTURE_ACCEL,
+	SENSOR_L_NUM_MAX,
+};
+
+/**
+ *  struct android_l_sensor - information for each android sensor.
+ *  @ts: this sensors timestamp.
+ *  @base: android sensor based on invensense sensor.
+ *  @rate: output rate.
+ *  @on:  sensor on/off.
+ *  @wake_on: wake on sensor is on/off.
+ *  @div: divider for the output.
+ *  @counter: counter works with the divider.
+ *  @header: header for the output.
+ */
+struct android_l_sensor {
+	u64 ts;
+	enum INV_SENSORS base;
+	int rate;
+	bool on;
+	bool wake_on;
+	int div;
+	int counter;
+	u16 header;
+};
+
+/**
+ *  struct inv_batch - information for batchmode.
+ *  @on: normal batch mode on.
+ *  @default_on: default batch on. This is optimization option.
+ *  @overflow_on: overflow mode for batchmode.
+ *  @wake_fifo_on: overflow for suspend mode.
+ *  @step_only: mean only step detector data is batched.
+ *  @post_isr_run: mean post isr has runned once.
+ *  @counter: counter for batch mode.
+ *  @timeout: nominal timeout value for batchmode in milliseconds.
+ *  @max_rate: max rate for all batched sensors.
+ *  @pk_size: packet size;
+ *  @engine_base: engine base batch mode should stick to.
+ */
+struct inv_batch {
+	bool on;
+	bool default_on;
+	bool overflow_on;
+	bool wake_fifo_on;
+	bool step_only;
+	bool post_isr_run;
+	u32 counter;
+	u32 timeout;
+	u32 max_rate;
+	u32 pk_size;
+	u32 fifo_wm_th;
+	enum INV_ENGINE engine_base;
+};
+
+/**
+ *  struct inv_chip_config_s - Cached chip configuration data.
+ *  @fsr:		Full scale range.
+ *  @lpf:		Digital low pass filter frequency.
+ *  @accel_fs:		accel full scale range.
+ *  @accel_enable:	enable accel functionality
+ *  @gyro_enable:	enable gyro functionality
+ *  @compass_enable:    enable compass functinality.
+ *  @geomag_enable:     enable geomag sensor functions.
+ *  @als_enable:        enable ALS functionality.
+ *  @pressure_enable:   eanble pressure functionality.
+ *  @secondary_enable:  secondary I2C bus enabled or not.
+ *  @has_gyro:	has gyro or not.
+ *  @has_compass:	has secondary I2C compass or not.
+ *  @has_pressure:      has secondary I2C pressure or not.
+ *  @has_als:           has secondary I2C als or not.
+ *  @slave_enable:      secondary I2C interface enabled or not.
+ *  @normal_compass_measure: discard first compass data after reset.
+ *  @is_asleep:		1 if chip is powered down.
+ *  @lp_en_set:         1 if LP_EN bit is set;
+ *  @lp_en_mode_off:    debug mode that turns off LP_EN mode off.
+ *  @clk_sel:           debug_mode that turns on/off clock selection.
+ *  @dmp_on:		dmp is on/off.
+ *  @dmp_event_int_on:  dmp event interrupt on/off.
+ *  @wom_on:        WOM interrupt on. This is an internal variable.
+ *  @step_indicator_on: step indicate bit added to the sensor or not.
+ *  @tilt_enable: tilt enable.
+ *  @pick_up_enable: pick up gesture enable.
+ *  @tap_enable: tap gesture enable.
+ *  @stationary_detect_enable: stationary detect enable.
+ *  @motion_detect_enable: motion detect enable.
+ *  @step_detector_on:  step detector on or not.
+ *  @activity_on: turn on/off activity.
+ *  @activity_eng_on: activity engine on/off.
+ *  @firmware_loaded:	flag indicate firmware loaded or not.
+ *  @low_power_gyro_on: flag indicating low power gyro on/off.
+ *  @wake_on: any wake on sensor is on/off.
+ *  @compass_rate:    compass engine rate. Determined by underlying data.
+ *  @high_res_mode: high resolution mode on/off.
+ */
+struct inv_chip_config_s {
+	u32 fsr:3;
+	u32 lpf:3;
+	u32 accel_fs:3;
+	u32 accel_enable:1;
+	u32 gyro_enable:1;
+	u32 compass_enable:1;
+	u32 geomag_enable:1;
+	u32 als_enable:1;
+	u32 prox_enable:1;
+	u32 pressure_enable:1;
+	u32 has_gyro:1;
+	u32 has_compass:1;
+	u32 has_pressure:1;
+	u32 has_als:1;
+	u32 slave_enable:1;
+	u32 normal_compass_measure:1;
+	u32 is_asleep:1;
+	u32 lp_en_set:1;
+	u32 lp_en_mode_off:1;
+	u32 clk_sel:1;
+	u32 dmp_on:1;
+	u32 dmp_event_int_on:1;
+	u32 wom_on:1;
+	u32 step_indicator_on:1;
+	u32 tilt_enable:1;
+	u32 pick_up_enable:1;
+	u32 tap_enable:1;
+	u32 stationary_detect_enable:1;
+	u32 motion_detect_enable:1;
+	u32 eis_enable:1;
+	u32 step_detector_on:1;
+	u32 activity_on:1;
+	u32 activity_eng_on:1;
+	u32 firmware_loaded:1;
+	u32 low_power_gyro_on:1;
+	u32 wake_on:1;
+	int compass_rate;
+	u32 high_res_mode:1;
+};
+
+/**
+ *  struct inv_temp_comp - temperature compensation structure.
+ *  @t_lo:    raw temperature in low temperature.
+ *  @t_hi:    raw temperature in high temperature.
+ *  @b_lo:    gyro bias in low temperature.
+ *  @b_hi:    gyro bias in high temperature.
+ *  @has_low:    flag indicate low temperature parameters is updated.
+ *  @has_high:   flag indicates high temperature parameters is updated.
+ *  @slope:      slope for temperature compensation.
+ */
+struct inv_temp_comp {
+	int t_lo;
+	int t_hi;
+	int b_lo[3];
+	int b_hi[3];
+	bool has_low;
+	bool has_high;
+	int slope[3];
+};
+
+/**
+ *  struct inv_chip_info_s - Chip related information.
+ *  @product_id:	Product id.
+ *  @product_revision:	Product revision.
+ *  @silicon_revision:	Silicon revision.
+ *  @software_revision:	software revision.
+ *  @compass_sens:	compass sensitivity.
+ *  @gyro_sens_trim:	Gyro sensitivity trim factor.
+ *  @accel_sens_trim:    accel sensitivity trim factor.
+ */
+struct inv_chip_info_s {
+	u8 product_id;
+	u8 product_revision;
+	u8 silicon_revision;
+	u8 software_revision;
+	u8 compass_sens[3];
+	u32 gyro_sens_trim;
+	u32 accel_sens_trim;
+};
+
+/**
+ * struct inv_smd significant motion detection structure.
+ * @threshold: accel threshold for motion detection.
+ * @delay: delay time to confirm 2nd motion.
+ * @delay2: delay window parameter.
+ * @on: smd on/off.
+ */
+struct inv_smd {
+	u32 threshold;
+	u32 delay;
+	u32 delay2;
+	bool on;
+};
+
+/**
+ * struct inv_ped pedometer related data structure.
+ * @step: steps taken.
+ * @time: time taken during the period.
+ * @last_step_time: last time the step is taken.
+ * @step_thresh: step threshold to show steps.
+ * @int_thresh: step threshold to generate interrupt.
+ * @int_on:   pedometer interrupt enable/disable.
+ * @int_mode: select the trigger to read step count from DMP, int or poll.
+ * @on:  pedometer on/off.
+ * @engine_on: pedometer engine on/off.
+ */
+struct inv_ped {
+	u64 step;
+	u64 time;
+	u64 last_step_time;
+	u16 step_thresh;
+	u16 int_thresh;
+	bool int_on;
+	bool int_mode;
+	bool on;
+	bool engine_on;
+};
+
+/**
+ * struct inv_eis EIS related data structure.
+ * @prev_gyro: latest gyro data just before FSYNC triggerd
+ * @prev_timestamp: latest gyro timestamp just before FSYNC triggered
+ * @current_gyro: gyro data just after FSYNC triggerd
+ * @current_timestamp: gyro timestamp just after FSYNC triggered
+ * @fsync_timestamp: timestamp of FSYNC event
+ * @fsync_delay: delay time of FSYNC and Gyro data. DMP data of FSYNC event
+ * @eis_triggered: check fsync event is triggered or not.
+ * @eis_frame: current frame is eis frame;
+ * @current_sync: current frame contains fsync counter.
+ * @frame_count: frame count for synchronization.
+ */
+struct inv_eis {
+	int prev_gyro[3];
+	u64 prev_timestamp;
+	int current_gyro[3];
+	u64 current_timestamp;
+	u32 frame_dur;
+	u64 slope[3];
+	u64 fsync_timestamp;
+	u64 last_fsync_timestamp;
+	u16 fsync_delay;
+	bool eis_triggered;
+	bool eis_frame;
+	bool current_sync;
+	bool prev_state;
+	u32 frame_count;
+	int gyro_counter;
+	int gyro_counter_s[3];
+	int fsync_delay_s[3];
+	int voting_count;
+	int voting_count_sub;
+	int voting_state;
+	int count_precision;
+};
+
+enum TRIGGER_STATE {
+	DATA_TRIGGER = 0,
+	RATE_TRIGGER,
+	EVENT_TRIGGER,
+	MISC_TRIGGER,
+	DEBUG_TRIGGER,
+};
+
+enum inv_fifo_count_mode {
+	BYTE_MODE,
+	RECORD_MODE
+};
+
+/**
+ *  struct inv_secondary_reg - secondary registers data structure.
+ *  @addr:       address of the slave.
+ *  @reg: register address of slave.
+ *  @ctrl: control register.
+ *  @d0: data out register.
+ */
+struct inv_secondary_reg {
+	u8 addr;
+	u8 reg;
+	u8 ctrl;
+	u8 d0;
+};
+
+struct inv_secondary_set {
+	u8 delay_enable;
+	u8 delay_time;
+	u8 odr_config;
+};
+/**
+ *  struct inv_engine_info - data structure for engines.
+ *  @base_time: base time for each engine.
+ *  @base_time_1k: base time when chip is running at 1K;
+ *  @base_time_vr: base time when chip is running in VR mode(500Hz);
+ *  @divider: divider used to downsample engine rate from original rate.
+ *  @running_rate: the actually running rate of engine.
+ *  @orig_rate: original rate for each engine before downsample.
+ *  @dur: duration for one tick.
+ *  @last_update_time: last update time.
+ */
+struct inv_engine_info {
+	u32 base_time;
+	u32 base_time_1k;
+	u32 base_time_vr;
+	u32 divider;
+	u32 running_rate;
+	u32 orig_rate;
+	u32 dur;
+	u64 last_update_time;
+};
+
+struct inv_ois {
+	int gyro_fs;
+	int accel_fs;
+	bool en;
+};
+
+/**
+ *  struct inv_timestamp_algo - timestamp algorithm .
+ *  @last_run_time: last time the post ISR runs.
+ *  @ts_for_calib: ts storage for calibration.
+ *  @reset_ts: reset time.
+ *  @dmp_ticks: dmp ticks storage for calibration.
+ *  @start_dmp_counter: dmp counter when start a new session.
+ *  @calib_counter: calibration counter for timestamp.
+ *  @resume_flag: flag to indicate this is the first time after resume. time
+ *				could have up to 1 seconds difference.
+ *  @clock_base: clock base to calculate the timestamp.
+ *  @gyro_ts_shift: 9 K counter for EIS.
+ *  @first_sample: first of 1K running should be dropped it affects timing
+ *  @first_drop_samples: the number of first samples to be dropped
+ */
+struct inv_timestamp_algo {
+	u64 last_run_time;
+	u64 ts_for_calib;
+	u64 reset_ts;
+	u32 dmp_ticks;
+	u32 start_dmp_counter;
+	int calib_counter;
+	bool resume_flag;
+	enum INV_ENGINE clock_base;
+	u32 gyro_ts_shift;
+	u32 first_sample;
+	u32 first_drop_samples[SENSOR_NUM_MAX];
+};
+
+#ifdef CONFIG_INV_MPU_IIO_ICM42600
+/**
+ *	struct inv_apex_data - apex gesture algo data .
+ *	@step_cnt_total: step count total.
+ *	@step_cnt_last_val: previous step count value from chip.
+ *	@step_reset_last_val: check if it is first time after step count reset.
+ */
+struct inv_apex_data {
+	uint32_t step_cnt_total;
+	uint32_t step_cnt_last_val;
+	bool step_reset_last_val;
+};
+#endif
+
+struct inv_mpu_slave;
+/**
+ *  struct inv_mpu_state - Driver state variables.
+ *  @dev:               device address of the current bus, i2c or spi.
+ *  @aux_dev:           device connected on auxiliary i2c bus with bypass mode.
+ *  @trig:		iio trigger device.
+ *  @chip_config:	Cached attribute information.
+ *  @chip_info:		Chip information from read-only registers.
+ *  @smd:               SMD data structure.
+ *  @ped:               pedometer data structure.
+ *  @batch:             batchmode data structure.
+ *  @temp_comp:         gyro temperature compensation structure.
+ *  @slave_compass:     slave compass.
+ *  @slave_pressure:    slave pressure.
+ *  @slave_als:         slave als.
+ *  @slv_reg: slave register data structure.
+ *  @ts_algo: timestamp algorithm data structure.
+ *  @apex_supported flag if apex feature is supported.
+ *  @smd_supported flag if smd is supported by hardware.
+ *  @apex_data data of apex data.
+ *  @sec_set: slave register odr config.
+ *  @eng_info: information for each engine.
+ *  @hw:		Other hardware-specific information.
+ *  @chip_type:		chip type.
+ *  @suspend_resume_sema: semaphore for suspend/resume.
+ *  @wake_lock: wake lock of the system.
+ *  @client:		i2c client handle.
+ *  @plat_data:		platform data.
+ *  @sl_handle:         Handle to I2C port.
+ *  @sensor{SENSOR_NUM_MAX]: sensor individual properties.
+ *  @sensor_l[SENSOR_L_NUM_MAX]: android L sensors properties.
+ *  @sensor_accuracy[SENSOR_ACCURACY_NUM_MAX]: sensor accuracy.
+ *  @sensor_acurracy_flag: flag indiciate whether to check output accuracy.
+ *  @irq:               irq number store.
+ *  @accel_bias:        accel bias store.
+ *  @gyro_bias:         gyro bias store.
+ *  @accel_st_bias:     accel bias store, result of self-test.
+ *  @gyro_st_bias:      gyro bias store, result of self-test.
+ *  @gyro_ois_st_bias:  gyro bias store from ois self test result.
+ *  @gyro_lp_mode:  gyro low power mode on/off.
+ *  @accel_lp_mode:  accel low power mode on/off.
+ *  @input_accel_dmp_bias[3]: accel bias for dmp.
+ *  @input_gyro_dmp_bias[3]: gyro bias for dmp.
+ *  @input_compass_dmp_bias[3]: compass bias for dmp.
+ *  @input_accel_bias[3]: accel bias for offset register.
+ *  @input_gyro_bias[3]: gyro bias for offset register.
+ *  @org_accel_offset_reg[3]: accel offset register original values.
+ *  @org_gyro_offset_reg[3]: gyro offset register original values.
+ *  @fifo_data[8]: fifo data storage.
+ *  @i2c_addr:          i2c address.
+ *  @header_count:      header count in current FIFO.
+ *  @step_det_count:    number of step detectors in one batch.
+ *  @gyro_sf: gyro scale factor.
+ *  @left_over[LEFT_OVER_BYTES]: left over bytes storage.
+ *  @left_over_size: left over size.
+ *  @fifo_count: current fifo_count;
+ *  @wake_sensor_received: wake up sensor received.
+ *  @accel_cal_enable:  accel calibration on/off
+ *  @gyro_cal_enable:   gyro calibration on/off
+ *  @calib_compass_on: calibrate compass on.
+ *  @debug_determine_engine_on: determine engine on/off.
+ *  @poke_mode_on: poke mode on/off.
+ *  @mode_1k_on: indicate 1K Hz mode is on.
+ *  @mode_vr_on: indicates VR mode (500 Hz) is on
+ *  @poke_ts: time stamp for poke feature.
+ *  @step_detector_base_ts: base time stamp for step detector calculation.
+ *  @last_temp_comp_time: last time temperature compensation is done.
+ *  @i2c_dis: disable I2C interface or not.
+ *  @name: name for the chip.
+ *  @gyro_st_data: gyro self test data.
+ *  @accel_st_data: accel self test data.
+ *  @secondary_name: name for the slave device in the secondary I2C.
+ *  @compass_var: compass variance from DMP.
+ *  @current_compass_matrix: matrix compass data multiplied to before soft iron.
+ *  @final_compass_matrix: matrix compass data multiplied to before soft iron.
+ *  @trigger_state: information that which part triggers set_inv_enable.
+ *  @firmware: firmware data pointer.
+ *  @accel_calib_threshold: accel calibration threshold;
+ *  @accel_calib_rate: divider for accel calibration rate.
+ *  @accel_covariance[COVARIANCE_SIZE]: accel covariance data;
+ *  @kf: kfifo for activity store.
+ *  @activity_size: size for activity.
+ *  @cntl: control word for sensor enable.
+ *  @cntl2: control word for sensor extension.
+ *  @motion_event_cntl: control word for events.
+ *  @intr_cntl: control word for fifo interrupt.
+ *  @dmp_image_size: dmp image size.
+ *  @dmp_start_address: start address of dmp.
+ *  @step_counter_l_on: step counter android L sensor on/off.
+ *  @step_counter_wake_l_on: step counter android L sensor wake on/off .
+ *  @step_detector_l_on: step detector android L sensor on/off.
+ *  @step_detector_wake_l_on: step detector android L sensor wake on/off .
+ *  @gesture_only_on: indicate it is gesture only.
+ *  @mag_divider: mag divider when gyro/accel is faster than mag maximum rate.
+ *  @mag_first_drop_cnt: mag sample counter to be dropped after enable.
+ *  @prev_steps: previous steps sent to the user.
+ *  @aut_key_in: authentication key input.
+ *  @aut_key_out: authentication key output.
+ *  @auth_i: authentication data input
+ *  @auth_o: authentication data output
+ *  @suspend_state: state variable to indicate that we are in suspend state.
+ *  @secondary_gyro_on: DMP out signal to turn on gyro.
+ *  @secondary_mag_on:  DMP out signal to turn on mag.
+ *  @secondary_prox_on: DMP out signal to turn on proximity.
+ *  @secondary_switch: showing this setup is triggerred by secondary switch.
+ *  @send_calib_gyro:       flag to indicate to send calibrated gyro.
+ *  @send_raw_compass: flag to send raw compass.
+ *  @resume_state: flag to synchronize the processing of inv_read_fifo()
+ *  @cycle_on: variable indicate accel cycle mode is on.
+ *  @secondary_switch_data: secondary switch data for activity.
+ *  @raw_gyro_data[6]:    save raw gyro data.
+ *  @raw_compass_data[3]: save raw compass data.
+ *  @wait_queue: wait queue to wake up inv_read_fifo()
+ *  @bac_drive_conf: bac drive configuration.
+ *  @bac_walk_conf: bac walk configuration.
+ *  @bac_smd_conf: bac smd configuration.
+ *  @bac_bike_conf: bac bike configuration.
+ *  @bac_run_conf: bac run configuration.
+ *  @bac_still_conf: back still configuration.
+ *  @power_on_data: power on data.
+ *  @fifo_data_store: store of FIFO data.
+ *  @int_en: store interrupt enable register data.
+ *  @int_en2: store interrupt enable register 2 data.
+ *  @gesture_int_count: interrupt count for gesture only mode.
+ *  @smplrt_div: SMPLRT_DIV register value.
+ */
+struct inv_mpu_state {
+	struct device *dev;
+	struct i2c_client *aux_dev;
+	struct iio_trigger *trig;
+	int (*write)(struct inv_mpu_state *st, u8 reg, u8 data);
+	int (*read)(struct inv_mpu_state *st, u8 reg, int len, u8 *data);
+	int (*mem_write)(struct inv_mpu_state *st, u8 mpu_addr, u16 mem_addr,
+			u32 len, u8 const *data);
+	int (*mem_read)(struct inv_mpu_state *st, u8 mpu_addr, u16 mem_addr,
+			u32 len, u8 *data);
+	struct inv_chip_config_s chip_config;
+	struct inv_chip_info_s chip_info;
+	struct inv_smd smd;
+	struct inv_ped ped;
+	struct inv_eis eis;
+	struct inv_batch batch;
+	struct inv_temp_comp temp_comp;
+	struct inv_mpu_slave *slave_compass;
+	struct inv_mpu_slave *slave_pressure;
+	struct inv_mpu_slave *slave_als;
+	struct inv_secondary_reg slv_reg[4];
+	struct inv_timestamp_algo ts_algo;
+#ifdef CONFIG_INV_MPU_IIO_ICM42600
+	bool apex_supported;
+	bool smd_supported;
+	struct inv_apex_data apex_data;
+#endif
+	struct inv_secondary_set sec_set;
+	struct inv_engine_info eng_info[ENGINE_NUM_MAX];
+	const struct inv_hw_s *hw;
+	enum inv_devices chip_type;
+	enum inv_bus_type bus_type;
+	enum inv_fifo_count_mode fifo_count_mode;
+#ifdef CONFIG_HAS_WAKELOCK
+	struct wake_lock wake_lock;
+#else
+	struct wakeup_source *wake_lock;
+#endif
+#ifdef TIMER_BASED_BATCHING
+	struct hrtimer hr_batch_timer;
+	u64 batch_timeout;
+	bool is_batch_timer_running;
+	struct work_struct batch_work;
+#endif
+	struct i2c_client *client;
+	struct mpu_platform_data plat_data;
+	void *sl_handle;
+	struct inv_sensor sensor[SENSOR_NUM_MAX];
+	struct android_l_sensor sensor_l[SENSOR_L_NUM_MAX];
+	struct inv_sensor_accuracy sensor_accuracy[SENSOR_ACCURACY_NUM_MAX];
+	struct inv_ois ois;
+	bool sensor_acurracy_flag[SENSOR_ACCURACY_NUM_MAX];
+	short irq;
+	int accel_bias[3];
+	int gyro_bias[3];
+	int accel_st_bias[3];
+	int accel_ois_st_bias[3];
+	int gyro_st_bias[3];
+	int gyro_ois_st_bias[3];
+	int gyro_lp_mode;
+	int accel_lp_mode;
+	int input_accel_dmp_bias[3];
+	int input_gyro_dmp_bias[3];
+	int input_compass_dmp_bias[3];
+	int input_accel_bias[3];
+	int input_gyro_bias[3];
+	s16 org_accel_offset_reg[3];
+	s16 org_gyro_offset_reg[3];
+	u8 fifo_data[8];
+	u8 i2c_addr;
+	int header_count;
+	int step_det_count;
+	s32 gyro_sf;
+	u8 left_over[LEFT_OVER_BYTES];
+	u32 left_over_size;
+	u32 fifo_count;
+	bool wake_sensor_received;
+	bool accel_cal_enable;
+	bool gyro_cal_enable;
+	bool calib_compass_on;
+	bool debug_determine_engine_on;
+	bool poke_mode_on;
+	bool mode_1k_on;
+	bool mode_vr_on;
+	u64 poke_ts;
+	u64 step_detector_base_ts;
+	u64 last_temp_comp_time;
+	u8 i2c_dis;
+	u8 name[20];
+	u8 gyro_st_data[3];
+	u8 accel_st_data[3];
+	u8 secondary_name[20];
+	s32 compass_var;
+	int current_compass_matrix[9];
+	int final_compass_matrix[9];
+	enum TRIGGER_STATE trigger_state;
+	u8 *firmware;
+	int accel_calib_threshold;
+	int accel_calib_rate;
+	u32 accel_covariance[COVARIANCE_SIZE];
+	 DECLARE_KFIFO(kf, u8, 128);
+	u32 activity_size;
+	int wom_thld;
+	u16 cntl;
+	u16 cntl2;
+	u16 motion_event_cntl;
+	u16 intr_cntl;
+	int dmp_image_size;
+	int dmp_start_address;
+	bool step_counter_l_on;
+	bool step_counter_wake_l_on;
+	bool step_detector_l_on;
+	bool step_detector_wake_l_on;
+	bool gesture_only_on;
+	int mag_first_drop_cnt;
+	int mag_divider;
+	int prev_steps;
+	u32 curr_steps;
+	int aut_key_in;
+	int aut_key_out;
+	u8 auth_i[256];
+	u8 auth_o[256];
+	bool secondary_gyro_on;
+	bool secondary_mag_on;
+	bool secondary_prox_on;
+	bool secondary_switch;
+	bool send_calib_gyro;
+	bool send_raw_compass;
+	bool send_raw_gyro;
+	bool resume_state;
+	bool cycle_on;
+	int secondary_switch_data;
+	u8 raw_gyro_data[6];
+	u32 raw_compass_data[3];
+	wait_queue_head_t wait_queue;
+	u32 bac_drive_conf;
+	u32 bac_walk_conf;
+	u32 bac_smd_conf;
+	u32 bac_bike_conf;
+	u32 bac_run_conf;
+	u32 bac_still_conf;
+	u32 power_on_data;
+	u8 fifo_data_store[HARDWARE_FIFO_SIZE + LEFT_OVER_BYTES];
+	u8 int_en;
+	u8 int_en_2;
+	u8 int_en_6;
+	int gesture_int_count;
+	u8 smplrt_div;
+};
+
+/**
+ *  struct inv_mpu_slave - MPU slave structure.
+ *  @st_upper:  compass self test upper limit.
+ *  @st_lower:  compass self test lower limit.
+ *  @scale: compass scale.
+ *  @rate_scale: decide how fast a compass can read.
+ *  @min_read_time: minimum time between each reading.
+ *  @self_test: self test method of the slave.
+ *  @set_scale: set scale of slave
+ *  @get_scale: read scale back of the slave.
+ *  @suspend:		suspend operation.
+ *  @resume:		resume operation.
+ *  @setup:		setup chip. initialization.
+ *  @combine_data:	combine raw data into meaningful data.
+ *  @read_data:        read external sensor and output
+ *  @get_mode:		get current chip mode.
+ *  @set_lpf:            set low pass filter.
+ *  @set_fs:             set full scale
+ *  @prev_ts: last time it is read.
+ */
+struct inv_mpu_slave {
+	const short *st_upper;
+	const short *st_lower;
+	int scale;
+	int rate_scale;
+	int min_read_time;
+	int (*self_test)(struct inv_mpu_state *);
+	int (*set_scale)(struct inv_mpu_state *, int scale);
+	int (*get_scale)(struct inv_mpu_state *, int *val);
+	int (*suspend)(struct inv_mpu_state *);
+	int (*resume)(struct inv_mpu_state *);
+	int (*setup)(struct inv_mpu_state *);
+	int (*combine_data)(u8 *in, short *out);
+	int (*read_data)(struct inv_mpu_state *, short *out);
+	int (*get_mode)(void);
+	int (*set_lpf)(struct inv_mpu_state *, int rate);
+	int (*set_fs)(struct inv_mpu_state *, int fs);
+	u64 prev_ts;
+};
+
+/* scan element definition */
+enum inv_mpu_scan {
+	INV_MPU_SCAN_TIMESTAMP,
+};
+
+/* IIO attribute address */
+enum MPU_IIO_ATTR_ADDR {
+	ATTR_DMP_GYRO_X_DMP_BIAS,
+	ATTR_DMP_GYRO_Y_DMP_BIAS,
+	ATTR_DMP_GYRO_Z_DMP_BIAS,
+	ATTR_DMP_GYRO_CAL_ENABLE,
+	ATTR_DMP_ACCEL_X_DMP_BIAS,
+	ATTR_DMP_ACCEL_Y_DMP_BIAS,
+	ATTR_DMP_ACCEL_Z_DMP_BIAS,
+	ATTR_DMP_MAGN_X_DMP_BIAS,
+	ATTR_DMP_MAGN_Y_DMP_BIAS,
+	ATTR_DMP_MAGN_Z_DMP_BIAS,
+	ATTR_DMP_MAGN_ACCURACY,
+	ATTR_GYRO_X_OFFSET,
+	ATTR_GYRO_Y_OFFSET,
+	ATTR_GYRO_Z_OFFSET,
+	ATTR_ACCEL_X_OFFSET,
+	ATTR_ACCEL_Y_OFFSET,
+	ATTR_ACCEL_Z_OFFSET,
+	ATTR_DMP_SC_AUTH,
+	ATTR_DMP_EIS_AUTH,
+	ATTR_DMP_ACCEL_CAL_ENABLE,
+	ATTR_DMP_PED_INT_ON,
+	ATTR_DMP_PED_STEP_THRESH,
+	ATTR_DMP_PED_INT_THRESH,
+	ATTR_DMP_PED_INT_MODE,
+	ATTR_DMP_PED_ON,
+	ATTR_DMP_SMD_ENABLE,
+	ATTR_DMP_TILT_ENABLE,
+	ATTR_DMP_PICK_UP_ENABLE,
+	ATTR_DMP_TAP_ENABLE,
+	ATTR_DMP_STATIONARY_DETECT_ENABLE,
+	ATTR_DMP_MOTION_DETECT_ENABLE,
+	ATTR_DMP_EIS_ENABLE,
+	ATTR_DMP_PEDOMETER_STEPS,
+	ATTR_DMP_PEDOMETER_TIME,
+	ATTR_DMP_PEDOMETER_COUNTER,
+	ATTR_DMP_LOW_POWER_GYRO_ON,
+	ATTR_DMP_LP_EN_OFF,
+	ATTR_DMP_CLK_SEL,
+	ATTR_DMP_DEBUG_MEM_READ,
+	ATTR_DMP_DEBUG_MEM_WRITE,
+	ATTR_DEBUG_REG_WRITE,
+	ATTR_DEBUG_WRITE_CFG,
+	ATTR_DEBUG_REG_ADDR,
+	ATTR_WOM_THLD,
+	/* *****above this line, are DMP features, power needs on/off */
+	/* *****below this line, are DMP features, no power needed */
+	ATTR_IN_POWER_ON,
+	ATTR_HIGH_RES_MODE,
+	ATTR_DMP_ON,
+	ATTR_DMP_EVENT_INT_ON,
+	ATTR_DMP_STEP_COUNTER_ON,
+	ATTR_DMP_STEP_COUNTER_WAKE_ON,
+	ATTR_DMP_STEP_COUNTER_SEND,
+	ATTR_DMP_BATCHMODE_TIMEOUT,
+	ATTR_DMP_BATCHMODE_WAKE_FIFO_FULL,
+	ATTR_DMP_STEP_DETECTOR_ON,
+	ATTR_DMP_STEP_DETECTOR_WAKE_ON,
+	ATTR_DMP_ACTIVITY_ON,
+	ATTR_DMP_IN_ANGLVEL_ACCURACY_ENABLE,
+	ATTR_DMP_IN_ACCEL_ACCURACY_ENABLE,
+	ATTR_DMP_DEBUG_DETERMINE_ENGINE_ON,
+	ATTR_DMP_MISC_GYRO_RECALIBRATION,
+	ATTR_DMP_MISC_ACCEL_RECALIBRATION,
+	ATTR_DMP_PARAMS_ACCEL_CALIBRATION_THRESHOLD,
+	ATTR_DMP_PARAMS_ACCEL_CALIBRATION_RATE,
+	ATTR_GYRO_SCALE,
+	ATTR_ACCEL_SCALE,
+	ATTR_COMPASS_SCALE,
+	ATTR_COMPASS_SENSITIVITY_X,
+	ATTR_COMPASS_SENSITIVITY_Y,
+	ATTR_COMPASS_SENSITIVITY_Z,
+	ATTR_GYRO_ENABLE,
+	ATTR_ACCEL_ENABLE,
+	ATTR_COMPASS_ENABLE,
+	ATTR_FIRMWARE_LOADED,
+	ATTR_POKE_MODE,
+	ATTR_ANGLVEL_X_CALIBBIAS,
+	ATTR_ANGLVEL_Y_CALIBBIAS,
+	ATTR_ANGLVEL_Z_CALIBBIAS,
+	ATTR_ACCEL_X_CALIBBIAS,
+	ATTR_ACCEL_Y_CALIBBIAS,
+	ATTR_ACCEL_Z_CALIBBIAS,
+	ATTR_ANGLVEL_X_ST_CALIBBIAS,
+	ATTR_ANGLVEL_Y_ST_CALIBBIAS,
+	ATTR_ANGLVEL_Z_ST_CALIBBIAS,
+	ATTR_ANGLVEL_X_OIS_ST_CALIBBIAS,
+	ATTR_ANGLVEL_Y_OIS_ST_CALIBBIAS,
+	ATTR_ANGLVEL_Z_OIS_ST_CALIBBIAS,
+	ATTR_GYRO_LP_MODE,
+	ATTR_ACCEL_LP_MODE,
+	ATTR_ACCEL_X_ST_CALIBBIAS,
+	ATTR_ACCEL_Y_ST_CALIBBIAS,
+	ATTR_ACCEL_Z_ST_CALIBBIAS,
+	ATTR_ACCEL_X_OIS_ST_CALIBBIAS,
+	ATTR_ACCEL_Y_OIS_ST_CALIBBIAS,
+	ATTR_ACCEL_Z_OIS_ST_CALIBBIAS,
+	ATTR_GYRO_MATRIX,
+	ATTR_ACCEL_MATRIX,
+	ATTR_COMPASS_MATRIX,
+	ATTR_FSYNC_FRAME_COUNT,
+	ATTR_SECONDARY_NAME,
+	ATTR_GYRO_SF,
+	ATTR_BAC_DRIVE_CONFIDENCE,
+	ATTR_BAC_WALK_CONFIDENCE,
+	ATTR_BAC_SMD_CONFIDENCE,
+	ATTR_BAC_BIKE_CONFIDENCE,
+	ATTR_BAC_STILL_CONFIDENCE,
+	ATTR_BAC_RUN_CONFIDENCE,
+	IN_OIS_ACCEL_FS,
+	IN_OIS_GYRO_FS,
+	IN_OIS_ENABLE,
+};
+
+int inv_mpu_configure_ring(struct iio_dev *indio_dev);
+int inv_mpu_probe_trigger(struct iio_dev *indio_dev);
+void inv_mpu_unconfigure_ring(struct iio_dev *indio_dev);
+void inv_mpu_remove_trigger(struct iio_dev *indio_dev);
+#ifdef CONFIG_PM_SLEEP
+int inv_mpu_suspend(struct iio_dev *indio_dev);
+void inv_mpu_complete(struct iio_dev *indio_dev);
+#endif
+
+int inv_get_pedometer_steps(struct inv_mpu_state *st, int *ped);
+int inv_get_pedometer_time(struct inv_mpu_state *st, int *ped);
+int inv_read_pedometer_counter(struct inv_mpu_state *st);
+int inv_dmp_read(struct inv_mpu_state *st, int off, int size, u8 *buf);
+int inv_firmware_load(struct inv_mpu_state *st);
+
+int set_inv_enable(struct iio_dev *indio_dev);
+
+int inv_mpu_setup_compass_slave(struct inv_mpu_state *st);
+int inv_mpu_setup_pressure_slave(struct inv_mpu_state *st);
+int inv_mpu_setup_als_slave(struct inv_mpu_state *st);
+int inv_mpu_initialize(struct inv_mpu_state *st);
+int inv_set_accel_sf(struct inv_mpu_state *st);
+int inv_write_accel_sf(struct inv_mpu_state *st); /* to DMP */
+int inv_set_gyro_sf(struct inv_mpu_state *st);
+s64 get_time_ns(void);
+int inv_i2c_read_base(struct inv_mpu_state *st, u16 i, u8 r, u16 l, u8 *d);
+int inv_i2c_single_write_base(struct inv_mpu_state *st, u16 i, u8 r, u8 d);
+int write_be32_to_mem(struct inv_mpu_state *st, u32 data, int addr);
+int write_be16_to_mem(struct inv_mpu_state *st, u16 data, int addr);
+int read_be32_from_mem(struct inv_mpu_state *st, u32 *o, int addr);
+int read_be16_from_mem(struct inv_mpu_state *st, u16 *o, int addr);
+u32 inv_get_cntr_diff(u32 curr_counter, u32 prev);
+int inv_write_2bytes(struct inv_mpu_state *st, int k, int data);
+int inv_set_bank(struct inv_mpu_state *st, u8 bank);
+int inv_set_power(struct inv_mpu_state *st, bool power_on);
+int inv_switch_power_in_lp(struct inv_mpu_state *st, bool on);
+#ifndef CONFIG_INV_MPU_IIO_ICM20608D
+int inv_set_accel_config2(struct inv_mpu_state *st, bool cycle_mode);
+#endif
+int inv_stop_dmp(struct inv_mpu_state *st);
+int inv_reset_fifo(struct inv_mpu_state *st, bool turn_off);
+int inv_create_dmp_sysfs(struct iio_dev *ind);
+int inv_check_chip_type(struct iio_dev *indio_dev, const char *name);
+int inv_write_compass_matrix(struct inv_mpu_state *st, int *adj);
+irqreturn_t inv_read_fifo(int irq, void *p);
+#ifdef TIMER_BASED_BATCHING
+void inv_batch_work(struct work_struct *work);
+#endif
+int inv_flush_batch_data(struct iio_dev *indio_dev, int data);
+static inline int mpu_memory_write(struct inv_mpu_state *st, u8 mpu_addr,
+		u16 mem_addr, u32 len, u8 const *data)
+{
+	int ret = -1;
+
+	if (st->mem_write)
+		ret = st->mem_write(st, mpu_addr, mem_addr, len, data);
+
+	return ret;
+}
+static inline int mpu_memory_read(struct inv_mpu_state *st, u8 mpu_addr,
+		u16 mem_addr, u32 len, u8 *data)
+{
+	int ret = -1;
+
+	if (st->mem_read)
+		ret = st->mem_read(st, mpu_addr, mem_addr, len, data);
+
+	return ret;
+}
+int inv_read_secondary(struct inv_mpu_state *st, int ind, int addr,
+			int reg, int len);
+int inv_write_secondary(struct inv_mpu_state *st, int ind, int addr,
+			int reg, int v);
+int inv_execute_write_secondary(struct inv_mpu_state *st, int ind, int addr,
+				int reg, int v);
+int inv_execute_read_secondary(struct inv_mpu_state *st, int ind, int addr,
+			       int reg, int len, u8 *d);
+
+int inv_push_16bytes_buffer(struct inv_mpu_state *st, u16 hdr,
+						u64 t, int *q, s16 accur);
+int inv_push_gyro_data(struct inv_mpu_state *st, s32 *raw, s32 *calib, u64 t);
+int inv_push_8bytes_buffer(struct inv_mpu_state *st, u16 hdr, u64 t, s16 *d);
+int inv_push_8bytes_kf(struct inv_mpu_state *st, u16 hdr, u64 t, s16 *d);
+
+void inv_push_step_indicator(struct inv_mpu_state *st, u64 t);
+int inv_send_steps(struct inv_mpu_state *st, int step, u64 t);
+int inv_push_marker_to_buffer(struct inv_mpu_state *st, u16 hdr, int data);
+
+int inv_check_sensor_on(struct inv_mpu_state *st);
+int inv_write_cntl(struct inv_mpu_state *st, u16 wd, bool en, int cntl);
+
+int inv_get_packet_size(struct inv_mpu_state *st, u16 hdr,
+						u32 *pk_size, u8 *dptr);
+int inv_parse_packet(struct inv_mpu_state *st, u16 hdr, u8 *dptr);
+int inv_pre_parse_packet(struct inv_mpu_state *st, u16 hdr, u8 *dptr);
+int inv_process_dmp_data(struct inv_mpu_state *st);
+
+int be32_to_int(u8 *d);
+void inv_convert_and_push_16bytes(struct inv_mpu_state *st, u16 hdr,
+							u8 *d, u64 t, s8 *m);
+void inv_convert_and_push_8bytes(struct inv_mpu_state *st, u16 hdr,
+						u8 *d, u64 t, s8 *m);
+int inv_get_dmp_ts(struct inv_mpu_state *st, int i);
+int inv_process_step_det(struct inv_mpu_state *st, u8 *dptr);
+int inv_process_eis(struct inv_mpu_state *st, u16 delay);
+int inv_rate_convert(struct inv_mpu_state *st, int ind, int data);
+
+int inv_setup_dmp_firmware(struct inv_mpu_state *st);
+/* used to print i2c data using pr_debug */
+char *wr_pr_debug_begin(u8 const *data, u32 len, char *string);
+char *wr_pr_debug_end(char *string);
+
+int inv_hw_self_test(struct inv_mpu_state *st);
+int inv_q30_mult(int a, int b);
+#ifdef ACCEL_BIAS_TEST
+int inv_get_3axis_average(s16 src[], s16 dst[], s16 reset);
+#endif
+
+static inline int inv_plat_single_write(struct inv_mpu_state *st,
+							u8 reg, u8 data)
+{
+	int ret = -1;
+
+	if (st->write)
+		ret = st->write(st, reg, data);
+
+	return ret;
+}
+static inline int inv_plat_read(struct inv_mpu_state *st, u8 reg,
+							int len, u8 *data)
+{
+	int ret = -1;
+
+	if (st->read)
+		ret = st->read(st, reg, len, data);
+
+	return ret;
+}
+
+int inv_stop_interrupt(struct inv_mpu_state *st);
+int inv_restore_interrupt(struct inv_mpu_state *st);
+int inv_stop_stream_interrupt(struct inv_mpu_state *st);
+int inv_restore_stream_interrupt(struct inv_mpu_state *st);
+
+int inv_enable_pedometer_interrupt(struct inv_mpu_state *st, bool en);
+int inv_dataout_control1(struct inv_mpu_state *st, u16 cntl1);
+int inv_dataout_control2(struct inv_mpu_state *st, u16 cntl2);
+int inv_motion_interrupt_control(struct inv_mpu_state *st,
+						u16 motion_event_cntl);
+
+int inv_bound_timestamp(struct inv_mpu_state *st);
+int inv_update_dmp_ts(struct inv_mpu_state *st, int ind);
+int inv_get_last_run_time_non_dmp_record_mode(struct inv_mpu_state *st);
+int inv_set_accel_intel(struct inv_mpu_state *st);
+
+int inv_read_offset_regs(struct inv_mpu_state *st,
+		s16 accel[3], s16 gyro[3]);
+int inv_write_offset_regs(struct inv_mpu_state *st,
+		const s16 accel[3], const s16 gyro[3]);
+
+#define mem_w(a, b, c) mpu_memory_write(st, st->i2c_addr, a, b, c)
+#define mem_r(a, b, c) mpu_memory_read(st, st->i2c_addr, a, b, c)
+
+#endif /* #ifndef _INV_MPU_IIO_H_ */
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_ring.c b/drivers/iio/imu/inv_mpu/inv_mpu_ring.c
new file mode 100644
index 000000000000..6e3217d7b6c1
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_ring.c
@@ -0,0 +1,613 @@
+/*
+* Copyright (C) 2012-2019 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/export.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/math64.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/triggered_buffer.h>
+
+#include "inv_mpu_iio.h"
+
+static void inv_push_timestamp(struct iio_dev *indio_dev, u64 t)
+{
+	u8 buf[IIO_BUFFER_BYTES];
+	struct inv_mpu_state *st;
+
+	st = iio_priv(indio_dev);
+	if (st->poke_mode_on)
+		memcpy(buf, &st->poke_ts, sizeof(t));
+	else
+		memcpy(buf, &t, sizeof(t));
+	iio_push_to_buffers(indio_dev, buf);
+}
+
+int inv_push_marker_to_buffer(struct inv_mpu_state *st, u16 hdr, int data)
+{
+	struct iio_dev *indio_dev = iio_priv_to_dev(st);
+	u8 buf[IIO_BUFFER_BYTES];
+
+	memcpy(buf, &hdr, sizeof(hdr));
+	memcpy(&buf[4], &data, sizeof(data));
+	iio_push_to_buffers(indio_dev, buf);
+
+	return 0;
+}
+
+static int inv_calc_precision(struct inv_mpu_state *st)
+{
+	int diff;
+	int init;
+
+	if (st->eis.voting_state != 8)
+		return 0;
+	diff = abs(st->eis.fsync_delay_s[1] - st->eis.fsync_delay_s[0]);
+	init = 0;
+	if (diff)
+		init = st->sensor[SENSOR_GYRO].dur / diff;
+
+	if (abs(init - NSEC_PER_USEC) < (NSEC_PER_USEC >> 3))
+		st->eis.count_precision = init;
+	else
+		st->eis.voting_state = 0;
+
+	pr_debug("dur= %d prc= %d\n", st->sensor[SENSOR_GYRO].dur,
+						st->eis.count_precision);
+
+	return 0;
+}
+
+static s64 calc_frame_ave(struct inv_mpu_state *st, int delay)
+{
+	s64 ts;
+
+	ts = st->eis.current_timestamp - delay;
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) | defined(CONFIG_INV_MPU_IIO_ICM20690)
+	ts -= st->ts_algo.gyro_ts_shift;
+#endif
+	pr_debug("shift= %d ts = %lld\n", st->ts_algo.gyro_ts_shift, ts);
+
+	return ts;
+}
+
+static void inv_push_eis_ring(struct inv_mpu_state *st, int *q, bool sync,
+								s64 t)
+{
+	struct iio_dev *indio_dev = iio_priv_to_dev(st);
+	struct inv_eis *eis = &st->eis;
+	u8 buf[IIO_BUFFER_BYTES];
+	int tmp, ii;
+
+	buf[0] = (EIS_GYRO_HDR & 0xff);
+	buf[1] = (EIS_GYRO_HDR >> 8);
+	memcpy(buf + 4, &q[0], sizeof(q[0]));
+	iio_push_to_buffers(indio_dev, buf);
+	for (ii = 0; ii < 2; ii++)
+		memcpy(buf + 4 * ii, &q[ii + 1], sizeof(q[ii]));
+	iio_push_to_buffers(indio_dev, buf);
+	tmp = eis->frame_count;
+	if (sync)
+		tmp |= 0x80000000;
+	memcpy(buf, &tmp, sizeof(tmp));
+	iio_push_to_buffers(indio_dev, buf);
+	inv_push_timestamp(indio_dev, t);
+}
+static int inv_do_interpolation_gyro(struct inv_mpu_state *st, int *prev,
+	s64 prev_t, int *curr, s64 curr_t, s64 t, bool trigger)
+{
+	int i;
+	int out[3];
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) | defined(CONFIG_INV_MPU_IIO_ICM20690)
+	prev_t -= st->ts_algo.gyro_ts_shift;
+	prev_t += MPU_4X_TS_GYRO_SHIFT;
+	curr_t -= st->ts_algo.gyro_ts_shift;
+	curr_t += MPU_4X_TS_GYRO_SHIFT;
+#endif
+	if ((t > prev_t) && (t < curr_t)) {
+		for (i = 0; i < 3; i++)
+			out[i] = (int)div_s64((s64)(curr[i] - prev[i]) *
+				(s64)(t - prev_t), curr_t - prev_t) + prev[i];
+	} else if (t < prev_t) {
+		for (i = 0; i < 3; i++)
+			out[i] = prev[i];
+	} else {
+		for (i = 0; i < 3; i++)
+			out[i] = curr[i];
+	}
+	pr_debug("prev= %lld t = %lld curr= %lld\n", prev_t, t, curr_t);
+	pr_debug("prev = %d, %d, %d\n", prev[0], prev[1], prev[2]);
+	pr_debug("curr = %d, %d, %d\n", curr[0], curr[1], curr[2]);
+	pr_debug("out = %d, %d, %d\n", out[0], out[1], out[2]);
+	inv_push_eis_ring(st, out, trigger, t);
+
+	return 0;
+}
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) | defined(CONFIG_INV_MPU_IIO_ICM20690)
+static void inv_handle_triggered_eis(struct inv_mpu_state *st)
+{
+	struct inv_eis *eis = &st->eis;
+	int delay;
+
+	if (st->eis.eis_frame) {
+		inv_calc_precision(st);
+		delay = ((int)st->eis.fsync_delay) * st->eis.count_precision;
+		eis->fsync_timestamp = calc_frame_ave(st, delay);
+		inv_do_interpolation_gyro(st,
+			st->eis.prev_gyro,    st->eis.prev_timestamp,
+			st->eis.current_gyro, st->eis.current_timestamp,
+			eis->fsync_timestamp, true);
+		pr_debug("fsync=%lld, curr=%lld, delay=%d\n",
+			eis->fsync_timestamp, eis->current_timestamp, delay);
+		inv_push_eis_ring(st, st->eis.current_gyro, false,
+			st->eis.current_timestamp - st->ts_algo.gyro_ts_shift
+						+ MPU_4X_TS_GYRO_SHIFT);
+		eis->last_fsync_timestamp = eis->fsync_timestamp;
+	} else {
+		pr_debug("cur= %lld\n", st->eis.current_timestamp);
+		inv_push_eis_ring(st, st->eis.current_gyro, false,
+			st->eis.current_timestamp - st->ts_algo.gyro_ts_shift
+						+ MPU_4X_TS_GYRO_SHIFT);
+	}
+}
+#else
+static void inv_handle_triggered_eis(struct inv_mpu_state *st)
+{
+	struct inv_eis *eis = &st->eis;
+	int delay;
+
+	if ((st->eis.eis_frame && (st->eis.fsync_delay != 5)) ||
+		(st->eis.eis_frame && (st->eis.fsync_delay == 5) &&
+		(!st->eis.current_sync))
+		) {
+		inv_calc_precision(st);
+		delay = ((int)st->eis.fsync_delay) * st->eis.count_precision;
+		eis->fsync_timestamp = calc_frame_ave(st, delay);
+		inv_do_interpolation_gyro(st,
+			st->eis.prev_gyro,    st->eis.prev_timestamp,
+			st->eis.current_gyro, st->eis.current_timestamp,
+			eis->fsync_timestamp, true);
+		pr_debug("fsync=%lld, curr=%lld, delay=%d\n",
+			eis->fsync_timestamp, eis->current_timestamp, delay);
+		inv_push_eis_ring(st, st->eis.current_gyro, false,
+				st->eis.current_timestamp);
+		eis->last_fsync_timestamp = eis->fsync_timestamp;
+		st->eis.eis_frame = false;
+	} else {
+		st->eis.current_sync = false;
+		pr_debug("cur= %lld\n", st->eis.current_timestamp);
+		inv_push_eis_ring(st, st->eis.current_gyro, false,
+				st->eis.current_timestamp);
+	}
+}
+#endif
+static void inv_push_eis_buffer(struct inv_mpu_state *st, u64 t, int *q)
+{
+	int ii;
+
+	if (st->eis.eis_triggered) {
+		for (ii = 0; ii < 3; ii++)
+			st->eis.prev_gyro[ii] = st->eis.current_gyro[ii];
+		st->eis.prev_timestamp = st->eis.current_timestamp;
+
+		for (ii = 0; ii < 3; ii++)
+			st->eis.current_gyro[ii] = q[ii];
+		st->eis.current_timestamp = t;
+		inv_handle_triggered_eis(st);
+	} else {
+		for (ii = 0; ii < 3; ii++)
+			st->eis.current_gyro[ii] = q[ii];
+		st->eis.current_timestamp = t;
+	}
+}
+static int inv_push_16bytes_final(struct inv_mpu_state *st, int j,
+						s32 *q, u64 t, s16 accur)
+{
+	struct iio_dev *indio_dev = iio_priv_to_dev(st);
+	u8 buf[IIO_BUFFER_BYTES];
+	int ii;
+
+	memcpy(buf, &st->sensor_l[j].header, sizeof(st->sensor_l[j].header));
+	memcpy(buf + 2, &accur, sizeof(accur));
+	memcpy(buf + 4, &q[0], sizeof(q[0]));
+	iio_push_to_buffers(indio_dev, buf);
+	for (ii = 0; ii < 2; ii++)
+		memcpy(buf + 4 * ii, &q[ii + 1], sizeof(q[ii]));
+	iio_push_to_buffers(indio_dev, buf);
+	inv_push_timestamp(indio_dev, t);
+	st->sensor_l[j].counter = 0;
+	if (st->sensor_l[j].wake_on)
+		st->wake_sensor_received = true;
+
+	return 0;
+}
+int inv_push_16bytes_buffer(struct inv_mpu_state *st, u16 sensor,
+				    u64 t, int *q, s16 accur)
+{
+	int j;
+
+	for (j = 0; j < SENSOR_L_NUM_MAX; j++) {
+		if (st->sensor_l[j].on && (st->sensor_l[j].base == sensor)) {
+			st->sensor_l[j].counter++;
+			if ((st->sensor_l[j].div != 0xffff) &&
+				(st->sensor_l[j].counter >=
+						st->sensor_l[j].div)) {
+				pr_debug(
+	"Sensor_l = %d sensor = %d header [%04X] div [%d] ts [%lld] %d %d %d\n",
+					j, sensor,
+					st->sensor_l[j].header,
+					st->sensor_l[j].div,
+					t, q[0], q[1], q[2]);
+				inv_push_16bytes_final(st, j, q, t, accur);
+			}
+		}
+	}
+	return 0;
+}
+
+void inv_convert_and_push_16bytes(struct inv_mpu_state *st, u16 hdr,
+							u8 *d, u64 t, s8 *m)
+{
+	int i, j;
+	s32 in[3], out[3];
+
+	for (i = 0; i < 3; i++)
+		in[i] = be32_to_int(d + i * 4);
+	/* multiply with orientation matrix can be optimized like this */
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			if (m[i * 3 + j])
+				out[i] = in[j] * m[i * 3 + j];
+
+	inv_push_16bytes_buffer(st, hdr, t, out, 0);
+}
+
+void inv_convert_and_push_8bytes(struct inv_mpu_state *st, u16 hdr,
+						u8 *d, u64 t, s8 *m)
+{
+	int i, j;
+	s16 in[3], out[3];
+
+	for (i = 0; i < 3; i++)
+		in[i] = be16_to_cpup((__be16 *) (d + i * 2));
+
+	/* multiply with orientation matrix can be optimized like this */
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			if (m[i * 3 + j])
+				out[i] = in[j] * m[i * 3 + j];
+
+	inv_push_8bytes_buffer(st, hdr, t, out);
+}
+
+int inv_push_special_8bytes_buffer(struct inv_mpu_state *st,
+				   u16 hdr, u64 t, s16 *d)
+{
+	struct iio_dev *indio_dev = iio_priv_to_dev(st);
+	u8 buf[IIO_BUFFER_BYTES];
+	int j;
+
+	memcpy(buf, &hdr, sizeof(hdr));
+	memcpy(&buf[2], &d[0], sizeof(d[0]));
+	for (j = 0; j < 2; j++)
+		memcpy(&buf[4 + j * 2], &d[j + 1], sizeof(d[j]));
+	iio_push_to_buffers(indio_dev, buf);
+	inv_push_timestamp(indio_dev, t);
+
+	return 0;
+}
+
+static int inv_s32_gyro_push(struct inv_mpu_state *st, int i, s32 *calib, u64 t)
+{
+	if (st->sensor_l[i].on) {
+		st->sensor_l[i].counter++;
+		if ((st->sensor_l[i].div != 0xffff) &&
+			(st->sensor_l[i].counter >= st->sensor_l[i].div)) {
+			inv_push_16bytes_final(st, i, calib, t, 0);
+			st->sensor_l[i].counter = 0;
+			if (st->sensor_l[i].wake_on)
+				st->wake_sensor_received = true;
+		}
+	}
+
+	return 0;
+}
+
+int inv_push_gyro_data(struct inv_mpu_state *st, s32 *raw, s32 *calib, u64 t)
+{
+	int gyro_data[] = {SENSOR_L_GYRO, SENSOR_L_GYRO_WAKE};
+	int calib_data[] = {SENSOR_L_GYRO_CAL, SENSOR_L_GYRO_CAL_WAKE};
+	int i;
+
+	if (st->sensor_l[SENSOR_L_EIS_GYRO].on)
+		inv_push_eis_buffer(st, t, calib);
+
+	for (i = 0; i < 2; i++)
+		inv_s32_gyro_push(st, gyro_data[i], raw, t);
+	for (i = 0; i < 2; i++)
+		inv_s32_gyro_push(st, calib_data[i], calib, t);
+
+	return 0;
+}
+int inv_push_8bytes_buffer(struct inv_mpu_state *st, u16 sensor, u64 t, s16 *d)
+{
+	struct iio_dev *indio_dev = iio_priv_to_dev(st);
+	u8 buf[IIO_BUFFER_BYTES];
+	int ii, j;
+
+	if ((sensor == STEP_DETECTOR_HDR) ||
+		(sensor == STEP_DETECTOR_WAKE_HDR) ||
+		(sensor == TAP_HDR)) {
+		memcpy(buf, &sensor, sizeof(sensor));
+		memcpy(&buf[2], &d[0], sizeof(d[0]));
+		for (j = 0; j < 2; j++)
+			memcpy(&buf[4 + j * 2], &d[j + 1], sizeof(d[j]));
+		iio_push_to_buffers(indio_dev, buf);
+		inv_push_timestamp(indio_dev, t);
+		if (sensor == STEP_DETECTOR_WAKE_HDR)
+			st->wake_sensor_received = true;
+		return 0;
+	}
+	for (ii = 0; ii < SENSOR_L_NUM_MAX; ii++) {
+		if (st->sensor_l[ii].on &&
+		    (st->sensor_l[ii].base == sensor) &&
+		    (st->sensor_l[ii].div != 0xffff)) {
+			st->sensor_l[ii].counter++;
+			if (st->sensor_l[ii].counter >= st->sensor_l[ii].div) {
+				pr_debug(
+	"Sensor_l = %d sensor = %d header [%04X] div [%d] ts [%lld] %d %d %d\n",
+	ii, sensor, st->sensor_l[ii].header,
+	st->sensor_l[ii].div, t, d[0], d[1], d[2]);
+
+				memcpy(buf, &st->sensor_l[ii].header,
+				       sizeof(st->sensor_l[ii].header));
+				memcpy(&buf[2], &d[0], sizeof(d[0]));
+				for (j = 0; j < 2; j++)
+					memcpy(&buf[4 + j * 2], &d[j + 1],
+					       sizeof(d[j]));
+
+				iio_push_to_buffers(indio_dev, buf);
+				inv_push_timestamp(indio_dev, t);
+				st->sensor_l[ii].counter = 0;
+				if (st->sensor_l[ii].wake_on)
+					st->wake_sensor_received = true;
+			}
+		}
+	}
+
+	return 0;
+}
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+/* Implemented activity to string function for BAC test */
+#define TILT_DETECTED  0x1000
+#define NONE 0x00
+#define DRIVE 0x01
+#define WALK 0x02
+#define RUN 0x04
+#define BIKE 0x08
+#define TILT 0x10
+#define STILL 0x20
+#define DRIVE_WALK (DRIVE | WALK)
+#define DRIVE_RUN (DRIVE | RUN)
+
+char *act_string(s16 data)
+{
+	data &= (~TILT);
+	switch (data) {
+	case NONE:
+		return "None";
+	case DRIVE:
+		return "Drive";
+	case WALK:
+		return "Walk";
+	case RUN:
+		return "Run";
+	case BIKE:
+		return "Bike";
+	case STILL:
+		return "Still";
+	case DRIVE_WALK:
+		return "drive and walk";
+	case DRIVE_RUN:
+		return "drive and run";
+	default:
+		return "Unknown";
+	}
+	return "Unknown";
+}
+
+char *inv_tilt_check(s16 data)
+{
+	if (data & TILT)
+		return "Tilt";
+	else
+		return "None";
+}
+
+int inv_push_8bytes_kf(struct inv_mpu_state *st, u16 hdr, u64 t, s16 *d)
+{
+	struct iio_dev *indio_dev = iio_priv_to_dev(st);
+	u8 buf[IIO_BUFFER_BYTES];
+	int i;
+
+	if (st->chip_config.activity_on) {
+		memcpy(buf, &hdr, sizeof(hdr));
+		for (i = 0; i < 3; i++)
+			memcpy(&buf[2 + i * 2], &d[i], sizeof(d[i]));
+
+		kfifo_in(&st->kf, buf, IIO_BUFFER_BYTES);
+		memcpy(buf, &t, sizeof(t));
+		kfifo_in(&st->kf, buf, IIO_BUFFER_BYTES);
+		st->activity_size += IIO_BUFFER_BYTES * 2;
+	}
+	if (st->chip_config.tilt_enable) {
+		pr_debug("d[0] = %04X,  [%X : %s] to [%X : %s]",
+		d[0], d[0] & 0x00FF,
+		inv_tilt_check(d[0] & 0x00FF),
+		(d[0] & 0xFF00) >> 8,  inv_tilt_check((d[0] & 0xFF00) >> 8));
+		if (!((d[0] & 0x00FF) & TILT) &&
+				(((d[0] & 0xFF00) >> 8) & TILT)) {
+			/* Not Tilt to Tilt */
+			sysfs_notify(&indio_dev->dev.kobj, NULL, "poll_tilt");
+			st->wake_sensor_received = true; /* Tilt is wake-up */
+		}
+	}
+
+	pr_debug("d[0] = %04X,  [%X : %s] to [%X : %s]", d[0], d[0] & 0x00FF,
+		act_string(d[0] & 0x00FF),
+		(d[0] & 0xFF00) >> 8,  act_string((d[0] & 0xFF00) >> 8));
+
+	read_be32_from_mem(st, &st->bac_drive_conf, BAC_DRIVE_CONFIDENCE);
+	read_be32_from_mem(st, &st->bac_walk_conf, BAC_WALK_CONFIDENCE);
+	read_be32_from_mem(st, &st->bac_smd_conf, BAC_SMD_CONFIDENCE);
+	read_be32_from_mem(st, &st->bac_bike_conf, BAC_BIKE_CONFIDENCE);
+	read_be32_from_mem(st, &st->bac_still_conf, BAC_STILL_CONFIDENCE);
+	read_be32_from_mem(st, &st->bac_run_conf, BAC_RUN_CONFIDENCE);
+
+	return 0;
+}
+#endif
+
+int inv_send_steps(struct inv_mpu_state *st, int step, u64 ts)
+{
+	s16 s[3];
+
+	s[0] = 0;
+	s[1] = (s16) (step & 0xffff);
+	s[2] = (s16) ((step >> 16) & 0xffff);
+	if (st->step_counter_l_on)
+		inv_push_special_8bytes_buffer(st, STEP_COUNTER_HDR, ts, s);
+	if (st->step_counter_wake_l_on) {
+		inv_push_special_8bytes_buffer(st, STEP_COUNTER_WAKE_HDR,
+					       ts, s);
+		st->wake_sensor_received = true;
+	}
+	return 0;
+}
+
+void inv_push_step_indicator(struct inv_mpu_state *st, u64 t)
+{
+	s16 sen[3];
+#define STEP_INDICATOR_HEADER 0x0001
+
+	sen[0] = 0;
+	sen[1] = 0;
+	sen[2] = 0;
+	inv_push_8bytes_buffer(st, STEP_INDICATOR_HEADER, t, sen);
+}
+
+#ifdef TIMER_BASED_BATCHING
+static enum hrtimer_restart inv_batch_timer_handler(struct hrtimer *timer)
+{
+	struct inv_mpu_state *st =
+		container_of(timer, struct inv_mpu_state, hr_batch_timer);
+
+	if (st->chip_config.gyro_enable || st->chip_config.accel_enable) {
+		hrtimer_forward_now(&st->hr_batch_timer,
+			ns_to_ktime(st->batch_timeout));
+		schedule_work(&st->batch_work);
+		return HRTIMER_RESTART;
+	}
+	st->is_batch_timer_running = 0;
+	return HRTIMER_NORESTART;
+}
+#endif
+
+static int inv_mpu_set_trigger(struct iio_trigger *trig, bool state)
+{
+	/* unused for the moment */
+	return 0;
+}
+
+static const struct iio_trigger_ops inv_mpu_trigger_ops = {
+	.set_trigger_state = &inv_mpu_set_trigger,
+};
+
+int inv_mpu_configure_ring(struct iio_dev *indio_dev)
+{
+	int ret;
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+#ifdef TIMER_BASED_BATCHING
+	/* configure hrtimer */
+	hrtimer_init(&st->hr_batch_timer, CLOCK_BOOTTIME, HRTIMER_MODE_REL);
+	st->hr_batch_timer.function = inv_batch_timer_handler;
+	INIT_WORK(&st->batch_work, inv_batch_work);
+#endif
+
+	ret = iio_triggered_buffer_setup(indio_dev, NULL, inv_read_fifo, NULL);
+	if (ret) {
+		dev_err(st->dev, "iio triggered buffer failed %d\n", ret);
+		return ret;
+	}
+
+	st->trig = iio_trigger_alloc("%s-dev%d", indio_dev->name,
+				     indio_dev->id);
+	if (st->trig == NULL) {
+		ret = -ENOMEM;
+		dev_err(st->dev, "iio trigger alloc error\n");
+		goto error_free_buffer;
+	}
+	st->trig->dev.parent = st->dev;
+	st->trig->ops = &inv_mpu_trigger_ops;
+	iio_trigger_set_drvdata(st->trig, indio_dev);
+
+	ret = request_irq(st->irq, &iio_trigger_generic_data_rdy_poll,
+			  IRQF_TRIGGER_RISING, "inv_mpu", st->trig);
+	if (ret) {
+		dev_err(st->dev, "irq request error %d\n", ret);
+		goto error_free_trigger;
+	}
+
+	ret = iio_trigger_register(st->trig);
+	if (ret) {
+		dev_err(st->dev, "iio trigger register error %d\n", ret);
+		goto error_free_irq;
+	}
+	iio_trigger_get(st->trig);
+	indio_dev->trig = st->trig;
+
+	return 0;
+
+error_free_irq:
+	free_irq(st->irq, st->trig);
+error_free_trigger:
+	iio_trigger_free(st->trig);
+error_free_buffer:
+	iio_triggered_buffer_cleanup(indio_dev);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(inv_mpu_configure_ring);
+
+void inv_mpu_unconfigure_ring(struct iio_dev *indio_dev)
+{
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+	iio_trigger_unregister(st->trig);
+	free_irq(st->irq, st->trig);
+	iio_trigger_free(st->trig);
+	iio_triggered_buffer_cleanup(indio_dev);
+};
+EXPORT_SYMBOL_GPL(inv_mpu_unconfigure_ring);
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_spi.c b/drivers/iio/imu/inv_mpu/inv_mpu_spi.c
new file mode 100644
index 000000000000..e895acf9cd46
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_spi.c
@@ -0,0 +1,410 @@
+/*
+* Copyright (C) 2012-2020 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/spinlock.h>
+#include <linux/of_device.h>
+
+#include "inv_mpu_iio.h"
+#include "inv_mpu_dts.h"
+
+#define INV_SPI_READ 0x80
+
+static int inv_spi_single_write(struct inv_mpu_state *st, u8 reg, u8 data)
+{
+	struct spi_message msg;
+	int res;
+	u8 d[2];
+	struct spi_transfer xfers = {
+		.tx_buf = d,
+		.bits_per_word = 8,
+		.len = 2,
+	};
+
+	pr_debug("reg_write: reg=0x%x data=0x%x\n", reg, data);
+	d[0] = reg;
+	d[1] = data;
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	res = spi_sync(to_spi_device(st->dev), &msg);
+
+	return res;
+}
+
+static int inv_spi_read(struct inv_mpu_state *st, u8 reg, int len, u8 *data)
+{
+	struct spi_message msg;
+	int res;
+	u8 d[1];
+	struct spi_transfer xfers[] = {
+		{
+		 .tx_buf = d,
+		 .bits_per_word = 8,
+		 .len = 1,
+		 },
+		{
+		 .rx_buf = data,
+		 .bits_per_word = 8,
+		 .len = len,
+		 }
+	};
+
+	if (!data)
+		return -EINVAL;
+
+	d[0] = (reg | INV_SPI_READ);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+	res = spi_sync(to_spi_device(st->dev), &msg);
+
+	if (len ==1)
+		pr_debug("reg_read: reg=0x%x length=%d data=0x%x\n",
+							reg, len, data[0]);
+	else
+		pr_debug("reg_read: reg=0x%x length=%d d0=0x%x d1=0x%x\n",
+					reg, len, data[0], data[1]);
+
+	return res;
+
+}
+
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20608D)
+static int inv_spi_mem_write(struct inv_mpu_state *st, u8 mpu_addr, u16 mem_addr,
+		     u32 len, u8 const *data)
+{
+	struct spi_message msg;
+	u8 buf[258];
+	int res;
+
+	struct spi_transfer xfers = {
+		.tx_buf = buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (!data || !st)
+		return -EINVAL;
+
+	if (len > (sizeof(buf) - 1))
+		return -ENOMEM;
+
+	inv_plat_single_write(st, REG_MEM_BANK_SEL, mem_addr >> 8);
+	inv_plat_single_write(st, REG_MEM_START_ADDR, mem_addr & 0xFF);
+
+	buf[0] = REG_MEM_R_W;
+	memcpy(buf + 1, data, len);
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	res = spi_sync(to_spi_device(st->dev), &msg);
+
+	return res;
+}
+
+static int inv_spi_mem_read(struct inv_mpu_state *st, u8 mpu_addr, u16 mem_addr,
+		    u32 len, u8 *data)
+{
+	int res;
+
+	if (!data || !st)
+		return -EINVAL;
+
+	if (len > 256)
+		return -EINVAL;
+
+	res = inv_plat_single_write(st, REG_MEM_BANK_SEL, mem_addr >> 8);
+	res = inv_plat_single_write(st, REG_MEM_START_ADDR, mem_addr & 0xFF);
+	res = inv_plat_read(st, REG_MEM_R_W, len, data);
+
+	return res;
+}
+#endif
+
+/*
+ *  inv_mpu_probe() - probe function.
+ */
+static int inv_mpu_probe(struct spi_device *spi)
+{
+	const struct spi_device_id *id = spi_get_device_id(spi);
+	struct inv_mpu_state *st;
+	struct iio_dev *indio_dev;
+	int result;
+
+	indio_dev = iio_device_alloc(sizeof(*st));
+	if (indio_dev == NULL) {
+		pr_err("memory allocation failed\n");
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	st = iio_priv(indio_dev);
+	st->write = inv_spi_single_write;
+	st->read = inv_spi_read;
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20608D)
+	st->mem_write = inv_spi_mem_write;
+	st->mem_read = inv_spi_mem_read;
+#endif
+	st->dev = &spi->dev;
+	st->irq = spi->irq;
+#if defined(CONFIG_INV_MPU_IIO_ICM42600)
+	st->i2c_dis = BIT_UI_SIFS_DISABLE_I2C;
+#elif !defined(CONFIG_INV_MPU_IIO_ICM20602) \
+	&& !defined(CONFIG_INV_MPU_IIO_IAM20680)
+	st->i2c_dis = BIT_I2C_IF_DIS;
+#endif
+	st->bus_type = BUS_SPI;
+	spi_set_drvdata(spi, indio_dev);
+	indio_dev->dev.parent = &spi->dev;
+	indio_dev->name = id->name;
+
+#ifdef CONFIG_OF
+	result = invensense_mpu_parse_dt(st->dev, &st->plat_data);
+	if (result)
+		goto out_free;
+#else
+	if (dev_get_platdata(st->dev) == NULL) {
+		result = -ENODEV;
+		goto out_free;
+	}
+	st->plat_data = *(struct mpu_platform_data *)dev_get_platdata(st->dev);
+#endif
+	/* Power on device */
+	if (st->plat_data.power_on) {
+		result = st->plat_data.power_on(&st->plat_data);
+		if (result < 0) {
+			dev_err(st->dev, "power_on failed: %d\n", result);
+			goto out_free;
+		}
+		pr_info("%s: power on here.\n", __func__);
+	}
+	pr_info("%s: power on.\n", __func__);
+
+	msleep(100);
+
+	/* power is turned on inside check chip type */
+	result = inv_check_chip_type(indio_dev, id->name);
+	if (result)
+		goto out_free;
+
+	result = inv_mpu_configure_ring(indio_dev);
+	if (result) {
+		pr_err("configure ring buffer fail\n");
+		goto out_free;
+	}
+
+	result = iio_device_register(indio_dev);
+	if (result) {
+		pr_err("IIO device register fail\n");
+		goto out_unreg_ring;
+	}
+
+	result = inv_create_dmp_sysfs(indio_dev);
+	if (result) {
+		pr_err("create dmp sysfs failed\n");
+		goto out_unreg_iio;
+	}
+	init_waitqueue_head(&st->wait_queue);
+	st->resume_state = true;
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_init(&st->wake_lock, WAKE_LOCK_SUSPEND, "inv_mpu");
+#else
+	st->wake_lock = wakeup_source_create("inv_mpu");
+	wakeup_source_add(st->wake_lock);
+	if (st->wake_lock)
+		pr_info("wakeup_source is created successfully\n");
+	else
+		pr_info("failed to create wakeup_source\n");
+#endif
+	dev_info(st->dev, "%s ma-kernel-%s is ready to go!\n",
+	         indio_dev->name, INVENSENSE_DRIVER_VERSION);
+
+#ifdef SENSOR_DATA_FROM_REGISTERS
+	pr_info("Data read from registers\n");
+#else
+	pr_info("Data read from FIFO\n");
+#endif
+#ifdef TIMER_BASED_BATCHING
+	pr_info("Timer based batching\n");
+#endif
+
+	return 0;
+
+out_unreg_iio:
+	iio_device_unregister(indio_dev);
+out_unreg_ring:
+	inv_mpu_unconfigure_ring(indio_dev);
+out_free:
+	iio_device_free(indio_dev);
+out_no_free:
+	dev_err(&spi->dev, "%s failed %d\n", __func__, result);
+	return result;
+}
+
+static void inv_mpu_shutdown(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(spi);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&indio_dev->mlock);
+	inv_switch_power_in_lp(st, true);
+	dev_dbg(st->dev, "Shutting down %s...\n", st->hw->name);
+
+	/* reset to make sure previous state are not there */
+#if defined(CONFIG_INV_MPU_IIO_ICM42600)
+	result = inv_plat_single_write(st, REG_CHIP_CONFIG_REG, BIT_SOFT_RESET);
+#else
+	result = inv_plat_single_write(st, REG_PWR_MGMT_1, BIT_H_RESET);
+#endif
+	if (result)
+		dev_err(st->dev, "Failed to reset %s\n",
+			st->hw->name);
+	msleep(POWER_UP_TIME);
+	/* turn off power to ensure gyro engine is off */
+	result = inv_set_power(st, false);
+	if (result)
+		dev_err(st->dev, "Failed to turn off %s\n",
+			st->hw->name);
+	inv_switch_power_in_lp(st, false);
+	mutex_unlock(&indio_dev->mlock);
+}
+
+/*
+ *  inv_mpu_remove() - remove function.
+ */
+static int inv_mpu_remove(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(spi);
+	struct inv_mpu_state *st = iio_priv(indio_dev);
+
+#ifndef CONFIG_HAS_WAKELOCK
+	if (st->wake_lock)
+		wakeup_source_destroy(st->wake_lock);
+#endif
+	iio_device_unregister(indio_dev);
+	inv_mpu_unconfigure_ring(indio_dev);
+	iio_device_free(indio_dev);
+	dev_info(st->dev, "inv-mpu-iio module removed.\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int inv_mpu_spi_suspend(struct device *dev)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(to_spi_device(dev));
+
+	return inv_mpu_suspend(indio_dev);
+}
+
+static void inv_mpu_spi_complete(struct device *dev)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(to_spi_device(dev));
+
+	inv_mpu_complete(indio_dev);
+}
+#endif
+
+static const struct dev_pm_ops inv_mpu_spi_pmops = {
+#ifdef CONFIG_PM_SLEEP
+	.suspend = inv_mpu_spi_suspend,
+	.complete = inv_mpu_spi_complete,
+#endif
+};
+
+/* device id table is used to identify what device can be
+ * supported by this driver
+ */
+static const struct spi_device_id inv_mpu_id[] = {
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	{"icm20648", ICM20648},
+#else
+	{"icm20608d", ICM20608D},
+	{"icm20690", ICM20690},
+	{"icm20602", ICM20602},
+	{"iam20680", IAM20680},
+	{"icm42600", ICM42600},
+	{"icm42686", ICM42686},
+	{"icm40609d", ICM40609D},
+#endif
+	{}
+};
+MODULE_DEVICE_TABLE(spi, inv_mpu_id);
+
+static const struct of_device_id inv_mpu_of_match[] = {
+#ifdef CONFIG_INV_MPU_IIO_ICM20648
+	{
+		.compatible = "invensense,icm20648",
+		.data = (void *)ICM20648,
+	},
+#else
+	{
+		.compatible = "invensense,icm20608d",
+		.data = (void *)ICM20608D,
+	}, {
+		.compatible = "invensense,icm20690",
+		.data = (void *)ICM20690,
+	}, {
+		.compatible = "invensense,icm20602",
+		.data = (void *)ICM20602,
+	}, {
+		.compatible = "invensense,iam20680",
+		.data = (void *)IAM20680,
+	}, {
+		.compatible = "invensense,icm42600",
+		.data = (void *)ICM42600,
+	}, {
+		.compatible = "invensense,icm42686",
+		.data = (void *)ICM42686,
+	}, {
+		.compatible = "invensense,icm40609d",
+		.data = (void *)ICM40609D,
+	},
+#endif
+	{ }
+};
+MODULE_DEVICE_TABLE(of, inv_mpu_of_match);
+
+static struct spi_driver inv_mpu_driver = {
+	.probe = inv_mpu_probe,
+	.remove = inv_mpu_remove,
+	.shutdown = inv_mpu_shutdown,
+	.id_table = inv_mpu_id,
+	.driver = {
+		.owner = THIS_MODULE,
+		.of_match_table = inv_mpu_of_match,
+		.name = "inv-mpu-iio-spi",
+		.pm = &inv_mpu_spi_pmops,
+	},
+};
+module_spi_driver(inv_mpu_driver);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense SPI device driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu/inv_mpu_timestamp.c b/drivers/iio/imu/inv_mpu/inv_mpu_timestamp.c
new file mode 100644
index 000000000000..0ec423d53a75
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu/inv_mpu_timestamp.c
@@ -0,0 +1,290 @@
+/*
+ * Copyright (C) 2012-2019 InvenSense, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "inv_mpu: " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/math64.h>
+
+#include "inv_mpu_iio.h"
+
+#define INV_TIME_CALIB_THRESHOLD_1 2
+
+#define MIN_DELAY (3 * NSEC_PER_MSEC)
+#define JITTER_THRESH (1 * NSEC_PER_MSEC)
+
+int inv_update_dmp_ts(struct inv_mpu_state *st, int ind)
+{
+	int i;
+	u32 counter;
+	u64 ts;
+	enum INV_ENGINE en_ind;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+	u32 base_time;
+	u64 cal_period;
+
+	if (st->mode_1k_on)
+		cal_period = (NSEC_PER_SEC >> 2);
+	else
+		cal_period = 2 * NSEC_PER_SEC;
+
+	ts = ts_algo->last_run_time - st->sensor[ind].time_calib;
+	counter = st->sensor[ind].sample_calib;
+	en_ind = st->sensor[ind].engine_base;
+	if (en_ind != ts_algo->clock_base)
+		return 0;
+	/* we average over 2 seconds period to do the timestamp calculation */
+	if (ts < cal_period)
+		return 0;
+	/* this is the first time we do timestamp averaging, return */
+	/* after resume from suspend, the clock of linux has up to 1 seconds
+	   drift. We should start from the resume clock instead of using clock
+	   before resume */
+	if ((!st->sensor[ind].calib_flag) || ts_algo->resume_flag) {
+		st->sensor[ind].sample_calib = 0;
+		st->sensor[ind].time_calib = ts_algo->last_run_time;
+		st->sensor[ind].calib_flag = 1;
+		ts_algo->resume_flag = false;
+
+		return 0;
+	}
+	/* if the sample number in current FIFO is not zero and between now and
+		last update time is more than 2 seconds, we do calculation */
+	if ((counter > 0) &&
+		(ts_algo->last_run_time - st->eng_info[en_ind].last_update_time >
+		 cal_period)) {
+		/* duration for each sensor */
+		st->sensor[ind].dur = (u32) div_u64(ts, counter);
+		/* engine duration derived from each sensor */
+		if (st->sensor[ind].div)
+			st->eng_info[en_ind].dur = st->sensor[ind].dur /
+							st->sensor[ind].div;
+		else
+			pr_err("sensor %d divider zero!\n", ind);
+		/* update base time for each sensor */
+		if (st->eng_info[en_ind].divider) {
+			base_time = (st->eng_info[en_ind].dur /
+					st->eng_info[en_ind].divider) *
+					st->eng_info[en_ind].orig_rate;
+			if (st->mode_1k_on)
+				st->eng_info[en_ind].base_time_1k = base_time;
+			else
+				st->eng_info[en_ind].base_time = base_time;
+		} else {
+			pr_err("engine %d divider zero!\n", en_ind);
+		}
+
+		st->eng_info[en_ind].last_update_time = ts_algo->last_run_time;
+		/* update all the sensors duration based on the same engine */
+		for (i = 0; i < SENSOR_NUM_MAX; i++) {
+			if (st->sensor[i].on &&
+			    (st->sensor[i].engine_base == en_ind))
+				st->sensor[i].dur = st->sensor[i].div *
+				    st->eng_info[en_ind].dur;
+		}
+
+	}
+	st->sensor[ind].sample_calib = 0;
+	st->sensor[ind].time_calib = ts_algo->last_run_time;
+
+	return 0;
+}
+/**
+ *     int inv_get_last_run_time_non_dmp_record_mode(struct inv_mpu_state *st)
+ *     This is the function to get last run time in non dmp and record mode.
+ *     This function will update the last_run_time, which is important parameter
+ *     in overall timestamp algorithm.
+ *     return value: this function returns fifo count value.
+*/
+int inv_get_last_run_time_non_dmp_record_mode(struct inv_mpu_state *st)
+{
+	long long t_pre, t_post, dur;
+	int fifo_count;
+#ifndef SENSOR_DATA_FROM_REGISTERS
+	int res;
+	u8 data[2];
+#endif
+
+	t_pre = get_time_ns();
+#ifndef SENSOR_DATA_FROM_REGISTERS
+	res = inv_plat_read(st, REG_FIFO_COUNT_H, FIFO_COUNT_BYTE, data);
+	if (res) {
+		pr_info("read REG_FIFO_COUNT_H failed= %d\n", res);
+		return 0;
+	}
+#endif
+	t_post = get_time_ns();
+
+#ifdef SENSOR_DATA_FROM_REGISTERS
+	if (st->fifo_count_mode == BYTE_MODE)
+		fifo_count = st->batch.pk_size;
+	else
+		fifo_count = 1;
+#else
+	fifo_count = be16_to_cpup((__be16 *) (data));
+#endif
+	pr_debug("fifc=%d\n", fifo_count);
+	if (!fifo_count)
+		return 0;
+
+	/* In non DMP mode, either gyro or accel duration is the duration
+		for each sample */
+	if (st->chip_config.gyro_enable)
+		dur = st->eng_info[ENGINE_GYRO].dur;
+	else
+		dur = st->eng_info[ENGINE_ACCEL].dur;
+
+	if (st->fifo_count_mode == BYTE_MODE) {
+		fifo_count /= st->batch.pk_size;
+	}
+
+	/* In record mode, each number in fifo_count is 1 record or 1 sample */
+	st->ts_algo.last_run_time += dur * fifo_count;
+	if (st->ts_algo.last_run_time < t_pre)
+		st->ts_algo.last_run_time = t_pre;
+	if (st->ts_algo.last_run_time > t_post)
+		st->ts_algo.last_run_time = t_post;
+
+	return fifo_count;
+}
+
+int inv_get_dmp_ts(struct inv_mpu_state *st, int i)
+{
+	u64 current_time;
+	int expected_lower_duration, expected_upper_duration;
+
+	current_time = get_time_ns();
+
+	st->sensor[i].ts += st->sensor[i].dur + st->sensor[i].ts_adj;
+
+	if (st->sensor[i].ts < st->sensor[i].previous_ts)
+		st->sensor[i].ts = st->sensor[i].previous_ts + st->sensor[i].dur;
+
+	/* hifi sensor limits ts jitter to +/- 2% */
+#if defined(CONFIG_INV_MPU_IIO_ICM20648) || \
+	defined(CONFIG_INV_MPU_IIO_ICM20608D)
+	/* for DMP enabled devices */
+	expected_upper_duration =
+		st->eng_info[st->sensor[i].engine_base].dur *
+		st->sensor[i].div / 1000 * 1020;
+	expected_lower_duration =
+		st->eng_info[st->sensor[i].engine_base].dur *
+		st->sensor[i].div / 1000 * 980;
+#else
+	/* for no DMP devices */
+	expected_upper_duration =
+		st->eng_info[st->sensor[i].engine_base].dur / 1000 * 1020;
+	expected_lower_duration =
+		st->eng_info[st->sensor[i].engine_base].dur / 1000 * 980;
+#endif
+
+	if (st->sensor[i].ts < st->sensor[i].previous_ts + expected_lower_duration)
+		st->sensor[i].ts = st->sensor[i].previous_ts + expected_lower_duration;
+	if (st->sensor[i].ts > st->sensor[i].previous_ts + expected_upper_duration)
+		st->sensor[i].ts = st->sensor[i].previous_ts + expected_upper_duration;
+
+	if (st->sensor[i].ts > current_time)
+		st->sensor[i].ts = current_time;
+
+	st->sensor[i].previous_ts = st->sensor[i].ts;
+
+	pr_debug("ts=%lld, reset=%lld\n", st->sensor[i].ts, st->ts_algo.reset_ts);
+	if (st->sensor[i].ts < st->ts_algo.reset_ts) {
+		pr_debug("less than reset\n");
+		st->sensor[i].send = false;
+	} else {
+		st->sensor[i].send = true;
+	}
+
+	if (st->header_count == 1)
+		inv_update_dmp_ts(st, i);
+
+	return 0;
+}
+
+static void process_sensor_bounding(struct inv_mpu_state *st, int i)
+{
+	s64 elaps_time, thresh1, thresh2;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+	u32 dur;
+
+	elaps_time = ((u64) (st->sensor[i].dur)) * st->sensor[i].count;
+	thresh1 = ts_algo->last_run_time - elaps_time;
+
+	dur = max(st->sensor[i].dur, (int)MIN_DELAY);
+	thresh2 = thresh1 - dur;
+	if (thresh1 < 0)
+		thresh1 = 0;
+	if (thresh2 < 0)
+		thresh2 = 0;
+	st->sensor[i].ts_adj = 0;
+	if ((ts_algo->calib_counter >= INV_TIME_CALIB_THRESHOLD_1) &&
+						(!ts_algo->resume_flag)) {
+		if (st->sensor[i].ts < thresh2)
+			st->sensor[i].ts_adj = thresh2 - st->sensor[i].ts;
+	} else if ((ts_algo->calib_counter >=
+		INV_TIME_CALIB_THRESHOLD_1) && ts_algo->resume_flag) {
+		if (st->sensor[i].ts < thresh2)
+			st->sensor[i].ts = ts_algo->last_run_time -
+						elaps_time - JITTER_THRESH;
+	} else {
+		st->sensor[i].ts = ts_algo->last_run_time - elaps_time -
+							JITTER_THRESH;
+		st->sensor[i].previous_ts = st->sensor[i].ts;
+	}
+
+	if (st->sensor[i].ts > thresh1)
+		st->sensor[i].ts_adj = thresh1 - st->sensor[i].ts;
+	pr_debug("cali=%d\n", st->ts_algo.calib_counter);
+	pr_debug("adj= %lld\n", st->sensor[i].ts_adj);
+	pr_debug("dur= %d count= %d last= %lld\n", st->sensor[i].dur,
+				st->sensor[i].count, ts_algo->last_run_time);
+	if (st->sensor[i].ts_adj && (st->sensor[i].count > 1))
+		st->sensor[i].ts_adj = div_s64(st->sensor[i].ts_adj,
+							st->sensor[i].count);
+}
+/* inv_bound_timestamp (struct inv_mpu_state *st)
+	The purpose this function is to give a generic bound to each
+	sensor timestamp. The timestamp cannot exceed current time.
+	The timestamp cannot backwards one sample time either, otherwise, there
+	would be another sample in between. Using this principle, we can bound
+	the sensor samples */
+int inv_bound_timestamp(struct inv_mpu_state *st)
+{
+	int i;
+	struct inv_timestamp_algo *ts_algo = &st->ts_algo;
+
+	for (i = 0; i < SENSOR_NUM_MAX; i++) {
+		if (st->sensor[i].on) {
+			if (st->sensor[i].count) {
+				process_sensor_bounding(st, i);
+			} else if (ts_algo->calib_counter <
+				   INV_TIME_CALIB_THRESHOLD_1) {
+				st->sensor[i].ts = ts_algo->reset_ts;
+				st->sensor[i].previous_ts = st->sensor[i].ts;
+			}
+		}
+	}
+
+	return 0;
+}
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index f9d7cd3be6a8..d8e3211cf384 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -365,6 +365,13 @@ config TOUCHSCREEN_EGALAX
 	  To compile this driver as a module, choose M here: the
 	  module will be called egalax_ts.
 
+config TOUCHSCREEN_EGALAX_I2C
+    tristate "EETI touch screen I2C driver"
+    depends on I2C && OF
+    help
+        Say Y here to enable support for touch screen I2C
+        driver for EETI controller.
+
 config TOUCHSCREEN_EGALAX_SERIAL
 	tristate "EETI eGalax serial touchscreen"
 	select SERIO
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 4dd7f23991fd..eccd03b8c4c2 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -44,6 +44,7 @@ obj-$(CONFIG_TOUCHSCREEN_ELO)		+= elo.o
 obj-$(CONFIG_TOUCHSCREEN_ELAN_TS)      += elan_ts.o
 obj-$(CONFIG_TOUCHSCREEN_EGALAX)	+= egalax_ts.o
 obj-$(CONFIG_TOUCHSCREEN_EGALAX_SERIAL)	+= egalax_ts_serial.o
+obj-$(CONFIG_TOUCHSCREEN_EGALAX_I2C) += egalax_i2c.o
 obj-$(CONFIG_TOUCHSCREEN_EXC3000)	+= exc3000.o
 obj-$(CONFIG_TOUCHSCREEN_FTS)		+= focaltech_touch/
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX)	+= synaptics_dsx/
diff --git a/drivers/input/touchscreen/egalax_i2c.c b/drivers/input/touchscreen/egalax_i2c.c
new file mode 100644
index 000000000000..aac9fb804323
--- /dev/null
+++ b/drivers/input/touchscreen/egalax_i2c.c
@@ -0,0 +1,1125 @@
+/*
+ *
+ * Touch Screen I2C Driver for EETI Controller
+ *
+ * Copyright (C) 2000-2016  eGalax_eMPIA Technology Inc.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#define RELEASE_DATE "2016/10/26"
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/device.h>
+#include <asm/uaccess.h>
+#include <linux/kfifo.h>
+#include <linux/version.h>
+#include <linux/input.h>
+#include <linux/irq.h>
+#include <linux/timer.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+#include <linux/input/mt.h>
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0)
+#include <linux/of_gpio.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0)
+	#define __devinit
+	#define __devexit
+	#define __devexit_p(x) x
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	#include <linux/earlysuspend.h>
+	static struct early_suspend egalax_early_suspend;
+#endif
+
+// Global define to enable function
+//#define _SWITCH_XY
+//#define _CONVERT_Y
+
+#define MAX_EVENTS		600
+#define MAX_I2C_LEN		64
+#define FIFO_SIZE		8192 //(PAGE_SIZE*2)
+#define MAX_SUPPORT_POINT	16
+#define REPORTID_MOUSE		0x01
+#define REPORTID_VENDOR		0x03
+#define REPORTID_MTOUCH		0x06//0x18//0x04
+#define MAX_RESOLUTION		4095
+
+// running mode
+#define MODE_STOP	0
+#define MODE_WORKING	1
+#define MODE_IDLE	2
+#define MODE_SUSPEND	3
+
+struct tagMTContacts {
+	unsigned char ID;
+	signed char Status;
+	unsigned short X;
+	unsigned short Y;
+};
+
+struct _egalax_i2c {
+	struct workqueue_struct *ktouch_wq;
+	struct work_struct work_irq;
+	struct delayed_work delay_work_ioctl;
+	struct mutex mutex_wq;
+	struct i2c_client *client;
+	unsigned char work_state;
+	unsigned char skip_packet;
+	unsigned int ioctl_cmd;
+	int interrupt_gpio;
+};
+
+struct egalax_char_dev
+{
+	int OpenCnts;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	struct kfifo* pDataKFiFo;
+#else
+	struct kfifo DataKFiFo;
+#endif
+	unsigned char *pFiFoBuf;
+	spinlock_t FiFoLock;
+	struct semaphore sem;
+	wait_queue_head_t fifo_inq;
+};
+
+static struct _egalax_i2c *p_egalax_i2c_dev = NULL;	// allocated in egalax_i2c_probe
+static struct egalax_char_dev *p_char_dev = NULL;	// allocated in init_module
+static atomic_t egalax_char_available = ATOMIC_INIT(1);
+static atomic_t wait_command_ack = ATOMIC_INIT(0);
+static struct input_dev *input_dev = NULL;
+static struct tagMTContacts pContactBuf[MAX_SUPPORT_POINT];
+static unsigned char input_report_buf[MAX_I2C_LEN+2];
+
+#define DBG_MODULE	0x00000001
+#define DBG_CDEV	0x00000002
+#define DBG_PROC	0x00000004
+#define DBG_POINT	0x00000008
+#define DBG_INT		0x00000010
+#define DBG_I2C		0x00000020
+#define DBG_SUSP	0x00000040
+#define DBG_INPUT	0x00000080
+#define DBG_CONST	0x00000100
+#define DBG_IDLE	0x00000200
+#define DBG_WAKEUP	0x00000400
+#define DBG_BUTTON	0x00000800
+static unsigned int DbgLevel = DBG_MODULE|DBG_SUSP;
+
+#define PROC_FS_NAME	"egalax_dbg"
+#define PROC_FS_MAX_LEN	8
+static struct proc_dir_entry *dbgProcFile;
+
+#define EGALAX_DBG(level, fmt, args...)  do{ if( (level&DbgLevel)>0 ) \
+					printk( KERN_DEBUG "[egalax_i2c]: " fmt, ## args); }while(0)
+
+static int egalax_I2C_read(unsigned char *pBuf, unsigned short len)
+{
+	struct i2c_msg xfer;
+
+	if(pBuf==NULL)
+		return -1;
+
+	// Read device data
+	xfer.addr = p_egalax_i2c_dev->client->addr;
+	xfer.flags = I2C_M_RD;
+	xfer.len = len;
+	xfer.buf = pBuf;
+
+	if(i2c_transfer(p_egalax_i2c_dev->client->adapter, &xfer, 1) != 1)
+	{
+		EGALAX_DBG(DBG_I2C, " %s: i2c transfer fail\n", __func__);
+		return -EIO;
+	}
+	else
+		EGALAX_DBG(DBG_I2C, " %s: i2c transfer success\n", __func__);
+
+	return 0;
+}
+
+static int egalax_I2C_write(unsigned short reg, unsigned char *pBuf, unsigned short len)
+{
+	unsigned char cmdbuf[4+len];
+	struct i2c_msg xfer;
+
+	if(pBuf==NULL)
+		return -1;
+
+	cmdbuf[0] = reg & 0x00FF;
+	cmdbuf[1] = (reg >> 8) & 0x00FF;
+	cmdbuf[2] = (len+2) & 0x00FF;
+	cmdbuf[3] = ((len+2) >> 8) & 0x00FF;
+	memcpy(cmdbuf+4, pBuf, len);
+
+	// Write data to device
+	xfer.addr = p_egalax_i2c_dev->client->addr;
+	xfer.flags = 0;
+	xfer.len = sizeof(cmdbuf);
+	xfer.buf = cmdbuf;
+
+	if(i2c_transfer(p_egalax_i2c_dev->client->adapter, &xfer, 1) != 1)
+	{
+		EGALAX_DBG(DBG_I2C, " %s: i2c transfer fail\n", __func__);
+		return -EIO;
+	}
+	else
+		EGALAX_DBG(DBG_I2C, " %s: i2c transfer success\n", __func__);
+
+	return 0;
+}
+
+static int wakeup_controller(int irq)
+{
+	int ret = 0;
+
+	disable_irq(irq);
+
+	gpio_direction_output(p_egalax_i2c_dev->interrupt_gpio, 0);
+	udelay(200);
+	gpio_direction_input(p_egalax_i2c_dev->interrupt_gpio); //return to high level
+
+	enable_irq(irq);
+
+	EGALAX_DBG(DBG_WAKEUP, " INT wakeup touch controller done\n");
+
+	return ret;
+}
+
+static int egalax_cdev_open(struct inode *inode, struct file *filp)
+{
+	if( !atomic_dec_and_test(&egalax_char_available) )
+	{
+		atomic_inc(&egalax_char_available);
+		return -EBUSY; // already open
+	}
+
+	p_char_dev->OpenCnts++;
+	filp->private_data = p_char_dev;// Used by the read and write metheds
+
+	EGALAX_DBG(DBG_CDEV, " CDev open done!\n");
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+static int egalax_cdev_release(struct inode *inode, struct file *filp)
+{
+	struct egalax_char_dev *cdev = filp->private_data;
+
+	atomic_inc(&egalax_char_available); // release the device
+
+	cdev->OpenCnts--;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	kfifo_reset( cdev->pDataKFiFo );
+#else
+	kfifo_reset( &cdev->DataKFiFo );
+#endif
+
+	EGALAX_DBG(DBG_CDEV, " CDev release done!\n");
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+static char fifo_read_buf[MAX_I2C_LEN];
+static ssize_t egalax_cdev_read(struct file *file, char __user *buf, size_t count, loff_t *offset)
+{
+	int read_cnt, ret, fifoLen;
+	struct egalax_char_dev *cdev = file->private_data;
+
+	if( down_interruptible(&cdev->sem) )
+		return -ERESTARTSYS;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	fifoLen = kfifo_len(cdev->pDataKFiFo);
+#else
+	fifoLen = kfifo_len(&cdev->DataKFiFo);
+#endif
+
+	while( fifoLen<1 ) // nothing to read
+	{
+		up(&cdev->sem); // release the lock
+		if( file->f_flags & O_NONBLOCK )
+			return -EAGAIN;
+
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+		if( wait_event_interruptible(cdev->fifo_inq, kfifo_len( cdev->pDataKFiFo )>0) )
+	#else
+		if( wait_event_interruptible(cdev->fifo_inq, kfifo_len( &cdev->DataKFiFo )>0) )
+	#endif
+		{
+			return -ERESTARTSYS; // signal: tell the fs layer to handle it
+		}
+
+		if( down_interruptible(&cdev->sem) )
+			return -ERESTARTSYS;
+	}
+
+	if(count > MAX_I2C_LEN)
+		count = MAX_I2C_LEN;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	read_cnt = kfifo_get(cdev->pDataKFiFo, fifo_read_buf, count);
+#else
+	read_cnt = kfifo_out_locked(&cdev->DataKFiFo, fifo_read_buf, count, &cdev->FiFoLock);
+#endif
+	EGALAX_DBG(DBG_CDEV, " \"%s\" reading fifo data count=%d\n", current->comm, read_cnt);
+
+	ret = copy_to_user(buf, fifo_read_buf, read_cnt)?-EFAULT:read_cnt;
+
+	up(&cdev->sem);
+
+	return ret;
+}
+
+static ssize_t egalax_cdev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)
+{
+	struct egalax_char_dev *cdev = file->private_data;
+	int ret=0;
+	char *tmp;
+
+	if( down_interruptible(&cdev->sem) )
+		return -ERESTARTSYS;
+
+	if (count > MAX_I2C_LEN)
+		count = MAX_I2C_LEN;
+
+	tmp = kzalloc(MAX_I2C_LEN, GFP_KERNEL);
+	if(tmp==NULL)
+	{
+		up(&cdev->sem);
+		return -ENOMEM;
+	}
+
+	if(copy_from_user(tmp, buf, count))
+	{
+		up(&cdev->sem);
+		kfree(tmp);
+		return -EFAULT;
+	}
+
+	ret = egalax_I2C_write(0x0067, tmp, MAX_I2C_LEN);
+
+	up(&cdev->sem);
+	EGALAX_DBG(DBG_CDEV, " I2C writing %zu bytes.\n", count);
+	kfree(tmp);
+
+	return (ret==0?count:-1);
+}
+
+static unsigned int egalax_cdev_poll(struct file *filp, struct poll_table_struct *wait)
+{
+	struct egalax_char_dev *cdev = filp->private_data;
+	unsigned int mask = 0;
+	int fifoLen;
+
+	down(&cdev->sem);
+	poll_wait(filp, &cdev->fifo_inq,  wait);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	fifoLen = kfifo_len(cdev->pDataKFiFo);
+#else
+	fifoLen = kfifo_len(&cdev->DataKFiFo);
+#endif
+
+	if( fifoLen > 0 )
+		mask |= POLLIN | POLLRDNORM;    /* readable */
+	if( (FIFO_SIZE - fifoLen) > MAX_I2C_LEN )
+		mask |= POLLOUT | POLLWRNORM;   /* writable */
+
+	up(&cdev->sem);
+	return mask;
+}
+
+static int egalax_proc_show(struct seq_file* seqfilp, void *v)
+{
+	seq_printf(seqfilp, "EETI I2C for All Points.\nDebug Level: 0x%08X\nRelease Date: %s\n", DbgLevel, RELEASE_DATE);
+	return 0;
+}
+
+static int egalax_proc_open(struct inode *inode, struct file *filp)
+{
+	EGALAX_DBG(DBG_PROC, " \"%s\" call proc_open\n", current->comm);
+	return single_open(filp, egalax_proc_show, NULL);
+}
+
+static ssize_t egalax_proc_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)
+{
+	char procfs_buffer_size = 0;
+	unsigned char procfs_buf[PROC_FS_MAX_LEN+1] = {0};
+
+	EGALAX_DBG(DBG_PROC, " \"%s\" call proc_write\n", current->comm);
+
+	procfs_buffer_size = count;
+	if(procfs_buffer_size > PROC_FS_MAX_LEN )
+		procfs_buffer_size = PROC_FS_MAX_LEN+1;
+
+	if( copy_from_user(procfs_buf, buf, procfs_buffer_size) )
+	{
+		EGALAX_DBG(DBG_PROC, " proc_write faied at copy_from_user\n");
+		return -EFAULT;
+	}
+
+	sscanf(procfs_buf, "%x", &DbgLevel);
+	EGALAX_DBG(DBG_PROC, " Switch Debug Level to 0x%08X\n", DbgLevel);
+
+	return procfs_buffer_size;
+}
+
+#define MAX_POINT_PER_PACKET	5
+#define POINT_STRUCT_SIZE	10
+static int TotalPtsCnt=0, RecvPtsCnt=0;
+static void ProcessReport(unsigned char *buf, struct _egalax_i2c *p_egalax_i2c)
+{
+	unsigned char i, index=0, cnt_down=0, cnt_up=0, shift=0;
+	unsigned char status=0;
+	unsigned short contactID=0, x=0, y=0;
+
+	//EGALAX_DBG(DBG_MODULE, " egalax ProcessReport\n");
+	if(TotalPtsCnt<=0)
+	{
+		if(buf[1]==0 || buf[1]>MAX_SUPPORT_POINT)
+		{
+			EGALAX_DBG(DBG_POINT, " NumsofContacts mismatch, skip packet\n");
+			return;
+		}
+
+		TotalPtsCnt = buf[1];
+		RecvPtsCnt = 0;
+	}
+	else if(buf[1]>0)
+	{
+		TotalPtsCnt = RecvPtsCnt = 0;
+		EGALAX_DBG(DBG_POINT, " NumsofContacts mismatch, skip packet\n");
+		return;
+	}
+
+	while(index<MAX_POINT_PER_PACKET)
+	{
+		shift = index * POINT_STRUCT_SIZE + 2;
+		status = buf[shift] & 0x01;
+		contactID = buf[shift+1];
+		x = ((buf[shift+3]<<8) + buf[shift+2]);
+		y = ((buf[shift+5]<<8) + buf[shift+4]);
+
+		if( contactID>=MAX_SUPPORT_POINT )
+		{
+			TotalPtsCnt = RecvPtsCnt = 0;
+			EGALAX_DBG(DBG_POINT, " Get error ContactID.\n");
+			return;
+		}
+
+		EGALAX_DBG(DBG_POINT, " Get Point[%d] Update: Status=%d X=%d Y=%d\n", contactID, status, x, y);
+		//EGALAX_DBG(DBG_MODULE, " Get Point[%d] Update: Status=%d X=%d Y=%d\n", contactID, status, x, y);
+
+	#ifdef _SWITCH_XY
+		short tmp = x;
+		x = y;
+		y = tmp;
+	#endif
+	#ifdef _CONVERT_X
+		x = MAX_RESOLUTION-x;
+	#endif
+
+	#ifdef _CONVERT_Y
+		y = MAX_RESOLUTION-y;
+	#endif
+
+		pContactBuf[RecvPtsCnt].ID = contactID;
+		pContactBuf[RecvPtsCnt].Status = status;
+		pContactBuf[RecvPtsCnt].X = x;
+		pContactBuf[RecvPtsCnt].Y = y;
+
+		RecvPtsCnt++;
+		index++;
+
+		// Recv all points, send input report
+		if(RecvPtsCnt==TotalPtsCnt)
+		{
+			for(i=0; i<RecvPtsCnt; i++)
+			{
+			#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+				input_mt_slot(input_dev, pContactBuf[i].ID);
+				input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, pContactBuf[i].Status);
+				if(pContactBuf[i].Status)
+				{
+					input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, pContactBuf[i].Status);
+					input_report_abs(input_dev, ABS_MT_POSITION_X, pContactBuf[i].X);
+					input_report_abs(input_dev, ABS_MT_POSITION_Y, pContactBuf[i].Y);
+				}
+			#else
+				input_report_abs(input_dev, ABS_MT_TRACKING_ID, pContactBuf[i].ID);
+				input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, pContactBuf[i].Status);
+				input_report_abs(input_dev, ABS_MT_POSITION_X, pContactBuf[i].X);
+				input_report_abs(input_dev, ABS_MT_POSITION_Y, pContactBuf[i].Y);
+				input_report_abs(input_dev, ABS_MT_WIDTH_MAJOR, 0);
+				input_report_key(input_dev, BTN_TOUCH, 1); /*add*/
+				input_mt_sync(input_dev);
+			#endif
+
+				if(pContactBuf[i].Status)
+					cnt_down++;
+				else
+					cnt_up++;
+			}
+		#ifndef CONFIG_HAS_EARLYSUSPEND //We use this config to distinguish Linux and Android
+			#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
+			input_mt_report_pointer_emulation(input_dev, true);
+			#endif
+		#endif
+			input_sync(input_dev);
+			EGALAX_DBG(DBG_POINT, " Input sync point data done! (Down:%d Up:%d)\n", cnt_down, cnt_up);
+			//EGALAX_DBG(DBG_MODULE, " Input sync point data done! (Down:%d Up:%d)\n", cnt_down, cnt_up);
+
+			TotalPtsCnt = RecvPtsCnt = 0;
+			return;
+		}
+	}
+}
+
+static struct input_dev * allocate_Input_Dev(struct i2c_client *client)
+{
+	int ret;
+	struct input_dev *pInputDev=NULL;
+
+	pInputDev = input_allocate_device();
+	if(pInputDev == NULL)
+	{
+		EGALAX_DBG(DBG_MODULE, " Failed to allocate input device\n");
+		return NULL;//-ENOMEM;
+	}
+
+	pInputDev->name = "eGalax_Touch_Screen";
+	pInputDev->phys = "I2C";
+	pInputDev->id.bustype = BUS_I2C;
+	pInputDev->id.vendor = 0x0EEF;
+	pInputDev->id.product = 0x0020;
+	pInputDev->id.version = 0x0001;
+	pInputDev->dev.parent = &client->dev;
+
+	set_bit(EV_ABS, pInputDev->evbit);
+#ifndef CONFIG_HAS_EARLYSUSPEND //We use this config to distinguish Linux and Android
+	set_bit(EV_KEY, pInputDev->evbit);
+	__set_bit(BTN_TOUCH, pInputDev->keybit);
+	input_set_abs_params(pInputDev, ABS_X, 0, MAX_RESOLUTION, 0, 0);
+	input_set_abs_params(pInputDev, ABS_Y, 0, MAX_RESOLUTION, 0, 0);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+	__set_bit(INPUT_PROP_DIRECT, pInputDev->propbit);
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0)
+		input_mt_init_slots(pInputDev, MAX_SUPPORT_POINT, 0);
+	#else
+		input_mt_init_slots(pInputDev, MAX_SUPPORT_POINT);
+	#endif
+	input_set_abs_params(pInputDev, ABS_MT_POSITION_X, 0, MAX_RESOLUTION, 0, 0);
+	input_set_abs_params(pInputDev, ABS_MT_POSITION_Y, 0, MAX_RESOLUTION, 0, 0);
+	input_set_abs_params(pInputDev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+#else
+	input_set_abs_params(pInputDev, ABS_MT_POSITION_X, 0, MAX_RESOLUTION, 0, 0);
+	input_set_abs_params(pInputDev, ABS_MT_POSITION_Y, 0, MAX_RESOLUTION, 0, 0);
+	input_set_abs_params(pInputDev, ABS_MT_WIDTH_MAJOR, 0, MAX_RESOLUTION, 0, 0); //Size
+	input_set_abs_params(pInputDev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0); //Pressure
+	input_set_abs_params(pInputDev, ABS_MT_TRACKING_ID, 0, MAX_SUPPORT_POINT, 0, 0);
+#endif // #if LINUX_VERSION_CODE > KERNEL_VERSION(3,0,0)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+	input_set_events_per_packet(pInputDev, MAX_EVENTS);
+#endif
+
+	ret = input_register_device(pInputDev);
+	if(ret)
+	{
+		EGALAX_DBG(DBG_MODULE, " Unable to register input device.\n");
+		input_free_device(pInputDev);
+		pInputDev = NULL;
+	}
+
+	return pInputDev;
+}
+
+static int egalax_i2c_measure(struct _egalax_i2c *egalax_i2c)
+{
+	int ret=0, frameLen=0, loop=3, i;
+
+	EGALAX_DBG(DBG_INT, " egalax_i2c_measure\n");
+
+	if( egalax_I2C_read(input_report_buf, MAX_I2C_LEN+2) < 0)
+	{
+		EGALAX_DBG(DBG_I2C, " I2C read input report fail!\n");
+		return -1;
+	}
+
+	if( DbgLevel&DBG_I2C )
+	{
+		char dbgmsg[(MAX_I2C_LEN+2)*4];
+		for(i=0; i<MAX_I2C_LEN+2; i++)
+			sprintf(dbgmsg+i*4, "[%02X]", input_report_buf[i]);
+		EGALAX_DBG(DBG_I2C, " Buf=%s\n", dbgmsg);
+	}
+
+	frameLen = input_report_buf[0] + (input_report_buf[1]<<8);
+	EGALAX_DBG(DBG_I2C, " I2C read data with Len=%d\n", frameLen);
+
+	if(frameLen==0)
+	{
+		EGALAX_DBG(DBG_MODULE, " Device reset\n");
+		return -1;
+	}
+
+	switch(input_report_buf[2])
+	{
+		case REPORTID_MTOUCH:
+			if( !egalax_i2c->skip_packet && egalax_i2c->work_state==MODE_WORKING )
+				ProcessReport(input_report_buf+2, egalax_i2c);
+			ret = 0;
+			break;
+		case REPORTID_VENDOR:
+			atomic_set(&wait_command_ack, 1);
+			EGALAX_DBG(DBG_I2C, " I2C get vendor command packet\n");
+
+			if( p_char_dev->OpenCnts>0 ) // If someone reading now! put the data into the buffer!
+			{
+				loop=3;
+				do {
+				#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+					ret = wait_event_timeout(p_char_dev->fifo_inq, (FIFO_SIZE-kfifo_len(p_char_dev->pDataKFiFo))>=MAX_I2C_LEN, HZ);
+				#else
+					ret = wait_event_timeout(p_char_dev->fifo_inq, kfifo_avail(&p_char_dev->DataKFiFo)>=MAX_I2C_LEN, HZ);
+				#endif
+				}while(ret<=0 && --loop);
+
+				if(ret>0) // fifo size is ready
+				{
+				#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+					ret = kfifo_put(p_char_dev->pDataKFiFo, input_report_buf+2, MAX_I2C_LEN);
+				#else
+					ret = kfifo_in_locked(&p_char_dev->DataKFiFo, input_report_buf+2, MAX_I2C_LEN, &p_char_dev->FiFoLock);
+				#endif
+
+					wake_up_interruptible( &p_char_dev->fifo_inq );
+				}
+				else
+					EGALAX_DBG(DBG_CDEV, " [Warning] Can't write data because fifo size is overflow.\n");
+			}
+
+			break;
+		default:
+			EGALAX_DBG(DBG_I2C, " I2C read error data with hedaer=%d\n", input_report_buf[2]);
+			ret = -1;
+			break;
+	}
+
+	return ret;
+}
+
+static void egalax_i2c_wq_irq(struct work_struct *work)
+{
+	struct _egalax_i2c *egalax_i2c = container_of(work, struct _egalax_i2c, work_irq);
+	struct i2c_client *client = egalax_i2c->client;
+
+	EGALAX_DBG(DBG_INT, " egalax_i2c_wq run\n");
+
+	/*continue recv data*/
+	while( !gpio_get_value(egalax_i2c->interrupt_gpio) )
+	{
+		egalax_i2c_measure(egalax_i2c);
+		schedule();
+	}
+
+	if( egalax_i2c->skip_packet > 0 )
+		egalax_i2c->skip_packet = 0;
+
+	enable_irq(client->irq);
+
+	EGALAX_DBG(DBG_INT, " egalax_i2c_wq leave\n");
+}
+
+static irqreturn_t egalax_i2c_interrupt(int irq, void *dev_id)
+{
+	struct _egalax_i2c *egalax_i2c = (struct _egalax_i2c *)dev_id;
+
+	EGALAX_DBG(DBG_INT, " INT with irq:%d\n", irq);
+
+	disable_irq_nosync(irq);
+
+	queue_work(egalax_i2c->ktouch_wq, &egalax_i2c->work_irq);
+
+	return IRQ_HANDLED;
+}
+
+static void egalax_i2c_senduppoint(void)
+{
+	int i=0;
+
+	EGALAX_DBG(DBG_SUSP, " %s\n", __func__);
+
+	for(i=0; i<MAX_SUPPORT_POINT; i++)
+	{
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+		input_mt_slot(input_dev, pContactBuf[i].ID);
+		input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, 0);
+	#else
+		input_report_abs(input_dev, ABS_MT_TRACKING_ID, pContactBuf[i].ID);
+		input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, 0);
+		input_mt_sync(input_dev);
+	#endif
+	
+		if(pContactBuf[i].Status)
+			pContactBuf[i].Status = 0;
+	}
+
+#ifndef CONFIG_HAS_EARLYSUSPEND //We use this config to distinguish Linux and Android
+	input_mt_report_pointer_emulation(input_dev, true);
+#endif
+	input_sync(input_dev);
+	EGALAX_DBG(DBG_POINT, " Sent up point data done!\n");
+}
+
+static int egalax_i2c_pm_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	unsigned char cmdbuf[4];
+	struct i2c_msg xfer;
+
+	EGALAX_DBG(DBG_SUSP, " Enter pm_suspend state:%d\n", p_egalax_i2c_dev->work_state);
+
+	if(!p_egalax_i2c_dev)
+		goto fail_suspend;
+
+	//Power sleep command
+	cmdbuf[0] = 0xA7;	cmdbuf[1] = 0x00;
+	cmdbuf[2] = 0x01;	cmdbuf[3] = 0x08;
+
+	// Write data to device
+	xfer.addr = p_egalax_i2c_dev->client->addr;
+	xfer.flags = 0;
+	xfer.len = sizeof(cmdbuf);
+	xfer.buf = cmdbuf;
+
+	if(i2c_transfer(p_egalax_i2c_dev->client->adapter, &xfer, 1) != 1)
+	{
+		EGALAX_DBG(DBG_I2C, " %s: i2c send Power command fail\n", __func__);
+		goto fail_suspend2;
+	}
+
+	p_egalax_i2c_dev->work_state = MODE_SUSPEND;
+
+	EGALAX_DBG(DBG_SUSP, " pm_suspend done!!\n");
+	return 0;
+
+fail_suspend2:
+	p_egalax_i2c_dev->work_state = MODE_SUSPEND;
+fail_suspend:
+	EGALAX_DBG(DBG_SUSP, " pm_suspend failed!!\n");
+	return -1;
+}
+
+static int egalax_i2c_pm_resume(struct i2c_client *client)
+{
+	unsigned char cmdbuf[4];
+        struct i2c_msg xfer;
+
+	EGALAX_DBG(DBG_SUSP, " Enter pm_resume state:%d\n", p_egalax_i2c_dev->work_state);
+
+	if(!p_egalax_i2c_dev)
+		goto fail_resume;
+
+	if( wakeup_controller(p_egalax_i2c_dev->client->irq)==0 )
+	{
+		//Power wakeup command
+		cmdbuf[0] = 0xA7;       cmdbuf[1] = 0x00;
+		cmdbuf[2] = 0x00;       cmdbuf[3] = 0x08;
+
+		// Write data to device
+		xfer.addr = p_egalax_i2c_dev->client->addr;
+		xfer.flags = 0;
+		xfer.len = sizeof(cmdbuf);
+		xfer.buf = cmdbuf;
+
+		if(i2c_transfer(p_egalax_i2c_dev->client->adapter, &xfer, 1) != 1)
+		{
+			EGALAX_DBG(DBG_I2C, " %s: i2c send Power command fail\n", __func__);
+			goto fail_resume2;
+		}
+
+		p_egalax_i2c_dev->work_state = MODE_WORKING;
+	}
+	else
+	{
+		goto fail_resume2;
+	}
+
+	egalax_i2c_senduppoint();
+
+	EGALAX_DBG(DBG_SUSP, " pm_resume done!!\n");
+	return 0;
+
+fail_resume2:
+	p_egalax_i2c_dev->work_state = MODE_WORKING;
+fail_resume:
+	EGALAX_DBG(DBG_SUSP, " pm_resume failed!!\n");
+	return -1;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void egalax_i2c_early_suspend(struct early_suspend *handler)
+{
+	pm_message_t state;
+	state.event = PM_EVENT_SUSPEND;
+
+	EGALAX_DBG(DBG_SUSP, " %s\n", __func__);
+	egalax_i2c_pm_suspend(p_egalax_i2c_dev->client, state);
+}
+
+static void egalax_i2c_early_resume(struct early_suspend *handler)
+{
+	EGALAX_DBG(DBG_SUSP, " %s\n", __func__);
+	egalax_i2c_pm_resume(p_egalax_i2c_dev->client);
+}
+#endif // #ifdef CONFIG_HAS_EARLYSUSPEND
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+static int egalax_i2c_ops_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	pm_message_t state;
+	state.event = PM_EVENT_SUSPEND;
+	EGALAX_DBG(DBG_SUSP, " %s\n", __func__);
+	return egalax_i2c_pm_suspend(client, state);
+}
+
+static int egalax_i2c_ops_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	EGALAX_DBG(DBG_SUSP, " %s\n", __func__);
+	return egalax_i2c_pm_resume(client);
+}
+
+static SIMPLE_DEV_PM_OPS(egalax_i2c_pm_ops, egalax_i2c_ops_suspend, egalax_i2c_ops_resume);
+#endif
+
+static int __devinit egalax_i2c_probe(struct i2c_client *client, const struct i2c_device_id *idp)
+{
+	int ret;
+#ifdef CONFIG_OF
+	struct device_node *devnode;
+#endif //#ifdef CONFIG_OF
+
+	EGALAX_DBG(DBG_MODULE, " Start probe\n");
+
+	p_egalax_i2c_dev = (struct _egalax_i2c *)kzalloc(sizeof(struct _egalax_i2c), GFP_KERNEL);
+	if (!p_egalax_i2c_dev)
+	{
+		EGALAX_DBG(DBG_MODULE, " Request memory failed\n");
+		ret = -ENOMEM;
+		goto fail1;
+	}
+
+#ifdef CONFIG_OF
+	devnode = client->dev.of_node;
+	if(devnode) //if use the device tree config
+	{
+		p_egalax_i2c_dev->interrupt_gpio = of_get_named_gpio(devnode, "int-gpios", 0);
+		client->irq = gpio_to_irq(p_egalax_i2c_dev->interrupt_gpio);
+	}
+#else
+	p_egalax_i2c_dev->interrupt_gpio = irq_to_gpio(client->irq);
+#endif //#ifdef CONFIG_OF
+
+	if( !gpio_is_valid(p_egalax_i2c_dev->interrupt_gpio) )
+	{
+		ret = -ENODEV;
+		goto fail1;
+	}
+	ret = gpio_request(p_egalax_i2c_dev->interrupt_gpio, "Touch IRQ");
+	if(ret<0 && ret!=-EBUSY)
+	{
+		EGALAX_DBG(DBG_MODULE, " gpio_request[%d] failed: %d\n", p_egalax_i2c_dev->interrupt_gpio, ret);
+		goto fail1;
+	}
+	gpio_direction_input(p_egalax_i2c_dev->interrupt_gpio);
+
+	input_dev = allocate_Input_Dev(client);
+	if(input_dev==NULL)
+	{
+		EGALAX_DBG(DBG_MODULE, " allocate_Input_Dev failed\n");
+		ret = -EINVAL;
+		goto fail2;
+	}
+
+	EGALAX_DBG(DBG_MODULE, " Register input device done\n");
+
+	p_egalax_i2c_dev->client = client;
+	mutex_init(&p_egalax_i2c_dev->mutex_wq);
+
+	p_egalax_i2c_dev->ktouch_wq = create_singlethread_workqueue("egalax_touch_wq");
+	INIT_WORK(&p_egalax_i2c_dev->work_irq, egalax_i2c_wq_irq);
+
+	i2c_set_clientdata(client, p_egalax_i2c_dev);
+
+	if( gpio_get_value(p_egalax_i2c_dev->interrupt_gpio) )
+		p_egalax_i2c_dev->skip_packet = 0;
+	else
+		p_egalax_i2c_dev->skip_packet = 1;
+
+	p_egalax_i2c_dev->work_state = MODE_WORKING;
+
+	ret = request_irq(client->irq, egalax_i2c_interrupt, IRQF_TRIGGER_LOW, client->name, p_egalax_i2c_dev);
+	if( ret )
+	{
+		EGALAX_DBG(DBG_MODULE, " Request irq(%d) failed\n", client->irq);
+		goto fail3;
+	}
+	EGALAX_DBG(DBG_MODULE, " Request irq(%d) gpio(%d) with result:%d\n", client->irq, p_egalax_i2c_dev->interrupt_gpio, ret);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	egalax_early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+	egalax_early_suspend.suspend = egalax_i2c_early_suspend;
+	egalax_early_suspend.resume = egalax_i2c_early_resume;
+	register_early_suspend(&egalax_early_suspend);
+	EGALAX_DBG(DBG_MODULE, " Register early_suspend done\n");
+#endif
+
+	EGALAX_DBG(DBG_MODULE, " I2C probe done\n");
+	return 0;
+
+fail3:
+	i2c_set_clientdata(client, NULL);
+	destroy_workqueue(p_egalax_i2c_dev->ktouch_wq);
+	free_irq(client->irq, p_egalax_i2c_dev);
+	input_unregister_device(input_dev);
+	input_dev = NULL;
+fail2:
+	gpio_free(p_egalax_i2c_dev->interrupt_gpio);
+fail1:
+	kfree(p_egalax_i2c_dev);
+	p_egalax_i2c_dev = NULL;
+
+	EGALAX_DBG(DBG_MODULE, " I2C probe failed\n");
+	return ret;
+}
+
+static int __devexit egalax_i2c_remove(struct i2c_client *client)
+{
+	struct _egalax_i2c *egalax_i2c = i2c_get_clientdata(client);
+
+	egalax_i2c->work_state = MODE_STOP;
+
+	cancel_work_sync(&egalax_i2c->work_irq);
+
+	if(client->irq)
+	{
+		disable_irq(client->irq);
+		free_irq(client->irq, egalax_i2c);
+	}
+
+	gpio_free(egalax_i2c->interrupt_gpio);
+
+	if(egalax_i2c->ktouch_wq)
+		destroy_workqueue(egalax_i2c->ktouch_wq);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&egalax_early_suspend);
+#endif
+
+	if(input_dev)
+	{
+		EGALAX_DBG(DBG_MODULE,  " Unregister input device\n");
+		input_unregister_device(input_dev);
+		input_dev = NULL;
+	}
+
+	i2c_set_clientdata(client, NULL);
+	kfree(egalax_i2c);
+	p_egalax_i2c_dev = NULL;
+
+	return 0;
+}
+
+static const struct i2c_device_id egalax_i2c_idtable[] = {
+	{ "egalax_i2c", 0 },
+	{ }
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0)
+static const struct of_device_id egalax_i2c_dt_ids[] = {
+	{ .compatible = "eeti,egalax_i2c" },
+	{ }
+};
+#endif
+
+MODULE_DEVICE_TABLE(i2c, egalax_i2c_idtable);
+
+static struct i2c_driver egalax_i2c_driver = {
+	.driver = {
+		.name	= "egalax_i2c",
+		.owner	= THIS_MODULE,
+	#ifdef CONFIG_OF
+		.of_match_table = egalax_i2c_dt_ids,
+	#endif
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+		.pm		= &egalax_i2c_pm_ops,
+	#endif
+	},
+	.id_table	= egalax_i2c_idtable,
+	.probe		= egalax_i2c_probe,
+	.remove		= __devexit_p(egalax_i2c_remove),
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)	
+	#ifndef CONFIG_HAS_EARLYSUSPEND
+	.suspend	= egalax_i2c_pm_suspend,
+	.resume		= egalax_i2c_pm_resume,
+	#endif
+#endif
+
+};
+
+static const struct file_operations egalax_cdev_fops = {
+	.owner	= THIS_MODULE,
+	.read	= egalax_cdev_read,
+	.write	= egalax_cdev_write,
+	.open	= egalax_cdev_open,
+	.release= egalax_cdev_release,
+	.poll	= egalax_cdev_poll,
+};
+
+static const struct file_operations egalax_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= egalax_proc_open,
+	.read		= seq_read,
+	.write		= egalax_proc_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static struct miscdevice egalax_misc_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "egalax_i2c",
+	.fops = &egalax_cdev_fops,
+};
+
+static void egalax_i2c_ts_exit(void)
+{
+	if(p_char_dev)
+	{
+		if( p_char_dev->pFiFoBuf )
+			kfree(p_char_dev->pFiFoBuf);
+
+		kfree(p_char_dev);
+		p_char_dev = NULL;
+	}
+
+	misc_deregister(&egalax_misc_dev);
+
+	i2c_del_driver(&egalax_i2c_driver);
+
+	remove_proc_entry(PROC_FS_NAME, NULL);
+
+	EGALAX_DBG(DBG_MODULE, " Exit driver done!\n");
+}
+
+static struct egalax_char_dev* setup_chardev(void)
+{
+	struct egalax_char_dev *pCharDev;
+
+	pCharDev = kzalloc(1*sizeof(struct egalax_char_dev), GFP_KERNEL);
+	if(!pCharDev)
+		goto fail_cdev;
+
+	spin_lock_init( &pCharDev->FiFoLock );
+	pCharDev->pFiFoBuf = kzalloc(sizeof(unsigned char)*FIFO_SIZE, GFP_KERNEL);
+	if(!pCharDev->pFiFoBuf)
+		goto fail_fifobuf;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	pCharDev->pDataKFiFo = kfifo_init(pCharDev->pFiFoBuf, FIFO_SIZE, GFP_KERNEL, &pCharDev->FiFoLock);
+	if( pCharDev->pDataKFiFo==NULL )
+		goto fail_kfifo;
+#else
+	kfifo_init(&pCharDev->DataKFiFo, pCharDev->pFiFoBuf, FIFO_SIZE);
+	if( !kfifo_initialized(&pCharDev->DataKFiFo) )
+		goto fail_kfifo;
+#endif
+
+	pCharDev->OpenCnts = 0;
+	sema_init(&pCharDev->sem, 1);
+	init_waitqueue_head(&pCharDev->fifo_inq);
+
+	return pCharDev;
+
+fail_kfifo:
+	kfree(pCharDev->pFiFoBuf);
+fail_fifobuf:
+	kfree(pCharDev);
+fail_cdev:
+	return NULL;
+}
+
+#if 0
+static int egalax_i2c_ts_init(void)
+{
+	int result;
+
+	result = misc_register(&egalax_misc_dev);
+	if(result)
+	{
+		EGALAX_DBG(DBG_MODULE, " misc device register failed\n");
+		goto fail;
+	}
+
+	p_char_dev = setup_chardev(); // allocate the character device
+	if(!p_char_dev)
+	{
+		result = -ENOMEM;
+		goto fail;
+	}
+
+	dbgProcFile = proc_create(PROC_FS_NAME, S_IRUGO|S_IWUGO, NULL, &egalax_proc_fops);
+	if (dbgProcFile == NULL)
+	{
+		remove_proc_entry(PROC_FS_NAME, NULL);
+		EGALAX_DBG(DBG_MODULE, " Could not initialize /proc/%s\n", PROC_FS_NAME);
+	}
+
+	EGALAX_DBG(DBG_MODULE, " Driver init done!\n");
+	return i2c_add_driver(&egalax_i2c_driver);
+
+fail:
+	egalax_i2c_ts_exit();
+	return result;
+}
+
+module_init(egalax_i2c_ts_init);
+module_exit(egalax_i2c_ts_exit);
+#endif
+
+module_i2c_driver(egalax_i2c_driver);
+
+MODULE_AUTHOR("EETI <touch_fae@eeti.com>");
+MODULE_DESCRIPTION("egalax all points controller i2c driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/touchscreen/goodix.c b/drivers/input/touchscreen/goodix.c
index 1c7270b59eff..543d53ebcd1f 100644
--- a/drivers/input/touchscreen/goodix.c
+++ b/drivers/input/touchscreen/goodix.c
@@ -1221,6 +1221,9 @@ static int goodix_ts_probe(struct i2c_client *client,
 
 	ts->chip = goodix_get_chip_data(ts->id);
 
+	ts->load_cfg_from_disk = device_property_read_bool(&client->dev,
+			"load-firmware");
+
 	if (ts->load_cfg_from_disk) {
 		/* update device config */
 		ts->cfg_name = devm_kasprintf(&client->dev, GFP_KERNEL,
diff --git a/drivers/net/usb/Kconfig b/drivers/net/usb/Kconfig
index 8939e5fbd50a..c316c92d608a 100644
--- a/drivers/net/usb/Kconfig
+++ b/drivers/net/usb/Kconfig
@@ -550,6 +550,28 @@ config USB_NET_QMI_WWAN
 	  To compile this driver as a module, choose M here: the
 	  module will be called qmi_wwan.
 
+config USB_NET_QMI_WWAN_Q
+	tristate "QMI WWAN Q driver for Qualcomm MSM based 3G and LTE modems"
+	depends on USB_USBNET
+	select USB_WDM
+	help
+	  Support WWAN LTE/3G devices based on Qualcomm Mobile Data Modem
+	  (MDM) chipsets.  Examples of such devices are
+	    * Huawei E392/E398
+
+	  This driver will only drive the ethernet part of the chips.
+	  The devices require additional configuration to be usable.
+	  Multiple management interfaces with linux drivers are
+	  available:
+
+	    * option: AT commands on /dev/ttyUSBx
+	    * cdc-wdm: Qualcomm MSM Interface (QMI) protocol on /dev/cdc-wdmx
+
+	  A modem manager with support for QMI is recommended.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called qmi_wwan.
+
 config USB_HSO
 	tristate "Option USB High Speed Mobile Devices"
 	depends on USB && RFKILL && TTY
diff --git a/drivers/net/usb/Makefile b/drivers/net/usb/Makefile
index 4964f7b326fb..b0d2e9bb0de0 100644
--- a/drivers/net/usb/Makefile
+++ b/drivers/net/usb/Makefile
@@ -38,6 +38,7 @@ obj-$(CONFIG_USB_NET_CDC_NCM)	+= cdc_ncm.o
 obj-$(CONFIG_USB_NET_HUAWEI_CDC_NCM)	+= huawei_cdc_ncm.o
 obj-$(CONFIG_USB_VL600)		+= lg-vl600.o
 obj-$(CONFIG_USB_NET_QMI_WWAN)	+= qmi_wwan.o
+obj-$(CONFIG_USB_NET_QMI_WWAN_Q)	+= qmi_wwan_q.o
 obj-$(CONFIG_USB_NET_CDC_MBIM)	+= cdc_mbim.o
 obj-$(CONFIG_USB_NET_CH9200)	+= ch9200.o
 obj-$(CONFIG_USB_NET_AQC111)	+= aqc111.o
diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c
index 15c90441285c..f0b513178916 100644
--- a/drivers/net/usb/qmi_wwan.c
+++ b/drivers/net/usb/qmi_wwan.c
@@ -1404,12 +1404,14 @@ static const struct usb_device_id products[] = {
 	{QMI_FIXED_INTF(0x22de, 0x9061, 3)},	/* WeTelecom WPD-600N */
 	{QMI_QUIRK_SET_DTR(0x1e0e, 0x9001, 5)},	/* SIMCom 7100E, 7230E, 7600E ++ */
 	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0121, 4)},	/* Quectel EC21 Mini PCIe */
+	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0125, 4)}, /* Quectel EC25 */ 
 	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0191, 4)},	/* Quectel EG91 */
 	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0195, 4)},	/* Quectel EG95 */
 	{QMI_FIXED_INTF(0x2c7c, 0x0296, 4)},	/* Quectel BG96 */
 	{QMI_QUIRK_SET_DTR(0x2cb7, 0x0104, 4)},	/* Fibocom NL678 series */
 	{QMI_FIXED_INTF(0x0489, 0xe0b4, 0)},	/* Foxconn T77W968 LTE */
 	{QMI_FIXED_INTF(0x0489, 0xe0b5, 0)},	/* Foxconn T77W968 LTE with eSIM support*/
+	{QMI_FIXED_INTF(0x05C6, 0x9215, 4)},	/* Quectel EC20 */ 
 	{QMI_FIXED_INTF(0x2692, 0x9025, 4)},    /* Cellient MPL200 (rebranded Qualcomm 05c6:9025) */
 
 	/* 4. Gobi 1000 devices */
diff --git a/drivers/net/usb/qmi_wwan_q.c b/drivers/net/usb/qmi_wwan_q.c
new file mode 100644
index 000000000000..a138e67cbce0
--- /dev/null
+++ b/drivers/net/usb/qmi_wwan_q.c
@@ -0,0 +1,2513 @@
+/*
+ * Copyright (c) 2012  Bjrn Mork <bjorn@mork.no>
+ *
+ * The probing code is heavily inspired by cdc_ether, which is:
+ * Copyright (C) 2003-2005 by David Brownell
+ * Copyright (C) 2006 by Ole Andre Vadla Ravnas (ActiveSync)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/ethtool.h>
+#include <linux/etherdevice.h>
+#include <linux/time.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,16,0) //8b094cd03b4a3793220d8d8d86a173bfea8c285b
+#include <linux/timekeeping.h>
+#else
+#define timespec64  timespec
+#define ktime_get_ts64 ktime_get_ts
+#define timespec64_sub timespec_sub
+#endif
+#include <net/arp.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <linux/mii.h>
+#include <linux/usb.h>
+#include <linux/usb/cdc.h>
+#include <linux/usb/usbnet.h>
+#include <linux/usb/cdc-wdm.h>
+
+#ifndef ETH_P_MAP
+#define ETH_P_MAP 0xDA1A
+#endif
+
+#if (ETH_P_MAP == 0x00F9)
+#undef ETH_P_MAP
+#define ETH_P_MAP 0xDA1A
+#endif
+
+#ifndef ARPHRD_RAWIP
+#define ARPHRD_RAWIP ARPHRD_NONE
+#endif
+
+#ifdef CONFIG_PINCTRL_IPQ807x
+#define CONFIG_QCA_NSS_DRV
+#endif
+
+#if 1//def CONFIG_QCA_NSS_DRV
+#define _RMNET_NSS_H_
+#define _RMENT_NSS_H_
+struct rmnet_nss_cb {
+        int (*nss_create)(struct net_device *dev);
+        int (*nss_free)(struct net_device *dev);
+        int (*nss_tx)(struct sk_buff *skb);
+};
+static struct rmnet_nss_cb *rmnet_nss_callbacks __rcu __read_mostly;
+#ifdef CONFIG_QCA_NSS_DRV
+static uint __read_mostly qca_nss_enabled = 1;
+module_param( qca_nss_enabled, uint, S_IRUGO);
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION( 4,0,0 )) //1e9e39f4a29857a396ac7b669d109f697f66695e
+#define usbnet_set_skb_tx_stats(skb, packets, bytes_delta) do { dev->net->stats.tx_packets += packets; } while(0)
+#endif
+
+/* This driver supports wwan (3G/LTE/?) devices using a vendor
+ * specific management protocol called Qualcomm MSM Interface (QMI) -
+ * in addition to the more common AT commands over serial interface
+ * management
+ *
+ * QMI is wrapped in CDC, using CDC encapsulated commands on the
+ * control ("master") interface of a two-interface CDC Union
+ * resembling standard CDC ECM.  The devices do not use the control
+ * interface for any other CDC messages.  Most likely because the
+ * management protocol is used in place of the standard CDC
+ * notifications NOTIFY_NETWORK_CONNECTION and NOTIFY_SPEED_CHANGE
+ *
+ * Alternatively, control and data functions can be combined in a
+ * single USB interface.
+ *
+ * Handling a protocol like QMI is out of the scope for any driver.
+ * It is exported as a character device using the cdc-wdm driver as
+ * a subdriver, enabling userspace applications ("modem managers") to
+ * handle it.
+ *
+ * These devices may alternatively/additionally be configured using AT
+ * commands on a serial interface
+ */
+#define VERSION_NUMBER "V1.2.0.13"
+#define QUECTEL_WWAN_VERSION "Quectel_Linux&Android_QMI_WWAN_Driver_"VERSION_NUMBER
+static const char driver_name[] = "qmi_wwan_q";
+
+/* driver specific data */
+struct qmi_wwan_state {
+	struct usb_driver *subdriver;
+	atomic_t pmcount;
+	unsigned long unused;
+	struct usb_interface *control;
+	struct usb_interface *data;
+};
+
+/* default ethernet address used by the modem */
+static const u8 default_modem_addr[ETH_ALEN] = {0x02, 0x50, 0xf3};
+
+#if 1 //Added by Quectel
+/*
+    Quectel_WCDMA&LTE_Linux_USB_Driver_User_Guide_V1.9.pdf
+    5.6.	Test QMAP on GobiNet or QMI WWAN
+    0 - no QMAP
+    1 - QMAP (Aggregation protocol)
+    X - QMAP (Multiplexing and Aggregation protocol)
+*/
+#define QUECTEL_WWAN_QMAP 4 //MAX is 7
+
+#if defined(QUECTEL_WWAN_QMAP)
+#define QUECTEL_QMAP_MUX_ID 0x81
+
+static uint __read_mostly qmap_mode = 0;
+module_param( qmap_mode, uint, S_IRUGO);
+module_param_named( rx_qmap, qmap_mode, uint, S_IRUGO );
+#endif
+
+#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
+#define QUECTEL_BRIDGE_MODE
+#endif
+
+#ifdef QUECTEL_BRIDGE_MODE
+static uint __read_mostly bridge_mode = 0/*|BIT(1)*/;
+module_param( bridge_mode, uint, S_IRUGO );
+#endif
+
+#if defined(QUECTEL_WWAN_QMAP)
+#define QUECTEL_UL_DATA_AGG 1
+
+#if defined(QUECTEL_UL_DATA_AGG)
+struct tx_agg_ctx {
+	/* QMIWDS_ADMIN_SET_DATA_FORMAT_RESP TLV_0x17 and TLV_0x18 */
+	uint ul_data_aggregation_max_datagrams; //UplinkDataAggregationMaxDatagramsTlv
+	uint ul_data_aggregation_max_size; //UplinkDataAggregationMaxSizeTlv
+	uint dl_minimum_padding; //0x1A
+};
+#endif
+
+typedef struct {
+    unsigned int size;
+    unsigned int rx_urb_size;
+    unsigned int ep_type;
+    unsigned int iface_id;
+    unsigned int qmap_mode;
+    unsigned int qmap_version;
+    unsigned int dl_minimum_padding;
+    char ifname[8][16];
+    unsigned char mux_id[8];
+} RMNET_INFO;
+
+typedef struct sQmiWwanQmap
+{
+	struct usbnet *mpNetDev;
+	struct driver_info driver_info;
+	atomic_t refcount;
+	struct net_device *mpQmapNetDev[QUECTEL_WWAN_QMAP];
+	uint link_state;
+	uint qmap_mode;
+	uint qmap_size;
+	uint qmap_version;
+	struct sk_buff_head skb_chain;
+
+#if defined(QUECTEL_UL_DATA_AGG)
+	struct tx_agg_ctx tx_ctx;
+	struct tasklet_struct	txq;
+#endif
+
+#ifdef QUECTEL_BRIDGE_MODE
+	uint bridge_mode;
+	uint bridge_ipv4;
+	unsigned char bridge_mac[ETH_ALEN];
+#endif
+	uint use_rmnet_usb;
+	RMNET_INFO rmnet_info;
+} sQmiWwanQmap;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,10,0)
+#define MHI_NETDEV_STATUS64
+#endif
+struct qmap_priv {
+	struct usbnet *dev;
+	struct net_device *real_dev;
+	struct net_device *self_dev;
+	u8 offset_id;
+	u8 mux_id;
+	u8 qmap_version; // 5~v1, 9~v5
+	u8 link_state;
+
+#if defined(MHI_NETDEV_STATUS64)
+	struct pcpu_sw_netstats __percpu *stats64;
+#endif
+
+	spinlock_t agg_lock;
+	struct sk_buff *agg_skb;
+	unsigned agg_count;
+	struct timespec64 agg_time;
+	struct hrtimer agg_hrtimer;
+	struct work_struct agg_wq;
+	
+#ifdef QUECTEL_BRIDGE_MODE
+	uint bridge_mode;
+	uint bridge_ipv4;
+	unsigned char bridge_mac[ETH_ALEN];
+#endif
+};
+
+struct qmap_hdr {
+    u8 cd_rsvd_pad;
+    u8 mux_id;
+    u16 pkt_len;
+} __packed;
+
+enum rmnet_map_v5_header_type {
+	RMNET_MAP_HEADER_TYPE_UNKNOWN,
+	RMNET_MAP_HEADER_TYPE_COALESCING = 0x1,
+	RMNET_MAP_HEADER_TYPE_CSUM_OFFLOAD = 0x2,
+	RMNET_MAP_HEADER_TYPE_ENUM_LENGTH
+};
+
+/* Main QMAP header */
+struct rmnet_map_header {
+	u8  pad_len:6;
+	u8  next_hdr:1;
+	u8  cd_bit:1;
+	u8  mux_id;
+	__be16 pkt_len;
+}  __aligned(1);
+
+/* QMAP v5 headers */
+struct rmnet_map_v5_csum_header {
+	u8  next_hdr:1;
+	u8  header_type:7;
+	u8  hw_reserved:7;
+	u8  csum_valid_required:1;
+	__be16 reserved;
+} __aligned(1);
+
+#ifdef QUECTEL_BRIDGE_MODE
+static int is_qmap_netdev(const struct net_device *netdev);
+#endif
+#endif
+
+#ifdef QUECTEL_BRIDGE_MODE
+static int bridge_arp_reply(struct net_device *net, struct sk_buff *skb, uint bridge_ipv4) {
+    struct arphdr *parp;
+    u8 *arpptr, *sha;
+    u8  sip[4], tip[4], ipv4[4];
+    struct sk_buff *reply = NULL;
+
+    ipv4[0]  = (bridge_ipv4 >> 24) & 0xFF;
+    ipv4[1]  = (bridge_ipv4 >> 16) & 0xFF;
+    ipv4[2]  = (bridge_ipv4 >> 8) & 0xFF;
+    ipv4[3]  = (bridge_ipv4 >> 0) & 0xFF;
+
+    parp = arp_hdr(skb);
+
+    if (parp->ar_hrd == htons(ARPHRD_ETHER)  && parp->ar_pro == htons(ETH_P_IP)
+        && parp->ar_op == htons(ARPOP_REQUEST) && parp->ar_hln == 6 && parp->ar_pln == 4) {
+        arpptr = (u8 *)parp + sizeof(struct arphdr);
+        sha = arpptr;
+        arpptr += net->addr_len;	/* sha */
+        memcpy(sip, arpptr, sizeof(sip));
+        arpptr += sizeof(sip);
+        arpptr += net->addr_len;	/* tha */
+        memcpy(tip, arpptr, sizeof(tip));
+
+        pr_info("%s sip = %d.%d.%d.%d, tip=%d.%d.%d.%d, ipv4=%d.%d.%d.%d\n", netdev_name(net),
+            sip[0], sip[1], sip[2], sip[3], tip[0], tip[1], tip[2], tip[3], ipv4[0], ipv4[1], ipv4[2], ipv4[3]);
+	//wwan0 sip = 10.151.137.255, tip=10.151.138.0, ipv4=10.151.137.255
+        if (tip[0] == ipv4[0] && tip[1] == ipv4[1] && (tip[2]&0xFC) == (ipv4[2]&0xFC) && tip[3] != ipv4[3])
+            reply = arp_create(ARPOP_REPLY, ETH_P_ARP, *((__be32 *)sip), net, *((__be32 *)tip), sha, default_modem_addr, sha);
+
+        if (reply) {
+            skb_reset_mac_header(reply);
+            __skb_pull(reply, skb_network_offset(reply));
+            reply->ip_summed = CHECKSUM_UNNECESSARY;
+            reply->pkt_type = PACKET_HOST;
+
+            netif_rx_ni(reply);
+        }
+        return 1;
+    }
+
+    return 0;
+}
+
+static struct sk_buff *bridge_mode_tx_fixup(struct net_device *net, struct sk_buff *skb, uint bridge_ipv4, unsigned char *bridge_mac) {
+	struct ethhdr *ehdr;
+	const struct iphdr *iph;
+
+	skb_reset_mac_header(skb);
+	ehdr = eth_hdr(skb);
+
+	if (ehdr->h_proto == htons(ETH_P_ARP)) {
+		if (bridge_ipv4)
+			bridge_arp_reply(net, skb, bridge_ipv4);
+		return NULL;
+	}
+
+	iph = ip_hdr(skb);
+	//DBG("iphdr: ");
+	//PrintHex((void *)iph, sizeof(struct iphdr));
+
+// 1	0.000000000	0.0.0.0	255.255.255.255	DHCP	362	DHCP Request  - Transaction ID 0xe7643ad7
+	if (ehdr->h_proto == htons(ETH_P_IP) && iph->protocol == IPPROTO_UDP && iph->saddr == 0x00000000 && iph->daddr == 0xFFFFFFFF) {
+		//if (udp_hdr(skb)->dest == htons(67)) //DHCP Request
+		{
+			memcpy(bridge_mac, ehdr->h_source, ETH_ALEN);
+			pr_info("%s PC Mac Address: %02x:%02x:%02x:%02x:%02x:%02x\n", netdev_name(net),
+				bridge_mac[0], bridge_mac[1], bridge_mac[2], bridge_mac[3], bridge_mac[4], bridge_mac[5]);
+		}
+	}
+
+	if (memcmp(ehdr->h_source, bridge_mac, ETH_ALEN)) {
+		return NULL;
+	}
+
+	return skb;
+}
+
+static void bridge_mode_rx_fixup(sQmiWwanQmap *pQmapDev, struct net_device *net, struct sk_buff *skb) {
+	uint bridge_mode = 0;
+	unsigned char *bridge_mac;
+
+	if (pQmapDev->qmap_mode > 1 || pQmapDev->use_rmnet_usb == 1) {
+		struct qmap_priv *priv = netdev_priv(net);
+		bridge_mode = priv->bridge_mode;
+		bridge_mac = priv->bridge_mac;
+	}
+	else {
+		bridge_mode = pQmapDev->bridge_mode;
+		bridge_mac = pQmapDev->bridge_mac;
+	}
+
+	if (bridge_mode)
+		memcpy(eth_hdr(skb)->h_dest, bridge_mac, ETH_ALEN);
+	else
+		memcpy(eth_hdr(skb)->h_dest, net->dev_addr, ETH_ALEN);
+}
+#endif
+
+#if defined(QUECTEL_WWAN_QMAP)
+static ssize_t qmap_mode_show(struct device *dev, struct device_attribute *attr, char *buf) {
+	struct net_device *netdev = to_net_dev(dev);
+	struct usbnet * usbnetdev = netdev_priv( netdev );
+	struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n",  pQmapDev->qmap_mode);
+}
+
+static DEVICE_ATTR(qmap_mode, S_IRUGO, qmap_mode_show, NULL);
+
+static ssize_t qmap_size_show(struct device *dev, struct device_attribute *attr, char *buf) {
+	struct net_device *netdev = to_net_dev(dev);
+	struct usbnet * usbnetdev = netdev_priv( netdev );
+	struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+	return snprintf(buf, PAGE_SIZE, "%u\n",  pQmapDev->qmap_size);
+}
+
+static DEVICE_ATTR(qmap_size, S_IRUGO, qmap_size_show, NULL);
+
+static ssize_t link_state_show(struct device *dev, struct device_attribute *attr, char *buf) {
+	struct net_device *netdev = to_net_dev(dev);
+	struct usbnet * usbnetdev = netdev_priv( netdev );
+	struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+	return snprintf(buf, PAGE_SIZE, "0x%x\n",  pQmapDev->link_state);
+}
+
+static ssize_t link_state_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
+	struct net_device *netdev = to_net_dev(dev);
+	struct usbnet * usbnetdev = netdev_priv( netdev );
+	struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+	unsigned link_state = 0;
+	unsigned old_link = pQmapDev->link_state;
+	uint offset_id = 0;
+
+	link_state = simple_strtoul(buf, NULL, 0);
+
+	if (pQmapDev->qmap_mode == 1) {
+		pQmapDev->link_state = !!link_state;
+	}
+	else if (pQmapDev->qmap_mode > 1) {
+		offset_id = ((link_state&0x7F) - 1);
+
+		if (offset_id >= pQmapDev->qmap_mode) {
+			dev_info(dev, "%s offset_id is %d. but qmap_mode is %d\n", __func__, offset_id, pQmapDev->qmap_mode);
+			return count;
+		}
+
+		if (link_state&0x80)
+			pQmapDev->link_state &= ~(1 << offset_id);
+		else
+			pQmapDev->link_state |= (1 << offset_id);
+	}
+
+	if (old_link != pQmapDev->link_state) {
+		struct net_device *qmap_net = pQmapDev->mpQmapNetDev[offset_id];
+
+		if (pQmapDev->link_state) {
+			netif_carrier_on(usbnetdev->net);
+		} else {
+			netif_carrier_off(usbnetdev->net);
+		}
+
+		if (qmap_net && qmap_net != netdev) {
+			struct qmap_priv *priv = netdev_priv(qmap_net);
+
+			priv->link_state = !!(pQmapDev->link_state & (1 << offset_id));
+			if (priv->link_state) {
+				netif_carrier_on(qmap_net);
+				if (netif_queue_stopped(qmap_net) && !netif_queue_stopped(usbnetdev->net))
+					netif_wake_queue(qmap_net);
+			}
+			else {
+				netif_carrier_off(qmap_net);
+			}
+		}
+
+		dev_info(dev, "link_state 0x%x -> 0x%x\n", old_link, pQmapDev->link_state);
+	}
+
+	return count;
+}
+
+#ifdef QUECTEL_BRIDGE_MODE
+static ssize_t bridge_mode_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
+	struct net_device *netdev = to_net_dev(dev);
+	uint old_mode = 0;
+	uint bridge_mode = simple_strtoul(buf, NULL, 0);
+    
+	if (netdev->type != ARPHRD_ETHER) {
+		return count;
+	}
+
+	if (is_qmap_netdev(netdev)) {
+		struct qmap_priv *priv = netdev_priv(netdev);
+		old_mode = priv->bridge_mode;
+		priv->bridge_mode = bridge_mode;
+	}
+	else {
+		struct usbnet * usbnetdev = netdev_priv( netdev );
+		struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+		old_mode = pQmapDev->bridge_mode;
+		pQmapDev->bridge_mode = bridge_mode;
+	}
+
+	if (old_mode != bridge_mode) {
+		dev_info(dev, "bridge_mode change to 0x%x\n", bridge_mode);
+	}
+
+	return count;
+}
+
+static ssize_t bridge_mode_show(struct device *dev, struct device_attribute *attr, char *buf) {
+	struct net_device *netdev = to_net_dev(dev);
+	uint bridge_mode = 0;
+
+	if (is_qmap_netdev(netdev)) {
+		struct qmap_priv *priv = netdev_priv(netdev);
+		bridge_mode = priv->bridge_mode;
+	}
+	else {
+		struct usbnet * usbnetdev = netdev_priv( netdev );
+		struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+		bridge_mode = pQmapDev->bridge_mode;
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", bridge_mode);
+}
+
+static ssize_t bridge_ipv4_show(struct device *dev, struct device_attribute *attr, char *buf) {
+	struct net_device *netdev = to_net_dev(dev);
+	unsigned int bridge_ipv4 = 0;
+	unsigned char ipv4[4];
+
+	if (is_qmap_netdev(netdev)) {
+		struct qmap_priv *priv = netdev_priv(netdev);
+		bridge_ipv4 = priv->bridge_ipv4;
+	}
+	else {
+		struct usbnet * usbnetdev = netdev_priv( netdev );
+		struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+		bridge_ipv4 = pQmapDev->bridge_ipv4;
+	}
+
+	ipv4[0]  = (bridge_ipv4 >> 24) & 0xFF;
+	ipv4[1]  = (bridge_ipv4 >> 16) & 0xFF;
+	ipv4[2]  = (bridge_ipv4 >> 8) & 0xFF;
+	ipv4[3]  = (bridge_ipv4 >> 0) & 0xFF;
+
+	return snprintf(buf, PAGE_SIZE, "%d.%d.%d.%d\n",  ipv4[0], ipv4[1], ipv4[2], ipv4[3]);
+}
+
+static ssize_t bridge_ipv4_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
+	struct net_device *netdev = to_net_dev(dev);
+
+	if (is_qmap_netdev(netdev)) {
+		struct qmap_priv *priv = netdev_priv(netdev);
+		priv->bridge_ipv4 = simple_strtoul(buf, NULL, 16);
+	}
+	else {
+		struct usbnet * usbnetdev = netdev_priv( netdev );
+		struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+		pQmapDev->bridge_ipv4 = simple_strtoul(buf, NULL, 16);
+	}
+
+	return count;
+}
+#endif
+
+static DEVICE_ATTR(link_state, S_IWUSR | S_IRUGO, link_state_show, link_state_store);
+#ifdef QUECTEL_BRIDGE_MODE
+static DEVICE_ATTR(bridge_mode, S_IWUSR | S_IRUGO, bridge_mode_show, bridge_mode_store);
+static DEVICE_ATTR(bridge_ipv4, S_IWUSR | S_IRUGO, bridge_ipv4_show, bridge_ipv4_store);
+#endif
+
+static struct attribute *qmi_wwan_sysfs_attrs[] = {
+	&dev_attr_link_state.attr,
+	&dev_attr_qmap_mode.attr,
+	&dev_attr_qmap_size.attr,
+#ifdef QUECTEL_BRIDGE_MODE
+	&dev_attr_bridge_mode.attr,
+	&dev_attr_bridge_ipv4.attr,
+#endif
+	NULL,
+};
+
+static struct attribute_group qmi_wwan_sysfs_attr_group = {
+	.attrs = qmi_wwan_sysfs_attrs,
+};
+
+#ifdef QUECTEL_BRIDGE_MODE
+static struct attribute *qmi_qmap_sysfs_attrs[] = {
+	&dev_attr_bridge_mode.attr,
+	&dev_attr_bridge_ipv4.attr,
+	NULL,
+};
+
+static struct attribute_group qmi_qmap_sysfs_attr_group = {
+	.attrs = qmi_qmap_sysfs_attrs,
+};
+#endif
+
+static int qmap_open(struct net_device *dev)
+{
+	struct qmap_priv *priv = netdev_priv(dev);
+	struct net_device *real_dev = priv->real_dev;
+
+	if (!(priv->real_dev->flags & IFF_UP))
+		return -ENETDOWN;
+
+	if (netif_carrier_ok(real_dev) && priv->link_state)
+		netif_carrier_on(dev);
+
+	if (netif_carrier_ok(dev)) {
+		if (netif_queue_stopped(dev) && !netif_queue_stopped(real_dev))
+			netif_wake_queue(dev);
+	}
+
+	return 0;
+}
+
+static int qmap_stop(struct net_device *pNet)
+{
+	netif_carrier_off(pNet);
+	return 0;
+}
+
+static struct sk_buff * add_qhdr(struct sk_buff *skb, u8 mux_id) {
+	struct qmap_hdr *qhdr;
+	int pad = 0;
+
+	pad = skb->len%4;
+	if (pad) {
+		pad = 4 - pad;
+		if (skb_tailroom(skb) < pad) {
+			printk("skb_tailroom small!\n");
+			pad = 0;
+		}
+		if (pad)
+			__skb_put(skb, pad);
+	}
+					
+	qhdr = (struct qmap_hdr *)skb_push(skb, sizeof(struct qmap_hdr));
+	qhdr->cd_rsvd_pad = pad;
+	qhdr->mux_id = mux_id;
+	qhdr->pkt_len = cpu_to_be16(skb->len - sizeof(struct qmap_hdr));
+
+	return skb;
+}
+
+static struct sk_buff * add_qhdr_v5(struct sk_buff *skb, u8 mux_id) {
+	struct rmnet_map_header *map_header;
+	struct rmnet_map_v5_csum_header *ul_header;
+	u32 padding, map_datalen;
+
+	map_datalen = skb->len;
+	padding = map_datalen%4;
+	if (padding) {
+		padding = 4 - padding;
+		if (skb_tailroom(skb) < padding) {
+			printk("skb_tailroom small!\n");
+			padding = 0;
+		}
+		if (padding)
+			__skb_put(skb, padding);
+	}
+					
+	map_header = (struct rmnet_map_header *)skb_push(skb, (sizeof(struct rmnet_map_header) + sizeof(struct rmnet_map_v5_csum_header)));
+	map_header->cd_bit = 0;
+	map_header->next_hdr = 1;
+	map_header->pad_len = padding;
+	map_header->mux_id = mux_id;
+	map_header->pkt_len = htons(map_datalen + padding);
+
+	ul_header = (struct rmnet_map_v5_csum_header *)(map_header + 1);
+	memset(ul_header, 0, sizeof(*ul_header));
+	ul_header->header_type = RMNET_MAP_HEADER_TYPE_CSUM_OFFLOAD;
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+#if 0 //TODO
+		skb->ip_summed = CHECKSUM_NONE;
+		/* Ask for checksum offloading */
+		ul_header->csum_valid_required = 1;
+#endif
+	}
+
+	return skb;
+}
+
+static void rmnet_vnd_update_rx_stats(struct net_device *net,
+			unsigned rx_packets, unsigned rx_bytes) {
+#if defined(MHI_NETDEV_STATUS64)
+	struct qmap_priv *dev = netdev_priv(net);
+	struct pcpu_sw_netstats *stats64 = this_cpu_ptr(dev->stats64);
+
+	u64_stats_update_begin(&stats64->syncp);
+	stats64->rx_packets += rx_packets;
+	stats64->rx_bytes += rx_bytes;
+	u64_stats_update_end(&stats64->syncp);
+#else
+	net->stats.rx_packets += rx_packets;
+	net->stats.rx_bytes += rx_bytes;
+#endif
+}
+
+static void rmnet_vnd_update_tx_stats(struct net_device *net,
+			unsigned tx_packets, unsigned tx_bytes) {	
+#if defined(MHI_NETDEV_STATUS64)
+	struct qmap_priv *dev = netdev_priv(net);
+	struct pcpu_sw_netstats *stats64 = this_cpu_ptr(dev->stats64);
+
+	u64_stats_update_begin(&stats64->syncp);
+	stats64->tx_packets += tx_packets;
+	stats64->tx_bytes += tx_bytes;
+	u64_stats_update_end(&stats64->syncp);
+#else
+	net->stats.tx_packets += tx_packets;
+	net->stats.tx_bytes += tx_bytes;
+#endif
+}
+
+#if defined(MHI_NETDEV_STATUS64)
+static struct rtnl_link_stats64 *_rmnet_vnd_get_stats64(struct net_device *net, struct rtnl_link_stats64 *stats)
+{
+	struct qmap_priv *dev = netdev_priv(net);
+	unsigned int start;
+	int cpu;
+	struct rmnet_nss_cb *nss_cb;
+
+	netdev_stats_to_stats64(stats, &net->stats);
+
+	nss_cb = rcu_dereference(rmnet_nss_callbacks);
+	if (nss_cb) { // rmnet_nss.c:rmnet_nss_tx() will update rx stats
+		stats->rx_packets = 0;
+		stats->rx_bytes = 0;
+	}
+
+	for_each_possible_cpu(cpu) {
+		struct pcpu_sw_netstats *stats64;
+		u64 rx_packets, rx_bytes;
+		u64 tx_packets, tx_bytes;
+
+		stats64 = per_cpu_ptr(dev->stats64, cpu);
+
+		do {
+			start = u64_stats_fetch_begin_irq(&stats64->syncp);
+			rx_packets = stats64->rx_packets;
+			rx_bytes = stats64->rx_bytes;
+			tx_packets = stats64->tx_packets;
+			tx_bytes = stats64->tx_bytes;
+		} while (u64_stats_fetch_retry_irq(&stats64->syncp, start));
+
+		stats->rx_packets += rx_packets;
+		stats->rx_bytes += rx_bytes;
+		stats->tx_packets += tx_packets;
+		stats->tx_bytes += tx_bytes;
+	}
+
+	return stats;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 4,10,0 )) //bc1f44709cf27fb2a5766cadafe7e2ad5e9cb221
+static void rmnet_vnd_get_stats64(struct net_device *net, struct rtnl_link_stats64 *stats) {
+	_rmnet_vnd_get_stats64(net, stats);
+}
+#else
+static struct rtnl_link_stats64 *rmnet_vnd_get_stats64(struct net_device *net, struct rtnl_link_stats64 *stats) {
+	return _rmnet_vnd_get_stats64(net, stats);
+}
+#endif
+#endif
+
+#if defined(QUECTEL_UL_DATA_AGG)
+static void rmnet_usb_tx_wake_queue(unsigned long data) {
+	sQmiWwanQmap *pQmapDev = (void *)data;
+	int i;
+
+	for (i = 0; i < pQmapDev->qmap_mode; i++) {
+		struct net_device *qmap_net = pQmapDev->mpQmapNetDev[i];
+		if (qmap_net) {
+			if (netif_queue_stopped(qmap_net) && !netif_queue_stopped(pQmapDev->mpNetDev->net)) {
+				netif_wake_queue(qmap_net);
+			}
+		}
+	}
+}
+
+static void rmnet_usb_tx_skb_destructor(struct sk_buff *skb) {
+	struct net_device	*net = skb->dev;
+	struct usbnet * dev = netdev_priv( net );
+	struct qmi_wwan_state *info = (void *)&dev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+	if (pQmapDev && pQmapDev->use_rmnet_usb) {
+		int i;
+		
+		for (i = 0; i < pQmapDev->qmap_mode; i++) {
+			struct net_device *qmap_net = pQmapDev->mpQmapNetDev[i];
+
+			if (qmap_net) {
+				if (netif_queue_stopped(qmap_net)) {
+					tasklet_schedule(&pQmapDev->txq);
+					break;
+				}
+			}
+		}
+	}
+}
+
+static int rmnet_usb_tx_agg_skip(struct sk_buff *skb, int offset)
+{
+	u8 *packet_start = skb->data + offset;
+	int ready2send = 0;
+
+	if (skb->protocol == htons(ETH_P_IP)) {
+		struct iphdr *ip4h = (struct iphdr *)(packet_start);
+
+		if (ip4h->protocol == IPPROTO_TCP) {
+			const struct tcphdr *th = (const struct tcphdr *)(packet_start + sizeof(struct iphdr));
+			if (th->psh) {
+				ready2send = 1;
+			}
+		}
+		else if (ip4h->protocol == IPPROTO_ICMP)
+			ready2send = 1;
+
+	} else if (skb->protocol == htons(ETH_P_IPV6)) {
+		struct ipv6hdr *ip6h = (struct ipv6hdr *)(packet_start);
+
+		if (ip6h->nexthdr == NEXTHDR_TCP) {
+			const struct tcphdr *th = (const struct tcphdr *)(packet_start + sizeof(struct ipv6hdr));
+			if (th->psh) {
+				ready2send = 1;
+			}
+		} else if (ip6h->nexthdr == NEXTHDR_ICMP) {
+			ready2send = 1;
+		} else if (ip6h->nexthdr == NEXTHDR_FRAGMENT) {
+			struct frag_hdr *frag;
+
+			frag = (struct frag_hdr *)(packet_start
+						   + sizeof(struct ipv6hdr));
+			if (frag->nexthdr == IPPROTO_ICMPV6)
+				ready2send = 1;
+		}
+	}
+
+	return ready2send;
+}
+
+static void rmnet_usb_tx_agg_work(struct work_struct *work)
+{
+	struct qmap_priv *priv =
+			container_of(work, struct qmap_priv, agg_wq);
+	struct sk_buff *skb = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->agg_lock, flags);
+	if (likely(priv->agg_skb)) {
+		skb = priv->agg_skb;
+		priv->agg_skb = NULL;
+		priv->agg_count = 0;
+		skb->protocol = htons(ETH_P_MAP);
+		skb->dev = priv->real_dev;
+		ktime_get_ts64(&priv->agg_time);
+	}
+	spin_unlock_irqrestore(&priv->agg_lock, flags);
+	
+	if (skb) {
+		int err = dev_queue_xmit(skb);
+		if (err != NET_XMIT_SUCCESS) {
+			priv->self_dev->stats.tx_errors++;
+		}
+	}
+}
+
+static enum hrtimer_restart  rmnet_usb_tx_agg_timer_cb(struct hrtimer *timer)
+{
+	struct qmap_priv *priv =
+			container_of(timer, struct qmap_priv, agg_hrtimer);
+
+	schedule_work(&priv->agg_wq);
+	return HRTIMER_NORESTART;
+}
+
+static long agg_time_limit __read_mostly = 1000000L; //reduce this time, can get better TPUT performance, but will increase USB interrupts
+module_param(agg_time_limit, long, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(agg_time_limit, "Maximum time packets sit in the agg buf");
+
+static long agg_bypass_time __read_mostly = 10000000L;
+module_param(agg_bypass_time, long, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(agg_bypass_time, "Skip agg when apart spaced more than this");
+
+static int rmnet_usb_tx_agg(struct sk_buff *skb, struct qmap_priv *priv) {
+	struct qmi_wwan_state *info = (void *)&priv->dev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+	struct tx_agg_ctx *ctx = &pQmapDev->tx_ctx;
+	int ready2send = 0;
+	int xmit_more = 0;
+	struct timespec64 diff, now;
+	struct sk_buff *agg_skb = NULL;
+	unsigned long flags;
+	int err;
+	struct net_device *pNet = priv->self_dev;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,1,0) //6b16f9ee89b8d5709f24bc3ac89ae8b5452c0d7c
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,16,0)
+	xmit_more = skb->xmit_more;
+#endif
+#else
+	xmit_more = netdev_xmit_more();
+#endif
+
+	rmnet_vnd_update_tx_stats(pNet, 1, skb->len);
+
+	if (ctx->ul_data_aggregation_max_datagrams == 1) {
+		skb->protocol = htons(ETH_P_MAP);
+		skb->dev = priv->real_dev;
+		if (!skb->destructor)
+			skb->destructor = rmnet_usb_tx_skb_destructor;
+		err = dev_queue_xmit(skb);
+		if (err != NET_XMIT_SUCCESS)		
+			pNet->stats.tx_errors++;
+		return NET_XMIT_SUCCESS;
+	}
+
+new_packet:
+	spin_lock_irqsave(&priv->agg_lock, flags);
+	agg_skb = NULL;
+	ready2send = 0;
+	ktime_get_ts64(&now);
+	diff = timespec64_sub(now, priv->agg_time);
+
+	if (priv->agg_skb) {
+		if ((priv->agg_skb->len + skb->len) < ctx->ul_data_aggregation_max_size) {
+			memcpy(skb_put(priv->agg_skb, skb->len), skb->data, skb->len);
+			priv->agg_count++;
+
+			if (diff.tv_sec > 0 || diff.tv_nsec > agg_time_limit) {
+				ready2send = 1;
+			}
+			else if (priv->agg_count == ctx->ul_data_aggregation_max_datagrams) {
+				ready2send = 1;
+			}
+			else if (xmit_more == 0) {
+				struct rmnet_map_header *map_header = (struct rmnet_map_header *)skb->data;
+				size_t offset = sizeof(struct rmnet_map_header);
+				if (map_header->next_hdr)
+					offset += sizeof(struct rmnet_map_v5_csum_header);
+
+				ready2send = rmnet_usb_tx_agg_skip(skb, offset);
+			}
+			
+			dev_kfree_skb_any(skb);
+			skb = NULL;
+		}
+		else {
+			ready2send = 1;
+		}
+
+		if (ready2send) {
+			agg_skb = priv->agg_skb;
+			priv->agg_skb = NULL;
+			priv->agg_count = 0;
+		}
+	}
+	else if (skb) {
+		if (diff.tv_sec > 0 || diff.tv_nsec > agg_bypass_time) {
+			ready2send = 1;
+		}
+		else if (xmit_more == 0) {
+			struct rmnet_map_header *map_header = (struct rmnet_map_header *)skb->data;
+			size_t offset = sizeof(struct rmnet_map_header);
+			if (map_header->next_hdr)
+				offset += sizeof(struct rmnet_map_v5_csum_header);
+
+			ready2send = rmnet_usb_tx_agg_skip(skb, offset);
+		}
+
+		if (ready2send == 0) {
+			priv->agg_skb = alloc_skb(ctx->ul_data_aggregation_max_size, GFP_ATOMIC);
+			if (priv->agg_skb) {
+				memcpy(skb_put(priv->agg_skb, skb->len), skb->data, skb->len);
+				priv->agg_count++;
+				dev_kfree_skb_any(skb);
+				skb = NULL;
+			}
+			else {
+				ready2send = 1;
+			}
+		}
+
+		if (ready2send) {
+			agg_skb = skb;
+			skb = NULL;
+		}
+	}
+
+	if (ready2send) {
+		priv->agg_time = now;
+	}
+	spin_unlock_irqrestore(&priv->agg_lock, flags);
+
+	if (agg_skb) {
+		agg_skb->protocol = htons(ETH_P_MAP);
+		agg_skb->dev = priv->real_dev;
+		if (!agg_skb->destructor)
+			agg_skb->destructor = rmnet_usb_tx_skb_destructor;
+		err = dev_queue_xmit(agg_skb);
+		if (err != NET_XMIT_SUCCESS) {
+			pNet->stats.tx_errors++;
+		}
+	}
+
+	if (skb) {
+		goto new_packet;
+	}
+
+	if (priv->agg_skb) {
+		if (!hrtimer_is_queued(&priv->agg_hrtimer))
+			hrtimer_start(&priv->agg_hrtimer, ns_to_ktime(NSEC_PER_MSEC * 2), HRTIMER_MODE_REL);
+	}
+
+	return NET_XMIT_SUCCESS;
+}
+#endif
+
+static netdev_tx_t rmnet_vnd_start_xmit(struct sk_buff *skb,
+					struct net_device *pNet)
+{
+	int err;
+	struct qmap_priv *priv = netdev_priv(pNet);
+
+	if (netif_queue_stopped(priv->real_dev)) {
+		netif_stop_queue(pNet);
+		return NETDEV_TX_BUSY;
+	}
+
+	//printk("%s 1 skb=%p, len=%d, protocol=%x, hdr_len=%d\n", __func__, skb, skb->len, skb->protocol, skb->hdr_len);
+	if (pNet->type == ARPHRD_ETHER) {
+		skb_reset_mac_header(skb);
+
+#ifdef QUECTEL_BRIDGE_MODE
+		if (priv->bridge_mode && bridge_mode_tx_fixup(pNet, skb, priv->bridge_ipv4, priv->bridge_mac) == NULL) {
+		      dev_kfree_skb_any (skb);
+		      return NETDEV_TX_OK;
+		}
+#endif
+
+		if (skb_pull(skb, ETH_HLEN) == NULL) {
+			dev_kfree_skb_any (skb);
+			return NETDEV_TX_OK;
+		}
+	}
+	//printk("%s 2 skb=%p, len=%d, protocol=%x, hdr_len=%d\n", __func__, skb, skb->len, skb->protocol, skb->hdr_len);
+
+	if (priv->qmap_version == 5) {
+		add_qhdr(skb, priv->mux_id);
+	}
+	else if (priv->qmap_version == 9) {
+		add_qhdr_v5(skb, priv->mux_id);
+	}
+	else {
+		dev_kfree_skb_any (skb);
+		return NETDEV_TX_OK;
+	}
+	//printk("%s skb=%p, len=%d, protocol=%x, hdr_len=%d\n", __func__, skb, skb->len, skb->protocol, skb->hdr_len);
+
+#if 0
+	skb->protocol = htons(ETH_P_MAP);
+	skb->dev = priv->real_dev;
+	err = dev_queue_xmit(skb);
+
+	if (err == NET_XMIT_SUCCESS) {
+		rmnet_vnd_update_tx_stats(pNet, 1, skb->len);
+	} else {
+		pNet->stats.tx_errors++;
+	}
+#else
+	err = rmnet_usb_tx_agg(skb, priv);
+#endif
+
+	return err;
+}
+
+static int rmnet_vnd_change_mtu(struct net_device *rmnet_dev, int new_mtu)
+{
+	if (new_mtu < 0 || new_mtu > 1500)
+		return -EINVAL;
+
+	rmnet_dev->mtu = new_mtu;
+	return 0;
+}
+
+/* drivers may override default ethtool_ops in their bind() routine */
+static const struct ethtool_ops rmnet_vnd_ethtool_ops = {
+	.get_link		= ethtool_op_get_link,
+};
+
+static int qmap_start_xmit(struct sk_buff *skb, struct net_device *pNet)
+{
+	int err;
+	struct qmap_priv *priv = netdev_priv(pNet);
+
+	//printk("%s 1 skb=%p, len=%d, protocol=%x, hdr_len=%d\n", __func__, skb, skb->len, skb->protocol, skb->hdr_len);
+	if (pNet->type == ARPHRD_ETHER) {
+		skb_reset_mac_header(skb);
+	
+#ifdef QUECTEL_BRIDGE_MODE
+		if (priv->bridge_mode && bridge_mode_tx_fixup(pNet, skb, priv->bridge_ipv4, priv->bridge_mac) == NULL) {
+		    dev_kfree_skb_any (skb);
+			return NETDEV_TX_OK;
+		}
+#endif
+	
+		if (skb_pull(skb, ETH_HLEN) == NULL) {
+			dev_kfree_skb_any (skb);
+			return NETDEV_TX_OK;
+		}
+	}
+
+
+	add_qhdr(skb, QUECTEL_QMAP_MUX_ID + priv->offset_id);
+
+	skb->dev = priv->real_dev;
+	err = dev_queue_xmit(skb);
+	if (err == NET_XMIT_SUCCESS) {
+		pNet->stats.tx_packets++;
+		pNet->stats.tx_bytes += skb->len;
+	} else {
+		pNet->stats.tx_errors++;
+	}
+
+	return err;
+}
+
+static const struct net_device_ops qmap_netdev_ops = {
+	.ndo_open       = qmap_open,
+	.ndo_stop       = qmap_stop,
+	.ndo_start_xmit = qmap_start_xmit,
+};
+
+static const struct net_device_ops rmnet_vnd_ops = {
+	.ndo_open       = qmap_open,
+	.ndo_stop       = qmap_stop,
+	.ndo_start_xmit = rmnet_vnd_start_xmit,
+	.ndo_change_mtu = rmnet_vnd_change_mtu,
+#if defined(MHI_NETDEV_STATUS64)
+	.ndo_get_stats64	= rmnet_vnd_get_stats64,
+#endif
+};
+
+static void rmnet_usb_vnd_setup(struct net_device *rmnet_dev)
+{
+	rmnet_dev->needed_headroom = 16;
+
+	/* Raw IP mode */
+	rmnet_dev->header_ops = NULL;  /* No header */
+	rmnet_dev->type = ARPHRD_RAWIP;
+	rmnet_dev->hard_header_len = 0;
+	rmnet_dev->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);
+}
+
+static rx_handler_result_t rmnet_usb_rx_priv_handler(struct sk_buff **pskb)
+{
+	struct sk_buff *skb = *pskb;
+	struct rmnet_nss_cb *nss_cb;
+
+	if (!skb)
+		return RX_HANDLER_CONSUMED;
+	
+	//printk("%s skb=%p, len=%d, protocol=%x, hdr_len=%d\n", __func__, skb, skb->len, skb->protocol, skb->hdr_len);
+
+	if (skb->pkt_type == PACKET_LOOPBACK)
+		return RX_HANDLER_PASS;
+
+	/* Check this so that we dont loop around netif_receive_skb */
+	if (skb->cb[0] == 1) {
+		skb->cb[0] = 0;
+
+		return RX_HANDLER_PASS;
+	}
+
+	nss_cb = rcu_dereference(rmnet_nss_callbacks);
+	if (nss_cb) {
+		nss_cb->nss_tx(skb);
+		return RX_HANDLER_CONSUMED;
+	}
+
+	return RX_HANDLER_PASS;
+}
+
+static int qmap_register_device(sQmiWwanQmap * pDev, u8 offset_id)
+{
+    struct net_device *real_dev = pDev->mpNetDev->net;
+    struct net_device *qmap_net;
+    struct qmap_priv *priv;
+    int err;
+    struct rmnet_nss_cb *nss_cb;
+
+    qmap_net = alloc_etherdev(sizeof(*priv));
+    if (!qmap_net)
+        return -ENOBUFS;
+
+    SET_NETDEV_DEV(qmap_net, &real_dev->dev);
+    priv = netdev_priv(qmap_net);
+    priv->offset_id = offset_id;
+    priv->real_dev = real_dev;
+    priv->self_dev = qmap_net;
+    priv->dev = pDev->mpNetDev;
+    priv->qmap_version = pDev->qmap_version;
+    priv->mux_id = QUECTEL_QMAP_MUX_ID + offset_id;
+    sprintf(qmap_net->name, "%s.%d", real_dev->name, offset_id + 1);
+    qmap_net->netdev_ops = &qmap_netdev_ops;
+    memcpy (qmap_net->dev_addr, real_dev->dev_addr, ETH_ALEN);
+
+#ifdef QUECTEL_BRIDGE_MODE
+	priv->bridge_mode = !!(pDev->bridge_mode & BIT(offset_id));
+	qmap_net->sysfs_groups[0] = &qmi_qmap_sysfs_attr_group;
+#endif
+
+	priv->agg_skb = NULL;
+	priv->agg_count = 0;
+	hrtimer_init(&priv->agg_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	priv->agg_hrtimer.function = rmnet_usb_tx_agg_timer_cb;
+	INIT_WORK(&priv->agg_wq, rmnet_usb_tx_agg_work);
+	ktime_get_ts64(&priv->agg_time);
+	spin_lock_init(&priv->agg_lock);
+
+	if (pDev->use_rmnet_usb) {
+		qmap_net->ethtool_ops = &rmnet_vnd_ethtool_ops;
+		qmap_net->netdev_ops = &rmnet_vnd_ops;
+#if defined(MHI_NETDEV_STATUS64)
+		priv->stats64 = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);
+		if (!priv->stats64) {
+			err = -ENOBUFS;
+			goto out_free_newdev;
+		}
+#endif
+	}
+
+	nss_cb = rcu_dereference(rmnet_nss_callbacks);
+#ifdef QUECTEL_BRIDGE_MODE
+    if(nss_cb && !priv->bridge_mode) {
+#else
+    if (nss_cb) {
+#endif
+		rmnet_usb_vnd_setup(qmap_net);
+	}
+
+    err = register_netdev(qmap_net);
+    dev_info(&real_dev->dev, "%s(%s)=%d\n", __func__, qmap_net->name, err);
+    if (err < 0)
+        goto out_free_newdev;
+    netif_device_attach (qmap_net);
+    netif_carrier_off(qmap_net);
+
+	nss_cb = rcu_dereference(rmnet_nss_callbacks);
+#ifdef QUECTEL_BRIDGE_MODE
+    if(nss_cb && !priv->bridge_mode) {
+#else
+    if (nss_cb) {
+#endif
+		int rc = nss_cb->nss_create(qmap_net);
+		if (rc) {
+			/* Log, but don't fail the device creation */
+			netdev_err(qmap_net, "Device will not use NSS path: %d\n", rc);
+		} else {
+			netdev_info(qmap_net, "NSS context created\n");
+			rtnl_lock();
+			netdev_rx_handler_register(qmap_net, rmnet_usb_rx_priv_handler, NULL);
+			rtnl_unlock();			
+		}
+	}
+
+	if (pDev->use_rmnet_usb) {
+		strcpy(pDev->rmnet_info.ifname[offset_id], qmap_net->name);
+		pDev->rmnet_info.mux_id[offset_id] = priv->mux_id;
+	}
+
+    pDev->mpQmapNetDev[offset_id] = qmap_net;
+    qmap_net->flags |= IFF_NOARP;
+    qmap_net->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);
+
+    dev_info(&real_dev->dev, "%s %s\n", __func__, qmap_net->name);
+
+    return 0;
+
+out_free_newdev:
+    free_netdev(qmap_net);
+    return err;
+}
+
+static void qmap_unregister_device(sQmiWwanQmap * pDev, u8 offset_id) {
+	struct net_device *qmap_net = pDev->mpQmapNetDev[offset_id];
+
+	if (qmap_net != NULL && qmap_net != pDev->mpNetDev->net) {
+		struct rmnet_nss_cb *nss_cb;
+		struct qmap_priv *priv = netdev_priv(qmap_net);
+		unsigned long flags;
+
+		pr_info("qmap_unregister_device(%s)\n", qmap_net->name);
+		pDev->mpQmapNetDev[offset_id] = NULL;
+		netif_carrier_off( qmap_net );
+		netif_stop_queue( qmap_net );
+		
+		hrtimer_cancel(&priv->agg_hrtimer);
+		cancel_work_sync(&priv->agg_wq);
+		spin_lock_irqsave(&priv->agg_lock, flags);
+		if (priv->agg_skb) {
+			kfree_skb(priv->agg_skb);
+		}
+		spin_unlock_irqrestore(&priv->agg_lock, flags);
+		nss_cb = rcu_dereference(rmnet_nss_callbacks);
+
+#ifdef QUECTEL_BRIDGE_MODE
+        if(nss_cb && !priv->bridge_mode) {
+#else
+        if (nss_cb) {
+#endif
+			rtnl_lock();
+			netdev_rx_handler_unregister(qmap_net);
+			rtnl_unlock();
+			nss_cb->nss_free(qmap_net);
+		}
+
+#if defined(MHI_NETDEV_STATUS64)
+		free_percpu(priv->stats64);
+#endif
+		unregister_netdev (qmap_net);
+		free_netdev(qmap_net);
+	}
+}
+
+#if 1//def CONFIG_ANDROID
+typedef struct {
+    unsigned int size;
+    unsigned int rx_urb_size;
+    unsigned int ep_type;
+    unsigned int iface_id;
+    unsigned int MuxId;
+    unsigned int ul_data_aggregation_max_datagrams; //0x17
+    unsigned int ul_data_aggregation_max_size ;//0x18
+    unsigned int dl_minimum_padding; //0x1A
+} QMAP_SETTING;
+
+int qma_setting_store(struct device *dev, QMAP_SETTING *qmap_settings, size_t size) {
+	struct net_device *netdev = to_net_dev(dev);
+	struct usbnet * usbnetdev = netdev_priv( netdev );
+	struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+	if (qmap_settings->size != size) {
+		dev_err(dev, "ERROR: qmap_settings.size donot match!\n");
+		return -EOPNOTSUPP;
+	}
+
+#ifdef QUECTEL_UL_DATA_AGG
+	netif_tx_lock_bh(netdev);
+	if (pQmapDev->tx_ctx.ul_data_aggregation_max_datagrams == 1 && qmap_settings->ul_data_aggregation_max_datagrams > 1) {
+		pQmapDev->tx_ctx.ul_data_aggregation_max_datagrams = qmap_settings->ul_data_aggregation_max_datagrams;
+		pQmapDev->tx_ctx.ul_data_aggregation_max_size = qmap_settings->ul_data_aggregation_max_size;
+		pQmapDev->tx_ctx.dl_minimum_padding = qmap_settings->dl_minimum_padding;
+		dev_info(dev, "ul_data_aggregation_max_datagrams=%d, ul_data_aggregation_max_size=%d, dl_minimum_padding=%d\n",
+			pQmapDev->tx_ctx.ul_data_aggregation_max_datagrams,
+			pQmapDev->tx_ctx.ul_data_aggregation_max_size,
+			pQmapDev->tx_ctx.dl_minimum_padding);
+	}
+	netif_tx_unlock_bh(netdev);
+	return 0;
+#endif
+
+	return -EOPNOTSUPP;
+}
+
+static int qmap_ndo_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd) {
+	struct usbnet * usbnetdev = netdev_priv( dev );
+	struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+	int rc = -EOPNOTSUPP;
+	uint link_state = 0;
+ 	QMAP_SETTING qmap_settings = {0};
+ 
+	switch (cmd) {
+	case 0x89F1: //SIOCDEVPRIVATE
+		rc = copy_from_user(&link_state, ifr->ifr_ifru.ifru_data, sizeof(link_state));
+		if (!rc) {
+			char buf[32];
+			snprintf(buf, sizeof(buf), "%u", link_state);
+			link_state_store(&dev->dev, NULL, buf, strlen(buf));
+		}
+	break;
+
+	case 0x89F2: //SIOCDEVPRIVATE
+		rc = copy_from_user(&qmap_settings, ifr->ifr_ifru.ifru_data, sizeof(qmap_settings));
+		if (!rc) {
+			rc = qma_setting_store(&dev->dev, &qmap_settings, sizeof(qmap_settings));
+		}
+	break;
+
+	case 0x89F3: //SIOCDEVPRIVATE
+		if (pQmapDev->use_rmnet_usb) {
+			uint i;
+
+			for (i = 0; i < pQmapDev->qmap_mode; i++) {
+				struct net_device *qmap_net = pQmapDev->mpQmapNetDev[i];
+
+				if (!qmap_net)
+					break;
+
+				strcpy(pQmapDev->rmnet_info.ifname[i], qmap_net->name);
+			}
+			rc = copy_to_user(ifr->ifr_ifru.ifru_data, &pQmapDev->rmnet_info, sizeof(pQmapDev->rmnet_info));
+		}
+	break;
+
+	default:
+	break;
+	}
+
+	return rc;
+}
+#endif
+
+#ifdef QUECTEL_BRIDGE_MODE
+static int is_qmap_netdev(const struct net_device *netdev) {
+	return netdev->netdev_ops == &qmap_netdev_ops || netdev->netdev_ops == &rmnet_vnd_ops;
+}
+#endif
+#endif
+
+static struct sk_buff *qmi_wwan_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags) {
+	//MDM9x07,MDM9628,MDM9x40,SDX20,SDX24 only work on RAW IP mode
+	if ((dev->driver_info->flags & FLAG_NOARP) == 0)
+		return skb;
+
+	// Skip Ethernet header from message
+	if (dev->net->hard_header_len == 0)
+		return skb;
+	else
+		skb_reset_mac_header(skb);
+
+#ifdef QUECTEL_BRIDGE_MODE
+{
+	struct qmi_wwan_state *info = (void *)&dev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+	if (pQmapDev->bridge_mode && bridge_mode_tx_fixup(dev->net, skb, pQmapDev->bridge_ipv4, pQmapDev->bridge_mac) == NULL) {
+	      dev_kfree_skb_any (skb);
+	      return NULL;
+	}
+}
+#endif
+
+	if (skb_pull(skb, ETH_HLEN)) {
+		return skb;
+	} else {
+		dev_err(&dev->intf->dev,  "Packet Dropped ");
+	}
+
+	// Filter the packet out, release it
+	dev_kfree_skb_any(skb);
+	return NULL;
+}
+#endif
+
+/* Make up an ethernet header if the packet doesn't have one.
+ *
+ * A firmware bug common among several devices cause them to send raw
+ * IP packets under some circumstances.  There is no way for the
+ * driver/host to know when this will happen.  And even when the bug
+ * hits, some packets will still arrive with an intact header.
+ *
+ * The supported devices are only capably of sending IPv4, IPv6 and
+ * ARP packets on a point-to-point link. Any packet with an ethernet
+ * header will have either our address or a broadcast/multicast
+ * address as destination.  ARP packets will always have a header.
+ *
+ * This means that this function will reliably add the appropriate
+ * header iff necessary, provided our hardware address does not start
+ * with 4 or 6.
+ *
+ * Another common firmware bug results in all packets being addressed
+ * to 00:a0:c6:00:00:00 despite the host address being different.
+ * This function will also fixup such packets.
+ */
+static int qmi_wwan_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+{
+	__be16 proto;
+
+	/* This check is no longer done by usbnet */
+	if (skb->len < dev->net->hard_header_len)
+		return 0;
+
+	switch (skb->data[0] & 0xf0) {
+	case 0x40:
+		proto = htons(ETH_P_IP);
+		break;
+	case 0x60:
+		proto = htons(ETH_P_IPV6);
+		break;
+	case 0x00:
+		if (is_multicast_ether_addr(skb->data))
+			return 1;
+		/* possibly bogus destination - rewrite just in case */
+		skb_reset_mac_header(skb);
+		goto fix_dest;
+	default:
+		/* pass along other packets without modifications */
+		return 1;
+	}
+	if (skb_headroom(skb) < ETH_HLEN)
+		return 0;
+	skb_push(skb, ETH_HLEN);
+	skb_reset_mac_header(skb);
+	eth_hdr(skb)->h_proto = proto;
+	memset(eth_hdr(skb)->h_source, 0, ETH_ALEN);
+#if 1 //Added by Quectel
+	//some kernel will drop ethernet packet which's souce mac is all zero
+	memcpy(eth_hdr(skb)->h_source, default_modem_addr, ETH_ALEN);
+#endif
+
+fix_dest:
+#ifdef QUECTEL_BRIDGE_MODE
+{
+	struct qmi_wwan_state *info = (void *)&dev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+	bridge_mode_rx_fixup(pQmapDev, dev->net, skb);
+}
+#else
+	memcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);
+#endif
+
+	return 1;
+}
+
+#if defined(QUECTEL_WWAN_QMAP)
+static struct sk_buff *qmap_qmi_wwan_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags) {
+	struct qmi_wwan_state *info = (void *)&dev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+	struct qmap_hdr *qhdr;
+
+	if (unlikely(pQmapDev == NULL)) {
+		goto drop_skb;
+	} else if (unlikely(pQmapDev->qmap_mode && !pQmapDev->link_state)) {
+		dev_dbg(&dev->net->dev, "link_state 0x%x, drop skb, len = %u\n", pQmapDev->link_state, skb->len);
+		goto drop_skb;
+	} else if (pQmapDev->qmap_mode == 0) {
+		skb = qmi_wwan_tx_fixup(dev, skb, flags);
+	}
+	else if (pQmapDev->qmap_mode > 1) {
+		if (likely(skb)) {	
+			qhdr = (struct qmap_hdr *)skb->data;
+			if ((qhdr->mux_id&0xF0) != 0x80 || ((be16_to_cpu(qhdr->pkt_len) + sizeof(struct qmap_hdr)) != skb->len)) {
+				goto drop_skb;
+			}
+		}
+	}
+	else {
+		if (likely(skb)) {
+			skb = qmi_wwan_tx_fixup(dev, skb, flags);
+
+			if (skb) {
+				add_qhdr(skb, QUECTEL_QMAP_MUX_ID);
+			}
+			else {
+				return NULL;
+			}
+		}
+	}
+
+	if (skb && (dev->driver_info->flags&FLAG_MULTI_PACKET)) {
+		usbnet_set_skb_tx_stats(skb, 1, 0);
+ 	}
+
+
+	return skb;
+drop_skb:
+	dev_kfree_skb_any (skb);
+	return NULL;
+}
+
+static int qmap_qmi_wwan_rx_fixup(struct usbnet *dev, struct sk_buff *skb_in)
+{
+	struct qmi_wwan_state *info = (void *)&dev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+	unsigned headroom = 0;
+	const unsigned need_headroot = ETH_HLEN;
+	struct sk_buff *qmap_skb;
+		
+	if (pQmapDev->qmap_mode == 0)
+		return qmi_wwan_rx_fixup(dev, skb_in);
+
+	headroom = skb_headroom(skb_in);
+
+	while (skb_in->len > sizeof(struct qmap_hdr)) {
+		struct qmap_hdr *qhdr = (struct qmap_hdr *)skb_in->data;
+		struct net_device *qmap_net;
+		int pkt_len = be16_to_cpu(qhdr->pkt_len);
+		int skb_len;
+		__be16 protocol;
+		int mux_id;
+
+		skb_len = pkt_len - (qhdr->cd_rsvd_pad&0x3F);
+		if (skb_len > 1500) {
+			dev_info(&dev->net->dev, "drop skb_len=%x larger than 1500\n", skb_len);
+			goto error_pkt;
+		}
+
+		if (skb_in->len < (pkt_len + sizeof(struct qmap_hdr))) {
+			dev_info(&dev->net->dev, "drop qmap unknow pkt, len=%d, pkt_len=%d\n", skb_in->len, pkt_len);
+			goto error_pkt;
+		}
+
+		if (qhdr->cd_rsvd_pad & 0x80) {
+			dev_info(&dev->net->dev, "skip qmap command packet %x\n", qhdr->cd_rsvd_pad);
+			goto skip_pkt;
+		}
+
+		switch (skb_in->data[sizeof(struct qmap_hdr)] & 0xf0) {
+			case 0x40:
+				protocol = htons(ETH_P_IP);
+			break;
+			case 0x60:
+				protocol = htons(ETH_P_IPV6);
+			break;
+			default:
+				dev_info(&dev->net->dev, "unknow skb->protocol %02x\n", skb_in->data[sizeof(struct qmap_hdr)]);
+				goto error_pkt;
+		}
+		
+		mux_id = qhdr->mux_id - QUECTEL_QMAP_MUX_ID;
+		if (mux_id >= pQmapDev->qmap_mode) {
+			dev_info(&dev->net->dev, "drop qmap unknow mux_id %x\n", qhdr->mux_id);
+			goto error_pkt;
+		}
+
+		qmap_net = pQmapDev->mpQmapNetDev[mux_id];
+
+		if (qmap_net == NULL) {
+			dev_info(&dev->net->dev, "drop qmap unknow mux_id %x\n", qhdr->mux_id);
+			goto skip_pkt;
+		}
+
+		if (headroom >= need_headroot) {
+			qmap_skb = skb_clone(skb_in, GFP_ATOMIC);
+			if (qmap_skb) {
+				qmap_skb->dev = qmap_net;
+				skb_pull(qmap_skb, sizeof(struct qmap_hdr));
+				skb_trim(qmap_skb, skb_len);
+			}
+			headroom = (qhdr->cd_rsvd_pad&0x3F);
+		}
+		else {	
+			qmap_skb = netdev_alloc_skb(qmap_net, need_headroot + skb_len);
+			if (qmap_skb) {
+				skb_reserve(qmap_skb, need_headroot);
+				skb_put(qmap_skb, skb_len);
+				memcpy(qmap_skb->data, skb_in->data + sizeof(struct qmap_hdr), skb_len);
+			}
+			headroom = pkt_len;
+		}		
+
+		if (qmap_skb == NULL) {
+			dev_info(&dev->net->dev, "fail to alloc skb, pkt_len = %d\n", skb_len);
+			return 0;
+		}
+
+		skb_push(qmap_skb, ETH_HLEN);
+		skb_reset_mac_header(qmap_skb);
+		memcpy(eth_hdr(qmap_skb)->h_source, default_modem_addr, ETH_ALEN);
+		memcpy(eth_hdr(qmap_skb)->h_dest, qmap_net->dev_addr, ETH_ALEN);
+		eth_hdr(qmap_skb)->h_proto =  protocol;
+#ifdef QUECTEL_BRIDGE_MODE
+		bridge_mode_rx_fixup(pQmapDev, qmap_net, qmap_skb);
+#endif
+
+		if (qmap_net != dev->net) {
+			qmap_net->stats.rx_packets++;
+			qmap_net->stats.rx_bytes += qmap_skb->len;
+		}
+		
+		skb_queue_tail(&pQmapDev->skb_chain, qmap_skb);
+
+skip_pkt:
+		skb_pull(skb_in, pkt_len + sizeof(struct qmap_hdr));
+	}
+
+	while ((qmap_skb = skb_dequeue (&pQmapDev->skb_chain))) {
+		if (qmap_skb->dev != dev->net) {
+			qmap_skb->protocol = eth_type_trans (qmap_skb, qmap_skb->dev);
+			netif_rx(qmap_skb);
+		}
+		else {
+			qmap_skb->protocol = 0;
+			usbnet_skb_return(dev, qmap_skb);
+		}
+	}
+
+error_pkt:
+    return 0;
+}
+#endif
+
+/* very simplistic detection of IPv4 or IPv6 headers */
+static bool possibly_iphdr(const char *data)
+{
+	return (data[0] & 0xd0) == 0x40;
+}
+
+/* disallow addresses which may be confused with IP headers */
+static int qmi_wwan_mac_addr(struct net_device *dev, void *p)
+{
+	int ret;
+	struct sockaddr *addr = p;
+
+	ret = eth_prepare_mac_addr_change(dev, p);
+	if (ret < 0)
+		return ret;
+	if (possibly_iphdr(addr->sa_data))
+		return -EADDRNOTAVAIL;
+	eth_commit_mac_addr_change(dev, p);
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION( 4,10,0 )) //bc1f44709cf27fb2a5766cadafe7e2ad5e9cb221
+static void (*_usbnet_get_stats64)(struct net_device *net, struct rtnl_link_stats64 *stats);
+
+static void qmi_wwan_get_stats64(struct net_device *net, struct rtnl_link_stats64 *stats) {
+	if (_usbnet_get_stats64) ////c8b5d129ee293bcf972e7279ac996bb8a138505c
+		return _usbnet_get_stats64(net, stats);
+	
+	netdev_stats_to_stats64(stats, &net->stats);
+}
+#else
+static struct rtnl_link_stats64 * (*_usbnet_get_stats64)(struct net_device *net, struct rtnl_link_stats64 *stats);
+
+static struct rtnl_link_stats64 * qmi_wwan_get_stats64(struct net_device *net, struct rtnl_link_stats64 *stats) {
+	if (_usbnet_get_stats64)
+		return _usbnet_get_stats64(net, stats);
+	
+	netdev_stats_to_stats64(stats, &net->stats);
+	return stats;
+}
+#endif
+
+static netdev_tx_t qmi_wwan_start_xmit (struct sk_buff *skb,
+				     struct net_device *net) 
+{
+	struct usbnet * usbnetdev = netdev_priv( net );
+	struct qmi_wwan_state *info = (void *)&usbnetdev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+	int retval;
+
+	retval = usbnet_start_xmit(skb, net);
+
+	if (netif_queue_stopped(net) && pQmapDev && pQmapDev->use_rmnet_usb) {
+		int i;
+		
+		for (i = 0; i < pQmapDev->qmap_mode; i++) {
+			struct net_device *qmap_net = pQmapDev->mpQmapNetDev[i];
+			if (qmap_net) {
+				netif_stop_queue(qmap_net);
+			}
+		}
+	}
+
+	return retval;
+}
+
+static const struct net_device_ops qmi_wwan_netdev_ops = {
+	.ndo_open		= usbnet_open,
+	.ndo_stop		= usbnet_stop,
+	.ndo_start_xmit		= qmi_wwan_start_xmit,
+	.ndo_tx_timeout		= usbnet_tx_timeout,
+	.ndo_change_mtu		= usbnet_change_mtu,
+	.ndo_get_stats64	= qmi_wwan_get_stats64,
+	.ndo_set_mac_address	= qmi_wwan_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+#if defined(QUECTEL_WWAN_QMAP)// && defined(CONFIG_ANDROID)
+	.ndo_do_ioctl = qmap_ndo_do_ioctl,
+#endif
+};
+
+static void ql_net_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
+{
+	/* Inherit standard device info */
+	usbnet_get_drvinfo(net, info);
+	strlcpy(info->driver, driver_name, sizeof(info->driver));
+	strlcpy(info->version, VERSION_NUMBER, sizeof(info->version));
+}
+
+static struct ethtool_ops ql_net_ethtool_ops;
+
+/* using a counter to merge subdriver requests with our own into a
+ * combined state
+ */
+static int qmi_wwan_manage_power(struct usbnet *dev, int on)
+{
+	struct qmi_wwan_state *info = (void *)&dev->data;
+	int rv;
+
+	dev_dbg(&dev->intf->dev, "%s() pmcount=%d, on=%d\n", __func__,
+		atomic_read(&info->pmcount), on);
+
+	if ((on && atomic_add_return(1, &info->pmcount) == 1) ||
+	    (!on && atomic_dec_and_test(&info->pmcount))) {
+		/* need autopm_get/put here to ensure the usbcore sees
+		 * the new value
+		 */
+		rv = usb_autopm_get_interface(dev->intf);
+		dev->intf->needs_remote_wakeup = on;
+		if (!rv)
+			usb_autopm_put_interface(dev->intf);
+	}
+	return 0;
+}
+
+static int qmi_wwan_cdc_wdm_manage_power(struct usb_interface *intf, int on)
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+
+	/* can be called while disconnecting */
+	if (!dev)
+		return 0;
+	return qmi_wwan_manage_power(dev, on);
+}
+
+/* collect all three endpoints and register subdriver */
+static int qmi_wwan_register_subdriver(struct usbnet *dev)
+{
+	int rv;
+	struct usb_driver *subdriver = NULL;
+	struct qmi_wwan_state *info = (void *)&dev->data;
+
+	/* collect bulk endpoints */
+	rv = usbnet_get_endpoints(dev, info->data);
+	if (rv < 0)
+		goto err;
+
+	/* update status endpoint if separate control interface */
+	if (info->control != info->data)
+		dev->status = &info->control->cur_altsetting->endpoint[0];
+
+	/* require interrupt endpoint for subdriver */
+	if (!dev->status) {
+		rv = -EINVAL;
+		goto err;
+	}
+
+	/* for subdriver power management */
+	atomic_set(&info->pmcount, 0);
+
+	/* register subdriver */
+	subdriver = usb_cdc_wdm_register(info->control, &dev->status->desc,
+					 4096, &qmi_wwan_cdc_wdm_manage_power);
+	if (IS_ERR(subdriver)) {
+		dev_err(&info->control->dev, "subdriver registration failed\n");
+		rv = PTR_ERR(subdriver);
+		goto err;
+	}
+
+	/* prevent usbnet from using status endpoint */
+	dev->status = NULL;
+
+	/* save subdriver struct for suspend/resume wrappers */
+	info->subdriver = subdriver;
+
+err:
+	return rv;
+}
+
+static int qmi_wwan_bind(struct usbnet *dev, struct usb_interface *intf)
+{
+	int status = -1;
+	struct usb_driver *driver = driver_of(intf);
+	struct qmi_wwan_state *info = (void *)&dev->data;
+
+	BUILD_BUG_ON((sizeof(((struct usbnet *)0)->data) <
+		      sizeof(struct qmi_wwan_state)));
+
+	/* set up initial state */
+	info->control = intf;
+	info->data = intf;
+
+	status = qmi_wwan_register_subdriver(dev);
+	if (status < 0 && info->control != info->data) {
+		usb_set_intfdata(info->data, NULL);
+		usb_driver_release_interface(driver, info->data);
+	}
+
+	/* Never use the same address on both ends of the link, even
+	 * if the buggy firmware told us to.
+	 */
+	if (ether_addr_equal(dev->net->dev_addr, default_modem_addr))
+		eth_hw_addr_random(dev->net);
+
+	/* make MAC addr easily distinguishable from an IP header */
+	if (possibly_iphdr(dev->net->dev_addr)) {
+		dev->net->dev_addr[0] |= 0x02;	/* set local assignment bit */
+		dev->net->dev_addr[0] &= 0xbf;	/* clear "IP" bit */
+	}
+	if (!_usbnet_get_stats64)
+		_usbnet_get_stats64 = dev->net->netdev_ops->ndo_get_stats64;
+	dev->net->netdev_ops = &qmi_wwan_netdev_ops;
+
+	ql_net_ethtool_ops = *dev->net->ethtool_ops;
+	ql_net_ethtool_ops.get_drvinfo = ql_net_get_drvinfo;
+	dev->net->ethtool_ops = &ql_net_ethtool_ops;
+
+#if 1 //Added by Quectel
+	if (dev->driver_info->flags & FLAG_NOARP) {
+		int ret;
+		char buf[32] = "Module";
+
+		ret = usb_string(dev->udev, dev->udev->descriptor.iProduct, buf, sizeof(buf));
+		if (ret > 0) {
+			buf[ret] = '\0';
+		}
+
+		dev_info(&intf->dev, "Quectel %s work on RawIP mode\n", buf);
+		dev->net->flags |= IFF_NOARP;
+		dev->net->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);
+
+		usb_control_msg(
+			interface_to_usbdev(intf),
+			usb_sndctrlpipe(interface_to_usbdev(intf), 0),
+			0x22, //USB_CDC_REQ_SET_CONTROL_LINE_STATE
+			0x21, //USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE
+			1, //active CDC DTR
+			intf->cur_altsetting->desc.bInterfaceNumber,
+			NULL, 0, 100);
+	}
+
+	//to advoid module report mtu 1460, but rx 1500 bytes IP packets, and cause the customer's system crash
+	//next setting can make usbnet.c:usbnet_change_mtu() do not modify rx_urb_size according to hard mtu
+	dev->rx_urb_size = ETH_DATA_LEN + ETH_HLEN + 6;
+
+#if defined(QUECTEL_WWAN_QMAP)
+	if (qmap_mode > QUECTEL_WWAN_QMAP)
+		qmap_mode = QUECTEL_WWAN_QMAP;
+
+	if (!status)
+	{
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)kzalloc(sizeof(sQmiWwanQmap), GFP_KERNEL);
+
+		if (pQmapDev == NULL)
+			return -ENODEV;
+
+#ifdef QUECTEL_BRIDGE_MODE
+		pQmapDev->bridge_mode = bridge_mode;
+#endif
+		pQmapDev->mpNetDev = dev;
+		pQmapDev->link_state = 1;
+		//on OpenWrt, if set rmnet_usb0.1 as WAN, '/sbin/netifd' will auto create VLAN for rmnet_usb0
+		dev->net->features |= (NETIF_F_VLAN_CHALLENGED);
+
+		skb_queue_head_init(&pQmapDev->skb_chain);
+
+		if (dev->driver_info->flags & FLAG_NOARP)
+		{
+			int idProduct = le16_to_cpu(dev->udev->descriptor.idProduct);
+			int lte_a = (idProduct == 0x0306 || idProduct == 0x0512 || idProduct == 0x0620 || idProduct == 0x0800);
+
+			pQmapDev->qmap_mode = qmap_mode;
+			if (lte_a || dev->udev->speed >= USB_SPEED_SUPER) {
+				if (pQmapDev->qmap_mode == 0) {
+					pQmapDev->qmap_mode = 1; //force use QMAP
+					if(qmap_mode == 0)
+						qmap_mode = 1; //old quectel-CM only check sys/module/wwan0/parameters/qmap_mode
+				}
+			}
+
+			if (pQmapDev->qmap_mode) {
+				pQmapDev->qmap_version = 5;
+				pQmapDev->qmap_size = (dev->udev->speed >= USB_SPEED_SUPER) ? 16*1024 : 4*1024;
+				
+				switch (idProduct) {
+					case 0x0800:
+						pQmapDev->qmap_version = 9;
+						pQmapDev->qmap_size = 31*1024;
+					break;
+					default:
+					break;
+				}
+
+				dev->rx_urb_size = pQmapDev->qmap_size;
+				//for these modules, if send pakcet before qmi_start_network, or cause host PC crash, or cause modules crash
+				if (lte_a || dev->udev->speed >= USB_SPEED_SUPER)
+					pQmapDev->link_state = 0;
+			}
+
+#if defined(QUECTEL_UL_DATA_AGG)
+			if (pQmapDev->qmap_mode) {
+				struct tx_agg_ctx *ctx = &pQmapDev->tx_ctx;
+				ctx->ul_data_aggregation_max_datagrams = 1;
+				ctx->ul_data_aggregation_max_size = 1500;
+			}
+#endif
+
+			if (pQmapDev->qmap_mode == 0) {
+				pQmapDev->driver_info = *dev->driver_info;
+				pQmapDev->driver_info.flags &= ~(FLAG_MULTI_PACKET); //see usbnet.c rx_process()
+				dev->driver_info = &pQmapDev->driver_info;
+			}
+		}
+
+		info->unused = (unsigned long)pQmapDev;
+		dev->net->sysfs_groups[0] = &qmi_wwan_sysfs_attr_group;
+
+		dev_info(&intf->dev, "rx_urb_size = %zd\n", dev->rx_urb_size);
+	}
+#endif
+#endif
+
+	return status;
+}
+
+static void qmi_wwan_unbind(struct usbnet *dev, struct usb_interface *intf)
+{
+	struct qmi_wwan_state *info = (void *)&dev->data;
+	struct usb_driver *driver = driver_of(intf);
+	struct usb_interface *other;
+
+	if (dev->udev && dev->udev->state == USB_STATE_CONFIGURED) {
+		usb_control_msg(
+			interface_to_usbdev(intf),
+			usb_sndctrlpipe(interface_to_usbdev(intf), 0),
+			0x22, //USB_CDC_REQ_SET_CONTROL_LINE_STATE
+			0x21, //USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE
+			0, //deactive CDC DTR
+			intf->cur_altsetting->desc.bInterfaceNumber,
+			NULL, 0, 100);
+	}
+
+	if (info->subdriver && info->subdriver->disconnect)
+		info->subdriver->disconnect(info->control);
+
+	/* allow user to unbind using either control or data */
+	if (intf == info->control)
+		other = info->data;
+	else
+		other = info->control;
+
+	/* only if not shared */
+	if (other && intf != other) {
+		usb_set_intfdata(other, NULL);
+		usb_driver_release_interface(driver, other);
+	}
+
+	info->subdriver = NULL;
+	info->data = NULL;
+	info->control = NULL;
+}
+
+/* suspend/resume wrappers calling both usbnet and the cdc-wdm
+ * subdriver if present.
+ *
+ * NOTE: cdc-wdm also supports pre/post_reset, but we cannot provide
+ * wrappers for those without adding usbnet reset support first.
+ */
+static int qmi_wwan_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+	struct qmi_wwan_state *info = (void *)&dev->data;
+	int ret;
+
+	/* Both usbnet_suspend() and subdriver->suspend() MUST return 0
+	 * in system sleep context, otherwise, the resume callback has
+	 * to recover device from previous suspend failure.
+	 */
+	ret = usbnet_suspend(intf, message);
+	if (ret < 0)
+		goto err;
+
+	if (intf == info->control && info->subdriver &&
+	    info->subdriver->suspend)
+		ret = info->subdriver->suspend(intf, message);
+	if (ret < 0)
+		usbnet_resume(intf);
+err:
+	return ret;
+}
+
+static int qmi_wwan_resume(struct usb_interface *intf)
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+	struct qmi_wwan_state *info = (void *)&dev->data;
+	int ret = 0;
+	bool callsub = (intf == info->control && info->subdriver &&
+			info->subdriver->resume);
+
+	if (callsub)
+		ret = info->subdriver->resume(intf);
+	if (ret < 0)
+		goto err;
+	ret = usbnet_resume(intf);
+	if (ret < 0 && callsub)
+		info->subdriver->suspend(intf, PMSG_SUSPEND);
+err:
+	return ret;
+}
+
+static int qmi_wwan_reset_resume(struct usb_interface *intf)
+{
+	dev_info(&intf->dev, "device do not support reset_resume\n");
+	intf->needs_binding = 1;
+	return -EOPNOTSUPP;
+}
+
+static int rmnet_usb_bind(struct usbnet *dev, struct usb_interface *intf)
+{	
+	int status = qmi_wwan_bind(dev, intf);
+
+	if (!status) {
+		struct qmi_wwan_state *info = (void *)&dev->data;
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+
+		if (pQmapDev && pQmapDev->qmap_mode) {
+			struct net_device *rmmet_usb = dev->net;
+			
+			pQmapDev->use_rmnet_usb = 1;
+			pQmapDev->rmnet_info.size = sizeof(RMNET_INFO);
+			pQmapDev->rmnet_info.rx_urb_size = pQmapDev->qmap_size;
+			pQmapDev->rmnet_info.ep_type = 2; //DATA_EP_TYPE_HSUSB
+			pQmapDev->rmnet_info.iface_id = 4;
+			pQmapDev->rmnet_info.qmap_mode = pQmapDev->qmap_mode;
+			pQmapDev->rmnet_info.qmap_version = pQmapDev->qmap_version;
+			pQmapDev->rmnet_info.dl_minimum_padding = 0;
+			
+			strcpy(rmmet_usb->name, "rmnet_usb%d");
+
+#if 0
+			rmmet_usb->header_ops = NULL; /* No header */
+			rmmet_usb->type = ARPHRD_RAWIP;
+			rmmet_usb->hard_header_len = 0;
+			rmmet_usb->addr_len = 0;
+#endif
+			rmmet_usb->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);
+			rmmet_usb->flags |= (IFF_NOARP);
+		}
+	}
+
+	return status;
+}
+
+static struct sk_buff *rmnet_usb_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
+{
+	//printk("%s skb=%p, len=%d, protocol=%x, hdr_len=%d\n", __func__, skb, skb->len, skb->protocol, skb->hdr_len);
+	if (skb->protocol != htons(ETH_P_MAP)) {
+		dev_kfree_skb_any(skb);
+		return NULL;
+	}
+
+	return skb;
+}
+
+static int rmnet_usb_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+{
+	struct net_device	*net = dev->net;
+
+	//printk("%s skb=%p, len=%d, protocol=%x, hdr_len=%d\n", __func__, skb, skb->len, skb->protocol, skb->hdr_len);
+	if (net->type == ARPHRD_ETHER && skb_headroom(skb) >= ETH_HLEN) {
+		//usbnet.c rx_process() usbnet_skb_return() eth_type_trans()
+		skb_push(skb, ETH_HLEN);
+		skb_reset_mac_header(skb);
+		memcpy(eth_hdr(skb)->h_source, default_modem_addr, ETH_ALEN);
+		memcpy(eth_hdr(skb)->h_dest, net->dev_addr, ETH_ALEN);
+		eth_hdr(skb)->h_proto = htons(ETH_P_MAP);
+
+		return 1;
+	}
+	
+	return 0;
+}
+
+static void _rmnet_usb_rx_handler(struct usbnet *dev, struct sk_buff *skb_in)
+{
+	struct qmi_wwan_state *info = (void *)&dev->data;
+	sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+	struct sk_buff *qmap_skb;
+	struct sk_buff_head skb_chain;
+	uint dl_minimum_padding = 0;
+
+	if (pQmapDev->qmap_version == 9)
+		dl_minimum_padding = pQmapDev->tx_ctx.dl_minimum_padding;
+
+	__skb_queue_head_init(&skb_chain);
+
+	while (skb_in->len > sizeof(struct qmap_hdr)) {
+		struct rmnet_map_header *map_header = (struct rmnet_map_header *)skb_in->data;
+		struct rmnet_map_v5_csum_header *ul_header = NULL;
+		size_t hdr_size = sizeof(struct rmnet_map_header);	
+		struct net_device *qmap_net;
+		int pkt_len = ntohs(map_header->pkt_len);
+		int skb_len;
+		__be16 protocol;
+		int mux_id;
+
+		if (map_header->next_hdr) {
+			ul_header = (struct rmnet_map_v5_csum_header *)(map_header + 1);
+			hdr_size += sizeof(struct rmnet_map_v5_csum_header);
+		}
+			
+		skb_len = pkt_len - (map_header->pad_len&0x3F);
+		skb_len -= dl_minimum_padding;
+		if (skb_len > 1500) {
+			dev_info(&dev->net->dev, "drop skb_len=%x larger than 1500\n", skb_len);
+			goto error_pkt;
+		}
+
+		if (skb_in->len < (pkt_len + hdr_size)) {
+			dev_info(&dev->net->dev, "drop qmap unknow pkt, len=%d, pkt_len=%d\n", skb_in->len, pkt_len);
+			goto error_pkt;
+		}
+
+		if (map_header->cd_bit) {
+			dev_info(&dev->net->dev, "skip qmap command packet\n");
+			goto skip_pkt;
+		}
+
+		switch (skb_in->data[hdr_size] & 0xf0) {
+			case 0x40:
+				protocol = htons(ETH_P_IP);
+			break;
+			case 0x60:
+				protocol = htons(ETH_P_IPV6);
+			break;
+			default:
+				dev_info(&dev->net->dev, "unknow skb->protocol %02x\n", skb_in->data[hdr_size]);
+				goto error_pkt;
+		}
+		
+		mux_id = map_header->mux_id - QUECTEL_QMAP_MUX_ID;
+		if (mux_id >= pQmapDev->qmap_mode) {
+			dev_info(&dev->net->dev, "drop qmap unknow mux_id %x\n", map_header->mux_id);
+			goto error_pkt;
+		}
+
+		qmap_net = pQmapDev->mpQmapNetDev[mux_id];
+
+		if (qmap_net == NULL) {
+			dev_info(&dev->net->dev, "drop qmap unknow mux_id %x\n", map_header->mux_id);
+			goto skip_pkt;
+		}
+
+		qmap_skb = netdev_alloc_skb(qmap_net, skb_len);
+		if (qmap_skb) {
+			skb_put(qmap_skb, skb_len);
+			memcpy(qmap_skb->data, skb_in->data + hdr_size, skb_len);
+		}
+
+		if (qmap_skb == NULL) {
+			dev_info(&dev->net->dev, "fail to alloc skb, pkt_len = %d\n", skb_len);
+			goto error_pkt;
+		}
+
+		skb_reset_transport_header(qmap_skb);
+		skb_reset_network_header(qmap_skb);
+		qmap_skb->pkt_type = PACKET_HOST;
+		skb_set_mac_header(qmap_skb, 0);
+		qmap_skb->protocol = protocol;
+
+		if (ul_header && ul_header->header_type == RMNET_MAP_HEADER_TYPE_CSUM_OFFLOAD
+			&& ul_header->csum_valid_required) {
+#if 0 //TODO
+			qmap_skb->ip_summed = CHECKSUM_UNNECESSARY;
+#endif
+		}
+
+		if (qmap_skb->dev->type == ARPHRD_ETHER) {
+			skb_push(qmap_skb, ETH_HLEN);
+			skb_reset_mac_header(qmap_skb);
+			memcpy(eth_hdr(qmap_skb)->h_source, default_modem_addr, ETH_ALEN);
+			memcpy(eth_hdr(qmap_skb)->h_dest, qmap_net->dev_addr, ETH_ALEN);
+			eth_hdr(qmap_skb)->h_proto = protocol;
+#ifdef QUECTEL_BRIDGE_MODE
+			bridge_mode_rx_fixup(pQmapDev, qmap_net, qmap_skb);
+#endif
+			__skb_pull(qmap_skb, ETH_HLEN);
+		}
+
+		rmnet_vnd_update_rx_stats(qmap_net, 1, skb_len);
+		__skb_queue_tail(&skb_chain, qmap_skb);
+
+skip_pkt:
+		skb_pull(skb_in, pkt_len + hdr_size);
+	}
+
+error_pkt:
+	while ((qmap_skb = __skb_dequeue (&skb_chain))) {
+		netif_receive_skb(qmap_skb);
+	}
+}
+
+static rx_handler_result_t rmnet_usb_rx_handler(struct sk_buff **pskb)
+{
+	struct sk_buff *skb = *pskb;
+	struct usbnet *dev;
+
+	if (!skb)
+		goto done;
+
+	//printk("%s skb=%p, protocol=%x, len=%d\n", __func__, skb, skb->protocol, skb->len);
+
+	if (skb->pkt_type == PACKET_LOOPBACK)
+		return RX_HANDLER_PASS;
+
+	if (skb->protocol != htons(ETH_P_MAP)) {
+		WARN_ON(1);
+		return RX_HANDLER_PASS;
+	}
+    /* when open hyfi function, run cm will make system crash */
+	//dev = rcu_dereference(skb->dev->rx_handler_data);
+	dev = netdev_priv(skb->dev);
+
+	if (dev == NULL) {
+		WARN_ON(1);
+		return RX_HANDLER_PASS;
+	}
+
+	_rmnet_usb_rx_handler(dev, skb);
+	consume_skb(skb);
+
+done:
+	return RX_HANDLER_CONSUMED;
+}
+
+static const struct driver_info	qmi_wwan_info = {
+	.description	= "WWAN/QMI device",
+	.flags		= FLAG_WWAN,
+	.bind		= qmi_wwan_bind,
+	.unbind		= qmi_wwan_unbind,
+	.manage_power	= qmi_wwan_manage_power,
+	.rx_fixup       = qmi_wwan_rx_fixup,
+};
+
+static const struct driver_info qmi_wwan_raw_ip_info = {
+	.description	= "WWAN/QMI device",
+	.flags		= FLAG_WWAN | FLAG_RX_ASSEMBLE | FLAG_NOARP | FLAG_SEND_ZLP | FLAG_MULTI_PACKET,
+	.bind		= qmi_wwan_bind,
+	.unbind		= qmi_wwan_unbind,
+	.manage_power	= qmi_wwan_manage_power,
+#if defined(QUECTEL_WWAN_QMAP)
+	.tx_fixup       = qmap_qmi_wwan_tx_fixup,
+	.rx_fixup       = qmap_qmi_wwan_rx_fixup,
+#else
+	.tx_fixup       = qmi_wwan_tx_fixup,
+	.rx_fixup       = qmi_wwan_rx_fixup,
+#endif
+};
+
+static const struct driver_info rmnet_usb_info = {
+	.description = "RMNET/USB device",
+	.flags		=  FLAG_NOARP | FLAG_SEND_ZLP,
+	.bind = rmnet_usb_bind,
+	.unbind = qmi_wwan_unbind,
+	.manage_power = qmi_wwan_manage_power,
+	.tx_fixup = rmnet_usb_tx_fixup,
+	.rx_fixup = rmnet_usb_rx_fixup,	
+};
+
+/* map QMI/wwan function by a fixed interface number */
+#define QMI_FIXED_INTF(vend, prod, num) \
+	USB_DEVICE_INTERFACE_NUMBER(vend, prod, num), \
+	.driver_info = (unsigned long)&qmi_wwan_info
+
+#define QMI_FIXED_RAWIP_INTF(vend, prod, num) \
+	USB_DEVICE_INTERFACE_NUMBER(vend, prod, num), \
+	.driver_info = (unsigned long)&qmi_wwan_raw_ip_info
+
+#define RMNET_USB_INTF(vend, prod, num) \
+		USB_DEVICE_INTERFACE_NUMBER(vend, prod, num), \
+		.driver_info = (unsigned long) &rmnet_usb_info
+
+static const struct usb_device_id products[] = {
+#if 1 //Added by Quectel
+	{ QMI_FIXED_INTF(0x05C6, 0x9003, 4) },  /* Quectel UC20 */
+	{ QMI_FIXED_INTF(0x05C6, 0x9215, 4) },  /* Quectel EC20 (MDM9215) */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0125, 4) },  /* Quectel EC20 (MDM9X07)/EC25/EG25 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0121, 4) },  /* Quectel EC21 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0191, 4) },  /* Quectel EG91 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0195, 4) },  /* Quectel EG95 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0306, 4) },  /* Quectel EG06/EP06/EM06 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0512, 4) },  /* Quectel EG12/EP12/EM12/EG16/EG18 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0296, 4) },  /* Quectel BG96 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0435, 4) },  /* Quectel AG35 */
+	{ QMI_FIXED_RAWIP_INTF(0x2C7C, 0x0620, 4) },  /* Quectel EG20 */
+	{ RMNET_USB_INTF(0x2C7C, 0x0800, 4) },  /* Quectel RG500 */
+#endif
+	{ }					/* END */
+};
+MODULE_DEVICE_TABLE(usb, products);
+
+static int qmi_wwan_probe(struct usb_interface *intf,
+			  const struct usb_device_id *prod)
+{
+	struct usb_device_id *id = (struct usb_device_id *)prod;
+
+	/* Workaround to enable dynamic IDs.  This disables usbnet
+	 * blacklisting functionality.  Which, if required, can be
+	 * reimplemented here by using a magic "blacklist" value
+	 * instead of 0 in the static device id table
+	 */
+	if (!id->driver_info) {
+		dev_dbg(&intf->dev, "setting defaults for dynamic device id\n");
+		id->driver_info = (unsigned long)&qmi_wwan_info;
+	}
+
+	if (intf->cur_altsetting->desc.bInterfaceClass != 0xff) {
+		dev_info(&intf->dev,  "Quectel module not qmi_wwan mode! please check 'at+qcfg=\"usbnet\"'\n");
+		return -ENODEV;
+	}
+
+	return usbnet_probe(intf, id);
+}
+
+#if defined(QUECTEL_WWAN_QMAP)
+static int qmap_qmi_wwan_probe(struct usb_interface *intf,
+			  const struct usb_device_id *prod)
+{
+	int status = qmi_wwan_probe(intf, prod);
+
+	if (!status) {
+		struct usbnet *dev = usb_get_intfdata(intf);
+		struct qmi_wwan_state *info = (void *)&dev->data;
+		sQmiWwanQmap *pQmapDev = (sQmiWwanQmap *)info->unused;
+		unsigned i;
+
+		if (!pQmapDev)
+			return status;
+
+		tasklet_init(&pQmapDev->txq, rmnet_usb_tx_wake_queue, (unsigned long)pQmapDev);
+
+		if (pQmapDev->qmap_mode == 1) {
+			pQmapDev->mpQmapNetDev[0] = dev->net;
+			if (pQmapDev->use_rmnet_usb) {
+				pQmapDev->mpQmapNetDev[0] = NULL;
+				qmap_register_device(pQmapDev, 0);
+			}
+		}
+		else if (pQmapDev->qmap_mode > 1) {
+			for (i = 0; i < pQmapDev->qmap_mode; i++) {
+				qmap_register_device(pQmapDev, i);
+			}
+		}
+
+		if (pQmapDev->use_rmnet_usb) {
+			rtnl_lock();
+			/* when open hyfi function, run cm will make system crash */
+			//netdev_rx_handler_register(dev->net, rmnet_usb_rx_handler, dev);
+			netdev_rx_handler_register(dev->net, rmnet_usb_rx_handler, NULL);
+			rtnl_unlock();
+		}
+
+		if (pQmapDev->link_state == 0) {
+			netif_carrier_off(dev->net);
+		}
+	}
+
+	return status;
+}
+
+static void qmap_qmi_wwan_disconnect(struct usb_interface *intf)
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+	struct qmi_wwan_state *info;
+	sQmiWwanQmap *pQmapDev;
+	uint i;
+
+	if (!dev)
+		return;
+
+	info = (void *)&dev->data;
+	pQmapDev = (sQmiWwanQmap *)info->unused;
+
+	if (!pQmapDev) {
+		return usbnet_disconnect(intf);
+	}
+
+	pQmapDev->link_state = 0;
+
+	if (pQmapDev->qmap_mode > 1) {
+		for (i = 0; i < pQmapDev->qmap_mode; i++) {
+			qmap_unregister_device(pQmapDev, i);
+		}
+	}
+
+	if (pQmapDev->use_rmnet_usb) {
+		qmap_unregister_device(pQmapDev, 0);
+		rtnl_lock();
+		netdev_rx_handler_unregister(dev->net);
+		rtnl_unlock();
+	}
+
+	tasklet_kill(&pQmapDev->txq);
+	
+	usbnet_disconnect(intf);
+	info->unused = 0;
+	kfree(pQmapDev);
+}
+#endif
+
+static struct usb_driver qmi_wwan_driver = {
+	.name		      = "qmi_wwan_q",
+	.id_table	      = products,
+	.probe		      = qmi_wwan_probe,
+#if defined(QUECTEL_WWAN_QMAP)
+	.probe		      = qmap_qmi_wwan_probe,
+	.disconnect	      = qmap_qmi_wwan_disconnect,
+#else
+	.probe		      = qmi_wwan_probe,
+	.disconnect	      = usbnet_disconnect,
+#endif
+	.suspend	      = qmi_wwan_suspend,
+	.resume		      =	qmi_wwan_resume,
+	.reset_resume         = qmi_wwan_reset_resume,
+	.supports_autosuspend = 1,
+	.disable_hub_initiated_lpm = 1,
+};
+
+#ifdef CONFIG_QCA_NSS_DRV
+/*
+	EXTRA_CFLAGS="-I$(STAGING_DIR)/usr/include/qca-nss-drv  $(EXTRA_CFLAGS)"
+	qsdk/qca/src/data-kernel/drivers/rmnet-nss/rmnet_nss.c 
+*/
+#include "rmnet_nss.c"
+#endif
+
+static int __init qmi_wwan_driver_init(void)
+{
+	RCU_INIT_POINTER(rmnet_nss_callbacks, NULL);
+#ifdef CONFIG_QCA_NSS_DRV
+	if (qca_nss_enabled)
+		rmnet_nss_init();
+#endif
+	return usb_register(&qmi_wwan_driver);
+}
+module_init(qmi_wwan_driver_init);
+static void __exit qmi_wwan_driver_exit(void)
+{
+#ifdef CONFIG_QCA_NSS_DRV
+	if (qca_nss_enabled)
+		rmnet_nss_exit();
+#endif
+	usb_deregister(&qmi_wwan_driver);
+}
+module_exit(qmi_wwan_driver_exit);
+
+MODULE_AUTHOR("Bjrn Mork <bjorn@mork.no>");
+MODULE_DESCRIPTION("Qualcomm MSM Interface (QMI) WWAN driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(QUECTEL_WWAN_VERSION);
diff --git a/drivers/regulator/pca9450-regulator.c b/drivers/regulator/pca9450-regulator.c
index e7408598cd79..9f47237c2203 100644
--- a/drivers/regulator/pca9450-regulator.c
+++ b/drivers/regulator/pca9450-regulator.c
@@ -18,6 +18,12 @@
 #include <linux/regulator/of_regulator.h>
 #include <linux/regulator/pca9450.h>
 
+#define PCA9450_LEVEL_TRANSLATOR_MASK 0x3
+#define PCA9450_LEVEL_TRANSLATOR_DISABLE 0x0
+#define PCA9450_LEVEL_TRANSLATOR_EN_STD_RUN 0x1
+#define PCA9450_LEVEL_TRANSLATOR_EN_RUN 0x2
+#define PCA9450_LEVEL_TRANSLATOR_FORCE_EN 0x3
+
 struct pc9450_dvs_config {
 	unsigned int run_reg; /* dvs0 */
 	unsigned int run_mask;
@@ -921,6 +927,8 @@ static int pca9450_i2c_probe(struct i2c_client *i2c,
 	struct regulator_config config = { };
 	struct pca9450 *pca9450;
 	unsigned int device_id, i;
+  int     level_translator;
+  struct device_node *np = i2c->dev.of_node;
 	int ret;
 
 	if (!i2c->irq) {
@@ -1018,6 +1026,23 @@ static int pca9450_i2c_probe(struct i2c_client *i2c,
 		return ret;
 	}
 
+	if (of_find_property(np, "level-trans-force-en", NULL)) {
+		level_translator = PCA9450_LEVEL_TRANSLATOR_FORCE_EN;
+	}else if (of_find_property(np, "level-trans-run-mode", NULL)) {
+		level_translator = PCA9450_LEVEL_TRANSLATOR_EN_RUN;
+	}else if (of_find_property(np, "level-trans-std-run-mode", NULL)) {
+		level_translator = PCA9450_LEVEL_TRANSLATOR_EN_STD_RUN;
+	}else if (of_find_property(np, "level-trans-force-dis", NULL)) {
+		level_translator = PCA9450_LEVEL_TRANSLATOR_DISABLE;
+	}
+	ret = regmap_update_bits(pca9450->regmap, PCA9450_REG_CONFIG2, PCA9450_LEVEL_TRANSLATOR_MASK, level_translator);
+	if (ret < 0) {
+		dev_err(pca9450->dev, "PCA9450 Set update bits faild\n");
+		return ret;
+	}
+
+	dev_info(pca9450->dev, "Update PCA9450 Level translator bits %d\n", level_translator);
+
 	/* Clear PRESET_EN bit in BUCK123_DVS to use DVS registers */
 	ret = regmap_clear_bits(pca9450->regmap, PCA9450_REG_BUCK123_DVS,
 				BUCK123_PRESET_EN);
diff --git a/drivers/usb/misc/Kconfig b/drivers/usb/misc/Kconfig
index 8f1144359012..8cc355fcf13e 100644
--- a/drivers/usb/misc/Kconfig
+++ b/drivers/usb/misc/Kconfig
@@ -255,6 +255,12 @@ config USB_HSIC_USB4604
 	help
 	  This option enables support for SMSC USB4604 HSIC to USB 2.0 Driver.
 
+config USB_HSIC_USB5744
+	tristate "USB5744 HSIC to USB20 Driver"
+	depends on I2C
+	help
+	  This option enables support for SMSC USB5744 HSIC to USB 2.0 Driver.
+
 config USB_LINK_LAYER_TEST
 	tristate "USB Link Layer Test driver"
 	help
diff --git a/drivers/usb/misc/Makefile b/drivers/usb/misc/Makefile
index 5f4e598573ab..60a34ceffe5f 100644
--- a/drivers/usb/misc/Makefile
+++ b/drivers/usb/misc/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_USB_YUREX)			+= yurex.o
 obj-$(CONFIG_USB_HUB_USB251XB)		+= usb251xb.o
 obj-$(CONFIG_USB_HSIC_USB3503)		+= usb3503.o
 obj-$(CONFIG_USB_HSIC_USB4604)		+= usb4604.o
+obj-$(CONFIG_USB_HSIC_USB5744)    += usb5744.o
 obj-$(CONFIG_USB_CHAOSKEY)		+= chaoskey.o
 
 obj-$(CONFIG_USB_SISUSBVGA)		+= sisusbvga/
diff --git a/drivers/usb/misc/usb5744.c b/drivers/usb/misc/usb5744.c
new file mode 100644
index 000000000000..62e1c68ead8b
--- /dev/null
+++ b/drivers/usb/misc/usb5744.c
@@ -0,0 +1,152 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Driver for SMSC USB5744 USB HSIC 4-port 2.0 hub controller driver
+ * Based on usb3503 driver
+ *
+ * Copyright (c) 2012-2013 Dongjin Kim (tobetter@gmail.com)
+ * Copyright (c) 2016 Linaro Ltd.
+ */
+
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/gpio/consumer.h>
+
+enum usb5744_mode {
+	USB5744_MODE_UNKNOWN,
+	USB5744_MODE_HUB,
+	USB5744_MODE_STANDBY,
+};
+
+struct usb5744 {
+	enum usb5744_mode	mode;
+	struct device		*dev;
+	struct gpio_desc	*gpio_reset;
+};
+
+static void usb5744_reset(struct usb5744 *hub, int state)
+{
+	gpiod_set_value_cansleep(hub->gpio_reset, state);
+
+	/* Wait for i2c logic to come up */
+	if (state)
+		msleep(250);
+}
+
+static int usb5744_connect(struct usb5744 *hub)
+{
+	struct device *dev = hub->dev;
+	struct i2c_client *client = to_i2c_client(dev);
+	int err;
+	u8 connect_cmd[] = { 0xaa, 0x55, 0x00 };
+
+	gpiod_set_value(hub->gpio_reset, 1);
+	usleep_range(5, 20);
+	gpiod_set_value(hub->gpio_reset, 0);
+	msleep(5);
+
+	err = i2c_master_send(client, connect_cmd, ARRAY_SIZE(connect_cmd));
+
+	if (err < 0) {
+		usb5744_reset(hub, 0);
+		return err;
+	}
+
+	hub->mode = USB5744_MODE_HUB;
+	dev_dbg(dev, "switched to HUB mode\n");
+
+	return 0;
+}
+
+static int usb5744_switch_mode(struct usb5744 *hub, enum usb5744_mode mode)
+{
+	struct device *dev = hub->dev;
+	int err = 0;
+
+	switch (mode) {
+	case USB5744_MODE_HUB:
+		err = usb5744_connect(hub);
+		break;
+
+	case USB5744_MODE_STANDBY:
+		usb5744_reset(hub, 0);
+		dev_dbg(dev, "switched to STANDBY mode\n");
+		break;
+
+	default:
+		dev_err(dev, "unknown mode is requested\n");
+		err = -EINVAL;
+		break;
+	}
+
+	return err;
+}
+
+static int usb5744_probe(struct usb5744 *hub)
+{
+	struct device *dev = hub->dev;
+	struct device_node *np = dev->of_node;
+	struct gpio_desc *gpio;
+	u32 mode = USB5744_MODE_HUB;
+
+	gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(gpio))
+		return PTR_ERR(gpio);
+	hub->gpio_reset = gpio;
+
+	if (of_property_read_u32(np, "initial-mode", &hub->mode))
+		hub->mode = mode;
+
+	return usb5744_switch_mode(hub, hub->mode);
+}
+
+static int usb5744_i2c_probe(struct i2c_client *i2c,
+			     const struct i2c_device_id *id)
+{
+	struct usb5744 *hub;
+
+	hub = devm_kzalloc(&i2c->dev, sizeof(*hub), GFP_KERNEL);
+	if (!hub)
+		return -ENOMEM;
+
+	i2c_set_clientdata(i2c, hub);
+	hub->dev = &i2c->dev;
+
+	return usb5744_probe(hub);
+}
+
+#define usb5744_i2c_suspend NULL
+#define usb5744_i2c_resume NULL
+
+static SIMPLE_DEV_PM_OPS(usb5744_i2c_pm_ops, usb5744_i2c_suspend,
+		usb5744_i2c_resume);
+
+static const struct i2c_device_id usb5744_id[] = {
+	{ "usb5744", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, usb5744_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id usb5744_of_match[] = {
+	{ .compatible = "smsc,usb5744" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, usb5744_of_match);
+#endif
+
+static struct i2c_driver usb5744_i2c_driver = {
+	.driver = {
+		.name = "usb5744",
+		.pm = pm_ptr(&usb5744_i2c_pm_ops),
+		.of_match_table = of_match_ptr(usb5744_of_match),
+	},
+	.probe		= usb5744_i2c_probe,
+	.id_table	= usb5744_id,
+};
+module_i2c_driver(usb5744_i2c_driver);
+
+MODULE_DESCRIPTION("USB5744 USB HUB driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index 697683e3fbff..580706f6a8dc 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -246,6 +246,7 @@ static void option_instat_callback(struct urb *urb);
 
 #define QUECTEL_VENDOR_ID			0x2c7c
 /* These Quectel products use Quectel's vendor ID */
+#define QUECTEL_PRODUCT_EC20			0x9215
 #define QUECTEL_PRODUCT_EC21			0x0121
 #define QUECTEL_PRODUCT_EC25			0x0125
 #define QUECTEL_PRODUCT_EG91			0x0191
@@ -1127,6 +1128,8 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, UBLOX_PRODUCT_R6XX),
 	  .driver_info = RSVD(3) },
 	/* Quectel products using Quectel vendor ID */
+ 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, QUECTEL_PRODUCT_EC20),
+	  .driver_info = RSVD(4) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC21, 0xff, 0xff, 0xff),
 	  .driver_info = NUMEP2 },
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC21, 0xff, 0, 0) },
@@ -2163,6 +2166,7 @@ static const struct usb_device_id option_ids[] = {
 	  .driver_info = RSVD(4) | RSVD(5) },
 	{ USB_DEVICE_INTERFACE_CLASS(0x2cb7, 0x0105, 0xff),			/* Fibocom NL678 series */
 	  .driver_info = RSVD(6) },
+	{ USB_DEVICE(0x05C6, 0x9003) }, /* Quectel UC20 */
 	{ USB_DEVICE_INTERFACE_CLASS(0x2cb7, 0x0106, 0xff) },			/* Fibocom MA510 (ECM mode w/ diag intf.) */
 	{ USB_DEVICE_INTERFACE_CLASS(0x2cb7, 0x010a, 0xff) },			/* Fibocom MA510 (ECM mode) */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2cb7, 0x010b, 0xff, 0xff, 0x30) },	/* Fibocom FG150 Diag */
@@ -2209,6 +2213,7 @@ static struct usb_serial_driver option_1port_device = {
 #ifdef CONFIG_PM
 	.suspend           = usb_wwan_suspend,
 	.resume            = usb_wwan_resume,
+ 	.reset_resume	     = usb_wwan_resume,
 #endif
 };
 
@@ -2252,6 +2257,41 @@ static int option_probe(struct usb_serial *serial,
 	if (device_flags & NUMEP2 && iface_desc->bNumEndpoints != 2)
 		return -ENODEV;
 
+  /* Added by Quectel */
+	/*Quectel EC20's interface 4 can be used as USB network device*/
+	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) &&
+	serial->dev->descriptor.idProduct == cpu_to_le16(0x9215)
+	&& serial->interface->cur_altsetting->desc.bInterfaceNumber >= 4)
+		return -ENODEV;
+	/*Quectel EC25's interface 4 can be used as USB network device*/
+	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x2c7c) &&
+	serial->dev->descriptor.idProduct == cpu_to_le16(0x0125)
+	&& serial->interface->cur_altsetting->desc.bInterfaceNumber >= 4)
+		return -ENODEV;
+
+	/* For Quectel EC20 usb auto suspend */
+	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) &&
+	serial->dev->descriptor.idProduct == cpu_to_le16(0x9215)) {
+		pm_runtime_set_autosuspend_delay(&serial->dev->dev, 3000);
+		usb_enable_autosuspend(serial->dev);
+	}
+	/* For Quectel EC25 usb auto suspend */
+	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x2c7c) &&
+	serial->dev->descriptor.idProduct == cpu_to_le16(0x0125)) {
+		pm_runtime_set_autosuspend_delay(&serial->dev->dev, 3000);
+		usb_enable_autosuspend(serial->dev);
+	}
+	/* For Quectel EC20 usb remote wakeup */
+	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) &&
+	serial->dev->descriptor.idProduct == cpu_to_le16(0x9215)) {
+	  device_init_wakeup(&serial->dev->dev, 1); 
+	}
+	/* For Quectel EC25 usb remote wakeup */
+	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x2c7c) &&
+	serial->dev->descriptor.idProduct == cpu_to_le16(0x0125)) {
+	  device_init_wakeup(&serial->dev->dev, 1); 
+	}
+
 	/* Store the device flags so we can use them during attach. */
 	usb_set_serial_data(serial, (void *)device_flags);
 
diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c
index 586ef5551e76..3dc4a78f1e3d 100644
--- a/drivers/usb/serial/qcserial.c
+++ b/drivers/usb/serial/qcserial.c
@@ -88,7 +88,6 @@ static const struct usb_device_id id_table[] = {
 	{USB_DEVICE(0x03f0, 0x241d)},	/* HP Gobi 2000 QDL device (VP412) */
 	{USB_DEVICE(0x03f0, 0x251d)},	/* HP Gobi 2000 Modem device (VP412) */
 	{USB_DEVICE(0x05c6, 0x9214)},	/* Acer Gobi 2000 QDL device (VP413) */
-	{USB_DEVICE(0x05c6, 0x9215)},	/* Acer Gobi 2000 Modem device (VP413) */
 	{USB_DEVICE(0x05c6, 0x9264)},	/* Asus Gobi 2000 QDL device (VR305) */
 	{USB_DEVICE(0x05c6, 0x9265)},	/* Asus Gobi 2000 Modem device (VR305) */
 	{USB_DEVICE(0x05c6, 0x9234)},	/* Top Global Gobi 2000 QDL device (VR306) */
diff --git a/drivers/usb/serial/usb_wwan.c b/drivers/usb/serial/usb_wwan.c
index f21f25a8cf6f..e04b8938e075 100644
--- a/drivers/usb/serial/usb_wwan.c
+++ b/drivers/usb/serial/usb_wwan.c
@@ -434,6 +434,18 @@ static struct urb *usb_wwan_setup_urb(struct usb_serial_port *port,
 
 	if (intfdata->use_zlp && dir == USB_DIR_OUT)
 		urb->transfer_flags |= URB_ZERO_PACKET;
+  //Added by Quectel for zero packet
+	if (dir == USB_DIR_OUT) {
+		struct usb_device_descriptor *desc = &serial->dev->descriptor;
+		if (desc->idVendor == cpu_to_le16(0x05C6) && desc->idProduct == cpu_to_le16(0x9090))
+			urb->transfer_flags |= URB_ZERO_PACKET;
+		if (desc->idVendor == cpu_to_le16(0x05C6) && desc->idProduct == cpu_to_le16(0x9003))
+			urb->transfer_flags |= URB_ZERO_PACKET;
+		if (desc->idVendor == cpu_to_le16(0x05C6) && desc->idProduct == cpu_to_le16(0x9215))
+			urb->transfer_flags |= URB_ZERO_PACKET;
+		if (desc->idVendor == cpu_to_le16(0x2C7C))
+			urb->transfer_flags |= URB_ZERO_PACKET;
+	}
 
 	return urb;
 }
diff --git a/drivers/usb/typec/tcpm/tcpci.c b/drivers/usb/typec/tcpm/tcpci.c
index 8c3848bb540c..3b08184be180 100644
--- a/drivers/usb/typec/tcpm/tcpci.c
+++ b/drivers/usb/typec/tcpm/tcpci.c
@@ -666,6 +666,11 @@ static int tcpci_init(struct tcpc_dev *tcpc)
 	if (ret < 0)
 		return ret;
 
+	/* Set VBUS_VOLTAGE_ALARM_HI threshold 800*25mV = 20000mV */
+	ret = tcpci_write16(tcpci, TCPC_VBUS_VOLTAGE_ALARM_HI_CFG, 920);
+	if (ret < 0)
+		return ret;
+
 	/* Enable Vbus detection */
 	ret = regmap_write(tcpci->regmap, TCPC_COMMAND,
 			   TCPC_CMD_ENABLE_VBUS_DETECT);
diff --git a/include/linux/iio/imu/mpu.h b/include/linux/iio/imu/mpu.h
new file mode 100644
index 000000000000..0e294aff8c50
--- /dev/null
+++ b/include/linux/iio/imu/mpu.h
@@ -0,0 +1,125 @@
+/*
+* Copyright (C) 2012-2017 InvenSense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+
+#ifndef __MPU_H_
+#define __MPU_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#endif
+
+enum secondary_slave_type {
+	SECONDARY_SLAVE_TYPE_NONE,
+	SECONDARY_SLAVE_TYPE_ACCEL,
+	SECONDARY_SLAVE_TYPE_COMPASS,
+	SECONDARY_SLAVE_TYPE_PRESSURE,
+	SECONDARY_SLAVE_TYPE_ALS,
+
+	SECONDARY_SLAVE_TYPE_TYPES
+};
+
+enum ext_slave_id {
+	ID_INVALID = 0,
+	GYRO_ID_MPU3050,
+	GYRO_ID_MPU6050A2,
+	GYRO_ID_MPU6050B1,
+	GYRO_ID_MPU6050B1_NO_ACCEL,
+	GYRO_ID_ITG3500,
+
+	ACCEL_ID_LIS331,
+	ACCEL_ID_LSM303DLX,
+	ACCEL_ID_LIS3DH,
+	ACCEL_ID_KXSD9,
+	ACCEL_ID_KXTF9,
+	ACCEL_ID_BMA150,
+	ACCEL_ID_BMA222,
+	ACCEL_ID_BMA250,
+	ACCEL_ID_ADXL34X,
+	ACCEL_ID_MMA8450,
+	ACCEL_ID_MMA845X,
+	ACCEL_ID_MPU6050,
+
+	COMPASS_ID_AK8963,
+	COMPASS_ID_AK8975,
+	COMPASS_ID_AK8972,
+	COMPASS_ID_AMI30X,
+	COMPASS_ID_AMI306,
+	COMPASS_ID_YAS529,
+	COMPASS_ID_YAS530,
+	COMPASS_ID_HMC5883,
+	COMPASS_ID_LSM303DLH,
+	COMPASS_ID_LSM303DLM,
+	COMPASS_ID_MMC314X,
+	COMPASS_ID_HSCDTD002B,
+	COMPASS_ID_HSCDTD004A,
+	COMPASS_ID_MLX90399,
+	COMPASS_ID_AK09911,
+	COMPASS_ID_AK09912,
+	COMPASS_ID_AK09915,
+	COMPASS_ID_AK09916,
+
+	PRESSURE_ID_BMP085,
+	PRESSURE_ID_BMP280,
+
+	ALS_ID_APDS_9900,
+	ALS_ID_APDS_9930,
+	ALS_ID_TSL_2772,
+};
+
+#define INV_PROD_KEY(ver, rev) (ver * 100 + rev)
+/**
+ * struct mpu_platform_data - Platform data for the mpu driver
+ * @int_config:		Bits [7:3] of the int config register.
+ * @level_shifter:	0: VLogic, 1: VDD
+ * @orientation:	Orientation matrix of the gyroscope
+ * @sec_slave_type:     secondary slave device type, can be compass, accel, etc
+ * @sec_slave_id:       id of the secondary slave device
+ * @secondary_i2c_address: secondary device's i2c address
+ * @secondary_orientation: secondary device's orientation matrix
+ * @aux_slave_type: auxiliary slave. Another slave device type
+ * @aux_slave_id: auxiliary slave ID.
+ * @aux_i2c_addr: auxiliary device I2C address.
+ * @read_only_slave_type: read only slave type.
+ * @read_only_slave_id: read only slave device ID.
+ * @read_only_i2c_addr: read only slave device address.
+ *
+ * Contains platform specific information on how to configure the MPU3050 to
+ * work on this platform.  The orientation matricies are 3x3 rotation matricies
+ * that are applied to the data to rotate from the mounting orientation to the
+ * platform orientation.  The values must be one of 0, 1, or -1 and each row and
+ * column should have exactly 1 non-zero value.
+ */
+struct mpu_platform_data {
+	__u8 int_config;
+	__u8 level_shifter;
+	__s8 orientation[9];
+	enum secondary_slave_type sec_slave_type;
+	enum ext_slave_id sec_slave_id;
+	__u16 secondary_i2c_addr;
+	__s8 secondary_orientation[9];
+	enum secondary_slave_type aux_slave_type;
+	enum ext_slave_id aux_slave_id;
+	__u16 aux_i2c_addr;
+	enum secondary_slave_type read_only_slave_type;
+	enum ext_slave_id read_only_slave_id;
+	__u16 read_only_i2c_addr;
+#ifdef CONFIG_OF
+	int (*power_on)(struct mpu_platform_data *);
+	int (*power_off)(struct mpu_platform_data *);
+	struct regulator *vdd_ana;
+	struct regulator *vdd_i2c;
+#endif
+};
+
+#endif	/* __MPU_H_ */
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index a78f28ea2bde..860f2c318c99 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -210,6 +210,7 @@ config SND_SOC_ALL_CODECS
 	imply SND_SOC_TAS5086
 	imply SND_SOC_TAS571X
 	imply SND_SOC_TAS5720
+	imply SND_SOC_TAS5760
 	imply SND_SOC_TAS6424
 	imply SND_SOC_TDA7419
 	imply SND_SOC_TFA9879
@@ -1424,6 +1425,13 @@ config SND_SOC_TAS5720
 	  Enable support for Texas Instruments TAS5720L/M high-efficiency mono
 	  Class-D audio power amplifiers.
 
+config SND_SOC_TAS5760
+	tristate "Texas Instruments TAS5760 Audio amplifier"
+	depends on I2C
+	help
+	  Enable support for Texas Instruments TAS5760 high-efficiency
+	  Class-D audio power amplifiers.
+
 config SND_SOC_TAS6424
 	tristate "Texas Instruments TAS6424 Quad-Channel Audio amplifier"
 	depends on I2C
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index a6adb49e222f..b71285048b19 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -227,6 +227,7 @@ snd-soc-sti-sas-objs := sti-sas.o
 snd-soc-tas5086-objs := tas5086.o
 snd-soc-tas571x-objs := tas571x.o
 snd-soc-tas5720-objs := tas5720.o
+snd-soc-tas5760-objs := tas5760.o
 snd-soc-tas6424-objs := tas6424.o
 snd-soc-tda7419-objs := tda7419.o
 snd-soc-tas2770-objs := tas2770.o
@@ -559,6 +560,7 @@ obj-$(CONFIG_SND_SOC_TAS2764)	+= snd-soc-tas2764.o
 obj-$(CONFIG_SND_SOC_TAS5086)	+= snd-soc-tas5086.o
 obj-$(CONFIG_SND_SOC_TAS571X)	+= snd-soc-tas571x.o
 obj-$(CONFIG_SND_SOC_TAS5720)	+= snd-soc-tas5720.o
+obj-$(CONFIG_SND_SOC_TAS5760) += snd-soc-tas5760.o
 obj-$(CONFIG_SND_SOC_TAS6424)	+= snd-soc-tas6424.o
 obj-$(CONFIG_SND_SOC_TDA7419)	+= snd-soc-tda7419.o
 obj-$(CONFIG_SND_SOC_TAS2770) += snd-soc-tas2770.o
diff --git a/sound/soc/codecs/tas5760.c b/sound/soc/codecs/tas5760.c
new file mode 100644
index 000000000000..8bf0dbd2eada
--- /dev/null
+++ b/sound/soc/codecs/tas5760.c
@@ -0,0 +1,469 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+* tas5760.c - ALSA SoC Texas Instruments TAS5760 Mono Audio Amplifier
+*
+*/
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/regulator/consumer.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/tlv.h>
+
+#include "tas5760.h"
+
+#define tas5760_suspend NULL
+#define tas5760_resume NULL
+
+enum tas576x_type {
+	TAS5760,
+};
+
+static const char * const tas5760_supply_names[] = {
+	"dvdd",		/* Digital power supply. Connect to 3.3-V supply. */
+	"pvdd",		/* Class-D amp and analog power supply (connected). */
+};
+
+#define TAS5760_NUM_SUPPLIES	ARRAY_SIZE(tas5760_supply_names)
+
+struct tas5760_data {
+	struct snd_soc_component *component;
+	struct regmap *regmap;
+	struct i2c_client *tas5760_client;
+	enum tas576x_type devtype;
+	struct regulator_bulk_data supplies[TAS5760_NUM_SUPPLIES];
+	struct gpio_desc *pasd_gpio;
+};
+
+static int tas5760_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params,
+			     struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	unsigned int rate = params_rate(params);
+	bool ss_ds;
+	int ret;
+
+	switch (rate) {
+	case 44100:
+	case 48000:
+		ss_ds = false;
+		break;
+	case 88200:
+	case 96000:
+		ss_ds = true;
+		break;
+	default:
+		dev_err(component->dev, "unsupported sample rate: %u\n", rate);
+		return -EINVAL;
+	}
+
+	ret = snd_soc_component_update_bits(component, TAS5760_DIGITAL_CTRL,
+				  TAS5760_SS_DS, ss_ds);
+	if (ret < 0) {
+		dev_err(component->dev, "error setting sample rate: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int tas5760_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct snd_soc_component *component = dai->component;
+	u8 serial_format;
+	int ret;
+
+	if ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS) {
+		dev_vdbg(component->dev, "DAI Format master is not found\n");
+		return -EINVAL;
+	}
+
+	switch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK |
+		       SND_SOC_DAIFMT_INV_MASK)) {
+	case (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF):
+		/* 1st data bit occur one BCLK cycle after the frame sync */
+		serial_format = TAS5760_SAIF_I2S;
+		break;
+	case (SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_NB_NF):
+		serial_format = TAS5760_SAIF_I2S;
+		break;
+	case (SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_NB_NF):
+		serial_format = TAS5760_SAIF_LEFTJ;
+		break;
+	case (SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF):
+		/* No delay after the frame sync */
+		serial_format = TAS5760_SAIF_LEFTJ;
+		break;
+	default:
+		dev_vdbg(component->dev, "DAI Format is not found\n");
+		return -EINVAL;
+	}
+
+	ret = snd_soc_component_update_bits(component, TAS5760_DIGITAL_CTRL,
+				  TAS5760_SAIF_FORMAT_MASK,
+				  serial_format);
+	if (ret < 0) {
+		dev_err(component->dev, "error setting SAIF format: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int tas5760_mute(struct snd_soc_dai *dai, int mute, int direction)
+{
+	struct snd_soc_component *component = dai->component;
+	int ret;
+
+	ret = snd_soc_component_update_bits(component, TAS5760_VOL_CTRL,
+				TAS5760_MUTE_MASK, mute ? TAS5760_MUTE_MASK : 0);
+	if (ret < 0) {
+		dev_err(component->dev, "error (un-)muting device: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int tas5760_codec_probe(struct snd_soc_component *component)
+{
+	struct tas5760_data *tas5760 = snd_soc_component_get_drvdata(component);
+	unsigned int device_id, expected_device_id;
+	int ret;
+
+	tas5760->component = component;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(tas5760->supplies),
+				    tas5760->supplies);
+	if (ret != 0) {
+		dev_err(component->dev, "failed to enable supplies: %d\n", ret);
+		return ret;
+	}
+
+	/*
+	 * Take a liberal approach to checking the device ID to allow the
+	 * driver to be used even if the device ID does not match, however
+	 * issue a warning if there is a mismatch.
+	 */
+	ret = regmap_read(tas5760->regmap, TAS5760_DEVICE_ID, &device_id);
+	if (ret < 0) {
+		dev_err(component->dev, "failed to read device ID register: %d\n",
+			ret);
+		goto probe_fail;
+	}
+
+	expected_device_id = TAS5760_DEVICE_ID;
+
+	if (device_id != expected_device_id)
+		dev_warn(component->dev, "wrong device ID. expected: %u read: %u\n",
+			 expected_device_id, device_id);
+
+	/* Set device to mute */
+	ret = snd_soc_component_update_bits(component, TAS5760_VOL_CTRL,
+				  TAS5760_MUTE_MASK, TAS5760_MUTE_MASK);
+
+	if (ret < 0)
+		goto error_snd_soc_component_update_bits;
+
+	/* Set device initial volume not too big */
+	snd_soc_component_write(component, TAS5760_VOL_CTRL_L, 0x7f);
+	snd_soc_component_write(component, TAS5760_VOL_CTRL_R, 0x7f);
+
+	/* Unmute device */
+	ret = snd_soc_component_update_bits(component, TAS5760_VOL_CTRL,
+				  TAS5760_MUTE_MASK, 0);
+	if (ret < 0)
+		goto error_snd_soc_component_update_bits;
+
+	if (!(IS_ERR(tas5760->pasd_gpio))) {
+		gpiod_set_value(tas5760->pasd_gpio, 1);
+	} else {
+		ret = snd_soc_component_update_bits(component, TAS5760_POWER_CTRL,
+				  TAS5760_SPK_SD_MASK, TAS5760_SPK_SD_MASK);
+	if (ret < 0)
+		return ret;
+	}
+
+	return 0;
+
+error_snd_soc_component_update_bits:
+	dev_err(component->dev, "error configuring device registers: %d\n", ret);
+
+probe_fail:
+	regulator_bulk_disable(ARRAY_SIZE(tas5760->supplies),
+			       tas5760->supplies);
+	return ret;
+}
+
+static void tas5760_codec_remove(struct snd_soc_component *component)
+{
+	struct tas5760_data *tas5760 = snd_soc_component_get_drvdata(component);
+	int ret;
+
+
+	ret = regulator_bulk_disable(ARRAY_SIZE(tas5760->supplies),
+				     tas5760->supplies);
+	if (ret < 0)
+		dev_err(component->dev, "failed to disable supplies: %d\n", ret);
+
+	if (!(IS_ERR(tas5760->pasd_gpio))) {
+		gpiod_set_value(tas5760->pasd_gpio, 0);
+	} else {
+		ret = snd_soc_component_update_bits(component, TAS5760_POWER_CTRL,
+					TAS5760_SPK_SD_MASK, 0);
+		if (ret < 0)
+			dev_err(component->dev, "failed to set SD for power down: %d\n", ret);;
+		}
+
+};
+
+static bool tas5760_is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case TAS5760_DEVICE_ID:
+	case TAS5760_ERR_STATUS:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct regmap_config tas5760_regmap_config = {
+	.reg_bits               = 8,
+	.val_bits               = 8,
+
+	.max_register           = TAS5760_MAX_REG,
+	.cache_type             = REGCACHE_RBTREE,
+	.volatile_reg           = tas5760_is_volatile_reg,
+};
+
+static const DECLARE_TLV_DB_RANGE(tas5760_dac_analog_tlv,
+	0x0, 0x0, TLV_DB_SCALE_ITEM(1920, 0, 0),
+	0x1, 0x1, TLV_DB_SCALE_ITEM(2260, 0, 0),
+	0x2, 0x2, TLV_DB_SCALE_ITEM(2500, 0, 0),
+);
+
+static DECLARE_TLV_DB_SCALE(tas5760_dac_tlv_left, -10350, 50, 1);
+static DECLARE_TLV_DB_SCALE(tas5760_dac_tlv_right, -10350, 50, 1);
+
+static int tas5760_volume_get_left(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	unsigned int val;
+
+	val = snd_soc_component_read(component, TAS5760_VOL_CTRL_L);
+	ucontrol->value.integer.value[0] = val;
+
+	return 0;
+}
+
+static int tas5760_volume_set_left(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	unsigned int val = ucontrol->value.integer.value[0];
+
+	snd_soc_component_write(component, TAS5760_VOL_CTRL_L, val);
+
+	return 0;
+}
+
+static int tas5760_volume_get_right(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	unsigned int val;
+
+	val = snd_soc_component_read(component, TAS5760_VOL_CTRL_R);
+	ucontrol->value.integer.value[0] = val;
+
+	return 0;
+}
+
+static int tas5760_volume_set_right(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	unsigned int val = ucontrol->value.integer.value[0];
+
+	snd_soc_component_write(component, TAS5760_VOL_CTRL_R, val);
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new tas5760_snd_controls[] = {
+       SOC_SINGLE_EXT_TLV("Speaker Driver Playback Volume Left",
+                       0, 0, 255, 0,
+                       tas5760_volume_get_left, tas5760_volume_set_left,
+                       tas5760_dac_tlv_left),
+       SOC_SINGLE_EXT_TLV("Speaker Driver Playback Volume Right",
+                       0, 0, 255, 0,
+                       tas5760_volume_get_right, tas5760_volume_set_right,
+                       tas5760_dac_tlv_right),
+       SOC_SINGLE_TLV("Speaker Driver Analog Gain", TAS5760_ANALOG_CTRL,
+                       TAS5760_ANALOG_GAIN_SHIFT, 2, 0, tas5760_dac_analog_tlv),
+};
+
+static const struct snd_soc_component_driver soc_component_dev_tas5760 = {
+	.probe = tas5760_codec_probe,
+	.remove = tas5760_codec_remove,
+	.suspend = tas5760_suspend,
+	.resume = tas5760_resume,
+	.controls = tas5760_snd_controls,
+	.num_controls = ARRAY_SIZE(tas5760_snd_controls),
+};
+
+#define TAS5760_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S18_3LE |\
+			 SNDRV_PCM_FMTBIT_U20_3LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+#define TAS5760_RATES	(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\
+			 SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+static const unsigned int tas5760_rates[] = {
+	32000, 44100, 48000, 88200,96000,
+};
+
+static const struct snd_pcm_hw_constraint_list tas5760_rate_constraints = {
+	.count = ARRAY_SIZE(tas5760_rates),
+	.list = tas5760_rates,
+};
+
+static int tas5760_startup(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+
+	int ret;
+	ret = snd_pcm_hw_constraint_list(substream->runtime, 0,
+					SNDRV_PCM_HW_PARAM_RATE,
+					&tas5760_rate_constraints);
+
+	return ret;
+}
+
+static const struct snd_soc_dai_ops tas5760_speaker_dai_ops = {
+	.hw_params      = tas5760_hw_params,
+	.set_fmt        = tas5760_set_dai_fmt,
+	.startup        = tas5760_startup,
+	.mute_stream   = tas5760_mute,
+	.no_capture_mute = 1,
+};
+
+static struct snd_soc_dai_driver tas5760_dai[] = {
+	{
+		.name = "tas5760-amplifier",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = TAS5760_RATES,
+			.formats = TAS5760_FORMATS,
+		},
+		.ops = &tas5760_speaker_dai_ops,
+	},
+};
+
+static int tas5760_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct tas5760_data *data;
+	const struct regmap_config *regmap_config;
+	int ret;
+	int i;
+
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->tas5760_client = client;
+	data->devtype = id->driver_data;
+
+	regmap_config = &tas5760_regmap_config;
+
+	data->regmap = devm_regmap_init_i2c(client, regmap_config);
+	if (IS_ERR(data->regmap)) {
+		ret = PTR_ERR(data->regmap);
+		dev_err(dev, "failed to allocate register map: %d\n", ret);
+		return ret;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(data->supplies); i++)
+		data->supplies[i].supply = tas5760_supply_names[i];
+
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(data->supplies),
+				      data->supplies);
+	if (ret != 0) {
+		dev_err(dev, "failed to request supplies: %d\n", ret);
+		return ret;
+	}
+
+	dev_set_drvdata(dev, data);
+
+	data->pasd_gpio = devm_gpiod_get_optional(dev, "pasd",
+							GPIOD_OUT_HIGH);
+
+	if (!(IS_ERR(data->pasd_gpio))) {
+		gpiod_direction_output(data->pasd_gpio, 1);
+		gpiod_set_value(data->pasd_gpio, 0);
+	} else {
+		dev_warn(dev, "error requesting spk_sd_gpio: %ld\n",
+				PTR_ERR(data->pasd_gpio));
+		ret = regmap_write_bits(data->regmap, TAS5760_POWER_CTRL,
+				TAS5760_SPK_SD_MASK, 0);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = devm_snd_soc_register_component(&client->dev,
+				&soc_component_dev_tas5760,
+				tas5760_dai,
+				ARRAY_SIZE(tas5760_dai));
+
+	if (ret < 0) {
+		dev_err(dev, "failed to register component: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct i2c_device_id tas5760_id[] = {
+	{ "tas5760", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, tas5760_id);
+
+#if IS_ENABLED(CONFIG_OF)
+static const struct of_device_id tas5760_of_match[] = {
+	{ .compatible = "ti,tas5760", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, tas5760_of_match);
+#endif
+
+static struct i2c_driver tas5760_i2c_driver = {
+	.driver = {
+		.name = "tas5760",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(tas5760_of_match),
+},
+	.probe = tas5760_probe,
+	.id_table = tas5760_id,
+};
+
+module_i2c_driver(tas5760_i2c_driver);
+MODULE_DESCRIPTION("TAS5760 Audio amplifier driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/tas5760.h b/sound/soc/codecs/tas5760.h
new file mode 100644
index 000000000000..29f70a01efd6
--- /dev/null
+++ b/sound/soc/codecs/tas5760.h
@@ -0,0 +1,72 @@
+/*
+ * TAS5760 speaker amplifier driver
+ *
+ * Copyright (C) 2015 Imagination Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+
+#ifndef __TAS5760_H__
+#define __TAS5760_H__
+
+/* Register Address Map */
+#define TAS5760_DEVICE_ID		0x00
+#define TAS5760_POWER_CTRL		0x01
+#define TAS5760_DIGITAL_CTRL	0x02
+#define TAS5760_VOL_CTRL		0x03
+#define TAS5760_VOL_CTRL_L		0x04
+#define TAS5760_VOL_CTRL_R		0x05
+#define TAS5760_ANALOG_CTRL		0x06
+#define TAS5760_ERR_STATUS		 0x08
+#define TAS5760_DIGITAL_CLIP_CTRL2 0x10
+#define TAS5760_DIGITAL_CLIP_CTRL1 0x11
+#define TAS5760_MAX_REG TAS5760_DIGITAL_CLIP_CTRL1
+
+/* Register bit values/masks */
+#define TAS5760_SPK_SD_MASK 0x01
+
+#define TAS5760_PBTL_EN_MASK 0x80
+#define TAS5760_PBTL_EN_VAL(val) ((val) << 7)
+#define TAS5760_PBTL_CH_VAL(val) ((val) << 1)
+#define TAS5760_PBTL_CH_MASK 0x02
+#define TAS5760_PBTL_MASK (TAS5760_PBTL_EN_MASK | TAS5760_PBTL_CH_MASK)
+
+#define TAS5760_VOL_FADE_MASK	0x80
+#define TAS5760_VOL_FADE_VAL(val) ((val) << 7)
+
+#define TAS5760_MUTE_L_MASK 0x01
+#define TAS5760_MUTE_R_MASK 0x02
+#define TAS5760_MUTE_MASK (TAS5760_MUTE_L_MASK | TAS5760_MUTE_R_MASK)
+
+#define TAS5760_DIGITAL_CLIP_MAX_VAL 0xFFFFF
+#define TAS5760_DIGITAL_CLIP_MASK 0xFC
+#define TAS5760_DIGITAL_CLIP1_VAL(val) ((val) << 2)
+#define TAS5760_DIGITAL_CLIP2_VAL(val) ((val) >> 6)
+#define TAS5760_DIGITAL_CLIP3_VAL(val) ((val) >> 12)
+
+#define TAS5760_DIGITAL_BOOST_MASK 0x30
+#define TAS5760_DIGITAL_BOOST_VAL(val) ((val) << 4)
+
+#define TAS5760_ANALOG_GAIN_MASK 0x0C
+#define TAS5760_ANALOG_GAIN_VAL(val) ((val) << 2)
+
+#define TAS5760_PWM_RATE_MAX 7
+#define TAS5760_PWM_RATE_MASK 0x70
+#define TAS5760_PWM_RATE_VAL(val) ((val) << 4)
+
+#define TAS5760_ANALOG_GAIN_SHIFT       (0x2)
+#define TAS5760_SS_DS                  BIT(3)
+#define TAS5760_SAIF_RIGHTJ_24BIT       (0x0)
+#define TAS5760_SAIF_RIGHTJ_20BIT       (0x1)
+#define TAS5760_SAIF_RIGHTJ_18BIT       (0x2)
+#define TAS5760_SAIF_RIGHTJ_16BIT       (0x3)
+#define TAS5760_SAIF_I2S                (0x4)
+#define TAS5760_SAIF_LEFTJ              (0x5)
+#define TAS5760_SAIF_FORMAT_MASK        GENMASK(2, 0)
+
+#endif /* _SND_SOC_CODEC_TAS5760_H_ */
+
diff --git a/sound/soc/fsl/Kconfig b/sound/soc/fsl/Kconfig
index c70e9c4eed08..a109800c20b2 100644
--- a/sound/soc/fsl/Kconfig
+++ b/sound/soc/fsl/Kconfig
@@ -282,6 +282,18 @@ config SND_SOC_EUKREA_TLV320
 	  Enable I2S based access to the TLV320AIC23B codec attached
 	  to the SSI interface
 
+config SND_SOC_IMX_TAS5760
+	tristate "SoC Audio support for i.MX boards with TAS5760"
+	depends on OF && I2C
+	select SND_SOC_TAS5760
+	select SND_SOC_IMX_PCM_DMA
+	select SND_SOC_FSL_SAI
+	select SND_SOC_FSL_UTILS
+	help
+	  SoC Audio support for i.MX boards with TAS5760
+	  Say Y if you want to add support for SoC audio on an i.MX board with
+	  an TAS5760 DAC.
+
 config SND_SOC_IMX_ES8328
 	tristate "SoC Audio support for i.MX boards with the ES8328 codec"
 	depends on OF && (I2C || SPI)
diff --git a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
index 63e6912675ea..e7a4bf056ffb 100644
--- a/sound/soc/fsl/Makefile
+++ b/sound/soc/fsl/Makefile
@@ -78,6 +78,7 @@ snd-soc-imx-hdmi-objs := imx-hdmi.o
 snd-soc-imx-rpmsg-objs := imx-rpmsg.o
 snd-soc-imx-card-objs := imx-card.o
 snd-soc-imx-pdm-objs := imx-pdm.o
+snd-soc-imx-tas5760-objs := imx-tas5760.o
 snd-soc-imx-pcm512x-objs := imx-pcm512x.o
 snd-soc-imx6qdl-hdmi-objs := imx6qdl-hdmi.o
 
@@ -90,6 +91,7 @@ obj-$(CONFIG_SND_SOC_IMX_HDMI) += snd-soc-imx-hdmi.o
 obj-$(CONFIG_SND_SOC_IMX_RPMSG) += snd-soc-imx-rpmsg.o
 obj-$(CONFIG_SND_SOC_IMX_CARD) += snd-soc-imx-card.o
 obj-$(CONFIG_SND_SOC_IMX_PDM_MIC) += snd-soc-imx-pdm.o
+obj-$(CONFIG_SND_SOC_IMX_TAS5760) += snd-soc-imx-tas5760.o
 obj-$(CONFIG_SND_SOC_IMX_PCM512X) += snd-soc-imx-pcm512x.o
 obj-$(CONFIG_SND_SOC_IMX6QDL_HDMI) += snd-soc-imx6qdl-hdmi.o
 
diff --git a/sound/soc/fsl/imx-tas5760.c b/sound/soc/fsl/imx-tas5760.c
new file mode 100644
index 000000000000..7c39b0d97681
--- /dev/null
+++ b/sound/soc/fsl/imx-tas5760.c
@@ -0,0 +1,236 @@
+/* i.MX TAS5760 audio support
+ *
+ * Copyright 2017 NXP
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of_device.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include <linux/clk.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/pcm.h>
+#include <sound/soc-dapm.h>
+
+#include "fsl_sai.h"
+#include "fsl_dsd.h"
+
+struct imx_tas5760_data {
+	struct snd_soc_card card;
+	int num_codec_conf;
+	struct snd_soc_codec_conf *codec_conf;
+	int pdn_gpio;
+};
+
+static u32 imx_tas5760_rates[] = { 8000, 16000, 32000, 48000 };
+static struct snd_pcm_hw_constraint_list imx_tas5760_rate_constraints = {
+	.count = ARRAY_SIZE(imx_tas5760_rates),
+	.list = imx_tas5760_rates,
+};
+
+static int imx_aif_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct snd_soc_card *card = rtd->card;
+	struct device *dev = card->dev;
+	unsigned int fmt = SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS;
+	int ret, i;
+
+	fmt |= SND_SOC_DAIFMT_I2S;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+	if (ret) {
+		dev_err(dev, "failed to set cpu dai fmt: %d\n", ret);
+		return ret;
+	}
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		struct snd_soc_dai *codec_dai =asoc_rtd_to_codec(rtd, i);
+
+		ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+		if (ret) {
+			dev_err(dev, "failed to set codec dai[%d] fmt: %d\n",
+					i, ret);
+			return ret;
+		}
+	}
+
+	/*mclk_freq = tas5760_get_mclk_rate(substream, params);
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, FSL_SAI_CLK_MAST1, mclk_freq,
+					SND_SOC_CLOCK_OUT);
+	if (ret < 0)
+		dev_err(dev, "failed to set cpui dai mclk1 rate (%lu): %d\n",
+			mclk_freq, ret);*/
+	return ret;
+}
+
+static int imx_aif_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int ret;
+
+	ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+						&imx_tas5760_rate_constraints);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops imx_aif_ops = {
+	.hw_params = imx_aif_hw_params,
+	.startup = imx_aif_startup,
+};
+
+static struct snd_soc_dai_link_component tas5760_codecs[] = {
+	{
+		/* Capture */
+		.dai_name = "tas5760-amplifier",
+	},
+};
+
+static struct snd_soc_dai_link imx_tas5760_dai = {
+	.name = "tas5760",
+	.stream_name = "Audio",
+	.codecs = tas5760_codecs,
+	.num_codecs = 1,
+	.ignore_pmdown_time = 1,
+	.ops = &imx_aif_ops,
+	.playback_only = 1,
+};
+
+static int imx_tas5760_probe(struct platform_device *pdev)
+{
+	struct imx_tas5760_data *priv;
+	struct device_node *cpu_np, *codec_np = NULL;
+	struct platform_device *cpu_pdev;
+	struct snd_soc_dai_link_component *dlc;
+	int ret;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	dlc = devm_kzalloc(&pdev->dev, 2 * sizeof(*dlc), GFP_KERNEL);
+	if (!dlc)
+		return -ENOMEM;
+
+	cpu_np = of_parse_phandle(pdev->dev.of_node, "audio-cpu", 0);
+	if (!cpu_np) {
+		dev_err(&pdev->dev, "audio dai phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	codec_np = of_parse_phandle(pdev->dev.of_node, "audio-codec", 0);
+	if (!codec_np) {
+		dev_err(&pdev->dev, "audio codec phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	cpu_pdev = of_find_device_by_node(cpu_np);
+	if (!cpu_pdev) {
+		dev_err(&pdev->dev, "failed to find SAI platform device\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	priv->num_codec_conf = 1;
+	priv->codec_conf = devm_kzalloc(&pdev->dev,
+		priv->num_codec_conf * sizeof(struct snd_soc_codec_conf),
+		GFP_KERNEL);
+	if (!priv->codec_conf) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	priv->codec_conf[0].name_prefix = "0";
+	priv->codec_conf[0].dlc.of_node = codec_np;
+
+	tas5760_codecs[0].of_node = codec_np;
+
+	imx_tas5760_dai.cpus = &dlc[0];
+	imx_tas5760_dai.num_cpus = 1;
+	imx_tas5760_dai.platforms = &dlc[1];
+	imx_tas5760_dai.num_platforms = 1;
+
+	imx_tas5760_dai.cpus->dai_name  = dev_name(&cpu_pdev->dev);
+	imx_tas5760_dai.platforms->of_node = cpu_np;
+
+	priv->card.num_links = 1;
+	priv->card.dai_link = &imx_tas5760_dai;
+	priv->card.dev = &pdev->dev;
+	priv->card.owner = THIS_MODULE;
+	priv->card.codec_conf = priv->codec_conf;
+	priv->card.num_configs = priv->num_codec_conf;
+
+	priv->pdn_gpio = of_get_named_gpio(pdev->dev.of_node, "tas5760,pdn-gpio", 0);
+	if (gpio_is_valid(priv->pdn_gpio)) {
+		ret = devm_gpio_request_one(&pdev->dev, priv->pdn_gpio,
+				GPIOF_OUT_INIT_LOW, "tas5760,pdn");
+		if (ret) {
+			dev_err(&pdev->dev, "unable to get pdn gpio\n");
+			goto fail;
+		}
+
+		gpio_set_value_cansleep(priv->pdn_gpio, 0);
+		usleep_range(1000, 2000);
+		gpio_set_value_cansleep(priv->pdn_gpio, 1);
+		usleep_range(1000, 2000);
+	}
+
+	ret = snd_soc_of_parse_card_name(&priv->card, "model");
+	if (ret)
+		goto fail;
+
+	snd_soc_card_set_drvdata(&priv->card, priv);
+
+	ret = devm_snd_soc_register_card(&pdev->dev, &priv->card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+		goto fail;
+	}
+
+	ret = 0;
+fail:
+	if (cpu_np)
+		of_node_put(cpu_np);
+	if (codec_np)
+		of_node_put(codec_np);
+
+	return ret;
+}
+
+static const struct of_device_id imx_tas5760_dt_ids[] = {
+	{ .compatible = "fsl,imx-audio-tas5760", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, imx_tas5760_dt_ids);
+
+static struct platform_driver imx_tas5760_driver = {
+	.driver = {
+		.name = "imx-tas5760",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = imx_tas5760_dt_ids,
+	},
+	.probe = imx_tas5760_probe,
+};
+module_platform_driver(imx_tas5760_driver);
+MODULE_DESCRIPTION("TAS5760 ASoC machine driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:imx-tas5760");
-- 
2.35.1

