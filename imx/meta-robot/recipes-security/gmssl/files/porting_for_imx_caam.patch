diff -uprN gmssl-1.0/apps/speed.c GmSSL-2.5.0_iMX/apps/speed.c
--- gmssl-1.0/apps/speed.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/apps/speed.c	2020-11-09 10:59:49.711907198 +0800
@@ -151,10 +151,18 @@
 #define ALGOR_NUM       33
 #define SIZE_NUM        6
 #define PRIME_NUM       3
+#ifdef HAVE_CRYPTODEV
+#define RSA_NUM         5
+#else
 #define RSA_NUM         7
+#endif
 #define DSA_NUM         3
 
+#ifdef HAVE_CRYPTODEV
+#define EC_NUM          11
+#else
 #define EC_NUM          17
+#endif
 #define SM2_NUM         1
 #define SM9_NUM	        1
 #define MAX_ECDH_SIZE   256
@@ -1554,6 +1562,20 @@ int speed_main(int argc, char **argv)
     };
 #endif
 #ifndef OPENSSL_NO_RSA
+#ifdef HAVE_CRYPTODEV
+    static const unsigned int rsa_bits[RSA_NUM] = {
+        512, 1024, 2048, 3072, 4096
+    };
+    static const unsigned char *rsa_data[RSA_NUM] = {
+        test512, test1024, test2048, test3072, test4096, test7680, test15360
+    };
+    static const int rsa_data_length[RSA_NUM] = {
+        sizeof(test512), sizeof(test1024),
+        sizeof(test2048), sizeof(test3072),
+        sizeof(test4096)
+    };
+    int rsa_doit[RSA_NUM] = { 0 };
+#else
     static const unsigned int rsa_bits[RSA_NUM] = {
         512, 1024, 2048, 3072, 4096, 7680, 15360
     };
@@ -1567,6 +1589,7 @@ int speed_main(int argc, char **argv)
         sizeof(test15360)
     };
     int rsa_doit[RSA_NUM] = { 0 };
+#endif    
 #endif
 #ifndef OPENSSL_NO_DSA
     static const unsigned int dsa_bits[DSA_NUM] = { 512, 1024, 2048 };
@@ -1578,6 +1601,30 @@ int speed_main(int argc, char **argv)
      * add tests over more curves, simply add the curve NID and curve name to
      * the following arrays and increase the EC_NUM value accordingly.
      */
+#ifdef HAVE_CRYPTODEV
+    static const unsigned int test_curves[EC_NUM] = {
+        /* Prime Curves */
+        NID_secp160r1, NID_X9_62_prime192v1, NID_secp224r1,
+        NID_X9_62_prime256v1, NID_secp384r1, NID_secp521r1,
+        /* Binary Curves */
+        NID_sect163k1, NID_sect233k1, NID_sect283k1,
+        NID_sect409k1, NID_sect571k1,
+    };
+    static const char *test_curves_names[EC_NUM] = {
+        /* Prime Curves */
+        "secp160r1", "nistp192", "nistp224",
+        "nistp256", "nistp384", "nistp521",
+        /* Binary Curves */
+        "nistk163", "nistk233", "nistk283",
+        "nistk409", "nistk571",
+    };
+    static const int test_curves_bits[EC_NUM] = {
+        160, 192, 224,
+        256, 384, 521,
+        163, 233, 283,
+        409, 571,
+    };
+#else
     static const unsigned int test_curves[EC_NUM] = {
         /* Prime Curves */
         NID_secp160r1, NID_X9_62_prime192v1, NID_secp224r1,
@@ -1611,6 +1658,7 @@ int speed_main(int argc, char **argv)
         571, 253 /* X25519 */,
     };
 
+#endif
     int ecdsa_doit[EC_NUM] = { 0 };
     int ecdh_doit[EC_NUM] = { 0 };
 #endif /* OPENSSL_NO_EC */
diff -uprN gmssl-1.0/Configurations/00-base-templates.conf GmSSL-2.5.0_iMX/Configurations/00-base-templates.conf
--- gmssl-1.0/Configurations/00-base-templates.conf	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/Configurations/00-base-templates.conf	2020-11-09 10:59:49.715907211 +0800
@@ -256,7 +256,7 @@
     aarch64_asm => {
 	template	=> 1,
 	cpuid_asm_src   => "armcap.c arm64cpuid.S",
-	ec_asm_src      => "ecp_nistz256.c ecp_nistz256-armv8.S",
+	ec_asm_src      => "ecp_nistz256.c ecp_nistz256-armv8.S ecp_sm2z256.c ecp_sm2z256-armv8.S",
 	bn_asm_src      => "bn_asm.c armv8-mont.S",
 	aes_asm_src     => "aes_core.c aes_cbc.c aesv8-armx.S vpaes-armv8.S",
 	sha1_asm_src    => "sha1-armv8.S sha256-armv8.S sha512-armv8.S",
diff -uprN gmssl-1.0/Configurations/unix-Makefile.tmpl GmSSL-2.5.0_iMX/Configurations/unix-Makefile.tmpl
--- gmssl-1.0/Configurations/unix-Makefile.tmpl	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/Configurations/unix-Makefile.tmpl	2020-11-09 10:59:49.715907211 +0800
@@ -169,7 +169,7 @@ HTMLSUFFIX=html
 
 
 
-CROSS_COMPILE= {- $config{cross_compile_prefix} -}
+CROSS_COMPILE=
 CC= $(CROSS_COMPILE){- $target{cc} -}
 CFLAGS={- our $cflags2 = join(" ",(map { "-D".$_} @{$target{defines}}, @{$config{defines}}),"-DOPENSSLDIR=\"\\\"\$(OPENSSLDIR)\\\"\"","-DENGINESDIR=\"\\\"\$(ENGINESDIR)\\\"\"") -} {- $target{cflags} -} {- $config{cflags} -}
 CFLAGS_Q={- $cflags2 =~ s|([\\"])|\\$1|g; $cflags2 -} {- $config{cflags} -}
@@ -260,7 +260,7 @@ list-tests:
 	@echo "Tests are not supported with your chosen Configure options"
 	@ : {- output_on() if !$disabled{tests}; "" -}
 
-install: install_sw install_ssldirs install_docs
+install: install_sw install_ssldirs 
 
 uninstall: uninstall_docs uninstall_sw
 
@@ -336,14 +336,14 @@ install_ssldirs:
 		mv -f $(DESTDIR)$(OPENSSLDIR)/misc/$$fn.new \
 		      $(DESTDIR)$(OPENSSLDIR)/misc/$$fn; \
 	done
-	@echo "install $(SRCDIR)/apps/openssl.cnf -> $(DESTDIR)$(OPENSSLDIR)/openssl.cnf.dist"
-	@cp $(SRCDIR)/apps/openssl.cnf $(DESTDIR)$(OPENSSLDIR)/openssl.cnf.new
-	@chmod 644 $(DESTDIR)$(OPENSSLDIR)/openssl.cnf.new
-	@mv -f  $(DESTDIR)$(OPENSSLDIR)/openssl.cnf.new $(DESTDIR)$(OPENSSLDIR)/openssl.cnf.dist
-	@if ! [ -f "$(DESTDIR)$(OPENSSLDIR)/openssl.cnf" ]; then \
-		echo "install $(SRCDIR)/apps/openssl.cnf -> $(DESTDIR)$(OPENSSLDIR)/openssl.cnf"; \
-		cp $(SRCDIR)/apps/openssl.cnf $(DESTDIR)$(OPENSSLDIR)/openssl.cnf; \
-		chmod 644 $(DESTDIR)$(OPENSSLDIR)/openssl.cnf; \
+	@echo "install $(SRCDIR)/apps/openssl.cnf -> $(DESTDIR)$(OPENSSLDIR)/gmssl.cnf.dist"
+	@cp $(SRCDIR)/apps/openssl.cnf $(DESTDIR)$(OPENSSLDIR)/gmssl.cnf.new
+	@chmod 644 $(DESTDIR)$(OPENSSLDIR)/gmssl.cnf.new
+	@mv -f  $(DESTDIR)$(OPENSSLDIR)/gmssl.cnf.new $(DESTDIR)$(OPENSSLDIR)/gmssl.cnf.dist
+	@if ! [ -f "$(DESTDIR)$(OPENSSLDIR)/gmssl.cnf" ]; then \
+		echo "install $(SRCDIR)/apps/openssl.cnf -> $(DESTDIR)$(OPENSSLDIR)/gmssl.cnf"; \
+		cp $(SRCDIR)/apps/openssl.cnf $(DESTDIR)$(OPENSSLDIR)/gmssl.cnf; \
+		chmod 644 $(DESTDIR)$(OPENSSLDIR)/gmssl.cnf; \
 	fi
 
 install_dev:
diff -uprN gmssl-1.0/crypto/bn/bn_sm2p256.c GmSSL-2.5.0_iMX/crypto/bn/bn_sm2p256.c
--- gmssl-1.0/crypto/bn/bn_sm2p256.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/bn/bn_sm2p256.c	2020-11-09 10:59:49.715907211 +0800
@@ -102,6 +102,16 @@ static const BN_ULONG _sm2_p_256_sqr[] =
     0xffffffffffffffffull, 0xfffffffe00000000ull,
 };
 
+static const BN_ULONG _sm2_p_256_a[BN_SM2_256_TOP] = {
+	0xFFFFFFFFFFFFFFFCull, 0xFFFFFFFF00000000ull,
+	0xFFFFFFFFFFFFFFFFull, 0xFFFFFFFEFFFFFFFFull,
+};
+
+static const BN_ULONG _sm2_p_256_b[BN_SM2_256_TOP] = {
+	0xDDBCBD414D940E93ull, 0xF39789F515AB8F92ull,
+	0x4D5A9E4BCF6509A7ull, 0x28E9FA9E9D9F5E34ull,
+};
+
 #elif BN_BITS2 == 32
 
 static const BN_ULONG _sm2_p_256[][BN_SM2_256_TOP] = {
@@ -140,6 +150,16 @@ static const BN_ULONG _sm2_p_256_sqr[] =
     0xffffffff, 0xffffffff, 0x00000000, 0xfffffffe
 };
 
+static const BN_ULONG _sm2_p_256_a[BN_SM2_256_TOP] = {
+	0xFFFFFFFC, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF,
+	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE,
+};
+
+static const BN_ULONG _sm2_p_256_b[BN_SM2_256_TOP] = {
+	0x4D940E93, 0xDDBCBD41, 0x15AB8F92, 0xF39789F5,
+	0xCF6509A7, 0x4D5A9E4B, 0x9D9F5E34, 0x28E9FA9E,
+};
+
 #else
 # error "unsupported BN_BITS2"
 #endif
@@ -152,11 +172,37 @@ static const BIGNUM _bignum_sm2_p_256 =
     BN_FLG_STATIC_DATA
 };
 
+static const BIGNUM _bignum_sm2_p_256_a = {
+    (BN_ULONG *)_sm2_p_256_a,
+    BN_SM2_256_TOP,
+    BN_SM2_256_TOP,
+    0,
+    BN_FLG_STATIC_DATA
+};
+
+static const BIGNUM _bignum_sm2_p_256_b = {
+    (BN_ULONG *)_sm2_p_256_b,
+    BN_SM2_256_TOP,
+    BN_SM2_256_TOP,
+    0,
+    BN_FLG_STATIC_DATA
+};
+
 const BIGNUM *BN_get0_sm2_prime_256(void)
 {
     return &_bignum_sm2_p_256;
 }
 
+const BIGNUM *BN_get0_sm2_a_256(void)
+{
+    return &_bignum_sm2_p_256_a;
+}
+
+const BIGNUM *BN_get0_sm2_b_256(void)
+{
+    return &_bignum_sm2_p_256_b;
+}
+
 static void sm2_cp_bn_0(BN_ULONG *dst, const BN_ULONG *src, int top, int max)
 {
     int i;
diff -uprN gmssl-1.0/crypto/ec/asm/ecp_sm2z256-armv8.pl GmSSL-2.5.0_iMX/crypto/ec/asm/ecp_sm2z256-armv8.pl
--- gmssl-1.0/crypto/ec/asm/ecp_sm2z256-armv8.pl	1970-01-01 08:00:00.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/ec/asm/ecp_sm2z256-armv8.pl	2020-11-09 10:59:49.715907211 +0800
@@ -0,0 +1,1602 @@
+#! /usr/bin/env perl
+
+#
+# ECP_SM2Z256 module for ARMv8.
+#
+
+
+$flavour = shift;
+while (($output=shift) && ($output!~/\w[\w\-]*\.\w+$/)) {}
+
+$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+( $xlate="${dir}arm-xlate.pl" and -f $xlate ) or
+( $xlate="${dir}../../perlasm/arm-xlate.pl" and -f $xlate) or
+die "can't locate arm-xlate.pl";
+
+open OUT,"| \"$^X\" $xlate $flavour $output";
+*STDOUT=*OUT;
+
+{
+my ($rp,$ap,$bp,$bi,$a0,$a1,$a2,$a3,$t0,$t1,$t2,$t3,$poly1,$poly3,
+    $acc0,$acc1,$acc2,$acc3,$acc4,$acc5) =
+    map("x$_",(0..17,19,20));
+
+my ($acc6,$acc7)=($ap,$bp);	# used in __ecp_sm2z256_sqr_mont
+
+$code.=<<___;
+#include "arm_arch.h"
+
+.text
+___
+########################################################################
+# Convert ecp_sm2z256_table.c to layout expected by ecp_sm2z_gather_w7
+#
+$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+open TABLE,"<ecp_sm2z256_table.c"		or
+open TABLE,"<${dir}../ecp_sm2z256_table.c"	or
+die "failed to open ecp_sm2z256_table.c:",$!;
+
+use integer;
+
+foreach(<TABLE>) {
+	s/TOBN\(\s*(0x[0-9a-f]+),\s*(0x[0-9a-f]+)\s*\)/push @arr,hex($2),hex($1)/geo;
+}
+close TABLE;
+
+# See ecp_sm2z256_table.c for explanation for why it's 64*16*37.
+# 64*16*37-1 is because $#arr returns last valid index or @arr, not
+# amount of elements.
+die "insane number of elements" if ($#arr != 64*16*37-1);
+
+$code.=<<___;
+.globl	ecp_sm2z256_precomputed
+.type	ecp_sm2z256_precomputed,%object
+.align	12
+ecp_sm2z256_precomputed:
+___
+########################################################################
+# this conversion smashes P256_POINT_AFFINE by individual bytes with
+# 64 byte interval, similar to
+#	1111222233334444
+#	1234123412341234
+for(1..37) {
+	@tbl = splice(@arr,0,64*16);
+	for($i=0;$i<64;$i++) {
+		undef @line;
+		for($j=0;$j<64;$j++) {
+			push @line,(@tbl[$j*16+$i/4]>>(($i%4)*8))&0xff;
+		}
+		$code.=".byte\t";
+		$code.=join(',',map { sprintf "0x%02x",$_} @line);
+		$code.="\n";
+	}
+}
+$code.=<<___;
+.size	ecp_sm2z256_precomputed,.-ecp_sm2z256_precomputed
+.align	5
+.Lpoly:
+.quad	0xffffffffffffffff, 0xffffffff00000000, 0xffffffffffffffff, 0xfffffffeffffffff
+.LRR:	// 2^512 mod P precomputed for SM2 polynomial
+.quad	0x0000000200000003, 0x00000002ffffffff, 0x0000000100000001, 0x0000000400000002
+.Lone_mont:
+.quad	0x0000000000000001, 0x00000000ffffffff, 0x0000000000000000, 0x0000000100000000
+.Lone:
+.quad	1,0,0,0
+.asciz	"ECP_SM2Z256 for ARMv8, CRYPTOGAMS by <appro\@openssl.org>"
+
+// void	ecp_sm2z256_to_mont(BN_ULONG x0[4],const BN_ULONG x1[4]);
+.globl	ecp_sm2z256_to_mont
+.type	ecp_sm2z256_to_mont,%function
+.align	6
+ecp_sm2z256_to_mont:
+	stp	x29,x30,[sp,#-32]!
+	add	x29,sp,#0
+	stp	x19,x20,[sp,#16]
+
+	ldr	$bi,.LRR		// bp[0]
+	ldp	$a0,$a1,[$ap]
+	ldp	$a2,$a3,[$ap,#16]
+	ldr	$poly1,.Lpoly+8
+	ldr	$poly3,.Lpoly+24
+	adr	$bp,.LRR		// &bp[0]
+
+	bl	__ecp_sm2z256_mul_mont
+
+	ldp	x19,x20,[sp,#16]
+	ldp	x29,x30,[sp],#32
+	ret
+.size	ecp_sm2z256_to_mont,.-ecp_sm2z256_to_mont
+
+// void	ecp_sm2z256_from_mont(BN_ULONG x0[4],const BN_ULONG x1[4]);
+.globl	ecp_sm2z256_from_mont
+.type	ecp_sm2z256_from_mont,%function
+.align	4
+ecp_sm2z256_from_mont:
+	stp	x29,x30,[sp,#-32]!
+	add	x29,sp,#0
+	stp	x19,x20,[sp,#16]
+
+	mov	$bi,#1			// bp[0]
+	ldp	$a0,$a1,[$ap]
+	ldp	$a2,$a3,[$ap,#16]
+	ldr	$poly1,.Lpoly+8
+	ldr	$poly3,.Lpoly+24
+	adr	$bp,.Lone		// &bp[0]
+
+	bl	__ecp_sm2z256_mul_mont
+
+	ldp	x19,x20,[sp,#16]
+	ldp	x29,x30,[sp],#32
+	ret
+.size	ecp_sm2z256_from_mont,.-ecp_sm2z256_from_mont
+
+// void	ecp_sm2z256_mul_mont(BN_ULONG x0[4],const BN_ULONG x1[4],
+//					     const BN_ULONG x2[4]);
+.globl	ecp_sm2z256_mul_mont
+.type	ecp_sm2z256_mul_mont,%function
+.align	4
+ecp_sm2z256_mul_mont:
+	stp	x29,x30,[sp,#-32]!
+	add	x29,sp,#0
+	stp	x19,x20,[sp,#16]
+
+	ldr	$bi,[$bp]		// bp[0]
+	ldp	$a0,$a1,[$ap]
+	ldp	$a2,$a3,[$ap,#16]
+	ldr	$poly1,.Lpoly+8
+	ldr	$poly3,.Lpoly+24
+
+	bl	__ecp_sm2z256_mul_mont
+
+	ldp	x19,x20,[sp,#16]
+	ldp	x29,x30,[sp],#32
+	ret
+.size	ecp_sm2z256_mul_mont,.-ecp_sm2z256_mul_mont
+
+// void	ecp_sm2z256_sqr_mont(BN_ULONG x0[4],const BN_ULONG x1[4]);
+.globl	ecp_sm2z256_sqr_mont
+.type	ecp_sm2z256_sqr_mont,%function
+.align	4
+ecp_sm2z256_sqr_mont:
+	stp	x29,x30,[sp,#-32]!
+	add	x29,sp,#0
+	stp	x19,x20,[sp,#16]
+
+	ldp	$a0,$a1,[$ap]
+	ldp	$a2,$a3,[$ap,#16]
+	ldr	$poly1,.Lpoly+8
+	ldr	$poly3,.Lpoly+24
+
+	bl	__ecp_sm2z256_sqr_mont
+
+	ldp	x19,x20,[sp,#16]
+	ldp	x29,x30,[sp],#32
+	ret
+.size	ecp_sm2z256_sqr_mont,.-ecp_sm2z256_sqr_mont
+
+// void	ecp_sm2z256_add(BN_ULONG x0[4],const BN_ULONG x1[4],
+//					const BN_ULONG x2[4]);
+.globl	ecp_sm2z256_add
+.type	ecp_sm2z256_add,%function
+.align	4
+ecp_sm2z256_add:
+	stp	x29,x30,[sp,#-16]!
+	add	x29,sp,#0
+
+	ldp	$acc0,$acc1,[$ap]
+	ldp	$t0,$t1,[$bp]
+	ldp	$acc2,$acc3,[$ap,#16]
+	ldp	$t2,$t3,[$bp,#16]
+	ldr	$poly1,.Lpoly+8
+	ldr	$poly3,.Lpoly+24
+
+	bl	__ecp_sm2z256_add
+
+	ldp	x29,x30,[sp],#16
+	ret
+.size	ecp_sm2z256_add,.-ecp_sm2z256_add
+
+// void	ecp_sm2z256_div_by_2(BN_ULONG x0[4],const BN_ULONG x1[4]);
+.globl	ecp_sm2z256_div_by_2
+.type	ecp_sm2z256_div_by_2,%function
+.align	4
+ecp_sm2z256_div_by_2:
+	stp	x29,x30,[sp,#-16]!
+	add	x29,sp,#0
+
+	ldp	$acc0,$acc1,[$ap]
+	ldp	$acc2,$acc3,[$ap,#16]
+	ldr	$poly1,.Lpoly+8
+	ldr	$poly3,.Lpoly+24
+
+	bl	__ecp_sm2z256_div_by_2
+
+	ldp	x29,x30,[sp],#16
+	ret
+.size	ecp_sm2z256_div_by_2,.-ecp_sm2z256_div_by_2
+
+// void	ecp_sm2z256_mul_by_2(BN_ULONG x0[4],const BN_ULONG x1[4]);
+.globl	ecp_sm2z256_mul_by_2
+.type	ecp_sm2z256_mul_by_2,%function
+.align	4
+ecp_sm2z256_mul_by_2:
+	stp	x29,x30,[sp,#-16]!
+	add	x29,sp,#0
+
+	ldp	$acc0,$acc1,[$ap]
+	ldp	$acc2,$acc3,[$ap,#16]
+	ldr	$poly1,.Lpoly+8
+	ldr	$poly3,.Lpoly+24
+	mov	$t0,$acc0
+	mov	$t1,$acc1
+	mov	$t2,$acc2
+	mov	$t3,$acc3
+
+	bl	__ecp_sm2z256_add	// ret = a+a	// 2*a
+
+	ldp	x29,x30,[sp],#16
+	ret
+.size	ecp_sm2z256_mul_by_2,.-ecp_sm2z256_mul_by_2
+
+// void	ecp_sm2z256_mul_by_3(BN_ULONG x0[4],const BN_ULONG x1[4]);
+.globl	ecp_sm2z256_mul_by_3
+.type	ecp_sm2z256_mul_by_3,%function
+.align	4
+ecp_sm2z256_mul_by_3:
+	stp	x29,x30,[sp,#-16]!
+	add	x29,sp,#0
+
+	ldp	$acc0,$acc1,[$ap]
+	ldp	$acc2,$acc3,[$ap,#16]
+	ldr	$poly1,.Lpoly+8
+	ldr	$poly3,.Lpoly+24
+	mov	$t0,$acc0
+	mov	$t1,$acc1
+	mov	$t2,$acc2
+	mov	$t3,$acc3
+	mov	$a0,$acc0
+	mov	$a1,$acc1
+	mov	$a2,$acc2
+	mov	$a3,$acc3
+
+	bl	__ecp_sm2z256_add	// ret = a+a	// 2*a
+
+	mov	$t0,$a0
+	mov	$t1,$a1
+	mov	$t2,$a2
+	mov	$t3,$a3
+
+	bl	__ecp_sm2z256_add	// ret += a	// 2*a+a=3*a
+
+	ldp	x29,x30,[sp],#16
+	ret
+.size	ecp_sm2z256_mul_by_3,.-ecp_sm2z256_mul_by_3
+
+// void	ecp_sm2z256_sub(BN_ULONG x0[4],const BN_ULONG x1[4],
+//				        const BN_ULONG x2[4]);
+.globl	ecp_sm2z256_sub
+.type	ecp_sm2z256_sub,%function
+.align	4
+ecp_sm2z256_sub:
+	stp	x29,x30,[sp,#-16]!
+	add	x29,sp,#0
+
+	ldp	$acc0,$acc1,[$ap]
+	ldp	$acc2,$acc3,[$ap,#16]
+	ldr	$poly1,.Lpoly+8
+	ldr	$poly3,.Lpoly+24
+
+	bl	__ecp_sm2z256_sub_from
+
+	ldp	x29,x30,[sp],#16
+	ret
+.size	ecp_sm2z256_sub,.-ecp_sm2z256_sub
+
+// void	ecp_sm2z256_neg(BN_ULONG x0[4],const BN_ULONG x1[4]);
+.globl	ecp_sm2z256_neg
+.type	ecp_sm2z256_neg,%function
+.align	4
+ecp_sm2z256_neg:
+	stp	x29,x30,[sp,#-16]!
+	add	x29,sp,#0
+
+	mov	$bp,$ap
+	mov	$acc0,xzr		// a = 0
+	mov	$acc1,xzr
+	mov	$acc2,xzr
+	mov	$acc3,xzr
+	ldr	$poly1,.Lpoly+8
+	ldr	$poly3,.Lpoly+24
+
+	bl	__ecp_sm2z256_sub_from
+
+	ldp	x29,x30,[sp],#16
+	ret
+.size	ecp_sm2z256_neg,.-ecp_sm2z256_neg
+
+// note that __ecp_sm2z256_mul_mont expects a[0-3] input pre-loaded
+// to $a0-$a3 and b[0] - to $bi
+.type	__ecp_sm2z256_mul_mont,%function
+.align	4
+__ecp_sm2z256_mul_mont:
+	mul	$acc0,$a0,$bi		// a[0]*b[0]
+	umulh	$t0,$a0,$bi
+
+	mul	$acc1,$a1,$bi		// a[1]*b[0]
+	umulh	$t1,$a1,$bi
+
+	mul	$acc2,$a2,$bi		// a[2]*b[0]
+	umulh	$t2,$a2,$bi
+
+	mul	$acc3,$a3,$bi		// a[3]*b[0]
+	umulh	$t3,$a3,$bi
+	ldr	$bi,[$bp,#8]		// b[1]
+
+	adds	$acc1,$acc1,$t0		// accumulate high parts of multiplication
+	 lsl	$t0,$acc0,#32
+	adcs	$acc2,$acc2,$t1
+	 lsr	$t1,$acc0,#32
+	adcs	$acc3,$acc3,$t2
+	adc	$acc4,xzr,$t3
+	mov	$acc5,xzr
+___
+for($i=1;$i<4;$i++) {
+        # Reduction iteration is normally performed by accumulating
+        # result of multiplication of modulus by "magic" digit [and
+        # omitting least significant word, which is guaranteed to
+        # be 0], but thanks to special form of modulus and "magic"
+        # digit being equal to least significant word, it can be
+        # performed with additions and subtractions alone. Indeed:
+        #
+        #            ffff0001.00000000.0000ffff.ffffffff
+        # *                                     abcdefgh
+        # + xxxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx.abcdefgh
+        #
+        # Now observing that ff..ff*x = (2^n-1)*x = 2^n*x-x, we
+        # rewrite above as:
+        #
+        #   xxxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx.abcdefgh
+        # + abcdefgh.abcdefgh.0000abcd.efgh0000.00000000
+        # - 0000abcd.efgh0000.00000000.00000000.abcdefgh
+        #
+        # or marking redundant operations:
+        #
+        #   xxxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx.--------
+        # + abcdefgh.abcdefgh.0000abcd.efgh0000.--------
+        # - 0000abcd.efgh0000.--------.--------.--------
+
+$code.=<<___;
+
+//////////////////////////////code change 
+        mov	$t2,$acc0
+
+	adds    $acc0,$acc1,$acc0
+        adcs	$acc1,$acc2,xzr
+        adcs	$acc2,$acc3,xzr
+        adcs	$acc3,$acc4,$t2
+        adcs	$acc4,$acc5,xzr
+	subs    $acc0,$acc0,$t0
+  	sbcs    $acc1,$acc1,$t1
+	sbcs    $acc2,$acc2,$t0
+	sbcs    $acc3,$acc3,$t1
+	sbc     $acc4,$acc4,xzr
+
+
+	 mul	$t0,$a0,$bi		// lo(a[0]*b[i])
+	 mul	$t1,$a1,$bi		// lo(a[1]*b[i])
+	 mul	$t2,$a2,$bi		// lo(a[2]*b[i])
+	 mul	$t3,$a3,$bi		// lo(a[3]*b[i])
+
+	adds	$acc0,$acc0,$t0		// accumulate low parts of multiplication
+	 umulh	$t0,$a0,$bi		// hi(a[0]*b[i])
+	adcs	$acc1,$acc1,$t1
+	 umulh	$t1,$a1,$bi		// hi(a[1]*b[i])
+	adcs	$acc2,$acc2,$t2
+	 umulh	$t2,$a2,$bi		// hi(a[2]*b[i])
+	adcs	$acc3,$acc3,$t3
+	 umulh	$t3,$a3,$bi		// hi(a[3]*b[i])
+	adc	$acc4,$acc4,xzr
+
+___
+$code.=<<___	if ($i<3);
+	ldr	$bi,[$bp,#8*($i+1)]	// b[$i+1]
+___
+$code.=<<___;
+	adds	$acc1,$acc1,$t0		// accumulate high parts of multiplication
+	 lsl	$t0,$acc0,#32
+	adcs	$acc2,$acc2,$t1
+	 lsr	$t1,$acc0,#32
+	adcs	$acc3,$acc3,$t2
+	adcs	$acc4,$acc4,$t3
+	adc	$acc5,xzr,xzr
+___
+}
+$code.=<<___;
+	// last reduction
+	mov	$t2,$acc0
+	adds    $acc0,$acc1,$acc0
+        adcs	$acc1,$acc2,xzr
+        adcs	$acc2,$acc3,xzr
+        adcs	$acc3,$acc4,$t2
+        adcs	$acc4,$acc5,xzr
+	subs    $acc0,$acc0,$t0
+  	sbcs    $acc1,$acc1,$t1
+	sbcs    $acc2,$acc2,$t0
+	sbcs    $acc3,$acc3,$t1
+	sbc     $acc4,$acc4,xzr
+
+
+
+	adds	$t0,$acc0,#1		// subs	$t0,$a0,#-1 // tmp = ret-modulus
+	sbcs	$t1,$acc1,$poly1
+
+        mov     $t3,#1
+        b.cs    Normal1
+        mov     $t3,xzr
+Normal1:
+        adds	$t2,$acc2,$t3
+
+	sbcs	$t3,$acc3,$poly3
+
+	sbcs	xzr,$acc4,xzr		// did it borrow?
+
+	csel	$acc0,$acc0,$t0,lo	// ret = borrow ? ret : ret-modulus
+	csel	$acc1,$acc1,$t1,lo
+	csel	$acc2,$acc2,$t2,lo
+	stp	$acc0,$acc1,[$rp]
+	csel	$acc3,$acc3,$t3,lo
+	stp	$acc2,$acc3,[$rp,#16]
+
+	ret
+.size	__ecp_sm2z256_mul_mont,.-__ecp_sm2z256_mul_mont
+
+
+// note that __ecp_nistz256_sqr_mont expects a[0-3] input pre-loaded
+// to $a0-$a3
+.type	__ecp_sm2z256_sqr_mont,%function
+.align	4
+__ecp_sm2z256_sqr_mont:
+	//  |  |  |  |  |  |a1*a0|  |
+	//  |  |  |  |  |a2*a0|  |  |
+	//  |  |a3*a2|a3*a0|  |  |  |
+	//  |  |  |  |a2*a1|  |  |  |
+	//  |  |  |a3*a1|  |  |  |  |
+	// *|  |  |  |  |  |  |  | 2|
+	// +|a3*a3|a2*a2|a1*a1|a0*a0|
+	//  |--+--+--+--+--+--+--+--|
+	//  |A7|A6|A5|A4|A3|A2|A1|A0|, where Ax is $accx, i.e. follow $accx
+	//
+	//  "can't overflow" below mark carrying into high part of
+	//  multiplication result, which can't overflow, because it
+	//  can never be all ones.
+
+	mul	$acc1,$a1,$a0		// a[1]*a[0]
+	umulh	$t1,$a1,$a0
+	mul	$acc2,$a2,$a0		// a[2]*a[0]
+	umulh	$t2,$a2,$a0
+	mul	$acc3,$a3,$a0		// a[3]*a[0]
+	umulh	$acc4,$a3,$a0
+
+	adds	$acc2,$acc2,$t1		// accumulate high parts of multiplication
+	 mul	$t0,$a2,$a1		// a[2]*a[1]
+	 umulh	$t1,$a2,$a1
+	adcs	$acc3,$acc3,$t2
+	 mul	$t2,$a3,$a1		// a[3]*a[1]
+	 umulh	$t3,$a3,$a1
+	adc	$acc4,$acc4,xzr		// can't overflow
+
+	mul	$acc5,$a3,$a2		// a[3]*a[2]
+	umulh	$acc6,$a3,$a2
+
+	adds	$t1,$t1,$t2		// accumulate high parts of multiplication
+	 mul	$acc0,$a0,$a0		// a[0]*a[0]
+	adc	$t2,$t3,xzr		// can't overflow
+
+	adds	$acc3,$acc3,$t0		// accumulate low parts of multiplication
+	 umulh	$a0,$a0,$a0
+	adcs	$acc4,$acc4,$t1
+	 mul	$t1,$a1,$a1		// a[1]*a[1]
+	adcs	$acc5,$acc5,$t2
+	 umulh	$a1,$a1,$a1
+	adc	$acc6,$acc6,xzr		// can't overflow
+
+	adds	$acc1,$acc1,$acc1	// acc[1-6]*=2
+	 mul	$t2,$a2,$a2		// a[2]*a[2]
+	adcs	$acc2,$acc2,$acc2
+	 umulh	$a2,$a2,$a2
+	adcs	$acc3,$acc3,$acc3
+	 mul	$t3,$a3,$a3		// a[3]*a[3]
+	adcs	$acc4,$acc4,$acc4
+	 umulh	$a3,$a3,$a3
+	adcs	$acc5,$acc5,$acc5
+	adcs	$acc6,$acc6,$acc6
+	adc	$acc7,xzr,xzr
+
+	adds	$acc1,$acc1,$a0		// +a[i]*a[i]
+	adcs	$acc2,$acc2,$t1
+	adcs	$acc3,$acc3,$a1
+	adcs	$acc4,$acc4,$t2
+	adcs	$acc5,$acc5,$a2
+	 lsl	$t0,$acc0,#32
+	adcs	$acc6,$acc6,$t3
+	 lsr	$t1,$acc0,#32
+	adc	$acc7,$acc7,$a3
+___
+for($i=0;$i<3;$i++) {			# reductions, see commentary in
+					# multiplication for details
+$code.=<<___;
+	//subs	$t2,$acc0,$t0		// "*0xffff0001"
+	//sbc	$t3,$acc0,$t1
+	//adds	$acc0,$acc1,$t0		// +=acc[0]<<96 and omit acc[0]
+	//adcs	$acc1,$acc2,$t1
+	// lsl	$t0,$acc0,#32
+	//adcs	$acc2,$acc3,$t2		// +=acc[0]*0xffff0001
+	// lsr	$t1,$acc0,#32
+	//adc	$acc3,$t3,xzr		// can't overflow
+
+        mov	$t2,$acc0
+
+	adds    $acc0,$acc1,$acc0
+        adcs	$acc1,$acc2,xzr
+        adcs	$acc2,$acc3,xzr
+	subs    $acc0,$acc0,$t0
+  	sbcs    $acc1,$acc1,$t1
+	sbcs    $acc2,$acc2,$t0
+        sbc     $acc3,$t2,$t1		  // can't overflow
+
+	lsl	$t0,$acc0,#32
+	lsr	$t1,$acc0,#32
+___
+}
+$code.=<<___;
+
+	mov	$t2,$acc0
+
+	adds    $acc0,$acc1,$acc0
+        adcs	$acc1,$acc2,xzr
+        adcs	$acc2,$acc3,xzr
+	subs    $acc0,$acc0,$t0
+  	sbcs    $acc1,$acc1,$t1
+	sbcs    $acc2,$acc2,$t0
+        sbc     $acc3,$t2,$t1		  // can't overflow
+
+
+	adds	$acc0,$acc0,$acc4	// accumulate upper half
+	adcs	$acc1,$acc1,$acc5
+	adcs	$acc2,$acc2,$acc6
+	adcs	$acc3,$acc3,$acc7
+	adc	$acc4,xzr,xzr
+
+
+	adds	$t0,$acc0,#1		// subs	$t0,$a0,#-1 // tmp = ret-modulus
+	sbcs	$t1,$acc1,$poly1
+
+        mov     $t3,#1
+        b.cs    Normal2
+        mov     $t3,xzr
+Normal2:
+        adds	$t2,$acc2,$t3
+
+	sbcs	$t3,$acc3,$poly3
+
+	sbcs	xzr,$acc4,xzr		// did it borrow?
+
+	csel	$acc0,$acc0,$t0,lo	// ret = borrow ? ret : ret-modulus
+	csel	$acc1,$acc1,$t1,lo
+	csel	$acc2,$acc2,$t2,lo
+	stp	$acc0,$acc1,[$rp]
+	csel	$acc3,$acc3,$t3,lo
+	stp	$acc2,$acc3,[$rp,#16]
+
+	ret
+.size	__ecp_sm2z256_sqr_mont,.-__ecp_sm2z256_sqr_mont
+
+
+// Note that __ecp_sm2z256_add expects both input vectors pre-loaded to
+// $a0-$a3 and $t0-$t3. This is done because it's used in multiple
+// contexts, e.g. in multiplication by 2 and 3...
+.type	__ecp_sm2z256_add,%function
+.align	4
+__ecp_sm2z256_add:
+	adds	$acc0,$acc0,$t0		// ret = a+b
+	adcs	$acc1,$acc1,$t1
+	adcs	$acc2,$acc2,$t2
+	adcs	$acc3,$acc3,$t3
+	adc		$ap,xzr,xzr		// zap $ap
+
+	adds	$t0,$acc0,#1		// subs	$t0,$a0,#-1 // tmp = ret-modulus
+	sbcs	$t1,$acc1,$poly1
+
+        mov     $t3,#1
+        b.cs    Normal3
+        mov     $t3,xzr
+Normal3:
+        adds	$t2,$acc2,$t3
+
+	sbcs	$t3,$acc3,$poly3
+	sbcs	xzr,$ap,xzr		// did subtraction borrow?
+
+	csel	$acc0,$acc0,$t0,lo	// ret = borrow ? ret : ret-modulus
+	csel	$acc1,$acc1,$t1,lo
+	csel	$acc2,$acc2,$t2,lo
+	stp		$acc0,$acc1,[$rp]
+	csel	$acc3,$acc3,$t3,lo
+	stp		$acc2,$acc3,[$rp,#16]
+
+	ret
+.size	__ecp_sm2z256_add,.-__ecp_sm2z256_add
+
+.type	__ecp_sm2z256_sub_from,%function
+.align	4
+__ecp_sm2z256_sub_from:
+	ldp	$t0,$t1,[$bp]
+	ldp	$t2,$t3,[$bp,#16]
+	subs	$acc0,$acc0,$t0		// ret = a-b
+	sbcs	$acc1,$acc1,$t1
+	sbcs	$acc2,$acc2,$t2
+	sbcs	$acc3,$acc3,$t3
+	sbc	$ap,xzr,xzr		// zap $ap
+
+	subs	$t0,$acc0,#1		// adds	$t0,$a0,#-1 // tmp = ret+modulus
+	adcs	$t1,$acc1,$poly1
+        mov     $t3,#1
+        b.cc    Normal4
+        mov     $t3,xzr
+Normal4:
+        subs	$t2,$acc2,$t3
+	adc	$t3,$acc3,$poly3
+	cmp	$ap,xzr			// did subtraction borrow?
+
+	csel	$acc0,$acc0,$t0,eq	// ret = borrow ? ret+modulus : ret
+	csel	$acc1,$acc1,$t1,eq
+	csel	$acc2,$acc2,$t2,eq
+	stp	$acc0,$acc1,[$rp]
+	csel	$acc3,$acc3,$t3,eq
+	stp	$acc2,$acc3,[$rp,#16]
+
+	ret
+.size	__ecp_sm2z256_sub_from,.-__ecp_sm2z256_sub_from
+
+.type	__ecp_sm2z256_sub_morf,%function
+.align	4
+__ecp_sm2z256_sub_morf:
+	ldp	$t0,$t1,[$bp]
+	ldp	$t2,$t3,[$bp,#16]
+	subs	$acc0,$t0,$acc0		// ret = b-a
+	sbcs	$acc1,$t1,$acc1
+	sbcs	$acc2,$t2,$acc2
+	sbcs	$acc3,$t3,$acc3
+	sbc	$ap,xzr,xzr		// zap $ap
+
+	subs	$t0,$acc0,#1		// adds	$t0,$a0,#-1 // tmp = ret+modulus
+	adcs	$t1,$acc1,$poly1
+        mov     $t3,#1
+        b.cc    Normal5
+        mov     $t3,xzr
+Normal5:
+        subs	$t2,$acc2,$t3
+	adc	$t3,$acc3,$poly3
+	cmp	$ap,xzr			// did subtraction borrow?
+
+	csel	$acc0,$acc0,$t0,eq	// ret = borrow ? ret+modulus : ret
+	csel	$acc1,$acc1,$t1,eq
+	csel	$acc2,$acc2,$t2,eq
+	stp	$acc0,$acc1,[$rp]
+	csel	$acc3,$acc3,$t3,eq
+	stp	$acc2,$acc3,[$rp,#16]
+
+	ret
+.size	__ecp_sm2z256_sub_morf,.-__ecp_sm2z256_sub_morf
+
+.type	__ecp_sm2z256_div_by_2,%function
+.align	4
+__ecp_sm2z256_div_by_2:
+
+	subs	$t0,$acc0,#1		// adds	$t0,$a0,#-1 // tmp = ret+modulus
+	adcs	$t1,$acc1,$poly1
+        mov     $t3,#1
+        b.cc    Normal6
+        mov     $t3,xzr
+Normal6:
+        subs	$t2,$acc2,$t3
+	adc	$t3,$acc3,$poly3
+
+	adc	$ap,xzr,xzr		// zap $ap
+	tst	$acc0,#1		// is a even?
+
+	csel	$acc0,$acc0,$t0,eq	// ret = even ? a : a+modulus 
+	csel	$acc1,$acc1,$t1,eq
+	csel	$acc2,$acc2,$t2,eq
+	csel	$acc3,$acc3,$t3,eq
+	csel	$ap,xzr,$ap,eq
+
+	lsr	$acc0,$acc0,#1		// ret >>= 1
+	orr	$acc0,$acc0,$acc1,lsl#63
+	lsr	$acc1,$acc1,#1
+	orr	$acc1,$acc1,$acc2,lsl#63
+	lsr	$acc2,$acc2,#1
+	orr	$acc2,$acc2,$acc3,lsl#63
+	lsr	$acc3,$acc3,#1
+	stp	$acc0,$acc1,[$rp]
+	orr	$acc3,$acc3,$ap,lsl#63
+	stp	$acc2,$acc3,[$rp,#16]
+
+	ret
+.size	__ecp_sm2z256_div_by_2,.-__ecp_sm2z256_div_by_2
+___
+########################################################################
+# following subroutines are "literal" implementation of those found in
+# ecp_sm2z256.c
+#
+########################################################################
+# void ecp_sm2z256_point_double(P256_POINT *out,const P256_POINT *inp);
+#
+{
+my ($S,$M,$Zsqr,$tmp0)=map(32*$_,(0..3));
+# above map() describes stack layout with 4 temporary
+# 256-bit vectors on top.
+my ($rp_real,$ap_real) = map("x$_",(21,22));
+
+$code.=<<___;
+.globl	ecp_sm2z256_point_double
+.type	ecp_sm2z256_point_double,%function
+.align	5
+ecp_sm2z256_point_double:
+	stp	x29,x30,[sp,#-80]!
+	add	x29,sp,#0
+	stp	x19,x20,[sp,#16]
+	stp	x21,x22,[sp,#32]
+	sub	sp,sp,#32*4
+
+.Ldouble_shortcut:
+	ldp	$acc0,$acc1,[$ap,#32]
+	 mov	$rp_real,$rp
+	ldp	$acc2,$acc3,[$ap,#48]
+	 mov	$ap_real,$ap
+	 ldr	$poly1,.Lpoly+8
+	mov	$t0,$acc0
+	 ldr	$poly3,.Lpoly+24
+	mov	$t1,$acc1
+	 ldp	$a0,$a1,[$ap_real,#64]	// forward load for p256_sqr_mont
+	mov	$t2,$acc2
+	mov	$t3,$acc3
+	 ldp	$a2,$a3,[$ap_real,#64+16]
+	add	$rp,sp,#$S
+	bl	__ecp_sm2z256_add	// p256_mul_by_2(S, in_y);
+
+	add	$rp,sp,#$Zsqr
+	bl	__ecp_sm2z256_sqr_mont	// p256_sqr_mont(Zsqr, in_z);
+
+	ldp	$t0,$t1,[$ap_real]
+	ldp	$t2,$t3,[$ap_real,#16]
+	mov	$a0,$acc0		// put Zsqr aside for p256_sub
+	mov	$a1,$acc1
+	mov	$a2,$acc2
+	mov	$a3,$acc3
+	add	$rp,sp,#$M
+	bl	__ecp_sm2z256_add	// p256_add(M, Zsqr, in_x);
+
+	add	$bp,$ap_real,#0
+	mov	$acc0,$a0		// restore Zsqr
+	mov	$acc1,$a1
+	 ldp	$a0,$a1,[sp,#$S]	// forward load for p256_sqr_mont
+	mov	$acc2,$a2
+	mov	$acc3,$a3
+	 ldp	$a2,$a3,[sp,#$S+16]
+	add	$rp,sp,#$Zsqr
+	bl	__ecp_sm2z256_sub_morf	// p256_sub(Zsqr, in_x, Zsqr);
+
+	add	$rp,sp,#$S
+	bl	__ecp_sm2z256_sqr_mont	// p256_sqr_mont(S, S);
+
+	ldr	$bi,[$ap_real,#32]
+	ldp	$a0,$a1,[$ap_real,#64]
+	ldp	$a2,$a3,[$ap_real,#64+16]
+	add	$bp,$ap_real,#32
+	add	$rp,sp,#$tmp0
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(tmp0, in_z, in_y);
+
+	mov	$t0,$acc0
+	mov	$t1,$acc1
+	 ldp	$a0,$a1,[sp,#$S]	// forward load for p256_sqr_mont
+	mov	$t2,$acc2
+	mov	$t3,$acc3
+	 ldp	$a2,$a3,[sp,#$S+16]
+	add	$rp,$rp_real,#64
+	bl	__ecp_sm2z256_add	// p256_mul_by_2(res_z, tmp0);
+
+	add	$rp,sp,#$tmp0
+	bl	__ecp_sm2z256_sqr_mont	// p256_sqr_mont(tmp0, S);
+
+	 ldr	$bi,[sp,#$Zsqr]		// forward load for p256_mul_mont
+	 ldp	$a0,$a1,[sp,#$M]
+	 ldp	$a2,$a3,[sp,#$M+16]
+	add	$rp,$rp_real,#32
+	bl	__ecp_sm2z256_div_by_2	// p256_div_by_2(res_y, tmp0);
+
+	add	$bp,sp,#$Zsqr
+	add	$rp,sp,#$M
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(M, M, Zsqr);
+
+	mov	$t0,$acc0		// duplicate M
+	mov	$t1,$acc1
+	mov	$t2,$acc2
+	mov	$t3,$acc3
+	mov	$a0,$acc0		// put M aside
+	mov	$a1,$acc1
+	mov	$a2,$acc2
+	mov	$a3,$acc3
+	add	$rp,sp,#$M
+	bl	__ecp_sm2z256_add
+	mov	$t0,$a0			// restore M
+	mov	$t1,$a1
+	 ldr	$bi,[$ap_real]		// forward load for p256_mul_mont
+	mov	$t2,$a2
+	 ldp	$a0,$a1,[sp,#$S]
+	mov	$t3,$a3
+	 ldp	$a2,$a3,[sp,#$S+16]
+	bl	__ecp_sm2z256_add	// p256_mul_by_3(M, M);
+
+	add	$bp,$ap_real,#0
+	add	$rp,sp,#$S
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(S, S, in_x);
+
+	mov	$t0,$acc0
+	mov	$t1,$acc1
+	 ldp	$a0,$a1,[sp,#$M]	// forward load for p256_sqr_mont
+	mov	$t2,$acc2
+	mov	$t3,$acc3
+	 ldp	$a2,$a3,[sp,#$M+16]
+	add	$rp,sp,#$tmp0
+	bl	__ecp_sm2z256_add	// p256_mul_by_2(tmp0, S);
+
+	add	$rp,$rp_real,#0
+	bl	__ecp_sm2z256_sqr_mont	// p256_sqr_mont(res_x, M);
+
+	add	$bp,sp,#$tmp0
+	bl	__ecp_sm2z256_sub_from	// p256_sub(res_x, res_x, tmp0);
+
+	add	$bp,sp,#$S
+	add	$rp,sp,#$S
+	bl	__ecp_sm2z256_sub_morf	// p256_sub(S, S, res_x);
+
+	ldr	$bi,[sp,#$M]
+	mov	$a0,$acc0		// copy S
+	mov	$a1,$acc1
+	mov	$a2,$acc2
+	mov	$a3,$acc3
+	add	$bp,sp,#$M
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(S, S, M);
+
+	add	$bp,$rp_real,#32
+	add	$rp,$rp_real,#32
+	bl	__ecp_sm2z256_sub_from	// p256_sub(res_y, S, res_y);
+
+	add	sp,x29,#0		// destroy frame
+	ldp	x19,x20,[x29,#16]
+	ldp	x21,x22,[x29,#32]
+	ldp	x29,x30,[sp],#80
+	ret
+.size	ecp_sm2z256_point_double,.-ecp_sm2z256_point_double
+___
+}
+
+########################################################################
+# void ecp_sm2z256_point_add(P256_POINT *out,const P256_POINT *in1,
+#			      const P256_POINT *in2);
+{
+my ($res_x,$res_y,$res_z,
+    $H,$Hsqr,$R,$Rsqr,$Hcub,
+    $U1,$U2,$S1,$S2)=map(32*$_,(0..11));
+my ($Z1sqr, $Z2sqr) = ($Hsqr, $Rsqr);
+# above map() describes stack layout with 12 temporary
+# 256-bit vectors on top.
+my ($rp_real,$ap_real,$bp_real,$in1infty,$in2infty,$temp)=map("x$_",(21..26));
+
+$code.=<<___;
+.globl	ecp_sm2z256_point_add
+.type	ecp_sm2z256_point_add,%function
+.align	5
+ecp_sm2z256_point_add:
+	stp	x29,x30,[sp,#-80]!
+	add	x29,sp,#0
+	stp	x19,x20,[sp,#16]
+	stp	x21,x22,[sp,#32]
+	stp	x23,x24,[sp,#48]
+	stp	x25,x26,[sp,#64]
+	sub	sp,sp,#32*12
+
+	ldp	$a0,$a1,[$bp,#64]	// in2_z
+	ldp	$a2,$a3,[$bp,#64+16]
+	 mov	$rp_real,$rp
+	 mov	$ap_real,$ap
+	 mov	$bp_real,$bp
+	 ldr	$poly1,.Lpoly+8
+	 ldr	$poly3,.Lpoly+24
+	orr	$t0,$a0,$a1
+	orr	$t2,$a2,$a3
+	orr	$in2infty,$t0,$t2
+	cmp	$in2infty,#0
+	csetm	$in2infty,ne		// !in2infty
+	add	$rp,sp,#$Z2sqr
+	bl	__ecp_sm2z256_sqr_mont	// p256_sqr_mont(Z2sqr, in2_z);
+
+	ldp	$a0,$a1,[$ap_real,#64]	// in1_z
+	ldp	$a2,$a3,[$ap_real,#64+16]
+	orr	$t0,$a0,$a1
+	orr	$t2,$a2,$a3
+	orr	$in1infty,$t0,$t2
+	cmp	$in1infty,#0
+	csetm	$in1infty,ne		// !in1infty
+	add	$rp,sp,#$Z1sqr
+	bl	__ecp_sm2z256_sqr_mont	// p256_sqr_mont(Z1sqr, in1_z);
+
+	ldr	$bi,[$bp_real,#64]
+	ldp	$a0,$a1,[sp,#$Z2sqr]
+	ldp	$a2,$a3,[sp,#$Z2sqr+16]
+	add	$bp,$bp_real,#64
+	add	$rp,sp,#$S1
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(S1, Z2sqr, in2_z);
+
+	ldr	$bi,[$ap_real,#64]
+	ldp	$a0,$a1,[sp,#$Z1sqr]
+	ldp	$a2,$a3,[sp,#$Z1sqr+16]
+	add	$bp,$ap_real,#64
+	add	$rp,sp,#$S2
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(S2, Z1sqr, in1_z);
+
+	ldr	$bi,[$ap_real,#32]
+	ldp	$a0,$a1,[sp,#$S1]
+	ldp	$a2,$a3,[sp,#$S1+16]
+	add	$bp,$ap_real,#32
+	add	$rp,sp,#$S1
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(S1, S1, in1_y);
+
+	ldr	$bi,[$bp_real,#32]
+	ldp	$a0,$a1,[sp,#$S2]
+	ldp	$a2,$a3,[sp,#$S2+16]
+	add	$bp,$bp_real,#32
+	add	$rp,sp,#$S2
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(S2, S2, in2_y);
+
+	add	$bp,sp,#$S1
+	 ldr	$bi,[sp,#$Z2sqr]	// forward load for p256_mul_mont
+	 ldp	$a0,$a1,[$ap_real]
+	 ldp	$a2,$a3,[$ap_real,#16]
+	add	$rp,sp,#$R
+	bl	__ecp_sm2z256_sub_from	// p256_sub(R, S2, S1);
+
+	orr	$acc0,$acc0,$acc1	// see if result is zero
+	orr	$acc2,$acc2,$acc3
+	orr	$temp,$acc0,$acc2
+
+	add	$bp,sp,#$Z2sqr
+	add	$rp,sp,#$U1
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(U1, in1_x, Z2sqr);
+
+	ldr	$bi,[sp,#$Z1sqr]
+	ldp	$a0,$a1,[$bp_real]
+	ldp	$a2,$a3,[$bp_real,#16]
+	add	$bp,sp,#$Z1sqr
+	add	$rp,sp,#$U2
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(U2, in2_x, Z1sqr);
+
+	add	$bp,sp,#$U1
+	 ldp	$a0,$a1,[sp,#$R]	// forward load for p256_sqr_mont
+	 ldp	$a2,$a3,[sp,#$R+16]
+	add	$rp,sp,#$H
+	bl	__ecp_sm2z256_sub_from	// p256_sub(H, U2, U1);
+
+	orr	$acc0,$acc0,$acc1	// see if result is zero
+	orr	$acc2,$acc2,$acc3
+	orr	$acc0,$acc0,$acc2
+	tst	$acc0,$acc0
+	b.ne	.Ladd_proceed		// is_equal(U1,U2)?
+
+	tst	$in1infty,$in2infty
+	b.eq	.Ladd_proceed		// (in1infty || in2infty)?
+
+	tst	$temp,$temp
+	b.eq	.Ladd_double		// is_equal(S1,S2)?
+
+	eor	$a0,$a0,$a0
+	eor	$a1,$a1,$a1
+	stp	$a0,$a1,[$rp_real]
+	stp	$a0,$a1,[$rp_real,#16]
+	stp	$a0,$a1,[$rp_real,#32]
+	stp	$a0,$a1,[$rp_real,#48]
+	stp	$a0,$a1,[$rp_real,#64]
+	stp	$a0,$a1,[$rp_real,#80]
+	b	.Ladd_done
+
+.align	4
+.Ladd_double:
+	mov	$ap,$ap_real
+	mov	$rp,$rp_real
+	ldp	x23,x24,[x29,#48]
+	ldp	x25,x26,[x29,#64]
+	add	sp,sp,#32*(12-4)	// difference in stack frames
+	b	.Ldouble_shortcut
+
+.align	4
+.Ladd_proceed:
+	add	$rp,sp,#$Rsqr
+	bl	__ecp_sm2z256_sqr_mont	// p256_sqr_mont(Rsqr, R);
+
+	ldr	$bi,[$ap_real,#64]
+	ldp	$a0,$a1,[sp,#$H]
+	ldp	$a2,$a3,[sp,#$H+16]
+	add	$bp,$ap_real,#64
+	add	$rp,sp,#$res_z
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(res_z, H, in1_z);
+
+	ldp	$a0,$a1,[sp,#$H]
+	ldp	$a2,$a3,[sp,#$H+16]
+	add	$rp,sp,#$Hsqr
+	bl	__ecp_sm2z256_sqr_mont	// p256_sqr_mont(Hsqr, H);
+
+	ldr	$bi,[$bp_real,#64]
+	ldp	$a0,$a1,[sp,#$res_z]
+	ldp	$a2,$a3,[sp,#$res_z+16]
+	add	$bp,$bp_real,#64
+	add	$rp,sp,#$res_z
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(res_z, res_z, in2_z);
+
+	ldr	$bi,[sp,#$H]
+	ldp	$a0,$a1,[sp,#$Hsqr]
+	ldp	$a2,$a3,[sp,#$Hsqr+16]
+	add	$bp,sp,#$H
+	add	$rp,sp,#$Hcub
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(Hcub, Hsqr, H);
+
+	ldr	$bi,[sp,#$Hsqr]
+	ldp	$a0,$a1,[sp,#$U1]
+	ldp	$a2,$a3,[sp,#$U1+16]
+	add	$bp,sp,#$Hsqr
+	add	$rp,sp,#$U2
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(U2, U1, Hsqr);
+
+	mov	$t0,$acc0
+	mov	$t1,$acc1
+	mov	$t2,$acc2
+	mov	$t3,$acc3
+	add	$rp,sp,#$Hsqr
+	bl	__ecp_sm2z256_add	// p256_mul_by_2(Hsqr, U2);
+
+	add	$bp,sp,#$Rsqr
+	add	$rp,sp,#$res_x
+	bl	__ecp_sm2z256_sub_morf	// p256_sub(res_x, Rsqr, Hsqr);
+
+	add	$bp,sp,#$Hcub
+	bl	__ecp_sm2z256_sub_from	//  p256_sub(res_x, res_x, Hcub);
+
+	add	$bp,sp,#$U2
+	 ldr	$bi,[sp,#$Hcub]		// forward load for p256_mul_mont
+	 ldp	$a0,$a1,[sp,#$S1]
+	 ldp	$a2,$a3,[sp,#$S1+16]
+	add	$rp,sp,#$res_y
+	bl	__ecp_sm2z256_sub_morf	// p256_sub(res_y, U2, res_x);
+
+	add	$bp,sp,#$Hcub
+	add	$rp,sp,#$S2
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(S2, S1, Hcub);
+
+	ldr	$bi,[sp,#$R]
+	ldp	$a0,$a1,[sp,#$res_y]
+	ldp	$a2,$a3,[sp,#$res_y+16]
+	add	$bp,sp,#$R
+	add	$rp,sp,#$res_y
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(res_y, res_y, R);
+
+	add	$bp,sp,#$S2
+	bl	__ecp_sm2z256_sub_from	// p256_sub(res_y, res_y, S2);
+
+	ldp	$a0,$a1,[sp,#$res_x]		// res
+	ldp	$a2,$a3,[sp,#$res_x+16]
+	ldp	$t0,$t1,[$bp_real]		// in2
+	ldp	$t2,$t3,[$bp_real,#16]
+___
+for($i=0;$i<64;$i+=32) {		# conditional moves
+$code.=<<___;
+	ldp	$acc0,$acc1,[$ap_real,#$i]	// in1
+	cmp	$in1infty,#0			// !$in1intfy, remember?
+	ldp	$acc2,$acc3,[$ap_real,#$i+16]
+	csel	$t0,$a0,$t0,ne
+	csel	$t1,$a1,$t1,ne
+	ldp	$a0,$a1,[sp,#$res_x+$i+32]	// res
+	csel	$t2,$a2,$t2,ne
+	csel	$t3,$a3,$t3,ne
+	cmp	$in2infty,#0			// !$in2intfy, remember?
+	ldp	$a2,$a3,[sp,#$res_x+$i+48]
+	csel	$acc0,$t0,$acc0,ne
+	csel	$acc1,$t1,$acc1,ne
+	ldp	$t0,$t1,[$bp_real,#$i+32]	// in2
+	csel	$acc2,$t2,$acc2,ne
+	csel	$acc3,$t3,$acc3,ne
+	ldp	$t2,$t3,[$bp_real,#$i+48]
+	stp	$acc0,$acc1,[$rp_real,#$i]
+	stp	$acc2,$acc3,[$rp_real,#$i+16]
+___
+}
+$code.=<<___;
+	ldp	$acc0,$acc1,[$ap_real,#$i]	// in1
+	cmp	$in1infty,#0			// !$in1intfy, remember?
+	ldp	$acc2,$acc3,[$ap_real,#$i+16]
+	csel	$t0,$a0,$t0,ne
+	csel	$t1,$a1,$t1,ne
+	csel	$t2,$a2,$t2,ne
+	csel	$t3,$a3,$t3,ne
+	cmp	$in2infty,#0			// !$in2intfy, remember?
+	csel	$acc0,$t0,$acc0,ne
+	csel	$acc1,$t1,$acc1,ne
+	csel	$acc2,$t2,$acc2,ne
+	csel	$acc3,$t3,$acc3,ne
+	stp	$acc0,$acc1,[$rp_real,#$i]
+	stp	$acc2,$acc3,[$rp_real,#$i+16]
+
+.Ladd_done:
+	add	sp,x29,#0	// destroy frame
+	ldp	x19,x20,[x29,#16]
+	ldp	x21,x22,[x29,#32]
+	ldp	x23,x24,[x29,#48]
+	ldp	x25,x26,[x29,#64]
+	ldp	x29,x30,[sp],#80
+	ret
+.size	ecp_sm2z256_point_add,.-ecp_sm2z256_point_add
+___
+}
+
+########################################################################
+# void ecp_sm2z256_point_add_affine(P256_POINT *out,const P256_POINT *in1,
+#				     const P256_POINT_AFFINE *in2);
+{
+my ($res_x,$res_y,$res_z,
+    $U2,$S2,$H,$R,$Hsqr,$Hcub,$Rsqr)=map(32*$_,(0..9));
+my $Z1sqr = $S2;
+# above map() describes stack layout with 10 temporary
+# 256-bit vectors on top.
+my ($rp_real,$ap_real,$bp_real,$in1infty,$in2infty,$temp)=map("x$_",(21..26));
+
+$code.=<<___;
+.globl	ecp_sm2z256_point_add_affine
+.type	ecp_sm2z256_point_add_affine,%function
+.align	5
+ecp_sm2z256_point_add_affine:
+	stp	x29,x30,[sp,#-80]!
+	add	x29,sp,#0
+	stp	x19,x20,[sp,#16]
+	stp	x21,x22,[sp,#32]
+	stp	x23,x24,[sp,#48]
+	stp	x25,x26,[sp,#64]
+	sub	sp,sp,#32*10
+
+	mov	$rp_real,$rp
+	mov	$ap_real,$ap
+	mov	$bp_real,$bp
+	ldr	$poly1,.Lpoly+8
+	ldr	$poly3,.Lpoly+24
+
+	ldp	$a0,$a1,[$ap,#64]	// in1_z
+	ldp	$a2,$a3,[$ap,#64+16]
+	orr	$t0,$a0,$a1
+	orr	$t2,$a2,$a3
+	orr	$in1infty,$t0,$t2
+	cmp	$in1infty,#0
+	csetm	$in1infty,ne		// !in1infty
+
+	ldp	$acc0,$acc1,[$bp]	// in2_x
+	ldp	$acc2,$acc3,[$bp,#16]
+	ldp	$t0,$t1,[$bp,#32]	// in2_y
+	ldp	$t2,$t3,[$bp,#48]
+	orr	$acc0,$acc0,$acc1
+	orr	$acc2,$acc2,$acc3
+	orr	$t0,$t0,$t1
+	orr	$t2,$t2,$t3
+	orr	$acc0,$acc0,$acc2
+	orr	$t0,$t0,$t2
+	orr	$in2infty,$acc0,$t0
+	cmp	$in2infty,#0
+	csetm	$in2infty,ne		// !in2infty
+
+	add	$rp,sp,#$Z1sqr
+	bl	__ecp_sm2z256_sqr_mont	// p256_sqr_mont(Z1sqr, in1_z);
+
+	mov	$a0,$acc0
+	mov	$a1,$acc1
+	mov	$a2,$acc2
+	mov	$a3,$acc3
+	ldr	$bi,[$bp_real]
+	add	$bp,$bp_real,#0
+	add	$rp,sp,#$U2
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(U2, Z1sqr, in2_x);
+
+	add	$bp,$ap_real,#0
+	 ldr	$bi,[$ap_real,#64]	// forward load for p256_mul_mont
+	 ldp	$a0,$a1,[sp,#$Z1sqr]
+	 ldp	$a2,$a3,[sp,#$Z1sqr+16]
+	add	$rp,sp,#$H
+	bl	__ecp_sm2z256_sub_from	// p256_sub(H, U2, in1_x);
+
+	add	$bp,$ap_real,#64
+	add	$rp,sp,#$S2
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(S2, Z1sqr, in1_z);
+
+	ldr	$bi,[$ap_real,#64]
+	ldp	$a0,$a1,[sp,#$H]
+	ldp	$a2,$a3,[sp,#$H+16]
+	add	$bp,$ap_real,#64
+	add	$rp,sp,#$res_z
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(res_z, H, in1_z);
+
+	ldr	$bi,[$bp_real,#32]
+	ldp	$a0,$a1,[sp,#$S2]
+	ldp	$a2,$a3,[sp,#$S2+16]
+	add	$bp,$bp_real,#32
+	add	$rp,sp,#$S2
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(S2, S2, in2_y);
+
+	add	$bp,$ap_real,#32
+	 ldp	$a0,$a1,[sp,#$H]	// forward load for p256_sqr_mont
+	 ldp	$a2,$a3,[sp,#$H+16]
+	add	$rp,sp,#$R
+	bl	__ecp_sm2z256_sub_from	// p256_sub(R, S2, in1_y);
+
+	add	$rp,sp,#$Hsqr
+	bl	__ecp_sm2z256_sqr_mont	// p256_sqr_mont(Hsqr, H);
+
+	ldp	$a0,$a1,[sp,#$R]
+	ldp	$a2,$a3,[sp,#$R+16]
+	add	$rp,sp,#$Rsqr
+	bl	__ecp_sm2z256_sqr_mont	// p256_sqr_mont(Rsqr, R);
+
+	ldr	$bi,[sp,#$H]
+	ldp	$a0,$a1,[sp,#$Hsqr]
+	ldp	$a2,$a3,[sp,#$Hsqr+16]
+	add	$bp,sp,#$H
+	add	$rp,sp,#$Hcub
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(Hcub, Hsqr, H);
+
+	ldr	$bi,[$ap_real]
+	ldp	$a0,$a1,[sp,#$Hsqr]
+	ldp	$a2,$a3,[sp,#$Hsqr+16]
+	add	$bp,$ap_real,#0
+	add	$rp,sp,#$U2
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(U2, in1_x, Hsqr);
+
+	mov	$t0,$acc0
+	mov	$t1,$acc1
+	mov	$t2,$acc2
+	mov	$t3,$acc3
+	add	$rp,sp,#$Hsqr
+	bl	__ecp_sm2z256_add	// p256_mul_by_2(Hsqr, U2);
+
+	add	$bp,sp,#$Rsqr
+	add	$rp,sp,#$res_x
+	bl	__ecp_sm2z256_sub_morf	// p256_sub(res_x, Rsqr, Hsqr);
+
+	add	$bp,sp,#$Hcub
+	bl	__ecp_sm2z256_sub_from	//  p256_sub(res_x, res_x, Hcub);
+
+	add	$bp,sp,#$U2
+	 ldr	$bi,[$ap_real,#32]	// forward load for p256_mul_mont
+	 ldp	$a0,$a1,[sp,#$Hcub]
+	 ldp	$a2,$a3,[sp,#$Hcub+16]
+	add	$rp,sp,#$res_y
+	bl	__ecp_sm2z256_sub_morf	// p256_sub(res_y, U2, res_x);
+
+	add	$bp,$ap_real,#32
+	add	$rp,sp,#$S2
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(S2, in1_y, Hcub);
+
+	ldr	$bi,[sp,#$R]
+	ldp	$a0,$a1,[sp,#$res_y]
+	ldp	$a2,$a3,[sp,#$res_y+16]
+	add	$bp,sp,#$R
+	add	$rp,sp,#$res_y
+	bl	__ecp_sm2z256_mul_mont	// p256_mul_mont(res_y, res_y, R);
+
+	add	$bp,sp,#$S2
+	bl	__ecp_sm2z256_sub_from	// p256_sub(res_y, res_y, S2);
+
+	ldp	$a0,$a1,[sp,#$res_x]		// res
+	ldp	$a2,$a3,[sp,#$res_x+16]
+	ldp	$t0,$t1,[$bp_real]		// in2
+	ldp	$t2,$t3,[$bp_real,#16]
+___
+for($i=0;$i<64;$i+=32) {		# conditional moves
+$code.=<<___;
+	ldp	$acc0,$acc1,[$ap_real,#$i]	// in1
+	cmp	$in1infty,#0			// !$in1intfy, remember?
+	ldp	$acc2,$acc3,[$ap_real,#$i+16]
+	csel	$t0,$a0,$t0,ne
+	csel	$t1,$a1,$t1,ne
+	ldp	$a0,$a1,[sp,#$res_x+$i+32]	// res
+	csel	$t2,$a2,$t2,ne
+	csel	$t3,$a3,$t3,ne
+	cmp	$in2infty,#0			// !$in2intfy, remember?
+	ldp	$a2,$a3,[sp,#$res_x+$i+48]
+	csel	$acc0,$t0,$acc0,ne
+	csel	$acc1,$t1,$acc1,ne
+	ldp	$t0,$t1,[$bp_real,#$i+32]	// in2
+	csel	$acc2,$t2,$acc2,ne
+	csel	$acc3,$t3,$acc3,ne
+	ldp	$t2,$t3,[$bp_real,#$i+48]
+	stp	$acc0,$acc1,[$rp_real,#$i]
+	stp	$acc2,$acc3,[$rp_real,#$i+16]
+___
+$code.=<<___	if ($i == 0);
+	adr	$bp_real,.Lone_mont-64
+___
+}
+$code.=<<___;
+	ldp	$acc0,$acc1,[$ap_real,#$i]	// in1
+	cmp	$in1infty,#0			// !$in1intfy, remember?
+	ldp	$acc2,$acc3,[$ap_real,#$i+16]
+	csel	$t0,$a0,$t0,ne
+	csel	$t1,$a1,$t1,ne
+	csel	$t2,$a2,$t2,ne
+	csel	$t3,$a3,$t3,ne
+	cmp	$in2infty,#0			// !$in2intfy, remember?
+	csel	$acc0,$t0,$acc0,ne
+	csel	$acc1,$t1,$acc1,ne
+	csel	$acc2,$t2,$acc2,ne
+	csel	$acc3,$t3,$acc3,ne
+	stp	$acc0,$acc1,[$rp_real,#$i]
+	stp	$acc2,$acc3,[$rp_real,#$i+16]
+
+	add	sp,x29,#0		// destroy frame
+	ldp	x19,x20,[x29,#16]
+	ldp	x21,x22,[x29,#32]
+	ldp	x23,x24,[x29,#48]
+	ldp	x25,x26,[x29,#64]
+	ldp	x29,x30,[sp],#80
+	ret
+.size	ecp_sm2z256_point_add_affine,.-ecp_sm2z256_point_add_affine
+___
+}	}
+
+########################################################################
+# scatter-gather subroutines
+{
+my ($out,$inp,$index,$mask)=map("x$_",(0..3));
+$code.=<<___;
+// void	ecp_sm2z256_scatter_w5(void *x0,const P256_POINT *x1,
+//					 int x2);
+.globl	ecp_sm2z256_scatter_w5
+.type	ecp_sm2z256_scatter_w5,%function
+.align	4
+ecp_sm2z256_scatter_w5:
+	stp	x29,x30,[sp,#-16]!
+	add	x29,sp,#0
+
+	add	$out,$out,$index,lsl#2
+
+	ldp	x4,x5,[$inp]		// X
+	ldp	x6,x7,[$inp,#16]
+	str	w4,[$out,#64*0-4]
+	lsr	x4,x4,#32
+	str	w5,[$out,#64*1-4]
+	lsr	x5,x5,#32
+	str	w6,[$out,#64*2-4]
+	lsr	x6,x6,#32
+	str	w7,[$out,#64*3-4]
+	lsr	x7,x7,#32
+	str	w4,[$out,#64*4-4]
+	str	w5,[$out,#64*5-4]
+	str	w6,[$out,#64*6-4]
+	str	w7,[$out,#64*7-4]
+	add	$out,$out,#64*8
+
+	ldp	x4,x5,[$inp,#32]	// Y
+	ldp	x6,x7,[$inp,#48]
+	str	w4,[$out,#64*0-4]
+	lsr	x4,x4,#32
+	str	w5,[$out,#64*1-4]
+	lsr	x5,x5,#32
+	str	w6,[$out,#64*2-4]
+	lsr	x6,x6,#32
+	str	w7,[$out,#64*3-4]
+	lsr	x7,x7,#32
+	str	w4,[$out,#64*4-4]
+	str	w5,[$out,#64*5-4]
+	str	w6,[$out,#64*6-4]
+	str	w7,[$out,#64*7-4]
+	add	$out,$out,#64*8
+
+	ldp	x4,x5,[$inp,#64]	// Z
+	ldp	x6,x7,[$inp,#80]
+	str	w4,[$out,#64*0-4]
+	lsr	x4,x4,#32
+	str	w5,[$out,#64*1-4]
+	lsr	x5,x5,#32
+	str	w6,[$out,#64*2-4]
+	lsr	x6,x6,#32
+	str	w7,[$out,#64*3-4]
+	lsr	x7,x7,#32
+	str	w4,[$out,#64*4-4]
+	str	w5,[$out,#64*5-4]
+	str	w6,[$out,#64*6-4]
+	str	w7,[$out,#64*7-4]
+
+	ldr	x29,[sp],#16
+	ret
+.size	ecp_sm2z256_scatter_w5,.-ecp_sm2z256_scatter_w5
+
+// void	ecp_sm2z256_gather_w5(P256_POINT *x0,const void *x1,
+//					      int x2);
+.globl	ecp_sm2z256_gather_w5
+.type	ecp_sm2z256_gather_w5,%function
+.align	4
+ecp_sm2z256_gather_w5:
+	stp	x29,x30,[sp,#-16]!
+	add	x29,sp,#0
+
+	cmp	$index,xzr
+	csetm	x3,ne
+	add	$index,$index,x3
+	add	$inp,$inp,$index,lsl#2
+
+	ldr	w4,[$inp,#64*0]
+	ldr	w5,[$inp,#64*1]
+	ldr	w6,[$inp,#64*2]
+	ldr	w7,[$inp,#64*3]
+	ldr	w8,[$inp,#64*4]
+	ldr	w9,[$inp,#64*5]
+	ldr	w10,[$inp,#64*6]
+	ldr	w11,[$inp,#64*7]
+	add	$inp,$inp,#64*8
+	orr	x4,x4,x8,lsl#32
+	orr	x5,x5,x9,lsl#32
+	orr	x6,x6,x10,lsl#32
+	orr	x7,x7,x11,lsl#32
+	csel	x4,x4,xzr,ne
+	csel	x5,x5,xzr,ne
+	csel	x6,x6,xzr,ne
+	csel	x7,x7,xzr,ne
+	stp	x4,x5,[$out]		// X
+	stp	x6,x7,[$out,#16]
+
+	ldr	w4,[$inp,#64*0]
+	ldr	w5,[$inp,#64*1]
+	ldr	w6,[$inp,#64*2]
+	ldr	w7,[$inp,#64*3]
+	ldr	w8,[$inp,#64*4]
+	ldr	w9,[$inp,#64*5]
+	ldr	w10,[$inp,#64*6]
+	ldr	w11,[$inp,#64*7]
+	add	$inp,$inp,#64*8
+	orr	x4,x4,x8,lsl#32
+	orr	x5,x5,x9,lsl#32
+	orr	x6,x6,x10,lsl#32
+	orr	x7,x7,x11,lsl#32
+	csel	x4,x4,xzr,ne
+	csel	x5,x5,xzr,ne
+	csel	x6,x6,xzr,ne
+	csel	x7,x7,xzr,ne
+	stp	x4,x5,[$out,#32]	// Y
+	stp	x6,x7,[$out,#48]
+
+	ldr	w4,[$inp,#64*0]
+	ldr	w5,[$inp,#64*1]
+	ldr	w6,[$inp,#64*2]
+	ldr	w7,[$inp,#64*3]
+	ldr	w8,[$inp,#64*4]
+	ldr	w9,[$inp,#64*5]
+	ldr	w10,[$inp,#64*6]
+	ldr	w11,[$inp,#64*7]
+	orr	x4,x4,x8,lsl#32
+	orr	x5,x5,x9,lsl#32
+	orr	x6,x6,x10,lsl#32
+	orr	x7,x7,x11,lsl#32
+	csel	x4,x4,xzr,ne
+	csel	x5,x5,xzr,ne
+	csel	x6,x6,xzr,ne
+	csel	x7,x7,xzr,ne
+	stp	x4,x5,[$out,#64]	// Z
+	stp	x6,x7,[$out,#80]
+
+	ldr	x29,[sp],#16
+	ret
+.size	ecp_sm2z256_gather_w5,.-ecp_sm2z256_gather_w5
+
+// void	ecp_sm2z256_scatter_w7(void *x0,const P256_POINT_AFFINE *x1,
+//					 int x2);
+.globl	ecp_sm2z256_scatter_w7
+.type	ecp_sm2z256_scatter_w7,%function
+.align	4
+ecp_sm2z256_scatter_w7:
+	stp	x29,x30,[sp,#-16]!
+	add	x29,sp,#0
+
+	add	$out,$out,$index
+	mov	$index,#64/8
+.Loop_scatter_w7:
+	ldr	x3,[$inp],#8
+	subs	$index,$index,#1
+	prfm	pstl1strm,[$out,#4096+64*0]
+	prfm	pstl1strm,[$out,#4096+64*1]
+	prfm	pstl1strm,[$out,#4096+64*2]
+	prfm	pstl1strm,[$out,#4096+64*3]
+	prfm	pstl1strm,[$out,#4096+64*4]
+	prfm	pstl1strm,[$out,#4096+64*5]
+	prfm	pstl1strm,[$out,#4096+64*6]
+	prfm	pstl1strm,[$out,#4096+64*7]
+	strb	w3,[$out,#64*0-1]
+	lsr	x3,x3,#8
+	strb	w3,[$out,#64*1-1]
+	lsr	x3,x3,#8
+	strb	w3,[$out,#64*2-1]
+	lsr	x3,x3,#8
+	strb	w3,[$out,#64*3-1]
+	lsr	x3,x3,#8
+	strb	w3,[$out,#64*4-1]
+	lsr	x3,x3,#8
+	strb	w3,[$out,#64*5-1]
+	lsr	x3,x3,#8
+	strb	w3,[$out,#64*6-1]
+	lsr	x3,x3,#8
+	strb	w3,[$out,#64*7-1]
+	add	$out,$out,#64*8
+	b.ne	.Loop_scatter_w7
+
+	ldr	x29,[sp],#16
+	ret
+.size	ecp_sm2z256_scatter_w7,.-ecp_sm2z256_scatter_w7
+
+// void	ecp_sm2z256_gather_w7(P256_POINT_AFFINE *x0,const void *x1,
+//						     int x2);
+.globl	ecp_sm2z256_gather_w7
+.type	ecp_sm2z256_gather_w7,%function
+.align	4
+ecp_sm2z256_gather_w7:
+	stp	x29,x30,[sp,#-16]!
+	add	x29,sp,#0
+
+	cmp	$index,xzr
+	csetm	x3,ne
+	add	$index,$index,x3
+	add	$inp,$inp,$index
+	mov	$index,#64/8
+	nop
+.Loop_gather_w7:
+	ldrb	w4,[$inp,#64*0]
+	prfm	pldl1strm,[$inp,#4096+64*0]
+	subs	$index,$index,#1
+	ldrb	w5,[$inp,#64*1]
+	prfm	pldl1strm,[$inp,#4096+64*1]
+	ldrb	w6,[$inp,#64*2]
+	prfm	pldl1strm,[$inp,#4096+64*2]
+	ldrb	w7,[$inp,#64*3]
+	prfm	pldl1strm,[$inp,#4096+64*3]
+	ldrb	w8,[$inp,#64*4]
+	prfm	pldl1strm,[$inp,#4096+64*4]
+	ldrb	w9,[$inp,#64*5]
+	prfm	pldl1strm,[$inp,#4096+64*5]
+	ldrb	w10,[$inp,#64*6]
+	prfm	pldl1strm,[$inp,#4096+64*6]
+	ldrb	w11,[$inp,#64*7]
+	prfm	pldl1strm,[$inp,#4096+64*7]
+	add	$inp,$inp,#64*8
+	orr	x4,x4,x5,lsl#8
+	orr	x6,x6,x7,lsl#8
+	orr	x8,x8,x9,lsl#8
+	orr	x4,x4,x6,lsl#16
+	orr	x10,x10,x11,lsl#8
+	orr	x4,x4,x8,lsl#32
+	orr	x4,x4,x10,lsl#48
+	and	x4,x4,x3
+	str	x4,[$out],#8
+	b.ne	.Loop_gather_w7
+
+	ldr	x29,[sp],#16
+	ret
+.size	ecp_sm2z256_gather_w7,.-ecp_sm2z256_gather_w7
+___
+}
+
+foreach (split("\n",$code)) {
+	s/\`([^\`]*)\`/eval $1/ge;
+
+	print $_,"\n";
+}
+close STDOUT;	# enforce flush
diff -uprN gmssl-1.0/crypto/ec/build.info GmSSL-2.5.0_iMX/crypto/ec/build.info
--- gmssl-1.0/crypto/ec/build.info	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/ec/build.info	2020-11-09 10:59:49.715907211 +0800
@@ -23,6 +23,8 @@ GENERATE[ecp_nistz256-armv8.S]=asm/ecp_n
 INCLUDE[ecp_nistz256-armv8.o]=..
 
 GENERATE[ecp_sm2z256-x86_64.s]=asm/ecp_sm2z256-x86_64.pl $(PERLASM_SCHEME)
+GENERATE[ecp_sm2z256-armv8.S]=asm/ecp_sm2z256-armv8.pl $(PERLASM_SCHEME)
+INCLUDE[ecp_sm2z256-armv8.o]=..
 
 BEGINRAW[Makefile]
 {- $builddir -}/ecp_nistz256-%.S:	{- $sourcedir -}/asm/ecp_nistz256-%.pl
diff -uprN gmssl-1.0/crypto/ec/ec_curve.c GmSSL-2.5.0_iMX/crypto/ec/ec_curve.c
--- gmssl-1.0/crypto/ec/ec_curve.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/ec/ec_curve.c	2020-11-09 10:59:49.715907211 +0800
@@ -2898,19 +2898,19 @@ static const struct {
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	/* b */
+        /* b */
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
-	/* x */
-	0x93, 0xDE, 0x05, 0x1D, 0x62, 0xBF, 0x71, 0x8F, 0xF5, 0xED, 0x07, 0x04,
+        /* x */
+        0x93, 0xDE, 0x05, 0x1D, 0x62, 0xBF, 0x71, 0x8F, 0xF5, 0xED, 0x07, 0x04,
         0x48, 0x7D, 0x01, 0xD6, 0xE1, 0xE4, 0x08, 0x69, 0x09, 0xDC, 0x32, 0x80,
         0xE8, 0xC4, 0xE4, 0x81, 0x7C, 0x66, 0xDD, 0xDD,
-	/* y */
-	0x21, 0xFE, 0x8D, 0xDA, 0x4F, 0x21, 0xE6, 0x07, 0x63, 0x10, 0x65, 0x12,
-	0x5C, 0x39, 0x5B, 0xBC, 0x1C, 0x1C, 0x00, 0xCB, 0xFA, 0x60, 0x24, 0x35,
-	0x0C, 0x46, 0x4C, 0xD7, 0x0A, 0x3E, 0xA6, 0x16,
-	/* order */
+        /* y */
+        0x21, 0xFE, 0x8D, 0xDA, 0x4F, 0x21, 0xE6, 0x07, 0x63, 0x10, 0x65, 0x12,
+        0x5C, 0x39, 0x5B, 0xBC, 0x1C, 0x1C, 0x00, 0xCB, 0xFA, 0x60, 0x24, 0x35,
+        0x0C, 0x46, 0x4C, 0xD7, 0x0A, 0x3E, 0xA6, 0x16,
+        /* order */
         0xB6, 0x40, 0x00, 0x00, 0x02, 0xA3, 0xA6, 0xF1, 0xD6, 0x03, 0xAB, 0x4F,
         0xF5, 0x8E, 0xC7, 0x44, 0x49, 0xF2, 0x93, 0x4B, 0x18, 0xEA, 0x8B, 0xEE,
         0xE5, 0x6E, 0xE1, 0x9C, 0xD6, 0x9E, 0xCF, 0x25,
@@ -3147,6 +3147,29 @@ static const ec_list_element curve_list[
 };
 
 #define curve_list_length OSSL_NELEM(curve_list)
+#ifdef HAVE_CRYPTODEV
+static int global_coordinate = EC_AFFINE_COORDINATES;
+static pthread_mutex_t coordinate_lock = PTHREAD_MUTEX_INITIALIZER;       /* used for global_coordinate w access */
+
+int EC_GROUP_set_coordinates(int coordinate)
+{
+    int orig_coordinate = 0;
+    pthread_mutex_lock(&coordinate_lock);
+    orig_coordinate = global_coordinate;
+    global_coordinate = coordinate;
+    return orig_coordinate;
+}
+void EC_GROUP_restore_coordinates(int coordinate)
+{
+	global_coordinate = coordinate;	
+	pthread_mutex_unlock(&coordinate_lock);	
+}
+
+int EC_GROUP_get_coordinates(const EC_GROUP *group)
+{
+	return global_coordinate;
+}
+#endif
 
 static EC_GROUP *ec_group_new_from_data(const ec_list_element curve)
 {
@@ -3207,6 +3230,18 @@ static EC_GROUP *ec_group_new_from_data(
     }
 #endif
 
+#ifdef HAVE_CRYPTODEV
+    extern int cryptodev_has_ecc(void);
+    if (cryptodev_has_ecc() && EC_AFFINE_COORDINATES == EC_GROUP_get_coordinates(group)) {
+        if (NULL == BN_copy(group->field, p))
+            goto err;
+        if(NULL == BN_copy(group->a,a))
+            goto err;
+        if(NULL == BN_copy(group->b,b))
+            goto err;
+    }
+#endif
+
     if ((P = EC_POINT_new(group)) == NULL) {
         ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);
         goto err;
@@ -3217,10 +3252,26 @@ static EC_GROUP *ec_group_new_from_data(
         ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_BN_LIB);
         goto err;
     }
+
+#ifdef HAVE_CRYPTODEV
+    if (cryptodev_has_ecc() && EC_AFFINE_COORDINATES == EC_GROUP_get_coordinates(group)) {
+        if(NULL == BN_copy(P->X,x))
+            goto err;
+        if(NULL == BN_copy(P->Y,y))
+            goto err;
+        BN_set_word(P->Z,1);
+        P->Z_is_one = 1;
+    }
+    else if (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) {
+        ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);
+        goto err;
+    }
+#else    
     if (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) {
         ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);
         goto err;
     }
+#endif
     if ((order = BN_bin2bn(params + 5 * param_len, param_len, NULL)) == NULL
         || !BN_set_word(x, (BN_ULONG)data->cofactor)) {
         ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_BN_LIB);
diff -uprN gmssl-1.0/crypto/ec/ec_cvt.c GmSSL-2.5.0_iMX/crypto/ec/ec_cvt.c
--- gmssl-1.0/crypto/ec/ec_cvt.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/ec/ec_cvt.c	2020-11-09 11:01:37.884221733 +0800
@@ -52,7 +52,19 @@ EC_GROUP *EC_GROUP_new_curve_GFp(const B
      * prime method...
      *                                              <appro>
      */
-    meth = EC_GFp_mont_method();
+    if ((BN_ucmp(BN_get0_sm2_prime_256(), p) == 0) &&
+        (BN_ucmp(BN_get0_sm2_a_256(), a) == 0) &&
+        (BN_ucmp(BN_get0_sm2_b_256(), b) == 0)
+        )
+#if defined(ECP_NISTZ256_ASM) && BN_BITS2 == 64 && !defined(GMSSL_NO_TURBO)
+        meth = EC_GFp_sm2z256_method();
+#elif !defined(OPENSSL_NO_EC_NISTP_64_GCC_128)
+        meth = EC_GFp_sm2p256_method;
+#else
+        meth = EC_GFp_mont_method();
+#endif
+    else     
+        meth = EC_GFp_mont_method();
 #else
     if (BN_nist_mod_func(p))
         meth = EC_GFp_nist_method();
diff -uprN gmssl-1.0/crypto/ec/ec_key.c GmSSL-2.5.0_iMX/crypto/ec/ec_key.c
--- gmssl-1.0/crypto/ec/ec_key.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/ec/ec_key.c	2020-11-09 10:59:49.715907211 +0800
@@ -270,7 +270,151 @@ int EC_KEY_check_key(const EC_KEY *eckey
 
     return eckey->group->meth->keycheck(eckey);
 }
+#ifdef HAVE_CRYPTODEV
+int orig_ec_key_simple_check_key(const EC_KEY *eckey)
+{
+    int ok = 0;
+    BN_CTX *ctx = NULL;
+    const BIGNUM *order = NULL;
+    EC_POINT *point = NULL;
+
+    if (eckey == NULL || eckey->group == NULL || eckey->pub_key == NULL) {
+        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
+    if (EC_POINT_is_at_infinity(eckey->group, eckey->pub_key)) {
+        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_POINT_AT_INFINITY);
+        goto err;
+    }
+
+    if ((ctx = BN_CTX_new()) == NULL)
+        goto err;
+    if ((point = EC_POINT_new(eckey->group)) == NULL)
+        goto err;
+
+    /* testing whether the pub_key is on the elliptic curve */
+    if (EC_POINT_is_on_curve(eckey->group, eckey->pub_key, ctx) <= 0) {
+        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_POINT_IS_NOT_ON_CURVE);
+        goto err;
+    }
+    /* testing whether pub_key * order is the point at infinity */
+    order = eckey->group->order;
+    if (BN_is_zero(order)) {
+        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_INVALID_GROUP_ORDER);
+        goto err;
+    }
+    if (!EC_POINT_mul(eckey->group, point, NULL, eckey->pub_key, order, ctx)) {
+        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, ERR_R_EC_LIB);
+        goto err;
+    }
+    if (!EC_POINT_is_at_infinity(eckey->group, point)) {
+        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_WRONG_ORDER);
+        goto err;
+    }
+    /*
+     * in case the priv_key is present : check if generator * priv_key ==
+     * pub_key
+     */
+    if (eckey->priv_key != NULL) {
+        if (BN_cmp(eckey->priv_key, order) >= 0) {
+            ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_WRONG_ORDER);
+            goto err;
+        }
+        if (!EC_POINT_mul(eckey->group, point, eckey->priv_key,
+                          NULL, NULL, ctx)) {
+            ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, ERR_R_EC_LIB);
+            goto err;
+        }
+        if (EC_POINT_cmp(eckey->group, point, eckey->pub_key, ctx) != 0) {
+            ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_INVALID_PRIVATE_KEY);
+            goto err;
+        }
+    }
+    ok = 1;
+ err:
+    BN_CTX_free(ctx);
+    EC_POINT_free(point);
+    return ok;
+}
+
+int ec_key_simple_check_key(const EC_KEY *eckey)
+{
+    int ok = 0;
+    BN_CTX *ctx = NULL;
+#if 0    
+    const BIGNUM *order = NULL;
+#endif
+    EC_POINT *point = NULL;
+    if (EC_PROJECTIVE_COORDINATES == EC_GROUP_get_coordinates(eckey->group))
+        return orig_ec_key_simple_check_key(eckey);
+
+    if (eckey == NULL || eckey->group == NULL || eckey->pub_key == NULL) {
+        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
+    if ((ctx = BN_CTX_new()) == NULL)
+        goto err;
+    if ((point = EC_POINT_new(eckey->group)) == NULL)
+        goto err;
+
+    /* testing whether the pub_key is on the elliptic curve( also not at infinity) */
+    if (NULL != eckey->meth->EC_POINT_check) {
+        if (!eckey->meth->EC_POINT_check(eckey->group, eckey->pub_key, ctx)) {
+            ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_POINT_IS_NOT_ON_CURVE);
+            goto err;
+        }
+    }
+#if 0
+    /* testing whether pub_key * order is the point at infinity */
+    order = eckey->group->order;
+    if (BN_is_zero(order)) {
+        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_INVALID_GROUP_ORDER);
+        goto err;
+    }
+    if (NULL != eckey->meth->EC_POINT_mul) {
+        point->flags |= SM2_FLG_CHECK_INFINITY;
+    	if (!eckey->meth->EC_POINT_mul(eckey->group, point, NULL, eckey->pub_key, order, ctx)) {
+    		ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_WRONG_ORDER);
+    		goto err;
+    	}
+    }
+    else 
+        goto err;
+    
+    /*
+     * in case the priv_key is present : check if generator * priv_key ==
+     * pub_key
+     */
+    if (eckey->priv_key != NULL) {
+        if (BN_cmp(eckey->priv_key, order) >= 0) {
+            ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_WRONG_ORDER);
+            goto err;
+        }
+        if (NULL != eckey->meth->EC_POINT_mul) {
+        	if (!eckey->meth->EC_POINT_mul(eckey->group, point, eckey->priv_key, NULL, NULL, ctx)) {
+        		ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, ERR_R_EC_LIB);
+        		goto err;
+        	}
+        }
+        else 
+            goto err;
+        if ( (BN_cmp(point->X, eckey->pub_key->X) != 0) || 
+            (BN_cmp(point->Y, eckey->pub_key->Y) != 0)) {
+            ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_INVALID_PRIVATE_KEY);
+            goto err;
+        }
+    }
+#endif
+    ok = 1;
+ err:
+    BN_CTX_free(ctx);
+    EC_POINT_free(point);
+    return ok;
+}
 
+#else
 int ec_key_simple_check_key(const EC_KEY *eckey)
 {
     int ok = 0;
@@ -337,7 +481,7 @@ int ec_key_simple_check_key(const EC_KEY
     EC_POINT_free(point);
     return ok;
 }
-
+#endif
 int EC_KEY_set_public_key_affine_coordinates(EC_KEY *key, BIGNUM *x,
                                              BIGNUM *y)
 {
diff -uprN gmssl-1.0/crypto/ec/ec_kmeth.c GmSSL-2.5.0_iMX/crypto/ec/ec_kmeth.c
--- gmssl-1.0/crypto/ec/ec_kmeth.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/ec/ec_kmeth.c	2020-11-09 10:59:49.715907211 +0800
@@ -40,6 +40,22 @@ static const EC_KEY_METHOD openssl_ec_ke
     ECIES_decrypt,
     NULL,
 #endif
+#ifdef HAVE_CRYPTODEV
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+#endif
 };
 
 static const EC_KEY_METHOD *default_ec_key_meth = &openssl_ec_key_method;
diff -uprN gmssl-1.0/crypto/ec/ec_lcl.h GmSSL-2.5.0_iMX/crypto/ec/ec_lcl.h
--- gmssl-1.0/crypto/ec/ec_lcl.h	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/ec/ec_lcl.h	2020-11-09 10:59:49.715907211 +0800
@@ -288,6 +288,10 @@ struct ec_point_st {
                                  * Z) represents (X/Z^2, Y/Z^3) if Z != 0 */
     int Z_is_one;               /* enable optimized point arithmetics for
                                  * special case */
+#ifdef HAVE_CRYPTODEV
+    /* Flags. */
+    int flags;
+#endif
 };
 
 NISTP224_PRE_COMP *EC_nistp224_pre_comp_dup(NISTP224_PRE_COMP *);
@@ -627,7 +631,31 @@ struct ec_key_method_st {
     int (*do_decrypt)(int type, const ECIES_CIPHERTEXT_VALUE *in,
                       unsigned char *out, size_t *outlen, EC_KEY *ec_key);
 #endif
+#ifdef HAVE_CRYPTODEV
+int (*BN_add_word)(BIGNUM *a, BN_ULONG w);
+int (*BN_add)(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+int (*BN_sub)(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+int (*BN_mul)(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
+int (*BN_mod_add)(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
+int (*BN_mod_sub)(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
+int (*BN_mod_mul)(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
+int (*BN_mod_sqr)(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
+BIGNUM *(*BN_mod_inverse)(BIGNUM *ret, const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx);
+int (*BN_mod)(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx);
+int (*BN_nnmod)(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx);
+int (*EC_POINT_add)(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
+                 const EC_POINT *b, BN_CTX *ctx);
+int (*EC_POINT_double)(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
+                 BN_CTX *ctx);
+int (*EC_POINT_mul)(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,
+                 const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);    
+int (*EC_POINT_check)(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx);
+
+#endif
 };
+#ifdef HAVE_CRYPTODEV
+#define SM2_FLG_CHECK_INFINITY       0x80000000
+#endif
 
 #define EC_KEY_METHOD_DYNAMIC   1
 
diff -uprN gmssl-1.0/crypto/ec/ec_lib.c GmSSL-2.5.0_iMX/crypto/ec/ec_lib.c
--- gmssl-1.0/crypto/ec/ec_lib.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/ec/ec_lib.c	2020-11-09 10:59:49.715907211 +0800
@@ -701,12 +701,21 @@ int EC_POINT_set_affine_coordinates_GFp(
     }
     if (!group->meth->point_set_affine_coordinates(group, point, x, y, ctx))
         return 0;
-
+#ifndef HAVE_CRYPTODEV
     if (EC_POINT_is_on_curve(group, point, ctx) <= 0) {
         ECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP,
               EC_R_POINT_IS_NOT_ON_CURVE);
         return 0;
     }
+#else
+    if (EC_PROJECTIVE_COORDINATES == EC_GROUP_get_coordinates(group)) {
+        if (EC_POINT_is_on_curve(group, point, ctx) <= 0) {
+            ECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP,
+                  EC_R_POINT_IS_NOT_ON_CURVE);
+            return 0;
+        }     
+    }
+#endif
     return 1;
 }
 
diff -uprN gmssl-1.0/crypto/ec/ecp_oct.c GmSSL-2.5.0_iMX/crypto/ec/ecp_oct.c
--- gmssl-1.0/crypto/ec/ecp_oct.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/ec/ecp_oct.c	2020-11-09 10:59:49.715907211 +0800
@@ -172,7 +172,7 @@ size_t ec_GFp_simple_point2oct(const EC_
         ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, EC_R_INVALID_FORM);
         goto err;
     }
-
+#ifndef HAVE_CRYPTODEV
     if (EC_POINT_is_at_infinity(group, point)) {
         /* encodes to a single 0 octet */
         if (buf != NULL) {
@@ -184,7 +184,21 @@ size_t ec_GFp_simple_point2oct(const EC_
         }
         return 1;
     }
-
+#else   
+    if (EC_PROJECTIVE_COORDINATES == EC_GROUP_get_coordinates(group)) {
+        if (EC_POINT_is_at_infinity(group, point)) {
+            /* encodes to a single 0 octet */
+            if (buf != NULL) {
+                if (len < 1) {
+                    ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);
+                    return 0;
+                }
+                buf[0] = 0;
+            }
+            return 1;
+        }
+    }
+#endif
     /* ret := required output buffer length */
     field_len = BN_num_bytes(group->field);
     ret =
@@ -210,10 +224,19 @@ size_t ec_GFp_simple_point2oct(const EC_
         y = BN_CTX_get(ctx);
         if (y == NULL)
             goto err;
-
+#ifdef HAVE_CRYPTODEV
+        if (EC_AFFINE_COORDINATES == EC_GROUP_get_coordinates(group)) {
+            if ((BN_copy(x, point->X) == NULL) || (BN_copy(y, point->Y) == NULL))
+            	goto err;
+        }
+        else {
+            if (!EC_POINT_get_affine_coordinates_GFp(group, point, x, y, ctx))
+                goto err;
+        }    
+#else
         if (!EC_POINT_get_affine_coordinates_GFp(group, point, x, y, ctx))
             goto err;
-
+#endif
         if ((form == POINT_CONVERSION_COMPRESSED
              || form == POINT_CONVERSION_HYBRID) && BN_is_odd(y))
             buf[0] = form + 1;
@@ -304,8 +327,18 @@ int ec_GFp_simple_oct2point(const EC_GRO
             ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
             return 0;
         }
-
+#ifdef HAVE_CRYPTODEV
+        if (EC_AFFINE_COORDINATES == EC_GROUP_get_coordinates(group)) {
+            BN_zero(point->X);
+            BN_zero(point->Y);
+            BN_zero(point->Z);
+            return 1;
+        }   
+        else 
+            return EC_POINT_set_to_infinity(group, point);
+#else
         return EC_POINT_set_to_infinity(group, point);
+#endif
     }
 
     field_len = BN_num_bytes(group->field);
@@ -354,6 +387,23 @@ int ec_GFp_simple_oct2point(const EC_GRO
                 goto err;
             }
         }
+#ifdef HAVE_CRYPTODEV
+        if (EC_AFFINE_COORDINATES == EC_GROUP_get_coordinates(group)) {
+            if ((BN_copy(point->X, x) == NULL) || (BN_copy(point->Y, y) == NULL))
+                goto err;
+            BN_set_word(point->Z,1);
+            point->Z_is_one = 1;     
+        }   
+        else {
+            /*
+             * EC_POINT_set_affine_coordinates_GFp is responsible for checking that
+             * the point is on the curve.
+             */
+            if (!EC_POINT_set_affine_coordinates_GFp(group, point, x, y, ctx))
+                goto err;
+        }
+        
+#else
 
         /*
          * EC_POINT_set_affine_coordinates_GFp is responsible for checking that
@@ -361,6 +411,7 @@ int ec_GFp_simple_oct2point(const EC_GRO
          */
         if (!EC_POINT_set_affine_coordinates_GFp(group, point, x, y, ctx))
             goto err;
+#endif
     }
 
     ret = 1;
diff -uprN gmssl-1.0/crypto/ecies/ecies_lib.c GmSSL-2.5.0_iMX/crypto/ecies/ecies_lib.c
--- gmssl-1.0/crypto/ecies/ecies_lib.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/ecies/ecies_lib.c	2020-11-09 10:59:49.715907211 +0800
@@ -292,7 +292,11 @@ ECIES_CIPHERTEXT_VALUE *ECIES_do_encrypt
 	ECIES_CIPHERTEXT_VALUE *ret = NULL;
 	const EC_GROUP *group = EC_KEY_get0_group(ec_key);
 	EC_KEY *ephem_key = NULL;
+#ifdef HAVE_CRYPTODEV
+    int point_form = POINT_CONVERSION_UNCOMPRESSED;
+#else
 	int point_form = POINT_CONVERSION_COMPRESSED;
+#endif
 	unsigned char *sharekey = NULL;
 	unsigned int sharekeylen;
 	unsigned char *enckey, *mackey;
diff -uprN gmssl-1.0/crypto/engine/eng_cryptodev.c GmSSL-2.5.0_iMX/crypto/engine/eng_cryptodev.c
--- gmssl-1.0/crypto/engine/eng_cryptodev.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/engine/eng_cryptodev.c	2020-11-09 10:59:49.719907221 +0800
@@ -54,7 +54,7 @@
 
 #include <sys/types.h>
 #ifdef HAVE_CRYPTODEV
-# include <crypto/cryptodev.h>
+# include <openssl/cryptodev.h>
 # include <sys/ioctl.h>
 # include <errno.h>
 # include <stdio.h>
@@ -64,6 +64,20 @@
 # include <syslog.h>
 # include <errno.h>
 # include <string.h>
+# include <openssl/ec.h>
+# include <openssl/rand.h>
+# include "internal/constant_time_locl.h"
+# include "../bn/bn_lcl.h"
+# include "../rsa/rsa_locl.h"
+#ifndef OPENSSL_NO_DSA
+# include "../dsa/dsa_locl.h"
+#endif
+#ifndef OPENSSL_NO_DH
+# include "../dh/dh_locl.h"
+#endif
+# include "../ec/ec_lcl.h"
+# include <openssl/ecies.h>
+
 #endif
 #include <openssl/dh.h>
 #include <openssl/dsa.h>
@@ -87,11 +101,61 @@ struct dev_crypto_state {
     char dummy_mac_key[HASH_MAX_LEN];
     unsigned char digest_res[HASH_MAX_LEN];
     char *mac_data;
-    int mac_len;
+    int mac_len;    
+	unsigned char * mac_key;
+    int mac_key_len;
 # endif
 };
 
-static u_int32_t cryptodev_asymfeat = 0;
+#define HW_MAX_MODULUS_SIZE_BITS   4096
+#define HW_RSA_MAX_PUBEXP_BITS    4096
+#define HW_DH_MAX_MODULUS_BITS    8192
+#define CRYPTODEV_MAX_SIZE 1024 /* Maximum number of bytes for cryptodev. */
+#define USE_BUILTIN_PRIME_GENERATION
+
+#define HW_BASE_bits            (128)                 /* base size with bit unit (32 ~ 1024) */
+#define HW_BASE_chars           (HW_BASE_bits / 8)   /* base size with char unit */
+#define HW_BASE_sections        (HW_BASE_bits / BN_BITS2 /*  32bit */)  /* base size with limb unit */
+
+#define QUAD_BYTES            	72
+#define QUAD0_BYTE_OFFSET   	0
+#define QUAD1_BYTE_OFFSET   	(QUAD_BYTES * 1)
+#define QUAD2_BYTE_OFFSET   	(QUAD_BYTES * 2)
+#define QUAD3_BYTE_OFFSET   	(QUAD_BYTES * 3)
+
+/* input the size with unit of unsigned int */
+#if (HW_BASE_sections == 1)
+#define TO_HW_BASE_SIZE(size_int)  (size_int)
+#elif (HW_BASE_sections == 2)
+#define TO_HW_BASE_SIZE(size_int) (( (size_int)  + /*(HW_BASE_sections - 1)*/1 ) >> 1 )
+#elif (HW_BASE_sections == 4)
+#define TO_HW_BASE_SIZE(size_int) (( (size_int)  + /*(HW_BASE_sections - 1)*/3 ) >> 2 )
+#elif (HW_BASE_sections == 8)
+#define TO_HW_BASE_SIZE(size_int) (( (size_int)  + /*(HW_BASE_sections - 1)*/7 ) >> 3 )
+#elif (HW_BASE_sections == 16)
+#define TO_HW_BASE_SIZE(size_int) (( (size_int)  + /*(HW_BASE_sections - 1)*/15 ) >> 4 ) // >> 4 for 16 uint32 , >> 5 for 32 uint32
+#elif (HW_BASE_sections == 32)
+#define TO_HW_BASE_SIZE(size_int) (( (size_int)  + /*(HW_BASE_sections - 1)*/31 ) >> 5 ) // >> 4 for 16 uint32 , >> 5 for 32 uint32
+#else
+#error "This HW base size dosen't be supported"
+#endif  /* HW_BASE_sections */
+
+typedef	unsigned char	bool;
+enum {
+	false	= 0,
+	true	= 1
+};
+typedef struct _cryptodev_ecc_point_t
+{
+    unsigned char *x; /* X coordinate (affine) */
+    unsigned short x_size;
+    unsigned char *y; /* Y coordinate (affine) */
+    unsigned short y_size;
+} cryptodev_ecc_point_t;
+
+int cryptodev_ec_keygen(EC_KEY *eckey);
+
+static unsigned int cryptodev_asymfeat = 0;
 
 static RSA_METHOD *cryptodev_rsa;
 #ifndef OPENSSL_NO_DSA
@@ -101,7 +165,6 @@ static DSA_METHOD *cryptodev_dsa = NULL;
 static DH_METHOD *cryptodev_dh;
 #endif
 
-static int get_asym_dev_crypto(void);
 static int open_dev_crypto(void);
 static int get_dev_crypto(void);
 static int get_cryptodev_ciphers(const int **cnids);
@@ -122,36 +185,53 @@ static int cryptodev_engine_digests(ENGI
 static int bn2crparam(const BIGNUM *a, struct crparam *crp);
 static int crparam2bn(struct crparam *crp, BIGNUM *a);
 static void zapparams(struct crypt_kop *kop);
-static int cryptodev_asym(struct crypt_kop *kop, int rlen, BIGNUM *r,
-                          int slen, BIGNUM *s);
-
-static int cryptodev_bn_mod_exp(BIGNUM *r, const BIGNUM *a,
-                                const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,
-                                BN_MONT_CTX *m_ctx);
-static int cryptodev_rsa_nocrt_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa,
-                                       BN_CTX *ctx);
-static int cryptodev_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa,
-                                 BN_CTX *ctx);
+static int curve2field(int curve_nid);
+static int cryptodev_bn_is_prime(BIGNUM *X);
+static int cryptodev_bn_generate_prime(BIGNUM *PRIME,int rsabits);
+static int cryptodev_bn_check_small_factors( const BIGNUM *X );
+static int cryptodev_bn_mod(BIGNUM *R, const BIGNUM *A, const BIGNUM *N);
+static int cryptodev_bn_gcd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+static int cryptodev_bn_inv_mod( BIGNUM *X, const BIGNUM *A, const BIGNUM *N);
+static int cryptodev_bn_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+static int cryptodev_bn_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+static int cryptodev_bn_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+static int cryptodev_bn_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+static int cryptodev_bn_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+static int cryptodev_bn_mul2(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
+static int cryptodev_bn_mod_exp(BIGNUM *R, const BIGNUM *A, const BIGNUM *B, const BIGNUM *N);
+static inline int cryptodev_bn_int_cmp(const BIGNUM *a, int i);
+static inline int cryptodev_bn_int_add(BIGNUM *r, BIGNUM *a, int i);
+static int cryptodev_rsa_keygen (RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
+static int cryptodev_bn_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx);
+static int cryptodev_bn_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
+static int cryptodev_bn_mod_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
+static int cryptodev_bn_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
+static BIGNUM *cryptodev_bn_mod_inverse(BIGNUM *ret, const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx);
+static int cryptodev_ec_point_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
+                 const EC_POINT *b, BN_CTX *ctx);
+static int cryptodev_ec_point_double(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
+                 BN_CTX *ctx);
+static int cryptodev_ec_point_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,
+                 const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);
 #ifndef OPENSSL_NO_DSA
-static int cryptodev_dsa_bn_mod_exp(DSA *dsa, BIGNUM *r, const BIGNUM *a,
-                                    const BIGNUM *p, const BIGNUM *m,
-                                    BN_CTX *ctx, BN_MONT_CTX *m_ctx);
-static int cryptodev_dsa_dsa_mod_exp(DSA *dsa, BIGNUM *t1, const BIGNUM *g,
-                                     const BIGNUM *u1, const BIGNUM *pub_key,
-                                     const BIGNUM *u2, const BIGNUM *p,
-                                     BN_CTX *ctx, BN_MONT_CTX *mont);
 static DSA_SIG *cryptodev_dsa_do_sign(const unsigned char *dgst, int dlen,
                                       DSA *dsa);
 static int cryptodev_dsa_verify(const unsigned char *dgst, int dgst_len,
                                 DSA_SIG *sig, DSA *dsa);
+static int cryptodev_dsa_keygen(DSA *dsa);
 #endif
+static ECDSA_SIG *cryptodev_ecdsa_sign_sig(const unsigned char *dgst, int dgst_len,
+                                const BIGNUM *in_kinv, const BIGNUM *in_r, EC_KEY *eckey);
+static int cryptodev_ecdsa_verify(int type, const unsigned char *dgst, int dgst_len,
+                      const unsigned char *sigbuf, int sig_len, EC_KEY *eckey);
+
 #ifndef OPENSSL_NO_DH
-static int cryptodev_mod_exp_dh(const DH *dh, BIGNUM *r, const BIGNUM *a,
-                                const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,
-                                BN_MONT_CTX *m_ctx);
-static int cryptodev_dh_compute_key(unsigned char *key, const BIGNUM *pub_key,
-                                    DH *dh);
+static int cryptodev_dh_generate_key(DH *dh);
+static int cryptodev_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh);
 #endif
+static int cryptodev_ecdh_compute_key(unsigned char **pout, size_t *outlen, const EC_POINT *pub_key,
+                            const EC_KEY *ecdh);
+
 static int cryptodev_ctrl(ENGINE *e, int cmd, long i, void *p,
                           void (*f) (void));
 void engine_load_cryptodev_int(void);
@@ -170,12 +250,39 @@ static struct {
         CRYPTO_ARC4, NID_rc4, 0, 16,
     },
     {
+        CRYPTO_DES_ECB, NID_des_ecb, 8, 8,
+    },    
+    {
         CRYPTO_DES_CBC, NID_des_cbc, 8, 8,
     },
     {
+        CRYPTO_DES_CFB, NID_des_cfb64, 8, 8,
+    },
+    {
+        CRYPTO_DES_CFB, NID_des_ofb64, 8, 8,
+    },
+    {
+        CRYPTO_3DES_ECB, NID_des_ede3_ecb, 8, 24,
+    },
+    {
         CRYPTO_3DES_CBC, NID_des_ede3_cbc, 8, 24,
     },
     {
+        CRYPTO_3DES_CFB, NID_des_ede3_cfb64, 8, 24,
+    },
+    {
+        CRYPTO_3DES_OFB, NID_des_ede3_ofb64, 8, 24,
+    },
+    {
+        CRYPTO_AES_ECB, NID_aes_128_ecb, 16, 16,
+    },
+    {
+        CRYPTO_AES_ECB, NID_aes_192_ecb, 16, 24,
+    },
+    {
+        CRYPTO_AES_ECB, NID_aes_256_ecb, 16, 32,
+    },
+    {
         CRYPTO_AES_CBC, NID_aes_128_cbc, 16, 16,
     },
     {
@@ -196,6 +303,42 @@ static struct {
     },
 # endif
     {
+        CRYPTO_AES_CFB128, NID_aes_128_cfb128, 14, 16,
+    },
+    {
+        CRYPTO_AES_CFB128, NID_aes_192_cfb128, 14, 24,
+    },
+    {
+        CRYPTO_AES_CFB128, NID_aes_256_cfb128, 14, 32,
+    },
+    {
+        CRYPTO_AES_OFB, NID_aes_128_ofb128, 14, 16,
+    },
+    {
+        CRYPTO_AES_OFB, NID_aes_192_ofb128, 14, 24,
+    },
+    {
+        CRYPTO_AES_OFB, NID_aes_256_ofb128, 14, 32,
+    },
+    {
+        CRYPTO_AES_GCM, NID_aes_128_gcm, 14, 16,
+    },
+    {
+        CRYPTO_AES_GCM, NID_aes_192_gcm, 14, 24,
+    },
+    {
+        CRYPTO_AES_GCM, NID_aes_256_gcm, 14, 32,
+    },
+    {
+        CRYPTO_AES_CCM, NID_aes_128_ccm, 14, 16,
+    },
+    {
+        CRYPTO_AES_CCM, NID_aes_192_ccm, 14, 24,
+    },
+    {
+        CRYPTO_AES_CCM, NID_aes_256_ccm, 14, 32,
+    },
+    {
         CRYPTO_BLF_CBC, NID_bf_cbc, 8, 16,
     },
     {
@@ -222,6 +365,19 @@ static struct {
         CRYPTO_SHA1_HMAC, NID_hmacWithSHA1, 20
     },
     {
+        CRYPTO_SHA2_224_HMAC, NID_hmacWithSHA224, 28
+    },
+    {
+        CRYPTO_SHA2_256_HMAC, NID_hmacWithSHA256, 32
+    },
+    {
+        CRYPTO_SHA2_384_HMAC, NID_hmacWithSHA384, 48
+    },
+    {
+        CRYPTO_SHA2_512_HMAC, NID_hmacWithSHA512, 64
+    },
+    
+    {
         CRYPTO_RIPEMD160_HMAC, NID_ripemd160, 16
         /* ? */
     },
@@ -236,6 +392,18 @@ static struct {
     },
     {
         CRYPTO_SHA1, NID_sha1, 20
+    },    
+    {
+        CRYPTO_SHA2_224, NID_sha224, 28
+    },
+    {
+        CRYPTO_SHA2_256, NID_sha256, 32
+    },
+    {
+        CRYPTO_SHA2_384, NID_sha384, 48
+    },
+    {
+        CRYPTO_SHA2_512, NID_sha512, 64
     },
     {
         0, NID_undef, 0
@@ -291,16 +459,6 @@ static void put_dev_crypto(int fd)
 # endif
 }
 
-/* Caching version for asym operations */
-static int get_asym_dev_crypto(void)
-{
-    static int fd = -1;
-
-    if (fd == -1)
-        fd = get_dev_crypto();
-    return fd;
-}
-
 /*
  * Find out what ciphers /dev/crypto will let us have a session for.
  * XXX note, that some of these openssl doesn't deal with yet!
@@ -446,17 +604,23 @@ cryptodev_cipher(EVP_CIPHER_CTX *ctx, un
     memset(&cryp, 0, sizeof(cryp));
 
     cryp.ses = sess->ses;
-    cryp.flags = 0;
+    if (EVP_CIPH_CTR_MODE == EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)))
+    	cryp.flags = COP_FLAG_WRITE_IV;
+	else
+        cryp.flags = 0;
     cryp.len = inl;
     cryp.src = (caddr_t) in;
     cryp.dst = (caddr_t) out;
     cryp.mac = 0;
 
-    cryp.op = EVP_CIPHER_CTX_encrypting(ctx) ? COP_ENCRYPT : COP_DECRYPT;
+    if (EVP_CIPH_CTR_MODE == EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)))
+        cryp.op = COP_ENCRYPT;
+    else
+        cryp.op = EVP_CIPHER_CTX_encrypting(ctx) ? COP_ENCRYPT : COP_DECRYPT;
 
     if (EVP_CIPHER_CTX_iv_length(ctx) > 0) {
         cryp.iv = (caddr_t) EVP_CIPHER_CTX_iv(ctx);
-        if (!EVP_CIPHER_CTX_encrypting(ctx)) {
+        if ((EVP_CIPH_CTR_MODE != EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx))) && !EVP_CIPHER_CTX_encrypting(ctx)) {
             iiv = in + inl - EVP_CIPHER_CTX_iv_length(ctx);
             memcpy(save_iv, iiv, EVP_CIPHER_CTX_iv_length(ctx));
         }
@@ -471,7 +635,7 @@ cryptodev_cipher(EVP_CIPHER_CTX *ctx, un
         return (0);
     }
 
-    if (EVP_CIPHER_CTX_iv_length(ctx) > 0) {
+    if ((EVP_CIPHER_CTX_iv_length(ctx) > 0) && (EVP_CIPH_CTR_MODE != EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)))) {
         if (EVP_CIPHER_CTX_encrypting(ctx))
             iiv = out + inl - EVP_CIPHER_CTX_iv_length(ctx);
         else
@@ -581,6 +745,30 @@ static const EVP_CIPHER *cryptodev_rc4(v
     return rc4_cipher;
 }
 
+/* DES ECB EVP */
+static EVP_CIPHER *des_ecb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_des_ecb(void)
+{
+    if (des_ecb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_des_ecb, 8, 8)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 8)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_ECB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        des_ecb_cipher = cipher;
+    }
+    return des_ecb_cipher;
+}
+
 /* DES CBC EVP */
 static EVP_CIPHER *des_cbc_cipher = NULL;
 static const EVP_CIPHER *cryptodev_des_cbc(void)
@@ -605,6 +793,78 @@ static const EVP_CIPHER *cryptodev_des_c
     return des_cbc_cipher;
 }
 
+/* DES CFB EVP */
+static EVP_CIPHER *des_cfb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_des_cfb(void)
+{
+    if (des_cfb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_des_cfb64, 8, 8)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 8)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_CFB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        des_cfb_cipher = cipher;
+    }
+    return des_cfb_cipher;
+}
+
+/* DES OFB EVP */
+static EVP_CIPHER *des_ofb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_des_ofb(void)
+{
+    if (des_ofb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_des_ofb64, 8, 8)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 8)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_OFB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        des_ofb_cipher = cipher;
+    }
+    return des_ofb_cipher;
+}
+
+/* 3DES ECB EVP */
+static EVP_CIPHER *des3_ecb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_3des_ecb(void)
+{
+    if (des3_ecb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_des_ede3_ecb, 8, 24)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 8)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_ECB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        des3_ecb_cipher = cipher;
+    }
+    return des3_ecb_cipher;
+}
+
 /* 3DES CBC EVP */
 static EVP_CIPHER *des3_cbc_cipher = NULL;
 static const EVP_CIPHER *cryptodev_3des_cbc(void)
@@ -629,6 +889,54 @@ static const EVP_CIPHER *cryptodev_3des_
     return des3_cbc_cipher;
 }
 
+/* 3DES CFB EVP */
+static EVP_CIPHER *des3_cfb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_3des_cfb(void)
+{
+    if (des3_cfb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_des_ede3_cfb64, 8, 24)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 8)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_CFB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        des3_cfb_cipher = cipher;
+    }
+    return des3_cfb_cipher;
+}
+
+/* 3DES OFB EVP */
+static EVP_CIPHER *des3_ofb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_3des_ofb(void)
+{
+    if (des3_ofb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_des_ede3_ofb64, 8, 24)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 8)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_OFB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        des3_ofb_cipher = cipher;
+    }
+    return des3_ofb_cipher;
+}
+
 static EVP_CIPHER *bf_cbc_cipher = NULL;
 static const EVP_CIPHER *cryptodev_bf_cbc(void)
 {
@@ -675,6 +983,77 @@ static const EVP_CIPHER *cryptodev_cast_
     return cast_cbc_cipher;
 }
 
+/* AES ECB EVP */
+static EVP_CIPHER *aes_ecb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_ecb(void)
+{
+    if (aes_ecb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_128_ecb, 16, 16)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 16)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_ECB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_ecb_cipher = cipher;
+    }
+    return aes_ecb_cipher;
+}
+
+static EVP_CIPHER *aes_192_ecb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_192_ecb(void)
+{
+    if (aes_192_ecb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_192_ecb, 16, 24)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 16)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_ECB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_192_ecb_cipher = cipher;
+    }
+    return aes_192_ecb_cipher;
+}
+
+static EVP_CIPHER *aes_256_ecb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_256_ecb(void)
+{
+    if (aes_256_ecb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_256_ecb, 16, 32)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 16)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_ECB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_256_ecb_cipher = cipher;
+    }
+    return aes_256_ecb_cipher;
+}
+
+/* AES CBC EVP */
 static EVP_CIPHER *aes_cbc_cipher = NULL;
 static const EVP_CIPHER *cryptodev_aes_cbc(void)
 {
@@ -745,6 +1124,7 @@ static const EVP_CIPHER *cryptodev_aes_2
 }
 
 # ifdef CRYPTO_AES_CTR
+/* AES CTR EVP */
 static EVP_CIPHER *aes_ctr_cipher = NULL;
 static const EVP_CIPHER *cryptodev_aes_ctr(void)
 {
@@ -814,6 +1194,286 @@ static const EVP_CIPHER *cryptodev_aes_2
     return aes_256_ctr_cipher;
 }
 # endif
+/* AES CFB128 EVP */
+static EVP_CIPHER *aes_cfb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_cfb(void)
+{
+    if (aes_cfb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_128_cfb128, 16, 16)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 14)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_CFB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_cfb_cipher = cipher;
+    }
+    return aes_cfb_cipher;
+}
+
+static EVP_CIPHER *aes_192_cfb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_192_cfb(void)
+{
+    if (aes_192_cfb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_192_cfb128, 16, 24)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 14)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_CFB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_192_cfb_cipher = cipher;
+    }
+    return aes_192_cfb_cipher;
+}
+
+static EVP_CIPHER *aes_256_cfb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_256_cfb(void)
+{
+    if (aes_256_cfb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_256_cfb128, 16, 32)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 14)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_CFB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_256_cfb_cipher = cipher;
+    }
+    return aes_256_cfb_cipher;
+}
+
+/* AES OFB EVP */
+static EVP_CIPHER *aes_ofb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_ofb(void)
+{
+    if (aes_ofb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_128_ofb128, 16, 16)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 16)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_OFB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_ofb_cipher = cipher;
+    }
+    return aes_ofb_cipher;
+}
+
+static EVP_CIPHER *aes_192_ofb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_192_ofb(void)
+{
+    if (aes_192_ofb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_192_ofb128, 16, 24)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 16)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_OFB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_192_ofb_cipher = cipher;
+    }
+    return aes_192_ofb_cipher;
+}
+
+static EVP_CIPHER *aes_256_ofb_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_256_ofb(void)
+{
+    if (aes_256_ofb_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_256_ofb128, 16, 32)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 16)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_OFB_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_256_ofb_cipher = cipher;
+    }
+    return aes_256_ofb_cipher;
+}
+
+/* AES GCM EVP */
+static EVP_CIPHER *aes_gcm_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_gcm(void)
+{
+    if (aes_gcm_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_128_gcm, 16, 16)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 16)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_GCM_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_gcm_cipher = cipher;
+    }
+    return aes_gcm_cipher;
+}
+
+static EVP_CIPHER *aes_192_gcm_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_192_gcm(void)
+{
+    if (aes_192_gcm_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_192_gcm, 16, 24)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 16)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_GCM_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_192_gcm_cipher = cipher;
+    }
+    return aes_192_gcm_cipher;
+}
+
+static EVP_CIPHER *aes_256_gcm_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_256_gcm(void)
+{
+    if (aes_256_gcm_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_256_gcm, 16, 32)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 16)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_GCM_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_256_gcm_cipher = cipher;
+    }
+    return aes_256_gcm_cipher;
+}
+
+/* AES CCM EVP */
+static EVP_CIPHER *aes_ccm_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_ccm(void)
+{
+    if (aes_ccm_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_128_ccm, 16, 16)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 16)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_CCM_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_ccm_cipher = cipher;
+    }
+    return aes_ccm_cipher;
+}
+
+static EVP_CIPHER *aes_192_ccm_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_192_ccm(void)
+{
+    if (aes_192_ccm_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_192_ccm, 16, 24)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 16)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_CCM_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_192_ccm_cipher = cipher;
+    }
+    return aes_192_ccm_cipher;
+}
+
+static EVP_CIPHER *aes_256_ccm_cipher = NULL;
+static const EVP_CIPHER *cryptodev_aes_256_ccm(void)
+{
+    if (aes_256_ccm_cipher == NULL) {
+        EVP_CIPHER *cipher;
+
+        if ((cipher = EVP_CIPHER_meth_new(NID_aes_256_ccm, 16, 32)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(cipher, 16)
+            || !EVP_CIPHER_meth_set_flags(cipher, EVP_CIPH_CCM_MODE)
+            || !EVP_CIPHER_meth_set_init(cipher, cryptodev_init_key)
+            || !EVP_CIPHER_meth_set_do_cipher(cipher, cryptodev_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(cipher, cryptodev_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(cipher, sizeof(struct dev_crypto_state))
+            || !EVP_CIPHER_meth_set_set_asn1_params(cipher, EVP_CIPHER_set_asn1_iv)
+            || !EVP_CIPHER_meth_set_get_asn1_params(cipher, EVP_CIPHER_get_asn1_iv)) {
+            EVP_CIPHER_meth_free(cipher);
+            cipher = NULL;
+        }
+        aes_256_ccm_cipher = cipher;
+    }
+    return aes_256_ccm_cipher;
+}
+
 /*
  * Registered by the ENGINE when used to find out how to deal with
  * a particular NID in the ENGINE. this says what we'll do at the
@@ -829,7 +1489,22 @@ cryptodev_engine_ciphers(ENGINE *e, cons
     switch (nid) {
     case NID_rc4:
         *cipher = cryptodev_rc4();
-        break;
+        break;       
+   case NID_des_ecb:
+       *cipher = cryptodev_des_ecb();
+       break;
+   case NID_des_ede3_ecb:
+       *cipher = cryptodev_3des_ecb();
+       break;    
+   case NID_aes_128_ecb:
+       *cipher = cryptodev_aes_ecb();
+       break;
+   case NID_aes_192_ecb:
+       *cipher = cryptodev_aes_192_ecb();
+       break;
+   case NID_aes_256_ecb:
+       *cipher = cryptodev_aes_256_ecb();
+       break;
     case NID_des_ede3_cbc:
         *cipher = cryptodev_3des_cbc();
         break;
@@ -850,6 +1525,45 @@ cryptodev_engine_ciphers(ENGINE *e, cons
         break;
     case NID_aes_256_cbc:
         *cipher = cryptodev_aes_256_cbc();
+        break;        
+    case NID_des_cfb64:
+        *cipher = cryptodev_des_cfb();
+        break;
+    case NID_des_ede3_cfb64:
+        *cipher = cryptodev_3des_cfb();
+        break;    
+    case NID_aes_128_cfb128:
+        *cipher = cryptodev_aes_cfb();
+        break;
+    case NID_aes_192_cfb128:
+        *cipher = cryptodev_aes_192_cfb();
+        break;
+    case NID_aes_256_cfb128:
+        *cipher = cryptodev_aes_256_cfb();
+        break;
+    case NID_des_ofb64:
+        *cipher = cryptodev_des_ofb();
+        break;
+    case NID_des_ede3_ofb64:
+        *cipher = cryptodev_3des_ofb();
+        break;    
+    case NID_aes_128_ofb128:
+        *cipher = cryptodev_aes_ofb();
+        break;
+    case NID_aes_192_ofb128:
+        *cipher = cryptodev_aes_192_ofb();
+        break;
+    case NID_aes_256_ofb128:
+        *cipher = cryptodev_aes_256_ofb();
+        break;
+    case NID_aes_128_gcm:
+        *cipher = cryptodev_aes_gcm();
+        break;
+    case NID_aes_192_gcm:
+        *cipher = cryptodev_aes_192_gcm();
+        break;
+    case NID_aes_256_gcm:
+        *cipher = cryptodev_aes_256_gcm();
         break;
 # ifdef CRYPTO_AES_CTR
     case NID_aes_128_ctr:
@@ -902,16 +1616,31 @@ static int cryptodev_digest_init(EVP_MD_
         printf("cryptodev_digest_init: Can't get digest \n");
         return (0);
     }
-
-    memset(state, 0, sizeof(*state));
+    if (NULL == EVP_MD_CTX_pkey_ctx(ctx)) {
+        memset(state, 0, sizeof(*state));
+    }    
+	else {
+        memset(state->dummy_mac_key, 0, sizeof(state->dummy_mac_key));
+        memset(&(state->d_sess), 0, sizeof( struct session_op ));
+        state->d_fd = 0;
+        memset(state->digest_res, 0, sizeof(state->digest_res));
+        state->mac_data = NULL;     /* for user data */
+        state->mac_len = 0;
+    }
 
     if ((state->d_fd = get_dev_crypto()) < 0) {
         printf("cryptodev_digest_init: Can't get Dev \n");
         return (0);
     }
-
-    sess->mackey = state->dummy_mac_key;
-    sess->mackeylen = digest_key_length(EVP_MD_CTX_type(ctx));
+    
+	if (NULL == EVP_MD_CTX_pkey_ctx(ctx)) {
+        sess->mackey = state->dummy_mac_key;
+        sess->mackeylen = digest_key_length(EVP_MD_CTX_type(ctx));
+    }    
+	else {
+        sess->mackey = state->mac_key;
+        sess->mackeylen = state->mac_key_len;
+    }
     sess->mac = digest;
 
     if (ioctl(state->d_fd, CIOCGSESSION, sess) < 0) {
@@ -932,13 +1661,13 @@ static int cryptodev_digest_update(EVP_M
     struct session_op *sess = &state->d_sess;
     char *new_mac_data;
 
-    if (!data || state->d_fd < 0) {
+    if ((!data && count != 0) || state->d_fd < 0) {
         printf("cryptodev_digest_update: illegal inputs \n");
         return (0);
     }
 
-    if (!count) {
-        return (0);
+    if (!count) {        
+        return (1); // allow null string such as ""        
     }
 
     if (!EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_ONESHOT)) {
@@ -960,8 +1689,9 @@ static int cryptodev_digest_update(EVP_M
 
     memset(&cryp, 0, sizeof(cryp));
 
-    cryp.ses = sess->ses;
-    cryp.flags = 0;
+    cryp.ses = sess->ses;    
+	cryp.op = COP_ENCRYPT;
+    cryp.flags = COP_FLAG_UPDATE;    
     cryp.len = count;
     cryp.src = (caddr_t) data;
     cryp.dst = NULL;
@@ -986,25 +1716,20 @@ static int cryptodev_digest_final(EVP_MD
         return (0);
     }
 
-    if (!EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_ONESHOT)) {
-        /* if application doesn't support one buffer */
-        memset(&cryp, 0, sizeof(cryp));
-        cryp.ses = sess->ses;
-        cryp.flags = 0;
-        cryp.len = state->mac_len;
-        cryp.src = state->mac_data;
-        cryp.dst = NULL;
-        cryp.mac = (caddr_t) md;
-        if (ioctl(state->d_fd, CIOCCRYPT, &cryp) < 0) {
-            printf("cryptodev_digest_final: digest failed\n");
-            return (0);
-        }
-
-        return 1;
+    /* if application doesn't support one buffer */
+    memset(&cryp, 0, sizeof(cryp));
+    cryp.ses = sess->ses;
+    cryp.op = COP_ENCRYPT;
+    cryp.flags = COP_FLAG_FINAL;
+    cryp.len = state->mac_len;
+    cryp.src = state->mac_data;
+    cryp.dst = NULL;
+    cryp.mac = (caddr_t) md;
+    if (ioctl(state->d_fd, CIOCCRYPT, &cryp) < 0) {
+        printf("cryptodev_digest_final: digest failed\n");
+        return (0);
     }
 
-    memcpy(md, state->digest_res, EVP_MD_CTX_size(ctx));
-
     return (ret);
 }
 
@@ -1054,18 +1779,18 @@ static int cryptodev_digest_copy(EVP_MD_
 
     digest = digest_nid_to_cryptodev(EVP_MD_CTX_type(to));
 
-    sess->mackey = dstate->dummy_mac_key;
-    sess->mackeylen = digest_key_length(EVP_MD_CTX_type(to));
-    sess->mac = digest;
-
-    dstate->d_fd = get_dev_crypto();
-
-    if (ioctl(dstate->d_fd, CIOCGSESSION, sess) < 0) {
-        put_dev_crypto(dstate->d_fd);
-        dstate->d_fd = -1;
-        printf("cryptodev_digest_copy: Open session failed\n");
-        return (0);
+    if (NULL == EVP_MD_CTX_pkey_ctx(from)) {
+        sess->mackey = dstate->dummy_mac_key;
+        sess->mackeylen = digest_key_length(EVP_MD_CTX_type(to));
+    }
+    else {
+        sess->mackey = dstate->mac_key;
+        sess->mackeylen = dstate->mac_key_len;
     }
+    sess->mac = digest;
+    
+    /* use the sess of the from */
+    memcpy(sess, &(fstate->d_sess), sizeof(struct session_op));
 
     if (fstate->mac_len != 0) {
         if (fstate->mac_data != NULL) {
@@ -1082,6 +1807,206 @@ static int cryptodev_digest_copy(EVP_MD_
     return 1;
 }
 
+static EVP_MD *sha512_md = NULL;
+static const EVP_MD *cryptodev_sha512(void)
+{
+    if (sha512_md == NULL) {
+        EVP_MD *md;
+
+        if ((md = EVP_MD_meth_new(NID_sha512, NID_undef)) == NULL
+            || !EVP_MD_meth_set_result_size(md, SHA512_DIGEST_LENGTH)
+            || !EVP_MD_meth_set_flags(md, EVP_MD_FLAG_ONESHOT)
+            || !EVP_MD_meth_set_input_blocksize(md, SHA512_CBLOCK)
+            || !EVP_MD_meth_set_app_datasize(md,
+                                             sizeof(struct dev_crypto_state))
+            || !EVP_MD_meth_set_init(md, cryptodev_digest_init)
+            || !EVP_MD_meth_set_update(md, cryptodev_digest_update)
+            || !EVP_MD_meth_set_final(md, cryptodev_digest_final)
+            || !EVP_MD_meth_set_copy(md, cryptodev_digest_copy)
+            || !EVP_MD_meth_set_cleanup(md, cryptodev_digest_cleanup)) {
+            EVP_MD_meth_free(md);
+            md = NULL;
+        }
+        sha512_md = md;
+    }
+    return sha512_md;
+}
+
+static EVP_MD *hmac_sha512_md = NULL;
+static const EVP_MD *cryptodev_hmac_sha512(void)
+{
+    if (hmac_sha512_md == NULL) {
+        EVP_MD *md;
+
+        if ((md = EVP_MD_meth_new(NID_hmacWithSHA512, NID_undef)) == NULL
+            || !EVP_MD_meth_set_result_size(md, SHA512_DIGEST_LENGTH)
+            || !EVP_MD_meth_set_flags(md, EVP_MD_FLAG_ONESHOT)
+            || !EVP_MD_meth_set_input_blocksize(md, SHA512_CBLOCK)
+            || !EVP_MD_meth_set_app_datasize(md,
+                                             sizeof(struct dev_crypto_state))
+            || !EVP_MD_meth_set_init(md, cryptodev_digest_init)
+            || !EVP_MD_meth_set_update(md, cryptodev_digest_update)
+            || !EVP_MD_meth_set_final(md, cryptodev_digest_final)
+            || !EVP_MD_meth_set_copy(md, cryptodev_digest_copy)
+            || !EVP_MD_meth_set_cleanup(md, cryptodev_digest_cleanup)) {
+            EVP_MD_meth_free(md);
+            md = NULL;
+        }
+        hmac_sha512_md = md;
+    }
+    return hmac_sha512_md;
+}
+
+static EVP_MD *sha384_md = NULL;
+static const EVP_MD *cryptodev_sha384(void)
+{
+    if (sha384_md == NULL) {
+        EVP_MD *md;
+
+        if ((md = EVP_MD_meth_new(NID_sha384, NID_undef)) == NULL
+            || !EVP_MD_meth_set_result_size(md, SHA384_DIGEST_LENGTH)
+            || !EVP_MD_meth_set_flags(md, EVP_MD_FLAG_ONESHOT)
+            || !EVP_MD_meth_set_input_blocksize(md, SHA512_CBLOCK)
+            || !EVP_MD_meth_set_app_datasize(md,
+                                             sizeof(struct dev_crypto_state))
+            || !EVP_MD_meth_set_init(md, cryptodev_digest_init)
+            || !EVP_MD_meth_set_update(md, cryptodev_digest_update)
+            || !EVP_MD_meth_set_final(md, cryptodev_digest_final)
+            || !EVP_MD_meth_set_copy(md, cryptodev_digest_copy)
+            || !EVP_MD_meth_set_cleanup(md, cryptodev_digest_cleanup)) {
+            EVP_MD_meth_free(md);
+            md = NULL;
+        }
+        sha384_md = md;
+    }
+    return sha384_md;
+}
+
+static EVP_MD *hmac_sha384_md = NULL;
+static const EVP_MD *cryptodev_hmac_sha384(void)
+{
+    if (hmac_sha384_md == NULL) {
+        EVP_MD *md;
+
+        if ((md = EVP_MD_meth_new(NID_hmacWithSHA384, NID_undef)) == NULL
+            || !EVP_MD_meth_set_result_size(md, SHA384_DIGEST_LENGTH)
+            || !EVP_MD_meth_set_flags(md, EVP_MD_FLAG_ONESHOT)
+            || !EVP_MD_meth_set_input_blocksize(md, SHA512_CBLOCK)
+            || !EVP_MD_meth_set_app_datasize(md,
+                                             sizeof(struct dev_crypto_state))
+            || !EVP_MD_meth_set_init(md, cryptodev_digest_init)
+            || !EVP_MD_meth_set_update(md, cryptodev_digest_update)
+            || !EVP_MD_meth_set_final(md, cryptodev_digest_final)
+            || !EVP_MD_meth_set_copy(md, cryptodev_digest_copy)
+            || !EVP_MD_meth_set_cleanup(md, cryptodev_digest_cleanup)) {
+            EVP_MD_meth_free(md);
+            md = NULL;
+        }
+        hmac_sha384_md = md;
+    }
+    return hmac_sha384_md;
+}
+
+static EVP_MD *sha256_md = NULL;
+static const EVP_MD *cryptodev_sha256(void)
+{
+    if (sha256_md == NULL) {
+        EVP_MD *md;
+
+        if ((md = EVP_MD_meth_new(NID_sha256, NID_undef)) == NULL
+            || !EVP_MD_meth_set_result_size(md, SHA256_DIGEST_LENGTH)
+            || !EVP_MD_meth_set_flags(md, EVP_MD_FLAG_ONESHOT)
+            || !EVP_MD_meth_set_input_blocksize(md, SHA256_CBLOCK)
+            || !EVP_MD_meth_set_app_datasize(md,
+                                             sizeof(struct dev_crypto_state))
+            || !EVP_MD_meth_set_init(md, cryptodev_digest_init)
+            || !EVP_MD_meth_set_update(md, cryptodev_digest_update)
+            || !EVP_MD_meth_set_final(md, cryptodev_digest_final)
+            || !EVP_MD_meth_set_copy(md, cryptodev_digest_copy)
+            || !EVP_MD_meth_set_cleanup(md, cryptodev_digest_cleanup)) {
+            EVP_MD_meth_free(md);
+            md = NULL;
+        }
+        sha256_md = md;
+    }
+    return sha256_md;
+}
+
+static EVP_MD *hmac_sha256_md = NULL;
+static const EVP_MD *cryptodev_hmac_sha256(void)
+{
+    if (hmac_sha256_md == NULL) {
+        EVP_MD *md;
+
+        if ((md = EVP_MD_meth_new(NID_hmacWithSHA256, NID_undef)) == NULL
+            || !EVP_MD_meth_set_result_size(md, SHA256_DIGEST_LENGTH)
+            || !EVP_MD_meth_set_flags(md, EVP_MD_FLAG_ONESHOT)
+            || !EVP_MD_meth_set_input_blocksize(md, SHA256_CBLOCK)
+            || !EVP_MD_meth_set_app_datasize(md,
+                                             sizeof(struct dev_crypto_state))
+            || !EVP_MD_meth_set_init(md, cryptodev_digest_init)
+            || !EVP_MD_meth_set_update(md, cryptodev_digest_update)
+            || !EVP_MD_meth_set_final(md, cryptodev_digest_final)
+            || !EVP_MD_meth_set_copy(md, cryptodev_digest_copy)
+            || !EVP_MD_meth_set_cleanup(md, cryptodev_digest_cleanup)) {
+            EVP_MD_meth_free(md);
+            md = NULL;
+        }
+        hmac_sha256_md = md;
+    }
+    return hmac_sha256_md;
+}
+
+static EVP_MD *sha224_md = NULL;
+static const EVP_MD *cryptodev_sha224(void)
+{
+    if (sha224_md == NULL) {
+        EVP_MD *md;
+
+        if ((md = EVP_MD_meth_new(NID_sha224, NID_undef)) == NULL
+            || !EVP_MD_meth_set_result_size(md, SHA224_DIGEST_LENGTH)
+            || !EVP_MD_meth_set_flags(md, EVP_MD_FLAG_ONESHOT)
+            || !EVP_MD_meth_set_input_blocksize(md, SHA256_CBLOCK)
+            || !EVP_MD_meth_set_app_datasize(md,
+                                             sizeof(struct dev_crypto_state))
+            || !EVP_MD_meth_set_init(md, cryptodev_digest_init)
+            || !EVP_MD_meth_set_update(md, cryptodev_digest_update)
+            || !EVP_MD_meth_set_final(md, cryptodev_digest_final)
+            || !EVP_MD_meth_set_copy(md, cryptodev_digest_copy)
+            || !EVP_MD_meth_set_cleanup(md, cryptodev_digest_cleanup)) {
+            EVP_MD_meth_free(md);
+            md = NULL;
+        }
+        sha224_md = md;
+    }
+    return sha224_md;
+}
+
+static EVP_MD *hmac_sha224_md = NULL;
+static const EVP_MD *cryptodev_hmac_sha224(void)
+{
+    if (hmac_sha224_md == NULL) {
+        EVP_MD *md;
+
+        if ((md = EVP_MD_meth_new(NID_hmacWithSHA224, NID_undef)) == NULL
+            || !EVP_MD_meth_set_result_size(md, SHA224_DIGEST_LENGTH)
+            || !EVP_MD_meth_set_flags(md, EVP_MD_FLAG_ONESHOT)
+            || !EVP_MD_meth_set_input_blocksize(md, SHA256_CBLOCK)
+            || !EVP_MD_meth_set_app_datasize(md,
+                                             sizeof(struct dev_crypto_state))
+            || !EVP_MD_meth_set_init(md, cryptodev_digest_init)
+            || !EVP_MD_meth_set_update(md, cryptodev_digest_update)
+            || !EVP_MD_meth_set_final(md, cryptodev_digest_final)
+            || !EVP_MD_meth_set_copy(md, cryptodev_digest_copy)
+            || !EVP_MD_meth_set_cleanup(md, cryptodev_digest_cleanup)) {
+            EVP_MD_meth_free(md);
+            md = NULL;
+        }
+        hmac_sha224_md = md;
+    }
+    return hmac_sha224_md;
+}
+
 static EVP_MD *sha1_md = NULL;
 static const EVP_MD *cryptodev_sha1(void)
 {
@@ -1107,6 +2032,31 @@ static const EVP_MD *cryptodev_sha1(void
     return sha1_md;
 }
 
+static EVP_MD *hmac_sha1_md = NULL;
+static const EVP_MD *cryptodev_hmac_sha1(void)
+{
+    if (hmac_sha1_md == NULL) {
+        EVP_MD *md;
+
+        if ((md = EVP_MD_meth_new(NID_hmacWithSHA1, NID_undef)) == NULL
+            || !EVP_MD_meth_set_result_size(md, SHA_DIGEST_LENGTH)
+            || !EVP_MD_meth_set_flags(md, EVP_MD_FLAG_ONESHOT)
+            || !EVP_MD_meth_set_input_blocksize(md, SHA_CBLOCK)
+            || !EVP_MD_meth_set_app_datasize(md,
+                                             sizeof(struct dev_crypto_state))
+            || !EVP_MD_meth_set_init(md, cryptodev_digest_init)
+            || !EVP_MD_meth_set_update(md, cryptodev_digest_update)
+            || !EVP_MD_meth_set_final(md, cryptodev_digest_final)
+            || !EVP_MD_meth_set_copy(md, cryptodev_digest_copy)
+            || !EVP_MD_meth_set_cleanup(md, cryptodev_digest_cleanup)) {
+            EVP_MD_meth_free(md);
+            md = NULL;
+        }
+        hmac_sha1_md = md;
+    }
+    return hmac_sha1_md;
+}
+
 static EVP_MD *md5_md = NULL;
 static const EVP_MD *cryptodev_md5(void)
 {
@@ -1132,6 +2082,31 @@ static const EVP_MD *cryptodev_md5(void)
     return md5_md;
 }
 
+static EVP_MD *hmac_md5_md = NULL;
+static const EVP_MD *cryptodev_hmac_md5(void)
+{
+    if (hmac_md5_md == NULL) {
+        EVP_MD *md;
+
+        if ((md = EVP_MD_meth_new(NID_hmacWithMD5, NID_undef)) == NULL
+            || !EVP_MD_meth_set_result_size(md, 16 /* MD5_DIGEST_LENGTH */)
+            || !EVP_MD_meth_set_flags(md, EVP_MD_FLAG_ONESHOT)
+            || !EVP_MD_meth_set_input_blocksize(md, 64 /* MD5_CBLOCK */)
+            || !EVP_MD_meth_set_app_datasize(md,
+                                             sizeof(struct dev_crypto_state))
+            || !EVP_MD_meth_set_init(md, cryptodev_digest_init)
+            || !EVP_MD_meth_set_update(md, cryptodev_digest_update)
+            || !EVP_MD_meth_set_final(md, cryptodev_digest_final)
+            || !EVP_MD_meth_set_copy(md, cryptodev_digest_copy)
+            || !EVP_MD_meth_set_cleanup(md, cryptodev_digest_cleanup)) {
+            EVP_MD_meth_free(md);
+            md = NULL;
+        }
+        hmac_md5_md = md;
+    }
+    return hmac_md5_md;
+}
+
 # endif                         /* USE_CRYPTODEV_DIGESTS */
 
 static int
@@ -1145,10 +2120,40 @@ cryptodev_engine_digests(ENGINE *e, cons
 # ifdef USE_CRYPTODEV_DIGESTS
     case NID_md5:
         *digest = cryptodev_md5();
+        break;        
+    case NID_hmacWithMD5:
+        *digest = cryptodev_hmac_md5();
         break;
     case NID_sha1:
         *digest = cryptodev_sha1();
         break;
+    case NID_hmacWithSHA1:
+        *digest = cryptodev_hmac_sha1();
+        break;
+	case NID_sha224:
+        *digest = cryptodev_sha224();
+        break;
+	case NID_hmacWithSHA224:
+        *digest = cryptodev_hmac_sha224();
+        break;
+	case NID_sha256:
+        *digest = cryptodev_sha256();
+        break;
+	case NID_hmacWithSHA256:
+        *digest = cryptodev_hmac_sha256();
+        break;
+	case NID_sha384:
+        *digest = cryptodev_sha384();
+        break;
+	case NID_hmacWithSHA384:
+        *digest = cryptodev_hmac_sha384();
+        break;
+	case NID_sha512:
+        *digest = cryptodev_sha512();
+        break;
+	case NID_hmacWithSHA512:
+        *digest = cryptodev_hmac_sha512();
+        break;
     default:
 # endif                         /* USE_CRYPTODEV_DIGESTS */
         *digest = NULL;
@@ -1161,20 +2166,50 @@ static int cryptodev_engine_destroy(ENGI
 {
     EVP_CIPHER_meth_free(rc4_cipher);
     rc4_cipher = NULL;
+    EVP_CIPHER_meth_free(des_ecb_cipher);
+    des_ecb_cipher = NULL;
     EVP_CIPHER_meth_free(des_cbc_cipher);
     des_cbc_cipher = NULL;
+    EVP_CIPHER_meth_free(des_cfb_cipher);
+    des_cfb_cipher = NULL;
+    EVP_CIPHER_meth_free(des_ofb_cipher);
+    des_ofb_cipher = NULL;
+    EVP_CIPHER_meth_free(des3_ecb_cipher);
+    des3_ecb_cipher = NULL;
     EVP_CIPHER_meth_free(des3_cbc_cipher);
     des3_cbc_cipher = NULL;
+    EVP_CIPHER_meth_free(des3_cfb_cipher);
+    des3_cfb_cipher = NULL;
+    EVP_CIPHER_meth_free(des3_ofb_cipher);
+    des3_ofb_cipher = NULL;
     EVP_CIPHER_meth_free(bf_cbc_cipher);
     bf_cbc_cipher = NULL;
     EVP_CIPHER_meth_free(cast_cbc_cipher);
     cast_cbc_cipher = NULL;
+    EVP_CIPHER_meth_free(aes_ecb_cipher);
+    aes_ecb_cipher = NULL;
+    EVP_CIPHER_meth_free(aes_192_ecb_cipher);
+    aes_192_ecb_cipher = NULL;
+    EVP_CIPHER_meth_free(aes_256_ecb_cipher);
+    aes_256_ecb_cipher = NULL;
     EVP_CIPHER_meth_free(aes_cbc_cipher);
     aes_cbc_cipher = NULL;
     EVP_CIPHER_meth_free(aes_192_cbc_cipher);
     aes_192_cbc_cipher = NULL;
     EVP_CIPHER_meth_free(aes_256_cbc_cipher);
     aes_256_cbc_cipher = NULL;
+    EVP_CIPHER_meth_free(aes_cfb_cipher);
+    aes_cfb_cipher = NULL;
+    EVP_CIPHER_meth_free(aes_192_cfb_cipher);
+    aes_192_cfb_cipher = NULL;
+    EVP_CIPHER_meth_free(aes_256_cfb_cipher);
+    aes_256_cfb_cipher = NULL;
+    EVP_CIPHER_meth_free(aes_ofb_cipher);
+    aes_ofb_cipher = NULL;
+    EVP_CIPHER_meth_free(aes_192_ofb_cipher);
+    aes_192_ofb_cipher = NULL;
+    EVP_CIPHER_meth_free(aes_256_ofb_cipher);
+    aes_256_ofb_cipher = NULL;
 # ifdef CRYPTO_AES_CTR
     EVP_CIPHER_meth_free(aes_ctr_cipher);
     aes_ctr_cipher = NULL;
@@ -1183,11 +2218,38 @@ static int cryptodev_engine_destroy(ENGI
     EVP_CIPHER_meth_free(aes_256_ctr_cipher);
     aes_256_ctr_cipher = NULL;
 # endif
+    EVP_CIPHER_meth_free(aes_gcm_cipher);
+    aes_gcm_cipher = NULL;
+    EVP_CIPHER_meth_free(aes_192_gcm_cipher);
+    aes_192_gcm_cipher = NULL;
+    EVP_CIPHER_meth_free(aes_256_gcm_cipher);
+    aes_256_gcm_cipher = NULL;
+
 # ifdef USE_CRYPTODEV_DIGESTS
+    EVP_MD_meth_free(sha512_md);
+    sha512_md = NULL;
+    EVP_MD_meth_free(hmac_sha512_md);
+    hmac_sha512_md = NULL;
+    EVP_MD_meth_free(sha384_md);
+    sha384_md = NULL;
+    EVP_MD_meth_free(hmac_sha384_md);
+    hmac_sha384_md = NULL;
+    EVP_MD_meth_free(sha256_md);
+    sha256_md = NULL;
+    EVP_MD_meth_free(hmac_sha256_md);
+    hmac_sha256_md = NULL;
+    EVP_MD_meth_free(sha224_md);
+    sha224_md = NULL;
+    EVP_MD_meth_free(hmac_sha224_md);
+    hmac_sha224_md = NULL;
     EVP_MD_meth_free(sha1_md);
     sha1_md = NULL;
+    EVP_MD_meth_free(hmac_sha1_md);
+    hmac_sha1_md = NULL;
     EVP_MD_meth_free(md5_md);
     md5_md = NULL;
+    EVP_MD_meth_free(hmac_md5_md);
+    hmac_md5_md = NULL;
 # endif
     RSA_meth_free(cryptodev_rsa);
     cryptodev_rsa = NULL;
@@ -1209,6 +2271,7 @@ static int cryptodev_engine_destroy(ENGI
  */
 static int bn2crparam(const BIGNUM *a, struct crparam *crp)
 {
+    int i, j, k;
     ssize_t bytes, bits;
     u_char *b;
 
@@ -1216,19 +2279,28 @@ static int bn2crparam(const BIGNUM *a, s
     crp->crp_nbits = 0;
 
     bits = BN_num_bits(a);
-    bytes = BN_num_bytes(a);
+    bytes = (bits + 7) / 8;
 
-    b = OPENSSL_zalloc(bytes);
+    b = malloc(bytes);
     if (b == NULL)
         return (1);
+    memset(b, 0, bytes);
 
     crp->crp_p = (caddr_t) b;
     crp->crp_nbits = bits;
 
-    BN_bn2bin(a, b);
+    for (i = 0, j = 0; i < a->top; i++) {
+        for (k = 0; k < BN_BITS2 / 8; k++) {
+            if ((j + k) >= bytes)
+                return (0);
+            b[j + k] = a->d[i] >> (k * 8);
+        }
+        j += BN_BITS2 / 8;
+    }
     return (0);
 }
 
+
 /* Convert a /dev/crypto parameter to a BIGNUM */
 static int crparam2bn(struct crparam *crp, BIGNUM *a)
 {
@@ -1240,14 +2312,14 @@ static int crparam2bn(struct crparam *cr
     if (bytes == 0)
         return (-1);
 
-    if ((pd = OPENSSL_malloc(bytes)) == NULL)
+    if ((pd = (u_int8_t *)OPENSSL_malloc(bytes)) == NULL)
         return (-1);
 
     for (i = 0; i < bytes; i++)
         pd[i] = crp->crp_p[bytes - i - 1];
 
     BN_bin2bn(pd, bytes, a);
-    free(pd);
+    OPENSSL_free(pd);
 
     return (0);
 }
@@ -1263,372 +2335,5205 @@ static void zapparams(struct crypt_kop *
     }
 }
 
-static int
-cryptodev_asym(struct crypt_kop *kop, int rlen, BIGNUM *r, int slen,
-               BIGNUM *s)
+static int curve2field(int curve_nid)
 {
-    int fd, ret = -1;
+    switch (curve_nid) {
+        case NID_secp160k1:
+        case NID_secp160r1:
+        case NID_secp160r2:
+        case NID_secp192k1:
+        case NID_secp224k1:
+        case NID_secp224r1:
+        case NID_secp256k1:
+        case NID_secp384r1:
+        case NID_secp521r1:
+        case NID_X9_62_prime192v1:
+        case NID_X9_62_prime192v2:
+        case NID_X9_62_prime192v3:
+        case NID_X9_62_prime239v1:
+        case NID_X9_62_prime239v2:
+        case NID_X9_62_prime239v3:
+        case NID_X9_62_prime256v1:
+        case NID_wap_wsg_idm_ecid_wtls6:
+        case NID_wap_wsg_idm_ecid_wtls7:
+        case NID_wap_wsg_idm_ecid_wtls8:
+        case NID_wap_wsg_idm_ecid_wtls9:
+        case NID_wap_wsg_idm_ecid_wtls12:
+        case NID_brainpoolP160r1:
+        case NID_brainpoolP160t1:
+        case NID_brainpoolP192r1:
+        case NID_brainpoolP192t1:
+        case NID_brainpoolP224r1:
+        case NID_brainpoolP224t1:
+        case NID_brainpoolP256r1:
+        case NID_brainpoolP256t1:
+        case NID_brainpoolP320r1:
+        case NID_brainpoolP320t1:
+        case NID_brainpoolP384r1:
+        case NID_brainpoolP384t1:
+        case NID_brainpoolP512r1:
+        case NID_brainpoolP512t1:
+#ifndef OPENSSL_NO_SM2
+        case NID_sm2p256v1:
+        case NID_wapip192v1:
+#endif
+            return KCOP_FLAG_INTEGER_ARITH;
+        case NID_sect163k1:
+        case NID_sect163r1:
+        case NID_sect163r2:
+        case NID_sect193r1:
+        case NID_sect193r2:
+        case NID_sect233k1:
+        case NID_sect233r1:
+        case NID_sect239k1:
+        case NID_sect283k1:
+        case NID_sect283r1:
+        case NID_sect409k1:
+        case NID_sect409r1:
+        case NID_sect571k1:
+        case NID_sect571r1:
+        case NID_X9_62_c2pnb163v1:
+        case NID_X9_62_c2pnb163v2:
+        case NID_X9_62_c2pnb163v3:
+        case NID_X9_62_c2pnb176v1:
+        case NID_X9_62_c2tnb191v1:
+        case NID_X9_62_c2tnb191v2:
+        case NID_X9_62_c2tnb191v3:
+        case NID_X9_62_c2pnb208w1:
+        case NID_X9_62_c2tnb239v1:
+        case NID_X9_62_c2tnb239v2:
+        case NID_X9_62_c2tnb239v3:
+        case NID_X9_62_c2pnb272w1:
+        case NID_X9_62_c2pnb304w1:
+        case NID_X9_62_c2tnb359v1:
+        case NID_X9_62_c2pnb368w1:
+        case NID_X9_62_c2tnb431r1:
+        case NID_wap_wsg_idm_ecid_wtls1:
+        case NID_wap_wsg_idm_ecid_wtls3:
+        case NID_wap_wsg_idm_ecid_wtls4:
+        case NID_wap_wsg_idm_ecid_wtls5:
+        case NID_wap_wsg_idm_ecid_wtls10:
+        case NID_wap_wsg_idm_ecid_wtls11:
+            return KCOP_FLAG_F2M_ARITH;
+        default:
+            return KCOP_FLAG_NONE;
+    }
+}
 
-    if ((fd = get_asym_dev_crypto()) < 0)
-        return ret;
+#define BITS_TO_CHARS(i)   (((i) + 7) / 8)       
+#define BITS_TO_UINT32(i)  (((i) + 31) / 32)    
+#define CHARS_TO_UINT32(i) (((i) + 3) / 4)   
+#define CHARS_TO_BITS(i)   (i * 8)                          
 
-    if (r) {
-        kop->crk_param[kop->crk_iparams].crp_p = OPENSSL_zalloc(rlen);
-        if (kop->crk_param[kop->crk_iparams].crp_p == NULL)
-            return ret;
-        kop->crk_param[kop->crk_iparams].crp_nbits = rlen * 8;
-        kop->crk_oparams++;
+#define BYTES_ALIGNED4(y)  (((y) & 3) ? (y) + (4 - ((y) & 3)) : (y))
+#define UINT32_TO_BYTES(i)  ((i) << 2)
+
+#ifdef CRYPTODEV_BN_DEBUG
+static char *bn_hex;
+#endif
+
+static const int small_prime[] =
+{
+        3,    5,    7,   11,   13,   17,   19,   23,
+       29,   31,   37,   41,   43,   47,   53,   59,
+       61,   67,   71,   73,   79,   83,   89,   97,
+      101,  103,  107,  109,  113,  127,  131,  137,
+      139,  149,  151,  157,  163,  167,  173,  179,
+      181,  191,  193,  197,  199,  211,  223,  227,
+      229,  233,  239,  241,  251,  257,  263,  269,
+      271,  277,  281,  283,  293,  307,  311,  313,
+      317,  331,  337,  347,  349,  353,  359,  367,
+      373,  379,  383,  389,  397,  401,  409,  419,
+      421,  431,  433,  439,  443,  449,  457,  461,
+      463,  467,  479,  487,  491,  499,  503,  509,
+      521,  523,  541,  547,  557,  563,  569,  571,
+      577,  587,  593,  599,  601,  607,  613,  617,
+      619,  631,  641,  643,  647,  653,  659,  661,
+      673,  677,  683,  691,  701,  709,  719,  727,
+      733,  739,  743,  751,  757,  761,  769,  773,
+      787,  797,  809,  811,  821,  823,  827,  829,
+      839,  853,  857,  859,  863,  877,  881,  883,
+      887,  907,  911,  919,  929,  937,  941,  947,
+      953,  967,  971,  977,  983,  991,  997, -103
+};
+
+static inline int int_swap(unsigned char *A, unsigned short sizeA)
+{
+	int i;
+	unsigned char *p;
+	
+	p = (unsigned char *)OPENSSL_malloc(sizeA);
+	
+	if (!p)
+		return -1;
+
+	memcpy(p, A, sizeA);
+
+	for(i = 0; i < sizeA; i++)
+		A[i] = p[sizeA - 1 - i];
+
+	OPENSSL_free(p);
+
+	return 0;
+}
+BIGNUM *cryptodev_bn_wexpand(BIGNUM *b, int words)
+{
+    BIGNUM *bn_p = NULL;
+    bn_p = bn_wexpand( b, words );
+    if (bn_p) {
+        bn_p->top = words;
     }
-    if (s) {
-        kop->crk_param[kop->crk_iparams + 1].crp_p =
-            OPENSSL_zalloc(slen);
-        /* No need to free the kop->crk_iparams parameter if it was allocated,
-         * callers of this routine have to free allocated parameters through
-         * zapparams both in case of success and failure
-         */
-        if (kop->crk_param[kop->crk_iparams+1].crp_p == NULL)
-            return ret;
-        kop->crk_param[kop->crk_iparams + 1].crp_nbits = slen * 8;
-        kop->crk_oparams++;
+#ifdef CRYPTODEV_BN_DEBUG
+    printf("b->top %d\n", b->top);
+#endif
+    return bn_p;
+}
+BIGNUM *cryptodev_bn_expand(BIGNUM *b, int bits)
+{
+    BIGNUM * bn_p = NULL;
+    bn_p = bn_expand( b, bits );
+    if (bn_p) {
+        bn_p->top =  (bits + (BN_BITS2 - 1))/BN_BITS2;
+    }
+#ifdef CRYPTODEV_BN_DEBUG
+    printf("b->top %d\n", b->top);
+#endif
+    return bn_p;
+}
+static size_t bignum_hw_base_size( const BIGNUM *X , int start_offset_bytes)
+{
+#if (HW_BASE_sections == 1)
+    return HW_BASE_chars;
+#else
+    int i, j, mpi_bytes;
+    unsigned char *chp;
+    
+#ifdef CRYPTODEV_BN_DEBUG
+    printf("HW_BASE_bits = %d, HW_BASE_chars = %d , HW_BASE_limbs= %d\n", HW_BASE_bits, HW_BASE_chars, HW_BASE_sections);
+#endif
+    mpi_bytes = (X->top) << 2  /* * sizeof(unsigned int)*/;
+    chp = (unsigned char *) (X->d);
+    
+    if ((start_offset_bytes + HW_BASE_chars) <= mpi_bytes) {
+        j = start_offset_bytes + HW_BASE_chars;
+    }
+    else {
+        j = mpi_bytes;
     }
 
-    if (ioctl(fd, CIOCKEY, kop) == 0) {
-        if (r)
-            crparam2bn(&kop->crk_param[kop->crk_iparams], r);
-        if (s)
-            crparam2bn(&kop->crk_param[kop->crk_iparams + 1], s);
-        ret = 0;
+    for( i = j ; i > start_offset_bytes; i--) {
+        if ( chp[i - 1] != 0 )
+            break;
+    }
+    
+    j = i - start_offset_bytes;
+    return (j < sizeof(unsigned int)) ? sizeof(unsigned int) : j;
+#endif
+}
+
+/* Execute Miller-Rabin primality test 
+    N = Candidate prime integer
+    A = An initial random seed for the base value of exponentiation; can be any integer 2 < A < N - 2
+    B = "t" parameter, which is the number of trial runs. By default, it is set at 1 or B[7:0]
+*/
+static inline int hw_primality_test(unsigned char *A,
+                                unsigned short sizeA,
+                                unsigned char *B,
+                                unsigned short sizeB,
+                                unsigned char *N,
+                                unsigned short sizeN,
+                                bool *result)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
     }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_PRIMALITY_TEST;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_primality_test: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+#ifndef HW_ENDIAN_SWAP
+	int_swap(A, sizeA);
+    if(B != A) int_swap(B, sizeB);
+    if((N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = sizeB * 8;
 
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = sizeN * 8;    
+
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_PRIMALITY_TEST;
+    kop.crk_flags = 0;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 0;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_primality_test ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result = kop.crk_status == 1 ? true : false;   
+#ifndef HW_ENDIAN_SWAP
+    int_swap(A, sizeA);
+    if(B != A) int_swap(B, sizeB);
+    if((N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+
+out:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_primality_test: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
     return ret;
 }
 
-static int
-cryptodev_bn_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                     const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
+static inline int hw_mod_inv(unsigned char *A,
+                         unsigned short sizeA,
+                         unsigned char *N,
+                         unsigned short sizeN,
+                         unsigned char *result,
+                         unsigned short *result_size)
 {
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
     struct crypt_kop kop;
-    int ret = 1;
 
-    /*
-     * Currently, we know we can do mod exp iff we can do any asymmetric
-     * operations at all.
-     */
-    if (cryptodev_asymfeat == 0) {
-        ret = BN_mod_exp(r, a, p, m, ctx);
-        return (ret);
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
     }
-
+    memset(&sess, 0, sizeof(sess));
     memset(&kop, 0, sizeof(kop));
-    kop.crk_op = CRK_MOD_EXP;
+    sess.pk_cipher = CRYPTO_PKHA_MOD_INV;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_mod_inv: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+
+#ifndef HW_ENDIAN_SWAP
+	int_swap(A, sizeA);
+    if(N != A) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+    kop.crk_param[1].crp_p = N;
+    kop.crk_param[1].crp_nbits = sizeN * 8;    
+    kop.crk_param[2].crp_p = result;
+    kop.crk_param[2].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_MOD_INV;
+    kop.crk_flags = KCOP_FLAG_INTEGER_ARITH;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 2;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_mod_inv ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result_size = kop.crk_param[2].crp_nbits/8; 
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result, *result_size);    
+#endif
 
-    /* inputs: a^p % m */
-    if (bn2crparam(a, &kop.crk_param[0]))
+out:
+#ifndef HW_ENDIAN_SWAP
+    if(A != result) int_swap(A, sizeA);
+    if((N != result) && (N != A)) int_swap(N, sizeN);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_mod_inv: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_mod_red(unsigned char *A,
+                         unsigned short sizeA,
+                         unsigned char *N,
+                         unsigned short sizeN,
+                         unsigned char *result,
+                         unsigned short *result_size)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_MOD_RED;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_mod_red: ioctl(CIOCGSESSION)");
+        ret = -1;
         goto err;
-    if (bn2crparam(p, &kop.crk_param[1]))
+	}
+
+#ifndef HW_ENDIAN_SWAP
+	int_swap(A, sizeA);
+    if(N != A) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+    kop.crk_param[1].crp_p = N;
+    kop.crk_param[1].crp_nbits = sizeN * 8;    
+    kop.crk_param[2].crp_p = result;
+    kop.crk_param[2].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_MOD_RED;
+    kop.crk_flags = KCOP_FLAG_INTEGER_ARITH;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 2;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_mod_red ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result_size = (kop.crk_param[2].crp_nbits + 7)/8;   
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result, *result_size);    
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    if(A != result) int_swap(A, sizeA);
+    if((N != result) && (N != A)) int_swap(N, sizeN);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_mod_red: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_mod_gcd(unsigned char *A,
+                         unsigned short sizeA,
+                         unsigned char *N,
+                         unsigned short sizeN,
+                         unsigned char *result,
+                         unsigned short *result_size)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_GCD;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_mod_gcd: ioctl(CIOCGSESSION)");
+        ret = -1;
         goto err;
-    if (bn2crparam(m, &kop.crk_param[2]))
+	}
+#ifndef HW_ENDIAN_SWAP
+	int_swap(A, sizeA);
+    if(N != A) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+    kop.crk_param[1].crp_p = N;
+    kop.crk_param[1].crp_nbits = sizeN * 8;    
+    kop.crk_param[2].crp_p = result;
+    kop.crk_param[2].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_GCD;
+    kop.crk_flags = KCOP_FLAG_INTEGER_ARITH;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 2;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_mod_gcd ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result_size = (kop.crk_param[2].crp_nbits + 7)/8;    
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result, *result_size);    
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    if(A != result) int_swap(A, sizeA);
+    if((N != result) && (N != A)) int_swap(N, sizeN);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_mod_gcd: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_mod_sub1(unsigned char *A,
+                         unsigned short sizeA,
+                         unsigned char *B,
+                         unsigned short sizeB,
+                         unsigned char *N,
+                         unsigned short sizeN,
+                         unsigned char *result,
+                         unsigned short *result_size)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_MOD_SUB1;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_mod_sub1: ioctl(CIOCGSESSION)");
+        ret = -1;
         goto err;
+	}
+#ifndef HW_ENDIAN_SWAP
+    int_swap(A, sizeA);
+    if(B != A) int_swap(B, sizeB);
+    if((N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = sizeB * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = sizeN * 8;
+
+    
+    kop.crk_param[3].crp_p = result;
+    kop.crk_param[3].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_MOD_SUB1;
+    kop.crk_flags = KCOP_FLAG_INTEGER_ARITH;  /* integer, not MONT in/out, no time eq */
     kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
 
-    if (cryptodev_asym(&kop, BN_num_bytes(m), r, 0, NULL)) {
-        const RSA_METHOD *meth = RSA_PKCS1_OpenSSL();
-        printf("OCF asym process failed, Running in software\n");
-        ret = RSA_meth_get_bn_mod_exp(meth)(r, a, p, m, ctx, in_mont);
-
-    } else if (ECANCELED == kop.crk_status) {
-        const RSA_METHOD *meth = RSA_PKCS1_OpenSSL();
-        printf("OCF hardware operation cancelled. Running in Software\n");
-        ret = RSA_meth_get_bn_mod_exp(meth)(r, a, p, m, ctx, in_mont);
-    }
-    /* else cryptodev operation worked ok ==> ret = 1 */
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_mod_sub1 ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result_size = (kop.crk_param[3].crp_nbits + 7)/8;    
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result, *result_size);       
+#endif
 
- err:
-    zapparams(&kop);
-    return (ret);
+out:
+#ifndef HW_ENDIAN_SWAP
+    if(A != result) int_swap(A, sizeA);
+    if((B != result) && (B != A)) int_swap(B, sizeB);
+    if((N != result) && (N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_mod_sub1: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
 }
 
-static int
-cryptodev_rsa_nocrt_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa,
-                            BN_CTX *ctx)
+static inline int hw_mod_add(unsigned char *A,
+                         unsigned short sizeA,
+                         unsigned char *B,
+                         unsigned short sizeB,
+                         unsigned char *N,
+                         unsigned short sizeN,
+                         unsigned char *result,
+                         unsigned short *result_size)
 {
-    int r;
-    const BIGNUM *n = NULL;
-    const BIGNUM *d = NULL;
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
 
-    ctx = BN_CTX_new();
-    RSA_get0_key(rsa, &n, NULL, &d);
-    r = cryptodev_bn_mod_exp(r0, I, d, n, ctx, NULL);
-    BN_CTX_free(ctx);
-    return (r);
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_MOD_ADD;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_mod_add: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+#ifndef HW_ENDIAN_SWAP
+	int_swap(A, sizeA);
+    if(B != A) int_swap(B, sizeB);
+    if((N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = sizeB * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = sizeN * 8;
+
+    
+    kop.crk_param[3].crp_p = result;
+    kop.crk_param[3].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_MOD_ADD;
+    kop.crk_flags = KCOP_FLAG_INTEGER_ARITH;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_mod_add ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result_size = (kop.crk_param[3].crp_nbits + 7)/8;    
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result, *result_size);    
+#endif
+out:
+#ifndef HW_ENDIAN_SWAP
+    if(A != result) int_swap(A, sizeA);
+    if((B != result) && (B != A)) int_swap(B, sizeB);
+    if((N != result) && (N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_mod_add: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
 }
 
-static int
-cryptodev_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
+static inline int hw_mod_mul(unsigned char *A,
+                         unsigned short sizeA,
+                         unsigned char *B,
+                         unsigned short sizeB,
+                         unsigned char *N,
+                         unsigned short sizeN,
+                         unsigned char *result,
+                         unsigned short *result_size)
 {
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
     struct crypt_kop kop;
-    int ret = 1;
-    const BIGNUM *p = NULL;
-    const BIGNUM *q = NULL;
-    const BIGNUM *dmp1 = NULL;
-    const BIGNUM *dmq1 = NULL;
-    const BIGNUM *iqmp = NULL;
-    const BIGNUM *n = NULL;
 
-    RSA_get0_factors(rsa, &p, &q);
-    RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
-    RSA_get0_key(rsa, &n, NULL, NULL);
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_MOD_MUL;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_mod_mul: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+
+#ifndef HW_ENDIAN_SWAP
+    int_swap(A, sizeA);
+    if(B != A) int_swap(B, sizeB);
+    if((N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = sizeB * 8;
 
-    if (!p || !q || !dmp1 || !dmq1 || !iqmp) {
-        /* XXX 0 means failure?? */
-        return (0);
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = sizeN * 8;
+
+    
+    kop.crk_param[3].crp_p = result;
+    kop.crk_param[3].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_MOD_MUL;
+    kop.crk_flags = KCOP_FLAG_INTEGER_ARITH;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_mod_mul ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result_size = (kop.crk_param[3].crp_nbits + 7)/8;    
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result, *result_size);    
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    if(A != result) int_swap(A, sizeA);
+    if((B != result) && (B != A)) int_swap(B, sizeB);
+    if((N != result) && (N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_mod_mul: ioctl(CIOCFSESSION)");
     }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
 
+static inline int hw_mod_exp(unsigned char *A,
+                         unsigned short sizeA,                         
+                         unsigned char *N,
+                         unsigned short sizeN,
+                         unsigned char *B,
+                         unsigned short sizeB,
+                         unsigned char *result,
+                         unsigned short *result_size)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
     memset(&kop, 0, sizeof(kop));
-    kop.crk_op = CRK_MOD_EXP_CRT;
-    /* inputs: rsa->p rsa->q I rsa->dmp1 rsa->dmq1 rsa->iqmp */
-    if (bn2crparam(p, &kop.crk_param[0]))
+    sess.pk_cipher = CRYPTO_PKHA_MOD_EXP;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_mod_exp: ioctl(CIOCGSESSION)");
+        ret = -1;
         goto err;
-    if (bn2crparam(q, &kop.crk_param[1]))
+	}
+#ifndef HW_ENDIAN_SWAP
+    int_swap(A, sizeA);
+    if(B != A) int_swap(B, sizeB);
+    if((N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+
+    kop.crk_param[1].crp_p = N;
+    kop.crk_param[1].crp_nbits = sizeN * 8;
+
+    kop.crk_param[2].crp_p = B;
+    kop.crk_param[2].crp_nbits = sizeB * 8;
+
+    
+    kop.crk_param[3].crp_p = result;
+    kop.crk_param[3].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_MOD_EXP;
+    kop.crk_flags = KCOP_FLAG_INTEGER_ARITH;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_mod_exp ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result_size = (kop.crk_param[3].crp_nbits + 7)/8;    
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result, *result_size);    
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    if(A != result) int_swap(A, sizeA);
+    if((B != result) && (B != A)) int_swap(B, sizeB);
+    if((N != result) && (N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_mod_exp: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+static inline void set_point(cryptodev_ecc_point_t *point_a, cryptodev_ecc_point_t *point_b,
+                            unsigned char *A, unsigned char *B)
+{
+    if (NULL != point_a) { /* A[0], A[1] */
+        if (NULL != point_a->x)
+            memcpy(A, point_a->x, point_a->x_size);
+        if (NULL != point_a->y)
+            memcpy(A + QUAD1_BYTE_OFFSET, point_a->y, point_a->y_size);
+    }
+    
+    if (NULL != point_b) {  /* B[1], B[2] */
+        if (NULL != point_b->x)
+            memcpy(B + QUAD1_BYTE_OFFSET, point_b->x, point_b->x_size);
+        if (NULL != point_b->y)
+            memcpy(B + QUAD2_BYTE_OFFSET, point_b->y, point_b->y_size);
+    }
+}
+
+static inline void set_curve_parameter(unsigned char * parameter_a, unsigned short a_size, unsigned char * parameter_b, unsigned short b_size, unsigned char *A, unsigned char *B)
+{
+    /* A3 = elliptic curve parameter "a" */
+    if (NULL !=parameter_a)
+        memcpy(A + QUAD3_BYTE_OFFSET, parameter_a, a_size);
+    
+    /* B0 = elliptic curve parameter "b" */
+    if (NULL !=parameter_b)
+        memcpy(B, parameter_b, b_size);
+}
+
+static inline int hw_ec_point_add(cryptodev_ecc_point_t *point_a,
+                         cryptodev_ecc_point_t *point_b,
+                         unsigned char *N,  
+                         unsigned short n_size,
+                         unsigned char *curve_parameter_a,
+                         unsigned short a_size,
+                         unsigned char *curve_parameter_b,
+                         unsigned short b_size,                         
+                         cryptodev_ecc_point_t *result,
+                         unsigned int flags)
+{
+    int ret = 0, result_size = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    unsigned char A[QUAD_BYTES * 4] = {0};
+    unsigned char B[QUAD_BYTES * 4] = {0};
+    unsigned char R[QUAD_BYTES * 2] = {0};
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_ECC_ADD;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_ec_point_add: ioctl(CIOCGSESSION)");
+        ret = -1;
         goto err;
-    if (bn2crparam(I, &kop.crk_param[2]))
+	}
+
+#ifndef HW_ENDIAN_SWAP
+	int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    int_swap(point_b->x, point_b->x_size);
+    int_swap(point_b->y, point_b->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+#endif
+    set_point(point_a, point_b, A, B);
+    set_curve_parameter(curve_parameter_a, a_size, curve_parameter_b, b_size, A, B);
+
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = n_size * 8;
+
+    kop.crk_param[3].crp_p = R;
+    kop.crk_param[3].crp_nbits = 0;
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECC_ADD;
+    kop.crk_flags = flags;  
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_ec_point_add ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    result_size = n_size;  
+    
+    memcpy(result->x, R, result_size);
+    memcpy(result->y, R + QUAD1_BYTE_OFFSET, result_size);
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result->x, result_size);  
+    int_swap(result->y, result_size); 
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    int_swap(point_b->x, point_b->x_size);
+    int_swap(point_b->y, point_b->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_ec_point_add: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_ec_point_double(cryptodev_ecc_point_t *point_a,                         
+                         unsigned char *N,
+                         unsigned short n_size,
+                         unsigned char *curve_parameter_a,
+                         unsigned short a_size,
+                         unsigned char *curve_parameter_b,
+                         unsigned short b_size,
+                         cryptodev_ecc_point_t *result,
+                         unsigned int flags)
+{
+    int ret = 0, result_size = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    unsigned char A[QUAD_BYTES * 4] = {0};
+    unsigned char B[QUAD_BYTES * 4] = {0};
+    unsigned char R[QUAD_BYTES * 2] = {0};
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_ECC_DOUBLE;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_ec_point_double: ioctl(CIOCGSESSION)");
+        ret = -1;
         goto err;
-    if (bn2crparam(dmp1, &kop.crk_param[3]))
+	}
+#ifndef HW_ENDIAN_SWAP
+	int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+#endif
+    set_point(NULL, point_a, A, B);
+    set_curve_parameter(curve_parameter_a, a_size, curve_parameter_b, b_size, A, B);
+
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = n_size * 8;
+
+    
+    kop.crk_param[3].crp_p = R;
+    kop.crk_param[3].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECC_DOUBLE;
+    kop.crk_flags = flags;  
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_ec_point_double ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    result_size = n_size;  
+    
+    memcpy(result->x, R, result_size);
+    memcpy(result->y, R + QUAD1_BYTE_OFFSET, result_size);
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result->x, result_size);  
+    int_swap(result->y, result_size); 
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_ec_point_double: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_ec_point_mul(cryptodev_ecc_point_t *point_a,
+                         unsigned char *N,
+                         unsigned short n_size,
+                         unsigned char *E,
+                         unsigned short e_size,
+                         unsigned char *curve_parameter_a,
+                         unsigned short a_size,
+                         unsigned char *curve_parameter_b,
+                         unsigned short b_size,
+                         cryptodev_ecc_point_t *result,
+                         unsigned int flags)
+{
+    int ret = 0, result_size = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    unsigned char A[QUAD_BYTES * 4] = {0};
+    unsigned char B[QUAD_BYTES * 4] = {0};
+    unsigned char R[QUAD_BYTES * 2] = {0};
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_ECC_MUL;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_ec_point_mul: ioctl(CIOCGSESSION)");
+        ret = -1;
         goto err;
-    if (bn2crparam(dmq1, &kop.crk_param[4]))
+	}
+
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+    int_swap(E, e_size);
+#endif
+    set_point(point_a, NULL, A, B);
+    set_curve_parameter(curve_parameter_a, a_size, curve_parameter_b, b_size, A, B);
+
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = n_size * 8;
+
+    kop.crk_param[3].crp_p = E;
+    kop.crk_param[3].crp_nbits = e_size * 8;
+    
+    kop.crk_param[4].crp_p = R;
+    kop.crk_param[4].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECC_MUL;
+    kop.crk_flags = flags;  
+    kop.crk_iparams = 4;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_ec_point_mul ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    result_size = n_size;  
+    
+    memcpy(result->x, R, result_size);
+    memcpy(result->y, R + QUAD1_BYTE_OFFSET, result_size);
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result->x, result_size);  
+    int_swap(result->y, result_size);     
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+    int_swap(E, e_size);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_ec_point_mul: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_ec_point_mul_is_infinity(cryptodev_ecc_point_t *point_a,
+                         unsigned char *N,
+                         unsigned short n_size,
+                         unsigned char *E,
+                         unsigned short e_size,
+                         unsigned char *curve_parameter_a,
+                         unsigned short a_size,
+                         unsigned char *curve_parameter_b,
+                         unsigned short b_size,
+                         cryptodev_ecc_point_t *result,
+                         unsigned int flags)
+{
+    int ret = 0, result_size = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    unsigned char A[QUAD_BYTES * 4] = {0};
+    unsigned char B[QUAD_BYTES * 4] = {0};
+    unsigned char R[QUAD_BYTES * 2] = {0};
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_ECC_IS_INFINITY;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_ec_point_mul_is_infinity: ioctl(CIOCGSESSION)");
+        ret = -1;
         goto err;
-    if (bn2crparam(iqmp, &kop.crk_param[5]))
+	}
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+    int_swap(E, e_size);
+#endif
+    set_point(point_a, NULL, A, B);
+    set_curve_parameter(curve_parameter_a, a_size, curve_parameter_b, b_size, A, B);
+
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = n_size * 8;
+
+    kop.crk_param[3].crp_p = E;
+    kop.crk_param[3].crp_nbits = e_size * 8;
+    
+    kop.crk_param[4].crp_p = R;
+    kop.crk_param[4].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECC_MUL_IS_INFINITY;
+    kop.crk_flags = flags;  
+    kop.crk_iparams = 4;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_ec_point_mul_is_infinity ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    result_size = n_size;  
+    
+    memcpy(result->x, R, result_size);
+    memcpy(result->y, R + QUAD1_BYTE_OFFSET, result_size);
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result->x, result_size);  
+    int_swap(result->y, result_size);     
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+    int_swap(E, e_size);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_ec_point_mul_is_infinity: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+/*check the point is on the curve (but not point at infinity).*/
+static inline int hw_ec_check_point(cryptodev_ecc_point_t *point_a,
+                         unsigned char *N,
+                         unsigned short n_size,
+                         unsigned char *curve_parameter_a,
+                         unsigned short a_size,
+                         unsigned char *curve_parameter_b,
+                         unsigned short b_size,
+                         unsigned int flags)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    unsigned char A[QUAD_BYTES * 4] = {0};
+    unsigned char B[QUAD_BYTES * 4] = {0};
+    unsigned char R[QUAD_BYTES * 2] = {0};
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_ECC_CHECK_POINT;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_ec_check_point: ioctl(CIOCGSESSION)");
+        ret = -1;
         goto err;
-    kop.crk_iparams = 6;
+	}
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+#endif
+    set_point(point_a, NULL, A, B);
+    set_curve_parameter(curve_parameter_a, a_size, curve_parameter_b, b_size, A, B);
+
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = QUAD_BYTES * 4 * 8;
 
-    if (cryptodev_asym(&kop, BN_num_bytes(n), r0, 0, NULL)) {
-        const RSA_METHOD *meth = RSA_PKCS1_OpenSSL();
-        printf("OCF asym process failed, running in Software\n");
-        ret = RSA_meth_get_mod_exp(meth)(r0, I, rsa, ctx);
-
-    } else if (ECANCELED == kop.crk_status) {
-        const RSA_METHOD *meth = RSA_PKCS1_OpenSSL();
-        printf("OCF hardware operation cancelled. Running in Software\n");
-        ret = RSA_meth_get_mod_exp(meth)(r0, I, rsa, ctx);
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = n_size * 8;
+
+    kop.crk_param[3].crp_p = R;
+    kop.crk_param[3].crp_nbits = 0;
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECC_CHECK_POINT;
+    kop.crk_flags = flags;  
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_ec_check_point ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    } 
+  
+out:
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_ec_check_point: ioctl(CIOCFSESSION)");
     }
-    /* else cryptodev operation worked ok ==> ret = 1 */
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
 
- err:
-    zapparams(&kop);
-    return (ret);
+/* R = A^B mod N  */
+static int cryptodev_bn_mod_exp(BIGNUM *R, const BIGNUM *A, const BIGNUM *B, const BIGNUM *N)
+{
+    int ret = 1;
+    BIGNUM *T;
+    unsigned short max_size;
+
+    // check module
+    if( N->neg || ( N->d[0] & 1 ) == 0 )
+        return( 0 );
+
+    if( B->neg )
+        return( 0 );
+
+    if(A->neg) {
+        perror("don't suport neg mod exp\n");
+        return(0);
+    }
+
+#ifdef CRYPTODEV_BN_DEBUG
+    if ((bn_hex = BN_bn2hex(A))) {
+        printf("A = %s\n", bn_hex);
+        OPENSSL_free(bn_hex);
+    }
+    if ((bn_hex = BN_bn2hex(B))) {
+        printf("B = %s\n", bn_hex);
+        OPENSSL_free(bn_hex);
+    }
+    if ((bn_hex = BN_bn2hex(N))) {
+        printf("N = %s\n", bn_hex);
+        OPENSSL_free(bn_hex);
+    }
+#endif
+
+    max_size = N->top;
+    T = BN_new();
+    if (NULL == cryptodev_bn_wexpand( R, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (NULL == cryptodev_bn_wexpand( T, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (BN_ucmp(A, N) == 1) {
+        if (0 != hw_mod_red((unsigned char *)(A->d), BN_num_bytes(A), (unsigned char *)(N->d), BN_num_bytes(N), (unsigned char *)(T->d), &max_size)) {
+            ret = 0;
+            perror("hw_mod_red failed!\n");
+            goto check_exit;
+        }
+    }
+    else {
+        if (NULL == BN_copy( T, A )) {
+            ret = 0;
+            goto check_exit;
+        }
+    }
+
+    if (0 != hw_mod_exp((unsigned char *)(T->d), BN_num_bytes(T), (unsigned char *)(N->d), BN_num_bytes(N), (unsigned char *)(B->d), BN_num_bytes(B), (unsigned char *)(R->d), &max_size)) {
+        ret = 0;
+        perror("hw_mod_exp failed!\n");
+        goto check_exit;
+    }
+
+    if (max_size < UINT32_TO_BYTES(R->top)) {
+        memset((unsigned char *)R->d + max_size, 0, UINT32_TO_BYTES(R->top) - max_size);
+    }
+
+
+check_exit:
+    BN_free( T );
+    bn_correct_top(R);
+    return( ret );
 }
 
-#ifndef OPENSSL_NO_DSA
-static int
-cryptodev_dsa_bn_mod_exp(DSA *dsa, BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                         const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
+
+/* R = A mod N  */
+static int cryptodev_bn_mod(BIGNUM *R, const BIGNUM *A, const BIGNUM *N)
+{
+    int ret = 1;
+    unsigned short max_size;
+    char * buf = NULL;
+
+    if (A->top > N->top) {
+        max_size = A->top;
+        buf = OPENSSL_malloc(BN_num_bytes(A));
+        memset(buf, 0, BN_num_bytes(A));
+        memcpy(buf, N->d, BN_num_bytes(N));
+        if (NULL == cryptodev_bn_wexpand( R, max_size )) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (0 != hw_mod_red((unsigned char *)(A->d), BN_num_bytes(A), buf, BN_num_bytes(A), (unsigned char *)(R->d), &max_size)) {
+            ret = 0;
+            perror("hw_mod_red failed!\n");
+            goto check_exit;
+        }
+    }
+    else {
+        max_size = N->top;
+        if (NULL == cryptodev_bn_wexpand( R, max_size )) {
+            ret = 0;
+            goto check_exit;
+        }
+
+        if (0 != hw_mod_red((unsigned char *)(A->d), BN_num_bytes(A), (unsigned char *)(N->d), BN_num_bytes(N), (unsigned char *)(R->d), &max_size)) {
+            ret = 0;
+            perror("hw_mod_red failed!\n");
+            goto check_exit;
+        }
+    }
+
+    if ( A->neg != 0) {  // this is a neg
+#ifdef CRYPTODEV_BN_DEBUG
+        if ((bn_hex = BN_bn2hex(N))) {
+            printf("N = %s\n", bn_hex);
+            OPENSSL_free(bn_hex);
+        }
+        if ((bn_hex = BN_bn2hex(R))) {
+            printf("R = %s\n", bn_hex);
+            OPENSSL_free(bn_hex);
+        }
+        if ((bn_hex = BN_bn2hex(A))) {
+            printf("A = %s\n", bn_hex);
+            OPENSSL_free(bn_hex);
+        }
+#endif
+        if (0 != hw_mod_sub1((unsigned char *)(N->d), BN_num_bytes(N), (unsigned char *)(R->d), BN_num_bytes(R), (unsigned char *)(N->d), BN_num_bytes(N), (unsigned char *)(R->d), &max_size)) {
+            ret = 0;
+            perror("hw_mod_sub1 failed!\n");
+            goto check_exit;
+        }
+    }
+
+    if (max_size < UINT32_TO_BYTES(R->top)) {
+        memset((unsigned char *)R->d + max_size, 0, UINT32_TO_BYTES(R->top) - max_size);
+    }
+
+    R->neg = 0;
+
+check_exit:
+    if (NULL != buf)
+        OPENSSL_free(buf);
+    bn_correct_top(R);
+    return( ret );
+}
+
+
+/* X = A^-1 mod N */
+static int cryptodev_bn_inv_mod( BIGNUM *X, const BIGNUM *A, const BIGNUM *N)
 {
-    return cryptodev_bn_mod_exp(r, a, p, m, ctx, m_ctx);
+    int ret = 1;
+    int i, j;
+    unsigned short max_size;
+    BIGNUM *G, *TA;
+    if (cryptodev_bn_int_cmp(N, 0) <= 0 )
+        return 0;
+    
+    G = BN_new(); TA = BN_new();
+    
+    if (!cryptodev_bn_gcd(G, A, N)) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (0 != cryptodev_bn_int_cmp( G, 1 )) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (NULL == cryptodev_bn_expand( TA, BN_num_bits(N))) {
+        ret = 0;
+        goto check_exit;
+    }
+    i = BN_num_bytes(A);
+    j = BN_num_bytes(N);
+    if (BN_ucmp(A, N) >= 0) {
+        if (0 != hw_mod_red((unsigned char *)(A->d), i, (unsigned char *)(N->d), j, (unsigned char *)(TA->d), &max_size)) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (max_size < UINT32_TO_BYTES(TA->top)) {
+            memset((unsigned char *)TA->d + max_size, 0, UINT32_TO_BYTES(TA->top) - max_size);
+        }
+    }
+    else {
+        if (NULL == BN_copy( TA, A )) {
+            ret = 0;
+            goto check_exit;
+        }
+        A = TA;
+    }
+    if (NULL == cryptodev_bn_expand( X, BN_num_bits(N))) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (0 != hw_mod_inv((unsigned char *)(TA->d), BN_num_bytes(TA), (unsigned char *)(N->d), BN_num_bytes(N), (unsigned char *)(X->d), &max_size)) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (max_size < UINT32_TO_BYTES(X->top)) {
+        memset((unsigned char *)X->d + max_size, 0, UINT32_TO_BYTES(X->top) - max_size);
+    }
+check_exit:
+    BN_free( G ); BN_free( TA );
+    bn_correct_top(X);
+    return( ret );
+
 }
 
-static int
-cryptodev_dsa_dsa_mod_exp(DSA *dsa, BIGNUM *t1, const BIGNUM *g,
-                          const BIGNUM *u1, const BIGNUM *pub_key,
-                          const BIGNUM *u2, const BIGNUM *p, BN_CTX *ctx,
-                          BN_MONT_CTX *mont)
+static int cryptodev_bn_gcd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
+{
+    int ret = 1;
+    int i, j;
+    unsigned short max_size;
+    BIGNUM *TA, *TB;
+    
+    TA = BN_new(); TB = BN_new();
+    if (NULL == BN_copy( TA, a )) {
+        ret = 0;
+        goto check_exit;
+    }
+    a = TA;
+    if (NULL == BN_copy( TB, b )) {
+        ret = 0;
+        goto check_exit;
+    }
+    b = TB; 
+    if (BN_cmp(a, b) > 0) {
+        if (NULL == BN_copy( TA, b )) {
+        ret = 0;
+        goto check_exit;
+        }
+        b = TA;
+        if (NULL == BN_copy( TB, a )) {
+            ret = 0;
+            goto check_exit;
+        }
+        a = TB; 
+    }
+    i = BN_num_bytes(a);
+    j = BN_num_bytes(b);
+    
+    if (0 != hw_mod_gcd((unsigned char *)(a->d), i, (unsigned char *)(b->d), j, (unsigned char *)(b->d), &max_size)) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (max_size < UINT32_TO_BYTES(b->top)) {
+        memset((unsigned char *)b->d + max_size, 0, UINT32_TO_BYTES(b->top) - max_size);
+    }
+
+    if (NULL == BN_copy( r, TB )) {
+        ret = 0;
+    }
+check_exit:
+    BN_free( TB ); BN_free( TA );
+    bn_correct_top(r);
+    return( ret );
+
+}
+
+/* unsigned add of b to a */
+/* r = a + b */
+static int cryptodev_bn_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
+{
+    int ret = 1;
+    int i, j;
+    unsigned short max_size;
+    
+    BIGNUM *TA, *TB, *Wi;
+    BIGNUM *N;
+    TA = BN_new(); TB = BN_new(); Wi = BN_new();
+    N = BN_new();
+
+    i = BN_num_bytes(a);
+    j = BN_num_bytes(b);
+
+    max_size = i > j ? i : j;
+    max_size = BYTES_ALIGNED4(max_size + 1);
+    if (NULL == cryptodev_bn_expand( N, CHARS_TO_BITS(max_size))) {
+        ret = 0;
+        goto check_exit;
+    }
+    memset((unsigned char *)N->d, 0xFF, max_size );
+
+
+    if (max_size <= BITS_TO_CHARS(HW_MAX_MODULUS_SIZE_BITS)) {
+        if (NULL == cryptodev_bn_wexpand( r, CHARS_TO_UINT32(max_size))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (0 != hw_mod_add((unsigned char *)(a->d), i, (unsigned char *)(b->d), j, (unsigned char *)(N->d), max_size,
+                                   (unsigned char *)(r->d), &max_size)) {
+            ret = 0;
+            goto check_exit;
+        }
+    }
+    else {
+        int n, t;
+        unsigned char carry[4] = {0x0, 0x0, 0x0, 0x0};
+        if (NULL == cryptodev_bn_wexpand( Wi, HW_BASE_sections + 1)) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (NULL == BN_copy( TA, a )) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (NULL == BN_copy( TB, b )) {
+            ret = 0;
+            goto check_exit;
+        }
+        
+        for( i = a->top; i > 0; i-- )
+          if( a->d[i - 1] != 0 )
+            break;
+        for( j = b->top; j > 0; j-- )
+          if( b->d[j - 1] != 0 )
+            break;
+
+        n = i > j ? i : j;
+        if (NULL == cryptodev_bn_wexpand( r, n + 1)) {
+            ret = 0;
+            goto check_exit;
+        }
+
+        if( i < j ) {
+            a = TB;   /* a must larger than b */
+            b = TA; 
+        }
+        j = TO_HW_BASE_SIZE(n);
+
+        carry[0] = 0;
+        t = TO_HW_BASE_SIZE(b->top);
+        for (i = 0; i < j; i++) {
+            unsigned short  ibase;
+            memset( (void *)(Wi->d), 0, HW_BASE_chars + 4);
+            ibase = HW_BASE_chars * i;
+
+            if (i < t ) {
+                if (0 != hw_mod_add(((unsigned char *)(a->d))  + ibase, bignum_hw_base_size(a, ibase),
+                                                        ((unsigned char *)(b->d))  + ibase, bignum_hw_base_size(b, ibase),
+                                                         /*NULL*/(unsigned char *)(N->d), HW_BASE_chars + 4,
+                                                         (unsigned char *)(Wi->d), &max_size)) {
+                    ret = 0;
+                    goto check_exit;
+                }
+            }
+            else {
+                memcpy( (unsigned char *)Wi->d, ((unsigned char *)(a->d))  + ibase, HW_BASE_chars);
+            }
+            
+            if (carry[0] == 1) {
+                if (0 != hw_mod_add((unsigned char *)(Wi->d), HW_BASE_chars + 4, carry, 4,
+                                                     /*NULL*/(unsigned char *)(N->d), HW_BASE_chars + 4,
+                                                     (unsigned char *)(Wi->d), &max_size)) {
+                    ret = 0;
+                    goto check_exit;
+                }
+            }
+            if (Wi->d[HW_BASE_sections] == 1) {
+                carry[0] = 1;
+            }
+            else {
+                carry[0] = 0;
+            }
+            memcpy(((unsigned char *)(r->d)) + HW_BASE_chars * i, (unsigned char *)(Wi->d), HW_BASE_chars);
+        }
+        if (carry[0] == 1) {
+            r->d[n] = 1;
+        }
+    }
+
+    r->neg = 0;
+
+check_exit:
+    BN_free(TA); BN_free(TB); BN_free(Wi);
+    BN_free(N);
+    bn_correct_top(r);
+    return( ret );
+}
+
+/* unsigned subtraction of b from a, a must be larger than b. */
+static int cryptodev_bn_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
+{
+    BIGNUM *N = NULL;
+    int ret = 1;
+
+    unsigned short max_size, i, j;    
+
+    if (BN_ucmp( a, b ) < 0 )
+        return 0;
+
+    N = BN_new();
+
+
+    i = BN_num_bytes(a);
+    j = BN_num_bytes(b);
+
+    // max_size unit is byte
+    max_size = i > j ? i : j;
+    max_size = BYTES_ALIGNED4(max_size+1);  
+    if (NULL == cryptodev_bn_expand( N, CHARS_TO_BITS(max_size))) {
+        ret = 0;
+        goto check_exit;
+    }
+    memset((unsigned char *)N->d, 0xFF, max_size );
+
+    // must expand r, return size is Nsize
+    if (NULL == cryptodev_bn_expand( r, CHARS_TO_BITS(max_size))) {
+        ret = 0;
+        goto check_exit;
+    }
+
+    r->neg = 0;
+    
+    if (max_size > BITS_TO_CHARS(HW_MAX_MODULUS_SIZE_BITS)) {
+        ret = 0;
+        perror("cryptodev_bn_usub: more than maximum modulus size");
+        goto check_exit;
+    }
+    
+    if (hw_mod_sub1((unsigned char *)(a->d), i, (unsigned char *)(b->d), j, (unsigned char *)(N->d), max_size, (unsigned char *)(r->d), &max_size)) {
+        ret = 0;
+        perror("hw_mod_sub1 failed!\n");
+    }
+
+    if (max_size < UINT32_TO_BYTES(r->top)) {
+        memset((unsigned char *)r->d + max_size, 0, UINT32_TO_BYTES(r->top) - max_size);
+    }
+
+check_exit:
+    BN_free(N);
+    bn_correct_top(r);
+    return( ret );
+}
+
+/* r =  a - b */
+static int cryptodev_bn_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
+{
+
+    int a_neg = a->neg;
+
+    if (a_neg ^ b->neg) {
+        if (!cryptodev_bn_uadd(r, a, b))
+            return (0);
+        r->neg = a_neg;
+    }
+    else {
+        if (BN_ucmp(a, b) < 0) {
+            if (!cryptodev_bn_usub(r, b, a))
+                return (0);
+            r->neg = a_neg == 1 ? 0: 1;
+        }
+		else {
+            if (!cryptodev_bn_usub(r, a, b))
+                return (0);
+            r->neg = a_neg == 1 ? 1: 0;;
+        }
+    }
+    return (1);
+}
+/* r = a + b */
+
+static int cryptodev_bn_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
+{
+    int a_neg = a->neg, ret = 1;
+
+    bn_check_top(a);
+    bn_check_top(b);
+
+    /*-
+       *  a +  b      a+b
+       *  a + -b      a-b
+       * -a +  b      b-a
+       * -a + -b      -(a+b)
+       */
+    if (a_neg ^ b->neg) {
+        /* we are now a - b */
+        if (BN_ucmp(a, b) < 0) {
+            if (!cryptodev_bn_usub(r, b, a))
+                return (0);
+            r->neg = a_neg == 1 ? 0: 1;
+        } 
+		else {
+            if (!cryptodev_bn_usub(r, a, b))
+                return (0);
+            r->neg = a_neg == 1 ? 1: 0;
+        }
+        return (1);
+    }
+
+    ret = cryptodev_bn_uadd(r, a, b);
+    r->neg = a_neg;
+    bn_check_top(r);
+    return ret;
+}
+
+static int cryptodev_bn_add_word(BIGNUM *a, BN_ULONG w)
+{
+    int ret = 1;
+    BIGNUM *b = NULL;
+    /* degenerate case: w is zero */
+    if (!w)
+        return 1;
+    /* degenerate case: a is zero */
+    if (BN_is_zero(a))
+        return BN_set_word(a, w);
+    b = BN_new();
+    if (NULL == b)
+        return 0;
+    BN_set_word(b, w);
+    ret = cryptodev_bn_add(a, a, b);
+    BN_free(b);
+    return ret;
+}
+
+/* big integer multiplication: r = a * b */
+static int cryptodev_bn_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
+{
+    int ret = 1;
+    int i, j;
+    BIGNUM *TA, *TB, *N;
+    BIGNUM  *C, *UV;
+    unsigned short max_size; 
+
+    TA = BN_new(); TB = BN_new();
+    C = BN_new(); UV = BN_new();
+    N = BN_new();
+
+    if (r == a) { 
+        if (NULL == BN_copy( TA, a )) {
+            ret = 0;
+            goto check_exit;
+        }
+        a = TA;
+    }
+    if (r == b) { 
+        if (NULL == BN_copy( TB, b )) {
+            ret = 0;
+            goto check_exit;
+        }
+        b = TB; 
+    }
+
+    i = BN_num_bytes(a);
+    j = BN_num_bytes(b);
+    
+    // max_size unit is byte
+    max_size = (i + j);
+    max_size = BYTES_ALIGNED4(max_size);
+    if (NULL == cryptodev_bn_expand( N, CHARS_TO_BITS(max_size))) {
+        ret = 0;
+        goto check_exit;
+    }
+   	memset((unsigned char *)N->d, 0xFF, max_size );
+
+    if (max_size <= BITS_TO_CHARS(HW_MAX_MODULUS_SIZE_BITS)) {
+        if (NULL == cryptodev_bn_wexpand( r, /*i + j*/CHARS_TO_UINT32(max_size))) {
+            ret = 0;
+            goto check_exit;
+        }
+        memset(r->d, 0x0, UINT32_TO_BYTES(r->dmax));
+#ifdef CRYPTODEV_BN_DEBUG
+        printf("r1 top %d, dmax %d\n", r->top, r->dmax );
+#endif
+        if (0 != hw_mod_mul((unsigned char *)(a->d),i, (unsigned char *)(b->d), j,
+                                          (unsigned char *)(N->d), max_size, (unsigned char *)(r->d), &max_size)) {
+            ret = 0;
+            goto check_exit;
+        }
+        
+#ifdef CRYPTODEV_BN_DEBUG
+        printf("r2 top %d, dmax %d\n", r->top, r->dmax );
+#endif
+    }
+    else {
+        if (NULL == cryptodev_bn_wexpand( C, HW_BASE_sections)) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (NULL == cryptodev_bn_wexpand( UV, HW_BASE_sections * 2 + 4)) {
+            ret = 0;
+            goto check_exit;
+        }
+    
+        int n, t;
+        for( i = a->top; i > 0; i-- )
+          if( a->d[i - 1] != 0 )
+            break;
+        for( j = b->top; j > 0; j-- )
+          if( b->d[j - 1] != 0 )
+            break;
+        n = TO_HW_BASE_SIZE(/*a->top*/ i);
+        t = TO_HW_BASE_SIZE(/*b->top*/ j);
+
+        if (NULL == cryptodev_bn_wexpand( r, (n + t) * HW_BASE_sections)) {
+            ret = 0;
+            goto check_exit;
+        }
+        memset(r->d, 0x0, UINT32_TO_BYTES(r->dmax));
+    
+        for (i = 0; i < t; i++) {
+            memset(C->d, 0x0, UINT32_TO_BYTES(C->dmax));
+
+            for(j = 0; j < n; j++) {
+                unsigned short ibase, jbase, ijbase;
+                memset(UV->d, 0x0, HW_BASE_chars * 2);
+                
+                ibase = HW_BASE_chars * i;
+                jbase = HW_BASE_chars * j;
+                ijbase = ibase + jbase;
+                if (0 != hw_mod_mul(((unsigned char *)(a->d)) + jbase, bignum_hw_base_size(a, jbase),
+                                                       ((unsigned char *)(b->d)) + ibase, bignum_hw_base_size(b, ibase),
+                                                       (unsigned char *)(N->d), HW_BASE_chars * 2 + 4,
+                                                       (unsigned char *)(UV->d), &max_size)) {
+                    ret = 0;
+                    goto check_exit;
+                }
+
+                if (0 != hw_mod_add(((unsigned char *)(r->d))  + ijbase, bignum_hw_base_size(r, ijbase),
+                                                             (unsigned char *)(UV->d), HW_BASE_chars * 2,
+                                                             (unsigned char *)(N->d), HW_BASE_chars * 2 + 4,
+                                                             (unsigned char *)(UV->d), &max_size)) {
+                    ret = 0;
+                    goto check_exit;
+                }
+
+                if (0 != hw_mod_add(((unsigned char *)(C->d)), HW_BASE_chars,
+                                                             (unsigned char *)(UV->d), HW_BASE_chars * 2,
+                                                             (unsigned char *)(N->d), HW_BASE_chars * 2 + 4,
+                                                             (unsigned char *)(UV->d), (unsigned short *)&max_size)) {
+                    ret = 0;
+                    goto check_exit;
+                }
+                
+                memcpy(((unsigned char *)(r->d)) + HW_BASE_chars * (i + j), (unsigned char *)(UV->d), HW_BASE_chars);
+
+                memcpy(((unsigned char *)(C->d)), (unsigned char *)(UV->d) + HW_BASE_chars, HW_BASE_chars);
+            }
+            memcpy(((unsigned char *)(r->d)) + HW_BASE_chars * (i + n), ((unsigned char *)(UV->d)) + HW_BASE_chars, HW_BASE_chars);
+        }
+    }
+   
+    r->neg = a->neg ^ b->neg;
+
+check_exit:
+    BN_free(TB); BN_free(TA);
+    BN_free(C); BN_free(UV);
+    BN_free(N);
+    bn_correct_top(r);
+    return( ret );
+}
+static inline int cryptodev_bn_int_cmp(const BIGNUM *a, int i)
+{
+    BIGNUM *b;
+    int ret; 
+    
+    b = BN_new();
+    if (b != NULL) {
+        if (0 == BN_set_word(b,i))
+            return -1;
+        ret = BN_cmp(a, b);
+        BN_free(b);
+        return ret;
+    }
+    else
+        return -1;
+}
+
+static inline int cryptodev_bn_int_add(BIGNUM *r, BIGNUM *a, int i)
+{
+    BIGNUM *b;
+    int ret = 1; 
+    
+    b = BN_new();
+    if (b != NULL) {
+        if (0 == BN_set_word(b,i))
+            return 0;
+        ret = cryptodev_bn_add(r, a, b);
+        BN_free(b);
+        return ret;
+    }
+    else
+        return 0;
+
+}
+static int cryptodev_bn_check_small_factors( const BIGNUM *X )
 {
-    const BIGNUM *dsag, *dsap, *dsapub_key;
-    BIGNUM *t2;
     int ret = 0;
-    const DSA_METHOD *meth;
-    int (*bn_mod_exp)(DSA *, BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *,
-                      BN_CTX *, BN_MONT_CTX *);
+    int i;
+    BIGNUM *TA,*TB;
+
+    if (( X->d[0] & 1 ) == 0)
+        return -1; /* is NOT acceptable */
+    TA = BN_new(); TB = BN_new();
+    if (NULL == TA || NULL == TB) {
+        perror("No memory!\n");
+        return -2; /* error */
+    }
+    for (i = 0; small_prime[i] > 0; i++ ) {
+        if (cryptodev_bn_int_cmp( X, small_prime[i] ) <= 0) {
+            ret = 1; /* certain prime */
+            goto check_exit;
+        }
+        BN_set_word(TA,small_prime[i]);
+        if (0 == cryptodev_bn_mod( TB, X, TA)) {
+            ret = -2; /* error */
+            goto check_exit;
+        }
+        if (BN_is_zero(TB)) {
+            ret = -1; /* is NOT acceptable */ 
+            goto check_exit;
+    	}
+    }
+
+check_exit:
+    BN_free(TB); BN_free(TA);
+    return ret;
+}
+
+/* Pseudo-primality test: small factors, then Miller-Rabin */
+static int cryptodev_bn_is_prime(BIGNUM *X)
+{
+    int ret = 1, size;
+    bool result;
+    BIGNUM *A = NULL,*B = NULL;
+    unsigned char t[4] = {0x0,0x0,0x0,0x5};
+    unsigned char buf[CRYPTODEV_MAX_SIZE];
+    if (cryptodev_bn_int_cmp( X, 0 ) == 0 ||
+        cryptodev_bn_int_cmp( X, 1 ) == 0 )
+        return 0; /* is NOT acceptable */
+
+    if (cryptodev_bn_int_cmp( X, 2 ) == 0 )
+        return 1; /* is prime */
+
+    if ((ret = cryptodev_bn_check_small_factors(X)) != 0) {
+        if (ret == 1)
+            return 1; /* is prime */
+        return 0;
+    }
+    A = BN_new();
+    size = (X->top) * (sizeof(BN_ULONG)) / 2;
+    if (NULL != A && size < CRYPTODEV_MAX_SIZE) {
+        if (RAND_bytes(buf, size) <= 0) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (NULL == BN_bin2bn(buf, size, A)) {
+            ret = 0;
+            goto check_exit;
+        }
+    }
+    else {
+        ret = 0;
+        goto check_exit;
+    }
+    if(BN_ucmp(A, X) == 1) {
+        B = BN_new();
+        if (NULL == B || (NULL == BN_copy(B,A))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (1 != BN_rshift1(A, B)) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (BN_ucmp(A, X)) {
+            if( 0 == cryptodev_bn_mod(A, A, X)) {
+                ret = 0;
+                goto check_exit;
+            }
+        }
+    }
+    if (hw_primality_test((unsigned char *)(A->d), BN_num_bytes(A), (unsigned char *)t, 4, (unsigned char *)(X->d), BN_num_bytes(X), &result)) {
+        ret = 0;
+        perror("hw_primality_test failed!\n");
+        goto check_exit;
+    }
+    else {		
+		if(true == result) 
+			ret = 1;  /* is prime */
+        else 
+            ret = 0;
+    }
+check_exit:
+    BN_free(A);
+    BN_free(B);
+    return ret;
+}
+
+static int cryptodev_bn_generate_prime(BIGNUM *PRIME,int rsabits)
+{
+    int ret = 1;
+    int k = 0;
+    BIGNUM *A = NULL;
+    unsigned char buf[BITS_TO_CHARS(HW_MAX_MODULUS_SIZE_BITS)];
+
+    if (rsabits < 3 || rsabits > HW_MAX_MODULUS_SIZE_BITS)
+        return 0;
+
+    if (RAND_bytes(buf, BITS_TO_CHARS(rsabits)) <= 0) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (NULL == BN_bin2bn(buf, BITS_TO_CHARS(rsabits), PRIME)) {
+        ret = 0;
+        goto check_exit;
+    }
+    k = BN_num_bits( PRIME );
+    if (k > rsabits) {
+        A = BN_new();
+        if (NULL == BN_copy(A, PRIME)) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (1 != BN_rshift(PRIME, A, k - rsabits + 1)) {
+            ret = 0;
+            goto check_exit;
+        }
+    }
+    if (1 != BN_set_bit(PRIME, rsabits - 1)) {
+        ret = 0;
+        goto check_exit;
+    }
+    
+    PRIME->d[0] |= 3;
+
+    while (1 != cryptodev_bn_is_prime(PRIME)) {
+            if (!cryptodev_bn_int_add(PRIME, PRIME, 2)) {
+                ret = 0;
+                goto check_exit;
+            }
+    }
+    
+check_exit:
+    if (NULL != A)
+        BN_free(A);
+    return ret;
+}
+static int cryptodev_bn_mul2(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
+{
+    if (BN_is_zero(a) || BN_is_zero(b)) {
+        return BN_zero(r);
+    }
+    return cryptodev_bn_mul(r, a, b);
+}
+static int cryptodev_bn_mod_ctx(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)
+{
+    return cryptodev_bn_mod(r, m, d);
+}
+
+static int cryptodev_bn_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)
+{
+    if(!cryptodev_bn_mod(r,m,d))
+        return 0;
+    if (!r->neg)
+        return 1;
+    if(d->neg)
+        return cryptodev_bn_sub(r, r, d);
+    else
+        return cryptodev_bn_add(r, r, d);
+}
+/* unsigned modular addition: r = |a| + |b| mod m  */
+static int cryptodev_bn_mod_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m)
+{
+    int ret = 1;
+    int i, j;
+    BIGNUM *TA = NULL, *TB = NULL;
+    unsigned short max_size;
+
+    if (BN_ucmp(a, m) > 0) {
+        TA = BN_new();
+        if (NULL == TA || (NULL == BN_copy( TA, a ))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if(!cryptodev_bn_mod(TA, TA, m)) {
+            ret = 0;
+            goto check_exit;
+        }
+        a = TA;
+    }
+    if (BN_ucmp(b, m) > 0) {
+        TB = BN_new();
+        if (NULL == TB || (NULL == BN_copy( TB, b ))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if(!cryptodev_bn_mod(TB, TB, m)) {
+            ret = 0;
+            goto check_exit;
+        }
+        b = TB;
+    }
+
+    i = BN_num_bytes(a);
+    j = BN_num_bytes(b);
+
+    max_size = BN_num_bytes(m);
+    max_size = BYTES_ALIGNED4(max_size + 1);
+
+    // must expand r, return size is Nsize
+    if (NULL == cryptodev_bn_expand( r, CHARS_TO_BITS(max_size))) {
+        ret = 0;
+        goto check_exit;
+    }
+    
+    r->neg = 0;
+
+    if (max_size > BITS_TO_CHARS(HW_MAX_MODULUS_SIZE_BITS)) {
+        ret = 0;
+        perror("cryptodev_bn_mod_uadd: more than maximum modulus size");
+        goto check_exit;
+    }    
+
+    if (0 != hw_mod_add((unsigned char *)(a->d), i, (unsigned char *)(b->d), j, (unsigned char *)(m->d), BN_num_bytes(m),
+                                   (unsigned char *)(r->d), &max_size)) {
+        ret = 0;
+        perror("hw_mod_add failed!\n");
+        goto check_exit;
+    }
+    
+
+check_exit:
+    if (NULL != TA)
+        BN_free(TA);
+    if (NULL != TB)
+        BN_free(TB);
+    bn_correct_top(r);    
+    return ret;
+}
+
+/* unsigned modular subtraction of b from a, a must be larger than b. r = |a| - |b| mod m */
+static int cryptodev_bn_mod_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m)
+{
+    int ret = 1;
+    BIGNUM *TA = NULL, *TB = NULL;
+    unsigned short max_size, i, j;    
+
+    if (BN_ucmp(a, m) > 0) {
+        TA = BN_new();
+        if (NULL == TA || (NULL == BN_copy( TA, a ))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if(!cryptodev_bn_mod(TA, TA, m)) {
+            ret = 0;
+            goto check_exit;
+        }
+        a = TA;
+    }
+    if (BN_ucmp(b, m) > 0) {
+        TB = BN_new();
+        if (NULL == TB || (NULL == BN_copy( TB, b ))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if(!cryptodev_bn_mod(TB, TB, m)) {
+            ret = 0;
+            goto check_exit;
+        }
+        b = TB;
+    }
+
+    i = BN_num_bytes(a);
+    j = BN_num_bytes(b);
+
+    // max_size unit is byte
+    max_size = BN_num_bytes(m);
+    max_size = BYTES_ALIGNED4(max_size+1);  
+
+    // must expand r, return size is Nsize
+    if (NULL == cryptodev_bn_expand( r, CHARS_TO_BITS(max_size))) {
+        ret = 0;
+        goto check_exit;
+    }
+
+    r->neg = 0;
+    
+    if (max_size > BITS_TO_CHARS(HW_MAX_MODULUS_SIZE_BITS)) {
+        ret = 0;
+        perror("cryptodev_bn_mod_usub: more than maximum modulus size");
+        goto check_exit;
+    }
+    
+    if (hw_mod_sub1((unsigned char *)(a->d), i, (unsigned char *)(b->d), j, (unsigned char *)(m->d), BN_num_bytes(m), (unsigned char *)(r->d), &max_size)) {
+        ret = 0;
+        perror("hw_mod_sub1 failed!\n");
+    }
+
+    if (max_size < UINT32_TO_BYTES(r->top)) 
+        memset((unsigned char *)r->d + max_size, 0, UINT32_TO_BYTES(r->top) - max_size);
+
+
+check_exit:
+    if (NULL != TA)
+        BN_free(TA);
+    if (NULL != TB)
+        BN_free(TB);
+    bn_correct_top(r);
+    return( ret );
+}
+static int cryptodev_bn_mod_umul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m)
+{
+    int ret = 1;
+    int i, j;
+    BIGNUM *TA = NULL, *TB = NULL;
+    unsigned short max_size = 0;     
+       
+    if (r == a) { 
+	    TA = BN_new();
+        if (NULL == BN_copy( TA, a )) {
+            ret = 0;
+            goto check_exit;
+        }
+        a = TA;
+    }
+    else if (BN_ucmp(a, m) > 0) {
+        TA = BN_new();
+        if (NULL == TA || (NULL == BN_copy( TA, a ))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if(!cryptodev_bn_mod(TA, TA, m)) {
+            ret = 0;
+            goto check_exit;
+        }
+        a = TA;
+    }
+    if (r == b) { 
+	    TB = BN_new();
+        if (NULL == BN_copy( TB, b )) {
+            ret = 0;
+            goto check_exit;
+        }
+        b = TB; 
+    }
+    else if (BN_ucmp(b, m) > 0) {
+        TB = BN_new();
+        if (NULL == TB || (NULL == BN_copy( TB, b ))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if(!cryptodev_bn_mod(TB, TB, m)) {
+            ret = 0;
+            goto check_exit;
+        }
+        b = TB;
+    }
+
+    i = BN_num_bytes(a);
+    j = BN_num_bytes(b);
+    
+    // max_size unit is byte
+    max_size = BN_num_bytes(m);
+    max_size = BYTES_ALIGNED4(max_size);
+
+    if (max_size <= BITS_TO_CHARS(HW_MAX_MODULUS_SIZE_BITS)) {
+        if (NULL == cryptodev_bn_wexpand( r, /*i + j*/CHARS_TO_UINT32(max_size))) {
+            ret = 0;
+            goto check_exit;
+        }
+        memset(r->d, 0x0, UINT32_TO_BYTES(r->dmax));
+#ifdef CRYPTODEV_BN_DEBUG
+        printf("r1 top %d, dmax %d\n", r->top, r->dmax );
+#endif
+        if (0 != hw_mod_mul((unsigned char *)(a->d),i, (unsigned char *)(b->d), j,
+                                          (unsigned char *)(m->d), BN_num_bytes(m), (unsigned char *)(r->d), &max_size)) {
+            ret = 0;
+            goto check_exit;
+        }
+        
+#ifdef CRYPTODEV_BN_DEBUG
+        printf("r2 top %d, dmax %d\n", r->top, r->dmax );
+#endif
+    }
+    else {
+        perror("cryptodev_bn_mod_umul: more than maximum modulus size");
+        ret = 0;
+        goto check_exit;
+    }
+   
+    r->neg = 0;
+
+check_exit:
+    if (NULL != TA)
+        BN_free(TA);
+    if (NULL != TB)
+        BN_free(TB);
+    bn_correct_top(r);
+    return( ret );
+}
+
+static int cryptodev_bn_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
+{
+    int a_neg = a->neg, ret = 1;
+
+    if (BN_is_zero(a) || BN_is_zero(b)) {
+        if (BN_is_zero(a) && BN_is_zero(b)) {
+            return BN_zero(r);
+        }
+        else if (BN_is_zero(a) && !BN_is_zero(b)) {
+            return cryptodev_bn_mod(r, b, m);
+        }
+        else if (!BN_is_zero(a) && BN_is_zero(b)) {
+            return cryptodev_bn_mod(r, a, m);
+        }
+    }
+    
+    bn_check_top(a);
+    bn_check_top(b);
+
+    /*-
+       *  a +  b      a+b
+       *  a + -b      a-b
+       * -a +  b      b-a
+       * -a + -b      -(a+b)
+       */
+    if (a_neg ^ b->neg) {
+        /* we are now a - b */
+        if (BN_ucmp(a, b) < 0) {
+            if (!cryptodev_bn_mod_usub(r, b, a, m))
+                return (0);
+            r->neg = a_neg == 1 ? 0: 1;
+        } 
+		else {
+            if (!cryptodev_bn_mod_usub(r, a, b, m))
+                return (0);
+            r->neg = a_neg == 1 ? 1: 0;
+        }
+        return (1);
+    }
+
+    ret = cryptodev_bn_mod_uadd(r, a, b, m);
+    r->neg = a_neg;
+    bn_check_top(r);
+    return ret;
+}
+/* signed modular subtraction: r = a - b mod m */
+static int cryptodev_bn_mod_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
+{
+    int a_neg = a->neg;
+
+    if (BN_is_zero(a) || BN_is_zero(b)) {
+        if (BN_is_zero(a) && BN_is_zero(b)) {
+            return BN_zero(r);
+        }
+        else if (BN_is_zero(a) && !BN_is_zero(b)) {
+            BN_set_negative(b, 1);
+            return cryptodev_bn_mod(r, b, m);
+        }
+        else if (!BN_is_zero(a) && BN_is_zero(b)) {
+            return cryptodev_bn_mod(r, a, m);
+        }
+    }
+    bn_check_top(a);
+    bn_check_top(b);
+   
+    if (a_neg ^ b->neg) {
+        if (!cryptodev_bn_mod_uadd(r, a, b, m))
+            return (0);
+        if (a_neg) {
+            if (!cryptodev_bn_mod_usub(r, m, r, m))
+                return (0);
+        }
+    }
+    else {
+        if (!cryptodev_bn_mod_usub(r, a, b, m))
+            return (0);
+        r->neg = 0;
+    }
+    return (1);
+}
+/* unsigned modular multiplication: r = a * b mod m */
+static int cryptodev_bn_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
+{
+    int ret = 1;
+    if (BN_is_zero(a) || BN_is_zero(b)) {
+        return BN_zero(r);
+    }
+    if (!cryptodev_bn_mod_umul(r, a, b, m))
+        return 0;
+
+    if (a->neg ^ b->neg) {
+        if (!cryptodev_bn_mod_usub(r, m, r, m))
+            return (0);
+    }
+    
+    r->neg = 0;
+        
+    return( ret );  
+}
+
+/* unsigned modular square: r = a^2 mod m */
+static int cryptodev_bn_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx)
+{
+    int ret = 1;
+    if (BN_is_zero(a)) {
+        return BN_zero(r);
+    }
+    ret = cryptodev_bn_mod_mul(r, a, a, m, ctx);        
+    return( ret );
+}
+
+static BIGNUM *cryptodev_bn_mod_inverse(BIGNUM *ret, const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)
+{
+    if (BN_is_zero(a)) {
+        return BN_mod_inverse(ret, a, n, ctx);
+    }
+
+    if (!cryptodev_bn_inv_mod(ret,a,n))
+        return NULL;
+    else
+        return ret;
+}
+static int cryptodev_ec_point_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
+                 const EC_POINT *b, BN_CTX *ctx)
+{
+    int ret = 1;
+    unsigned short max_size = 0;
+    const EC_POINT *generator = NULL;
+    cryptodev_ecc_point_t point_a = {0}, point_b = {0}, point_r = {0};
+#ifndef HW_ENDIAN_SWAP	
+	EC_POINT *tmp_point = NULL;
+#endif	
+
+    BN_CTX_start(ctx);
+    
+    if (NULL == group || NULL == a || NULL == b || NULL == r) {
+        perror("cryptodev_ec_point_add failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    generator = EC_GROUP_get0_generator(group);
+    if (NULL == generator) {
+        perror("cryptodev_ec_point_add failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    if (!generator->Z_is_one) {
+        printf("\n cryptodev_ec_point_add : Z of the generator is NOT 1! We don't support the case\n");
+        ret = 0;
+        goto check_exit;
+    }
+    max_size = group->field->top;
+    if (NULL == cryptodev_bn_wexpand( r->X, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (NULL == cryptodev_bn_wexpand( r->Y, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+#ifndef HW_ENDIAN_SWAP
+		if (r == a) {
+			tmp_point = EC_POINT_new(group);
+			if(NULL == BN_copy(tmp_point->X,a->X))
+				goto check_exit;
+			if(NULL == BN_copy(tmp_point->Y,a->Y))
+				goto check_exit;
+			BN_set_word(tmp_point->Z,1);
+			tmp_point->Z_is_one = 1;
+			point_a.x = (unsigned char*)tmp_point->X->d;
+		    point_a.x_size = BN_num_bytes(tmp_point->X);
+		    point_a.y = (unsigned char*)tmp_point->Y->d;
+		    point_a.y_size = BN_num_bytes(tmp_point->Y);
+		    point_b.x = (unsigned char*)b->X->d;
+		    point_b.x_size = BN_num_bytes(b->X);
+		    point_b.y = (unsigned char*)b->Y->d;
+		    point_b.y_size = BN_num_bytes(b->Y);
+		}
+		else if (r == b) {
+			tmp_point = EC_POINT_new(group);
+			if(NULL == BN_copy(tmp_point->X,a->X))
+				goto check_exit;
+			if(NULL == BN_copy(tmp_point->Y,a->Y))
+				goto check_exit;
+			BN_set_word(tmp_point->Z,1);
+			tmp_point->Z_is_one = 1;
+			point_a.x = (unsigned char*)a->X->d;
+		    point_a.x_size = BN_num_bytes(a->X);
+		    point_a.y = (unsigned char*)a->Y->d;
+		    point_a.y_size = BN_num_bytes(a->Y);
+		    point_b.x = (unsigned char*)tmp_point->X->d;
+		    point_b.x_size = BN_num_bytes(tmp_point->X);
+		    point_b.y = (unsigned char*)tmp_point->Y->d;
+		    point_b.y_size = BN_num_bytes(tmp_point->Y);
+		}
+		else {
+			point_a.x = (unsigned char*)a->X->d;
+		    point_a.x_size = BN_num_bytes(a->X);
+		    point_a.y = (unsigned char*)a->Y->d;
+		    point_a.y_size = BN_num_bytes(a->Y);
+		    point_b.x = (unsigned char*)b->X->d;
+		    point_b.x_size = BN_num_bytes(b->X);
+		    point_b.y = (unsigned char*)b->Y->d;
+		    point_b.y_size = BN_num_bytes(b->Y);
+		}
+#else
+    point_a.x = (unsigned char*)a->X->d;
+    point_a.x_size = BN_num_bytes(a->X);
+    point_a.y = (unsigned char*)a->Y->d;
+    point_a.y_size = BN_num_bytes(a->Y);
+    point_b.x = (unsigned char*)b->X->d;
+    point_b.x_size = BN_num_bytes(b->X);
+    point_b.y = (unsigned char*)b->Y->d;
+    point_b.y_size = BN_num_bytes(b->Y);
+#endif
+    point_r.x = (unsigned char*)r->X->d;
+    point_r.y = (unsigned char*)r->Y->d;
+    if (0 != hw_ec_point_add(&point_a, &point_b, (unsigned char *)(group->field->d), BN_num_bytes(group->field), (unsigned char*)group->a->d,
+        BN_num_bytes(group->a), (unsigned char*)group->b->d, BN_num_bytes(group->b), &point_r, curve2field(group->curve_name))) {
+        ret = 0;
+        perror("hw_ec_point_add failed!\n");
+        goto check_exit;
+    }
+    
+check_exit:
+    BN_CTX_end(ctx);
+    return( ret );
+}
+static int cryptodev_ec_point_double(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
+                 BN_CTX *ctx)
+{
+    int ret = 1;
+    unsigned short max_size = 0;
+    const EC_POINT *generator = NULL;
+    cryptodev_ecc_point_t point_a, point_r;
+
+    BN_CTX_start(ctx);
+    
+    if (NULL == group || NULL == a || NULL == r) {
+        perror("cryptodev_ec_point_double failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    generator = EC_GROUP_get0_generator(group);
+    if (NULL == generator) {
+        perror("cryptodev_ec_point_double failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    if (!generator->Z_is_one) {
+        printf("\n cryptodev_ec_point_double : Z of the generator is NOT 1! We don't support the case\n");
+        ret = 0;
+        goto check_exit;
+    }
+    max_size = group->field->top;
+    if (NULL == cryptodev_bn_wexpand( r->X, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (NULL == cryptodev_bn_wexpand( r->Y, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+
+    point_a.x = (unsigned char*)a->X->d;
+    point_a.x_size = BN_num_bytes(a->X);
+    point_a.y = (unsigned char*)a->Y->d;
+    point_a.y_size = BN_num_bytes(a->Y);
+    point_r.x = (unsigned char*)r->X->d;
+    point_r.y = (unsigned char*)r->Y->d;
+    if (0 != hw_ec_point_double(&point_a, (unsigned char *)(group->field->d), BN_num_bytes(group->field), (unsigned char*)group->a->d,
+        BN_num_bytes(group->a), (unsigned char*)group->b->d, BN_num_bytes(group->b), &point_r, curve2field(group->curve_name))) {
+        ret = 0;
+        perror("hw_ec_point_double failed!\n");
+        goto check_exit;
+    }
+    
+check_exit:
+    BN_CTX_end(ctx);
+    return( ret );
+}
+
+static int ec_point_mul(const EC_GROUP *group, EC_POINT *r, 
+                 const EC_POINT *a, const BIGNUM *m, int flags)
+{
+    int ret = 1;
+    unsigned short max_size= 0;
+    const EC_POINT *generator = NULL;
+#ifndef HW_ENDIAN_SWAP	
+	EC_POINT *tmp_point = NULL;
+#endif
+    cryptodev_ecc_point_t point_a  = {0}, point_r  = {0};
+
+    
+    if (NULL == group || NULL == a || NULL == m || NULL == r) {
+        perror("ec_point_mul failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    generator = EC_GROUP_get0_generator(group);
+    if (NULL == generator) {
+        perror("ec_point_mul failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    if (!generator->Z_is_one) {
+        printf("\n ec_point_mul : Z of the generator is NOT 1! We don't support the case\n");
+        ret = 0;
+        goto check_exit;
+    }
+    max_size = group->field->top;
+    if (NULL == cryptodev_bn_wexpand( r->X, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (NULL == cryptodev_bn_wexpand( r->Y, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+#ifndef HW_ENDIAN_SWAP
+	if (r == a) {
+		tmp_point = EC_POINT_new(group);
+		if(NULL == BN_copy(tmp_point->X,a->X))
+            goto check_exit;
+        if(NULL == BN_copy(tmp_point->Y,a->Y))
+            goto check_exit;
+        BN_set_word(tmp_point->Z,1);
+        tmp_point->Z_is_one = 1;
+		point_a.x = (unsigned char*)tmp_point->X->d;
+	    point_a.x_size = BN_num_bytes(tmp_point->X);
+	    point_a.y = (unsigned char*)tmp_point->Y->d;
+	    point_a.y_size = BN_num_bytes(tmp_point->Y);
+	}
+	else {
+		point_a.x = (unsigned char*)a->X->d;
+	    point_a.x_size = BN_num_bytes(a->X);
+	    point_a.y = (unsigned char*)a->Y->d;
+	    point_a.y_size = BN_num_bytes(a->Y);
+	}
+#else
+    point_a.x = (unsigned char*)a->X->d;
+    point_a.x_size = BN_num_bytes(a->X);
+    point_a.y = (unsigned char*)a->Y->d;
+    point_a.y_size = BN_num_bytes(a->Y);
+#endif	
+    point_r.x = (unsigned char*)r->X->d;
+    point_r.y = (unsigned char*)r->Y->d;
+    if (SM2_FLG_CHECK_INFINITY == flags) {
+        if (0 != hw_ec_point_mul_is_infinity(&point_a, (unsigned char *)(group->field->d), BN_num_bytes(group->field), (unsigned char *)(m->d), BN_num_bytes(m),
+            (unsigned char*)group->a->d, BN_num_bytes(group->a), (unsigned char*)group->b->d, BN_num_bytes(group->b), &point_r, curve2field(group->curve_name))) {
+            ret = 0;
+            perror("hw_ec_point_mul_is_infinity failed! point at infinity\n");
+            goto check_exit;
+        }
+    }
+    else {
+        if (0 != hw_ec_point_mul(&point_a, (unsigned char *)(group->field->d), BN_num_bytes(group->field), (unsigned char *)(m->d), BN_num_bytes(m),
+            (unsigned char*)group->a->d, BN_num_bytes(group->a), (unsigned char*)group->b->d, BN_num_bytes(group->b), &point_r, curve2field(group->curve_name))) {
+            ret = 0;
+            perror("hw_ec_point_mul failed!\n");
+            goto check_exit;
+        }
+    }
+    
+check_exit:
+#ifndef HW_ENDIAN_SWAP	
+	EC_POINT_free(tmp_point);
+#endif	
+    return( ret );
+}
+static int cryptodev_ec_point_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,
+                 const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx)
+{
+    int ret = 1;
+    const EC_POINT *generator = NULL;
+    EC_POINT *p = NULL,*o = NULL;
+    if (NULL == group || NULL == r) {
+        perror("cryptodev_ec_point_mul failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    generator = EC_GROUP_get0_generator(group);
+    if (NULL == generator) {
+        perror("cryptodev_ec_point_mul failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    if (NULL == n && NULL != m) {
+        if(!ec_point_mul(group, r, q, m, r->flags)) {
+            perror("ec_point_mul failed!\n");
+            ret = 0;
+            goto check_exit;
+        }
+    }
+    else if (NULL != n && NULL == m) {
+        if(!ec_point_mul(group, r, generator, n, 0)) {
+            perror("ec_point_mul failed!\n");
+            ret = 0;
+            goto check_exit;
+        }
+    }
+    else {        
+        if ((p = EC_POINT_new(group)) == NULL) {
+            perror("EC_POINT_new failed!\n");
+            ret = 0;
+            goto check_exit;
+        }
+        if ((o = EC_POINT_new(group)) == NULL) {
+            perror("EC_POINT_new failed!\n");
+            ret = 0;
+            goto check_exit;
+        }
+        if(!ec_point_mul(group, p, q, m, 0)) {
+            perror("ec_point_mul failed!\n");
+            ret = 0;
+            goto check_exit;
+        }
+        if(!ec_point_mul(group, o, generator, n, 0)) {
+            perror("ec_point_mul failed!\n");
+            ret = 0;
+            goto check_exit;
+        }
+        if(!cryptodev_ec_point_add(group, r, o, p, ctx)) {
+            perror("cryptodev_ec_point_add failed!\n");
+            ret = 0;
+            goto check_exit;
+        }
+    }
+check_exit:
+    if (p)
+        EC_POINT_free(p);
+    if (o)
+        EC_POINT_free(o);
+    return( ret );
+}
+static int cryptodev_ec_check_point(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)
+{
+    int ret = 1;
+    const EC_POINT *generator = NULL;
+    cryptodev_ecc_point_t check_point = {0};
+
+    BN_CTX_start(ctx);
+    
+    if (NULL == group || NULL == point) {
+        perror("cryptodev_ec_check_point failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    generator = EC_GROUP_get0_generator(group);
+    if (NULL == generator) {
+        perror("cryptodev_ec_check_point failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    if (!generator->Z_is_one) {
+        printf("\n cryptodev_ec_check_point : Z of the generator is NOT 1! We don't support the case\n");
+        ret = 0;
+        goto check_exit;
+    }
+
+    check_point.x = (unsigned char*)point->X->d;    
+    check_point.x_size = BN_num_bytes(point->X);
+    check_point.y = (unsigned char*)point->Y->d;
+    check_point.y_size = BN_num_bytes(point->Y);
+
+    if (0 != hw_ec_check_point(&check_point, (unsigned char *)(group->field->d), BN_num_bytes(group->field), (unsigned char*)group->a->d,
+        BN_num_bytes(group->a), (unsigned char*)group->b->d, BN_num_bytes(group->b), curve2field(group->curve_name))) {
+        ret = 0;
+        perror("hw_ec_point_add failed!\n");
+        goto check_exit;
+    }
+    
+check_exit:
+    BN_CTX_end(ctx);
+    return( ret );
+}
+
+
+#ifdef USE_BUILTIN_PRIME_GENERATION
+static int cryptodev_rsa_keygen (RSA *rsa, int bits, BIGNUM *e_value, BN_GENCB *cb)
+{
+    BIGNUM *r1 = NULL, *r2 = NULL, *tmp = NULL, *tmp1 = NULL;
+    int bitsp, bitsq, ok = -1, n = 0;
+    BN_CTX *ctx = NULL;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if (bits > HW_MAX_MODULUS_SIZE_BITS) {
+        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+        goto err;
+    }
+    /*
+     * When generating ridiculously small keys, we can get stuck
+     * continually regenerating the same prime values.
+     */
+    if (bits < 16) {
+        ok = 0;             /* we set our own err */
+        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_KEY_SIZE_TOO_SMALL);
+        goto err;
+    }
 
-    t2 = BN_new();
-    if (t2 == NULL)
+    if ((cfd = get_dev_crypto()) < 0) {
+        ok = 0;             
+        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_RSA);
         goto err;
+    }
 
-    /* v = ( g^u1 * y^u2 mod p ) mod q */
-    /* let t1 = g ^ u1 mod p */
-    ret = 0;
+    ctx = BN_CTX_new();
+    if (ctx == NULL)
+        goto err;
+    BN_CTX_start(ctx);
+    r1 = BN_CTX_get(ctx);
+    r2 = BN_CTX_get(ctx);
+    tmp1 = BN_CTX_get(ctx);
 
-    DSA_get0_pqg(dsa, &dsap, NULL, &dsag);
-    DSA_get0_key(dsa, &dsapub_key, NULL);
+    bitsp = (bits + 1) / 2;
+    bitsq = bits - bitsp;
 
-    meth = DSA_get_method(dsa);
-    if (meth == NULL)
+    /* We need the RSA components non-NULL */
+    if (!rsa->n && ((rsa->n = BN_new()) == NULL))
+        goto err;
+    if (!rsa->d && ((rsa->d = BN_new()) == NULL))
+        goto err;
+    if (!rsa->e && ((rsa->e = BN_new()) == NULL))
         goto err;
-    bn_mod_exp = DSA_meth_get_bn_mod_exp(meth);
-    if (bn_mod_exp == NULL)
+    if (!rsa->p && ((rsa->p = BN_new()) == NULL))
+        goto err;
+    if (!rsa->q && ((rsa->q = BN_new()) == NULL))
+        goto err;
+    if (!rsa->dmp1 && ((rsa->dmp1 = BN_new()) == NULL))
+        goto err;
+    if (!rsa->dmq1 && ((rsa->dmq1 = BN_new()) == NULL))
+        goto err;
+    if (!rsa->iqmp && ((rsa->iqmp = BN_new()) == NULL))
         goto err;
 
-    if (!bn_mod_exp(dsa, t1, dsag, u1, dsap, ctx, mont))
+    if (BN_copy(rsa->e, e_value) == NULL)
         goto err;
 
-    /* let t2 = y ^ u2 mod p */
-    if (!bn_mod_exp(dsa, t2, dsapub_key, u2, dsap, ctx, mont))
+    /* generate p and q */
+    for (;;) {
+        if (!BN_generate_prime_ex(rsa->p, bitsp, 0, NULL, NULL, cb))
+            goto err;
+        if (0 == BN_set_word(tmp1,1))
+            goto err;
+        if (!cryptodev_bn_sub(r2, rsa->p, tmp1))
+            goto err;
+        if (!cryptodev_bn_gcd(r1, rsa->e, r2))
+            goto err;
+        if (BN_is_one(r1))
+            break;
+        if (!BN_GENCB_call(cb, 2, n++))
+            goto err;
+    }
+    if (!BN_GENCB_call(cb, 3, 0))
         goto err;
-    /* let t1 = t1 * t2 mod p */
-    if (!BN_mod_mul(t1, t1, t2, dsap, ctx))
+    for (;;) {
+        do {
+            if (!BN_generate_prime_ex(rsa->q, bitsq, 0, NULL, NULL, cb))
+                goto err;
+        } while (BN_cmp(rsa->p, rsa->q) == 0);
+        if (!cryptodev_bn_sub(r2, rsa->q, tmp1))
+            goto err;
+        if (!cryptodev_bn_gcd(r1, rsa->e, r2))
+            goto err;
+        if (BN_is_one(r1))
+            break;
+        if (!BN_GENCB_call(cb, 2, n++))
+            goto err;
+    }
+    if (!BN_GENCB_call(cb, 3, 1))
         goto err;
+    if (BN_cmp(rsa->p, rsa->q) < 0) {
+        tmp = rsa->p;
+        rsa->p = rsa->q;
+        rsa->q = tmp;
+    }
+    /* calculate n d dp dq qp*/
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_RSA_GENERATE_KEY;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_rsa_keygen: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_RSA_GENERATE_KEY;
+    kop.crk_pad1 = (bits + 7) / 8; /* n len*/
+	if (bn2crparam(rsa->p, &kop.crk_param[0]))
+        goto out_rsa_keygen;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->p));
+    if (bn2crparam(rsa->q, &kop.crk_param[1]))
+        goto out_rsa_keygen;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->q));
+	if (bn2crparam(rsa->e, &kop.crk_param[2]))
+        goto out_rsa_keygen;
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(rsa->e));
+    kop.crk_iparams = 3;
+    
+    kop.crk_param[kop.crk_iparams].crp_p = OPENSSL_malloc(kop.crk_pad1);
+    if(NULL == kop.crk_param[kop.crk_iparams].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams].crp_p, 0, kop.crk_pad1);
+
+    kop.crk_param[kop.crk_iparams+1].crp_p = OPENSSL_malloc(kop.crk_pad1);
+    if(NULL == kop.crk_param[kop.crk_iparams+1].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams+1].crp_p, 0, kop.crk_pad1);
+
+    kop.crk_param[kop.crk_iparams+2].crp_p = OPENSSL_malloc(BN_num_bytes(rsa->p));
+    if(NULL == kop.crk_param[kop.crk_iparams+2].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams+2].crp_p, 0, BN_num_bytes(rsa->p));
+
+    kop.crk_param[kop.crk_iparams+3].crp_p = OPENSSL_malloc(BN_num_bytes(rsa->p));
+    if(NULL == kop.crk_param[kop.crk_iparams+3].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams+3].crp_p, 0, BN_num_bytes(rsa->p));
+
+    kop.crk_param[kop.crk_iparams+4].crp_p = OPENSSL_malloc(BN_num_bytes(rsa->p));
+    if(NULL == kop.crk_param[kop.crk_iparams+4].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams+4].crp_p, 0, BN_num_bytes(rsa->p));
+
+    kop.crk_oparams = 5;
+    if (ioctl(cfd, CIOCKEY, &kop)) {
+        perror("\n cryptodev_rsa_keygen failed \n");
+        goto out_rsa_keygen;
+    }
+
+    /* Get n = p * q */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8, rsa->n);
+    /* Get D  = E^-1 mod ((P-1)*(Q-1)) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams+1].crp_p, (kop.crk_param[kop.crk_iparams+1].crp_nbits + 7)/8, rsa->d);
+    /* Get DP = D mod (P - 1) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams+2].crp_p, (kop.crk_param[kop.crk_iparams+2].crp_nbits + 7)/8, rsa->dmp1);
+    /* Get DQ = D mod (Q - 1) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams+3].crp_p, (kop.crk_param[kop.crk_iparams+3].crp_nbits + 7)/8, rsa->dmq1);
+    /* Get QP = Q^-1 mod P */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams+4].crp_p, (kop.crk_param[kop.crk_iparams+4].crp_nbits + 7)/8, rsa->iqmp);
+    ok = 1;
+    
+out_rsa_keygen:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses))
+        perror("cryptodev_rsa_keygen : ioctl(CIOCFSESSION)");
+    zapparams(&kop);
+
+err:
+    if (ok == -1) {
+        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_BN);
+        ok = 0;
+    }
+    if (ctx != NULL) {
+        BN_CTX_end(ctx);
+        BN_CTX_free(ctx);
+    }
+
+    return ok;
 
-    ret = 1;
- err:
-    BN_free(t2);
-    return (ret);
 }
+#else
+static int cryptodev_rsa_keygen (RSA *rsa, int rsabits, BIGNUM *e, BN_GENCB *cb)
+{
+    int ok = -1;
+    BN_CTX *ctx = NULL;
+    BIGNUM *P1 = NULL, *Q1 = NULL, *H = NULL, *G = NULL, *tmp;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
 
-static DSA_SIG *cryptodev_dsa_do_sign(const unsigned char *dgst, int dlen,
-                                      DSA *dsa)
+    if (rsabits < 3 || rsabits > HW_MAX_MODULUS_SIZE_BITS) {
+        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_BAD_RSA_PARAMETERS);
+        goto err;
+    }
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        ok = 0;             
+        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_RSA);
+        goto err;
+    }
+    
+    ctx = BN_CTX_new();
+    if (ctx == NULL)
+        goto err;
+    BN_CTX_start(ctx);
+    P1 = BN_CTX_get(ctx);
+    Q1 = BN_CTX_get(ctx);
+    H = BN_CTX_get(ctx);
+    G = BN_CTX_get(ctx);
+	tmp = BN_CTX_get(ctx);
+    if (P1 == NULL || Q1 == NULL || H == NULL || G == NULL)
+        goto err;
+
+    /* We need to check RSA components */
+    if (!rsa->n && ((rsa->n = BN_new()) == NULL))
+        goto err;
+    if (!rsa->d && ((rsa->d = BN_new()) == NULL))
+        goto err;
+    if (!rsa->e && ((rsa->e = BN_new()) == NULL))
+        goto err;
+    if (!rsa->p && ((rsa->p = BN_new()) == NULL))
+        goto err;
+    if (!rsa->q && ((rsa->q = BN_new()) == NULL))
+        goto err;
+    if (!rsa->dmp1 && ((rsa->dmp1 = BN_new()) == NULL))
+        goto err;
+    if (!rsa->dmq1 && ((rsa->dmq1 = BN_new()) == NULL))
+        goto err;
+    if (!rsa->iqmp && ((rsa->iqmp = BN_new()) == NULL))
+        goto err;
+
+    BN_copy(rsa->e, e);
+    /* Generate primes P and Q with Q < P so that:
+         * GCD( E, (P-1)*(Q-1) ) == 1
+       */
+	do {
+		if (!cryptodev_bn_generate_prime(rsa->p, (rsabits + 1) >> 1)) 
+			goto err;
+		if (!cryptodev_bn_generate_prime(rsa->q, (rsabits + 1) >> 1)) 
+			goto err;
+
+        if (BN_cmp(rsa->p, rsa->q) < 0)
+			BN_swap(rsa->p, rsa->q);
+
+        if (BN_cmp(rsa->p, rsa->q) == 0)
+            continue;
+		/*Calculate n = p * q */
+		if (!cryptodev_bn_mul(rsa->n, rsa->p, rsa->q))
+			goto err;
+        if (BN_num_bits(rsa->n) != rsabits)
+            continue;
+		if (0 == BN_set_word(tmp,1))
+            goto err;
+		if (!cryptodev_bn_sub(P1, rsa->p, tmp))
+			goto err;
+		if (!cryptodev_bn_sub(Q1, rsa->q, tmp))
+			goto err;
+		if (!cryptodev_bn_mul(H, P1, Q1))
+			goto err;
+		if (!cryptodev_bn_gcd(G, rsa->e, H))
+			goto err;
+    }
+    while( cryptodev_bn_int_cmp(G, 1) != 0 );
+
+    /* Calculate D  = E^-1 mod ((P-1)*(Q-1))
+       * Calculate DP = D mod (P - 1)
+       * Calculate DQ = D mod (Q - 1)
+       * Calculate QP = Q^-1 mod P
+       */
+	memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_RSA_GENERATE_KEY;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_rsa_keygen: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_RSA_GENERATE_KEY;
+    kop.crk_pad1 = (rsabits + 7) / 8; /* n len*/
+	if (bn2crparam(rsa->p, &kop.crk_param[0]))
+        goto out_rsa_keygen;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->p));
+    if (bn2crparam(rsa->q, &kop.crk_param[1]))
+        goto out_rsa_keygen;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->q));
+	if (bn2crparam(rsa->e, &kop.crk_param[2]))
+        goto out_rsa_keygen;
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(rsa->e));
+    kop.crk_iparams = 3;
+    
+    kop.crk_param[kop.crk_iparams].crp_p = OPENSSL_malloc(kop.crk_pad1);
+    if(NULL == kop.crk_param[kop.crk_iparams].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams].crp_p, 0, kop.crk_pad1);
+
+    kop.crk_param[kop.crk_iparams+1].crp_p = OPENSSL_malloc(kop.crk_pad1);
+    if(NULL == kop.crk_param[kop.crk_iparams+1].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams+1].crp_p, 0, kop.crk_pad1);
+
+    kop.crk_param[kop.crk_iparams+2].crp_p = OPENSSL_malloc(BN_num_bytes(rsa->p));
+    if(NULL == kop.crk_param[kop.crk_iparams+2].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams+2].crp_p, 0, BN_num_bytes(rsa->p));
+
+    kop.crk_param[kop.crk_iparams+3].crp_p = OPENSSL_malloc(BN_num_bytes(rsa->p));
+    if(NULL == kop.crk_param[kop.crk_iparams+3].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams+3].crp_p, 0, BN_num_bytes(rsa->p));
+
+    kop.crk_param[kop.crk_iparams+4].crp_p = OPENSSL_malloc(BN_num_bytes(rsa->p));
+    if(NULL == kop.crk_param[kop.crk_iparams+4].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams+4].crp_p, 0, BN_num_bytes(rsa->p));
+
+    kop.crk_oparams = 5;
+    if (ioctl(cfd, CIOCKEY, &kop)) {
+        perror("\n cryptodev_rsa_keygen failed \n");
+        goto out_rsa_keygen;
+    }
+
+    /* Get n = p * q */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8, rsa->n);
+    /* Get D  = E^-1 mod ((P-1)*(Q-1)) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams+1].crp_p, (kop.crk_param[kop.crk_iparams+1].crp_nbits + 7)/8, rsa->d);
+    /* Get DP = D mod (P - 1) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams+2].crp_p, (kop.crk_param[kop.crk_iparams+2].crp_nbits + 7)/8, rsa->dmp1);
+    /* Get DQ = D mod (Q - 1) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams+3].crp_p, (kop.crk_param[kop.crk_iparams+3].crp_nbits + 7)/8, rsa->dmq1);
+    /* Get QP = Q^-1 mod P */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams+4].crp_p, (kop.crk_param[kop.crk_iparams+4].crp_nbits + 7)/8, rsa->iqmp);
+
+	ok = 1;
+out_rsa_keygen:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses))
+        perror("cryptodev_rsa_keygen : ioctl(CIOCFSESSION)");
+    zapparams(&kop);
+    
+err:
+    if (ok == -1) {
+        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_USER);
+        ok = 0;
+    }
+    if (ctx != NULL) {
+        BN_CTX_end(ctx);
+        BN_CTX_free(ctx);
+    }
+    return ok;
+}
+#endif
+static int rsa_padding_check_ssl_v23(unsigned char *to, const unsigned char *from, int flen, int num)
 {
+    int i, j;
+    const unsigned char *p;
+
+    p = from;
+    if (flen < 10) {
+        RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, RSA_R_DATA_TOO_SMALL);
+        return (-1);
+    }
+    if ((*(p+1) != 02)) {
+        RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, RSA_R_BLOCK_TYPE_IS_NOT_02);
+        return (-1);
+    }
+    p += 2;
+    /* scan over padding data */
+    j = flen - 7;               /* one for type */
+    for (i = 0; i < j; i++)
+        if (p[i] == 03 && p[i+1] == 03 && p[i+2] == 03 && p[i+3] == 03 && p[i+4] == 03 && p[i+5] == 03 && p[i+6] == 03 && p[i+7] == 03)
+            break;
+
+    if ((i == j) || (i < 8)) {
+        RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,
+               RSA_R_NULL_BEFORE_BLOCK_MISSING);
+        return (-1);
+    }
+
+    i += 9;                        /* Skip over the '\0' */
+    p += i;
+    j = flen - i -2;
+    memcpy(to, p, (unsigned int)j);
+
+    return (j);
+}
+
+static int rsa_padding_check_pkcs1_oaep(unsigned char *to,
+                                      const unsigned char *from, int flen,
+                                      int num, const unsigned char *param,
+                                      int plen)
+{
+    int i, dblen, mlen = -1, one_index = 0, msg_index;
+    unsigned int good, found_one_byte;
+    const unsigned char *maskedseed, *maskeddb;
+    const EVP_MD *md;
+    const EVP_MD *mgf1md;
+    /*
+     * |em| is the encoded message, zero-padded to exactly |num| bytes: em =
+     * Y || maskedSeed || maskedDB
+     */
+    unsigned char *db = NULL, *em = NULL, seed[EVP_MAX_MD_SIZE],
+        phash[EVP_MAX_MD_SIZE];
+    int mdlen;
+
+    md = EVP_sha1();
+    mgf1md = md;
+
+    mdlen = EVP_MD_size(md);
+
+    if (flen <= 0)
+        return -1;
+    /*
+     * |num| is the length of the modulus; |flen| is the length of the
+     * encoded message. Therefore, for any |from| that was obtained by
+     * decrypting a ciphertext, we must have |flen| <= |num|. Similarly,
+     * num < 2 * mdlen + 2 must hold for the modulus irrespective of
+     * the ciphertext, see PKCS #1 v2.2, section 7.1.2.
+     * This does not leak any side-channel information.
+     */
+    if (num < flen || num < 2 * mdlen + 2)
+        goto decoding_err;
+
+    dblen = num - mdlen - 1;
+    db = OPENSSL_malloc(dblen);
+    em = OPENSSL_malloc(num);
+    if (db == NULL || em == NULL) {
+        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1, ERR_R_MALLOC_FAILURE);
+        goto cleanup;
+    }
+
+    /*
+     * Always do this zero-padding copy (even when num == flen) to avoid
+     * leaking that information. The copy still leaks some side-channel
+     * information, but it's impossible to have a fixed  memory access
+     * pattern since we can't read out of the bounds of |from|.
+     *
+     * TODO(emilia): Consider porting BN_bn2bin_padded from BoringSSL.
+     */
+    memset(em, 0, num);
+    memcpy(em + num - flen, from, flen);
+
+    /*
+     * The first byte must be zero, however we must not leak if this is
+     * true. See James H. Manger, "A Chosen Ciphertext  Attack on RSA
+     * Optimal Asymmetric Encryption Padding (OAEP) [...]", CRYPTO 2001).
+     */
+    good = constant_time_is_zero(em[0]);
+
+    maskedseed = em + 1;
+    maskeddb = em + 1 + mdlen;
+
+    if (PKCS1_MGF1(seed, mdlen, maskeddb, dblen, mgf1md))
+        goto cleanup;
+    for (i = 0; i < mdlen; i++)
+        seed[i] ^= maskedseed[i];
+
+    if (PKCS1_MGF1(db, dblen, seed, mdlen, mgf1md))
+        goto cleanup;
+    for (i = 0; i < dblen; i++)
+        db[i] ^= maskeddb[i];
+
+    if (!EVP_Digest((void *)param, plen, phash, NULL, md, NULL))
+        goto cleanup;
+
+    good &= constant_time_is_zero(CRYPTO_memcmp(db, phash, mdlen));
+
+    found_one_byte = 0;
+    for (i = mdlen; i < dblen; i++) {
+        /*
+         * Padding consists of a number of 0-bytes, followed by a 1.
+         */
+        unsigned int equals1 = constant_time_eq(db[i], 1);
+        unsigned int equals0 = constant_time_is_zero(db[i]);
+        one_index = constant_time_select_int(~found_one_byte & equals1,
+                                             i, one_index);
+        found_one_byte |= equals1;
+        good &= (found_one_byte | equals0);
+    }
+
+    good &= found_one_byte;
+
+    /*
+     * At this point |good| is zero unless the plaintext was valid,
+     * so plaintext-awareness ensures timing side-channels are no longer a
+     * concern.
+     */
+    if (!good)
+        goto decoding_err;
+
+    msg_index = one_index + 1;
+    mlen = dblen - msg_index;
+
+    memcpy(to, db + msg_index, mlen);
+    goto cleanup;
+
+ decoding_err:
+    /*
+     * To avoid chosen ciphertext attacks, the error message should not
+     * reveal which kind of decoding error happened.
+     */
+    RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1,
+           RSA_R_OAEP_DECODING_ERROR);
+ cleanup:
+    if (db != NULL)
+        OPENSSL_free(db);
+    if (em != NULL)
+        OPENSSL_free(em);
+    return mlen;
+}
+
+static int cryptodev_rsa_public_encrypt(int flen, const unsigned char *from,
+                                  unsigned char *to, RSA *rsa, int padding)
+{
+    BIGNUM *f;
+    int i, num = 0, r = -1;
+    unsigned char *buf = NULL;
+    BN_CTX *ctx = NULL;
+    int cfd;
+    struct session_op sess;
     struct crypt_kop kop;
-    BIGNUM *r, *s;
-    const BIGNUM *dsap = NULL, *dsaq = NULL, *dsag = NULL;
-    const BIGNUM *priv_key = NULL;
-    DSA_SIG *dsasig, *dsaret = NULL;
 
-    dsasig = DSA_SIG_new();
-    if (dsasig == NULL)
+   
+    if (BN_num_bits(rsa->n) > HW_MAX_MODULUS_SIZE_BITS || BN_num_bits(rsa->e) > HW_RSA_MAX_PUBEXP_BITS) {
+        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, RSA_R_MODULUS_TOO_LARGE);
+        return -1;
+    }
+
+    if (BN_ucmp(rsa->n, rsa->e) <= 0) {
+        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
+        return -1;
+    }
+    
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    if ((ctx = BN_CTX_new()) == NULL)
+        goto err;
+    BN_CTX_start(ctx);
+    num = BN_num_bytes(rsa->n);
+    f = BN_CTX_get(ctx);
+    buf = OPENSSL_malloc(num);
+    if (!f || !buf) {
+        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+    memset(buf, 0, num);
+    
+    switch (padding) {
+    case RSA_PKCS1_PADDING:
+        i = RSA_padding_add_PKCS1_type_2(buf, num, from, flen);
+        break;
+# ifndef OPENSSL_NO_SHA
+    case RSA_PKCS1_OAEP_PADDING:
+        i = RSA_padding_add_PKCS1_OAEP(buf, num, from, flen, NULL, 0);
+        break;
+# endif
+    case RSA_SSLV23_PADDING:
+        i = RSA_padding_add_SSLv23(buf, num, from, flen);
+        break;
+    case RSA_NO_PADDING:
+        i = RSA_padding_add_none(buf, num, from, flen);
+        break;
+    default:
+        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+        goto err;
+    }
+    if (i <= 0)
+        goto err;
+
+    if (BN_bin2bn(buf, num, f) == NULL)
         goto err;
 
+    if (BN_ucmp(f, rsa->n) >= 0) {
+        /* usually the padding functions would catch this */
+        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT,
+               RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+        goto err;
+    }
+    memset(&sess, 0, sizeof(sess));
     memset(&kop, 0, sizeof(kop));
-    kop.crk_op = CRK_DSA_SIGN;
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_RSA_PUBLIC;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_rsa_public_encrypt: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_RSA_PUBLIC;
+
+    /* inputs: rsa->n rsa->e f */    
+    if (bn2crparam(rsa->n, &kop.crk_param[0]))
+        goto out_rsa_public_encrypt;
+	int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->n));
+    if (bn2crparam(rsa->e, &kop.crk_param[1]))
+        goto out_rsa_public_encrypt;
+	int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->e));
+    kop.crk_param[2].crp_p = buf;
+    kop.crk_param[2].crp_nbits = num * 8;
+    kop.crk_param[3].crp_p = OPENSSL_malloc(num);
+    if(NULL == kop.crk_param[3].crp_p)
+        goto out_rsa_public_encrypt;
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) == 0) { 
+        int_swap(kop.crk_param[kop.crk_iparams].crp_p, num);
+        memcpy(to, kop.crk_param[kop.crk_iparams].crp_p, num);
+    }
+    else {
+        perror("\ncryptodev_rsa_public_encrypt: RSA encryption failed \n");
+        goto out_rsa_public_encrypt;
+    }
+    r = num;
+out_rsa_public_encrypt:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses))
+        perror("ncryptodev_rsa_public_encrypt : ioctl(CIOCFSESSION)");
+    zapparams(&kop);
+    
+err:    
+    if (ctx != NULL) {
+        BN_CTX_end(ctx);
+        BN_CTX_free(ctx);
+    }
+    put_dev_crypto(cfd);    
+    return (r);
+
+}
+/* signing */
+static int cryptodev_rsa_private_encrypt(int flen, const unsigned char *from,
+                                   unsigned char *to, RSA *rsa, int padding)
+{
+    BIGNUM *f;
+    int i, num = 0, r = -1;
+    unsigned char *buf = NULL;
+    BN_CTX *ctx = NULL;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    ssize_t nbits;
 
-    /* inputs: dgst dsa->p dsa->q dsa->g dsa->priv_key */
-    kop.crk_param[0].crp_p = (caddr_t) dgst;
-    kop.crk_param[0].crp_nbits = dlen * 8;
-    DSA_get0_pqg(dsa, &dsap, &dsaq, &dsag);
-    DSA_get0_key(dsa, NULL, &priv_key);
-    if (bn2crparam(dsap, &kop.crk_param[1]))
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    if ((ctx = BN_CTX_new()) == NULL)
         goto err;
-    if (bn2crparam(dsaq, &kop.crk_param[2]))
+    
+    BN_CTX_start(ctx);
+    num = BN_num_bytes(rsa->n);
+    f = BN_CTX_get(ctx);
+    buf = OPENSSL_malloc(num);
+    if (!f || !buf) {
+        RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, ERR_R_MALLOC_FAILURE);
         goto err;
-    if (bn2crparam(dsag, &kop.crk_param[3]))
+    }
+    memset(buf, 0, num);
+
+    switch (padding) {
+    case RSA_PKCS1_PADDING:
+        i = RSA_padding_add_PKCS1_type_1(buf, num, from, flen);
+        break;
+    case RSA_X931_PADDING:
+        i = RSA_padding_add_X931(buf, num, from, flen);
+        break;
+    case RSA_NO_PADDING:
+        i = RSA_padding_add_none(buf, num, from, flen);
+        break;
+    case RSA_SSLV23_PADDING:
+    default:
+        RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
         goto err;
-    if (bn2crparam(priv_key, &kop.crk_param[4]))
+    }
+    if (i <= 0)
         goto err;
-    kop.crk_iparams = 5;
 
-    r = BN_new();
-    if (r == NULL)
+    if (BN_bin2bn(buf, num, f) == NULL)
         goto err;
-    s = BN_new();
-    if (s == NULL)
+
+    if (BN_ucmp(f, rsa->n) >= 0) {
+        /* usually the padding functions would catch this */
+        RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
         goto err;
-    if (cryptodev_asym(&kop, BN_num_bytes(dsaq), r,
-                       BN_num_bytes(dsaq), s) == 0) {
-        DSA_SIG_set0(dsasig, r, s);
-        dsaret = dsasig;
-    } else {
-        dsaret = DSA_meth_get_sign(DSA_OpenSSL())(dgst, dlen, dsa);
     }
- err:
-    if (dsaret != dsasig)
-        DSA_SIG_free(dsasig);
-    kop.crk_param[0].crp_p = NULL;
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_RSA_PRIVATE;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_rsa_private_encrypt: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_RSA_PRIVATE;
+    /* inputs: rsa->p rsa->q rsa->iqmp rsa->dmp1 rsa->dmq1  f*/
+    if(rsa->p != NULL && rsa->q != NULL && rsa->dmp1 != NULL && rsa->dmq1 != NULL && rsa->iqmp != NULL) {
+        nbits = BN_num_bits(rsa->n);
+        kop.crk_pad1 = (nbits + 7) / 8; /* n len*/
+		if (bn2crparam(rsa->p, &kop.crk_param[0]))
+            goto out_rsa_private_encrypt;
+        int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->p));
+        if (bn2crparam(rsa->q, &kop.crk_param[1]))
+            goto out_rsa_private_encrypt;
+        int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->q));
+		if (bn2crparam(rsa->iqmp, &kop.crk_param[2]))
+            goto out_rsa_private_encrypt;
+        int_swap(kop.crk_param[2].crp_p, BN_num_bytes(rsa->iqmp));
+        if (bn2crparam(rsa->dmp1, &kop.crk_param[3]))
+            goto out_rsa_private_encrypt;
+        int_swap(kop.crk_param[3].crp_p, BN_num_bytes(rsa->dmp1));
+		if (bn2crparam(rsa->dmq1, &kop.crk_param[4]))
+            goto out_rsa_private_encrypt;
+        int_swap(kop.crk_param[4].crp_p, BN_num_bytes(rsa->dmq1));
+		kop.crk_param[5].crp_p = buf;
+        kop.crk_param[5].crp_nbits = num * 8;
+        kop.crk_param[6].crp_p = OPENSSL_malloc(num);
+        if(NULL == kop.crk_param[6].crp_p) {
+    		perror("cryptodev_rsa_private_encrypt: OPENSSL_malloc error");
+    		goto out_rsa_private_encrypt;
+    	}            
+        memset(kop.crk_param[6].crp_p, 0, num);
+        kop.crk_iparams = 6;
+        kop.crk_oparams = 1;
+    }
+    else {
+		/* inputs: rsa->n rsa->d f*/
+        if (bn2crparam(rsa->n, &kop.crk_param[0]))
+            goto out_rsa_private_encrypt;
+        int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->n));
+        if (bn2crparam(rsa->d, &kop.crk_param[1]))
+            goto out_rsa_private_encrypt;
+        int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->d));
+        kop.crk_param[2].crp_p = buf;
+        kop.crk_param[2].crp_nbits = num * 8;
+        kop.crk_param[3].crp_p = OPENSSL_malloc(num);
+        if(NULL == kop.crk_param[3].crp_p) {
+    		perror("cryptodev_rsa_private_encrypt: OPENSSL_malloc error");
+    		goto out_rsa_private_encrypt;
+    	}  
+        memset(kop.crk_param[3].crp_p, 0, num);
+        kop.crk_iparams = 3;
+        kop.crk_oparams = 1;
+    }
+
+    if (ioctl(cfd, CIOCKEY, &kop) == 0) {     
+        int_swap(kop.crk_param[kop.crk_iparams].crp_p, num);
+        memcpy(to, kop.crk_param[kop.crk_iparams].crp_p, num);           
+        r = num; 
+    }
+    else {
+        perror("cryptodev_rsa_private_encrypt: RSA encryption failed \n");
+        goto out_rsa_private_encrypt;
+    }    
+out_rsa_private_encrypt:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses))
+        perror("cryptodev_rsa_private_encrypt : ioctl(CIOCFSESSION)");    
     zapparams(&kop);
-    return dsaret;
+    
+err:
+    if (ctx != NULL) {
+        BN_CTX_end(ctx);
+        BN_CTX_free(ctx);
+    }
+    put_dev_crypto(cfd);
+    return (r);
 }
+/* signature verification */
+static int cryptodev_rsa_public_decrypt(int flen, const unsigned char *from,
+                                  unsigned char *to, RSA *rsa, int padding)
+{
+    BIGNUM *ret;
+    int i, num = 0, r = -1;
+    BN_CTX *ctx = NULL;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
 
-static int
-cryptodev_dsa_verify(const unsigned char *dgst, int dlen,
-                     DSA_SIG *sig, DSA *dsa)
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    if ((ctx = BN_CTX_new()) == NULL)
+        goto err;
+    
+    BN_CTX_start(ctx);
+    num = BN_num_bytes(rsa->n);
+    ret = BN_CTX_get(ctx);
+    if (!ret) {
+        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    if (flen > num) {
+        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_DATA_GREATER_THAN_MOD_LEN);
+        goto err;
+    }
+
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_RSA_PUBLIC;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_rsa_public_encrypt: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_RSA_PUBLIC;
+
+    /* inputs: rsa->n rsa->e f */    
+    if (bn2crparam(rsa->n, &kop.crk_param[0]))
+        goto out_rsa_public_decrypt;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->n));
+    if (bn2crparam(rsa->e, &kop.crk_param[1]))
+        goto out_rsa_public_decrypt;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->e));	
+    kop.crk_param[2].crp_p = OPENSSL_malloc(flen);
+    if(NULL == kop.crk_param[2].crp_p)
+        goto out_rsa_public_decrypt;
+    memset(kop.crk_param[2].crp_p, 0, flen);
+    kop.crk_param[2].crp_nbits = flen * 8;
+    memcpy(kop.crk_param[2].crp_p, from, flen);
+    int_swap(kop.crk_param[2].crp_p, flen);
+    kop.crk_param[3].crp_p = OPENSSL_malloc(num);
+    if(NULL == kop.crk_param[3].crp_p) {
+		perror("cryptodev_rsa_public_decrypt: OPENSSL_malloc error");
+		goto out_rsa_public_decrypt;
+	} 
+    memset(kop.crk_param[3].crp_p, 0, num);
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) == 0) {     
+        crparam2bn(&kop.crk_param[kop.crk_iparams], ret);
+        if ((padding == RSA_X931_PADDING) && ((kop.crk_param[kop.crk_iparams].crp_p[0] & 0xf) != 12))             
+            if (!BN_sub(ret, rsa->n, ret))
+                goto out_rsa_public_decrypt;
+
+        switch (padding) {
+        case RSA_PKCS1_PADDING:
+            {
+                int ilen, pad_count = 0, i;
+                unsigned char *p, bad, pad_done = 0;
+                
+                ilen = BN_num_bytes(rsa->n);
+                p = kop.crk_param[kop.crk_iparams].crp_p;
+                bad = 0;
+
+                bad |= *p++; /* First byte must be 0 */
+
+                /* This test does not depend on secret data */
+                 bad |= *p++ ^ 1;
+
+                /* Get padding len, but always read till end of buffer
+                             * (minus one, for the 00 byte) */
+                for( i = 0; i < ilen - 3; i++ )
+                {
+                    pad_done |= ( p[i] != 0xFF );
+                    pad_count += ( pad_done == 0 );
+                }
+
+                p += pad_count;
+                bad |= *p++; /* Must be zero */            
+
+                if( bad ) {
+                    RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+                    goto out_rsa_public_decrypt;
+                }
+                    
+                r = ilen - (p - kop.crk_param[kop.crk_iparams].crp_p);
+                memcpy( to, p, r );
+            }
+            break;
+        case RSA_X931_PADDING:
+            i = num;
+            r = RSA_padding_check_X931(to, num, kop.crk_param[kop.crk_iparams].crp_p, i, num);
+            break;
+        case RSA_NO_PADDING:
+            memcpy( to, kop.crk_param[kop.crk_iparams].crp_p, num );
+            r = num;
+            break;
+        default:
+            RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+            goto out_rsa_public_decrypt;
+        }
+        if (r < 0)
+            RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_PADDING_CHECK_FAILED);
+    }
+    else {
+        perror("\ncryptodev_rsa_public_encrypt: RSA decryption failed \n");
+        goto out_rsa_public_decrypt;
+    }
+out_rsa_public_decrypt:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses))
+        perror("ncryptodev_rsa_public_encrypt : ioctl(CIOCFSESSION)");
+    zapparams(&kop);
+    
+err:
+    if (ctx != NULL) {
+        BN_CTX_end(ctx);
+        BN_CTX_free(ctx);
+    }
+    put_dev_crypto(cfd);    
+    return (r);
+}
+
+static int cryptodev_rsa_private_decrypt(int flen, const unsigned char *from,
+                                   unsigned char *to, RSA *rsa, int padding)
 {
+    int j, num = 0, r = -1;
+    unsigned char *buf = NULL;
+    BN_CTX *ctx = NULL;
+    int cfd;
+    struct session_op sess;
     struct crypt_kop kop;
-    int dsaret = 1;
-    const BIGNUM *pr, *ps, *p = NULL, *q = NULL, *g = NULL, *pub_key = NULL;
+    ssize_t nbits;
+
+ 
+    if (flen <= 0 || (cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    
+    if ((ctx = BN_CTX_new()) == NULL)
+        goto err;
+    BN_CTX_start(ctx);
+    num = BN_num_bytes(rsa->n);
+    buf = OPENSSL_malloc(num);
+    if (!buf) {
+        RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+    memset(buf, 0, num);
+
+    /*
+     * This check was for equality but PGP does evil things and chops off the
+     * top '0' bytes
+     */
+    if (flen > num) {
+        RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_DATA_GREATER_THAN_MOD_LEN);
+        goto err;
+    }
 
+    memset(&sess, 0, sizeof(sess));
     memset(&kop, 0, sizeof(kop));
-    kop.crk_op = CRK_DSA_VERIFY;
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_RSA_PRIVATE;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_rsa_private_decrypt: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_RSA_PRIVATE;
+    /* inputs: rsa->p rsa->q rsa->iqmp rsa->dmp1 rsa->dmq1  f*/
+    if(rsa->p != NULL && rsa->q != NULL && rsa->dmp1 != NULL && rsa->dmq1 != NULL && rsa->iqmp != NULL) {
+        nbits = BN_num_bits(rsa->n);
+        kop.crk_pad1 = (nbits + 7) / 8; /* n len*/
+		if (bn2crparam(rsa->p, &kop.crk_param[0]))
+            goto out_rsa_private_decrypt;
+        int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->p));
+        if (bn2crparam(rsa->q, &kop.crk_param[1]))
+            goto out_rsa_private_decrypt;
+        int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->q));
+		if (bn2crparam(rsa->iqmp, &kop.crk_param[2]))
+            goto out_rsa_private_decrypt;
+        int_swap(kop.crk_param[2].crp_p, BN_num_bytes(rsa->iqmp));
+        if (bn2crparam(rsa->dmp1, &kop.crk_param[3]))
+            goto out_rsa_private_decrypt;
+        int_swap(kop.crk_param[3].crp_p, BN_num_bytes(rsa->dmp1));
+		if (bn2crparam(rsa->dmq1, &kop.crk_param[4]))
+            goto out_rsa_private_decrypt;
+        int_swap(kop.crk_param[4].crp_p, BN_num_bytes(rsa->dmq1));
+        kop.crk_param[5].crp_p = OPENSSL_malloc(flen);
+        if(NULL == kop.crk_param[5].crp_p) {
+            perror("cryptodev_rsa_private_decrypt: OPENSSL_malloc error");
+            goto out_rsa_private_decrypt;
+        }
+        memset(kop.crk_param[5].crp_p, 0, flen);
+        kop.crk_param[5].crp_nbits = flen * 8;
+        memcpy(kop.crk_param[5].crp_p, from, flen);
+        kop.crk_param[5].crp_nbits = flen * 8;
+        int_swap(kop.crk_param[5].crp_p, flen);
+        kop.crk_param[6].crp_p = OPENSSL_malloc(num);
+        if(NULL == kop.crk_param[6].crp_p) {
+    		perror("cryptodev_rsa_private_decrypt: OPENSSL_malloc error");
+    		goto out_rsa_private_decrypt;
+    	}            
+        memset(kop.crk_param[6].crp_p, 0, num);
+        kop.crk_iparams = 6;
+        kop.crk_oparams = 1;
+    }
+    else {
+		/* inputs: rsa->n rsa->d f*/
+        if (bn2crparam(rsa->n, &kop.crk_param[0]))
+            goto out_rsa_private_decrypt;
+        int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->n));
+        if (bn2crparam(rsa->d, &kop.crk_param[1]))
+            goto out_rsa_private_decrypt;
+        int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->d));
+        kop.crk_param[2].crp_p = OPENSSL_malloc(flen);
+        if(NULL == kop.crk_param[2].crp_p) {
+            perror("cryptodev_rsa_private_decrypt: OPENSSL_malloc error");
+            goto out_rsa_private_decrypt;
+        }
+        memset(kop.crk_param[2].crp_p, 0, flen);
+        kop.crk_param[2].crp_nbits = flen * 8;
+        memcpy(kop.crk_param[2].crp_p, from, flen);
+        int_swap(kop.crk_param[2].crp_p, flen);
+        kop.crk_param[3].crp_p = OPENSSL_malloc(num);
+        if(NULL == kop.crk_param[3].crp_p) {
+    		perror("cryptodev_rsa_private_decrypt: OPENSSL_malloc error");
+    		goto out_rsa_private_decrypt;
+    	}            
+        memset(kop.crk_param[3].crp_p, 0, num);
+        kop.crk_iparams = 3;
+        kop.crk_oparams = 1;
+    }
+
+    if (ioctl(cfd, CIOCKEY, &kop) == 0) {  
+        memcpy(buf, kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8);      
+        switch (padding) {
+        case RSA_PKCS1_PADDING:
+            {
+                int ilen, pad_count = 0, i;
+                unsigned char *p, bad, pad_done = 0;
+
+                
+                ilen = BN_num_bytes(rsa->n);
+                p = buf;
+                bad = 0;
+
+                bad |= *p++; /* First byte must be 0 */
+
+                /* This test does not depend on secret data */
+                bad |= *p++ ^ 2;
+
+                /* Get padding len, but always read till end of buffer
+                 * (minus one, for the 00 byte) */
+                for( i = 0; i < ilen - 3; i++ )
+                {
+                    pad_done |= ( p[i] == 0 );
+                    pad_count += ( pad_done == 0 );  /* all nozero padding bytes */
+                }
+                p += pad_count;
+                bad |= *p++; /* Must be zero */            
+
+                if( bad ) {
+                    RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+                    goto out_rsa_private_decrypt;
+                }
+                    
+                r = ilen - (p - buf);
+                memcpy( to, p, r );
+            }
+            break;
+
+# ifndef OPENSSL_NO_SHA
+        case RSA_PKCS1_OAEP_PADDING:
+            j = (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8;
+            r = rsa_padding_check_pkcs1_oaep(to, buf, j, num, NULL, 0);
+            break;
+# endif
+
+        case RSA_SSLV23_PADDING:
+            j = (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8;
+            r = rsa_padding_check_ssl_v23(to, buf, j, num);
+            break;
+
+        case RSA_NO_PADDING:
+            memcpy( to, buf, num );
+            r = num;
+            break;
+        default:
+            RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+            goto out_rsa_private_decrypt;
+        }
+        if (r < 0)
+            RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_PADDING_CHECK_FAILED);
+    
+    }
+    else {
+        perror("cryptodev_rsa_private_decrypt: RSA decryption failed \n");
+        goto out_rsa_private_decrypt;
+    }
+out_rsa_private_decrypt:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses))
+        perror("cryptodev_rsa_private_decrypt : ioctl(CIOCFSESSION)");
+    zapparams(&kop);
+    
+err:
+    if (ctx != NULL) {
+        BN_CTX_end(ctx);
+        BN_CTX_free(ctx);
+    }
+    if (buf != NULL) {
+        OPENSSL_free(buf);
+    }
+    put_dev_crypto(cfd);
+    
+    return (r);
+}
 
-    /* inputs: dgst dsa->p dsa->q dsa->g dsa->pub_key sig->r sig->s */
-    kop.crk_param[0].crp_p = (caddr_t) dgst;
-    kop.crk_param[0].crp_nbits = dlen * 8;
-    DSA_get0_pqg(dsa, &p, &q, &g);
-    if (bn2crparam(p, &kop.crk_param[1]))
+#ifndef OPENSSL_NO_DSA
+static DSA_SIG *cryptodev_dsa_do_sign(const unsigned char *dgst, int dlen,
+                                      DSA *dsa)
+{
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    BIGNUM *r = NULL, *s = NULL;
+    DSA_SIG *dsaret = NULL;    
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+    if (!dsa->p || !dsa->q || !dsa->g) {
+        printf("\n cryptodev_dsa_do_sign : missing parameters! \n");
+        goto err;
+    }
+    if ((r = BN_new()) == NULL)
         goto err;
-    if (bn2crparam(q, &kop.crk_param[2]))
+    if ((s = BN_new()) == NULL) {
+        BN_free(r);
         goto err;
-    if (bn2crparam(g, &kop.crk_param[3]))
+    }
+
+    if (dlen > BN_num_bytes(dsa->q))
         goto err;
-    DSA_get0_key(dsa, &pub_key, NULL);
-    if (bn2crparam(pub_key, &kop.crk_param[4]))
+        
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_DSA_SIGN;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_dsa_do_sign: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_DSA_SIGN;
+
+    /* inputs: dsa->p dsa->q dsa->g dsa->priv_key dgst */    
+    if (bn2crparam(dsa->p, &kop.crk_param[0]))
+        goto out_dsa_sign;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(dsa->p));
+    if (bn2crparam(dsa->q, &kop.crk_param[1]))
+        goto out_dsa_sign;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(dsa->q));
+    if (bn2crparam(dsa->g, &kop.crk_param[2]))
+        goto out_dsa_sign;
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(dsa->g));
+    if (bn2crparam(dsa->priv_key, &kop.crk_param[3]))
+        goto out_dsa_sign;
+    int_swap(kop.crk_param[3].crp_p, BN_num_bytes(dsa->priv_key));
+    kop.crk_param[4].crp_p = malloc(BN_num_bytes(dsa->q));
+    if (NULL == kop.crk_param[4].crp_p) {
+        perror("cryptodev_dsa_do_sign: OPENSSL_malloc error");
+        goto out_dsa_sign;
+    }
+    memset(kop.crk_param[4].crp_p, 0, BN_num_bytes(dsa->q));
+    kop.crk_param[4].crp_nbits = BN_num_bytes(dsa->q) * 8;
+    memcpy(kop.crk_param[4].crp_p, dgst, dlen);
+    kop.crk_iparams = 5;
+
+    if (r) {
+        kop.crk_param[kop.crk_iparams].crp_p = OPENSSL_malloc(BN_num_bytes(dsa->q));
+        kop.crk_param[kop.crk_iparams].crp_nbits = BN_num_bytes(dsa->q) * 8;
+    }
+    if (s) {
+        kop.crk_param[kop.crk_iparams + 1].crp_p = OPENSSL_malloc(BN_num_bytes(dsa->q));
+        kop.crk_param[kop.crk_iparams + 1].crp_nbits = BN_num_bytes(dsa->q) * 8;
+    }
+    kop.crk_oparams = 2;
+
+    if (ioctl(cfd, CIOCKEY, &kop) == 0) {
+        if (r) {
+            BN_bin2bn(kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8, r);
+        }
+        if (s) {
+            BN_bin2bn(kop.crk_param[kop.crk_iparams + 1].crp_p, (kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8, s);
+        }
+        dsaret = DSA_SIG_new();
+        if (dsaret == NULL)
+            goto out_dsa_sign;
+        dsaret->r = r;
+        dsaret->s = s;
+        r = s = NULL;
+    }
+out_dsa_sign:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_dsa_do_sign: ioctl(CIOCFSESSION)");
+    }
+ err:
+    BN_free(r);
+    BN_free(s);
+    kop.crk_param[4].crp_p = NULL;
+    put_dev_crypto(cfd);
+    zapparams(&kop);
+    return (dsaret);
+}
+
+static int
+cryptodev_dsa_verify(const unsigned char *dgst, int dlen,
+                     DSA_SIG *sig, DSA *dsa)
+{
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    int dsaret = 0;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+
+    if (BN_is_zero(sig->r) || BN_is_negative(sig->r) ||
+        BN_ucmp(sig->r, dsa->q) >= 0) {
+        dsaret = 0;
         goto err;
-    DSA_SIG_get0(sig, &pr, &ps);
-    if (bn2crparam(pr, &kop.crk_param[5]))
+    }
+    if (BN_is_zero(sig->s) || BN_is_negative(sig->s) ||
+        BN_ucmp(sig->s, dsa->q) >= 0) {
+        dsaret = 0;
         goto err;
-    if (bn2crparam(ps, &kop.crk_param[6]))
+    }
+
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_DSA_VERIFY;
+
+    if (dlen > BN_num_bytes(dsa->q))
         goto err;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_dsa_verify: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_DSA_VERIFY;
+
+    /* inputs: dsa->p dsa->q dsa->g dsa->pub_key dgst sig->r sig->s */
+    
+    if (bn2crparam(dsa->p, &kop.crk_param[0]))
+        goto out_dsa_verify;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(dsa->p));
+    if (bn2crparam(dsa->q, &kop.crk_param[1]))
+        goto out_dsa_verify;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(dsa->q));
+    if (bn2crparam(dsa->g, &kop.crk_param[2]))
+        goto out_dsa_verify;
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(dsa->g));
+    if (bn2crparam(dsa->pub_key, &kop.crk_param[3]))
+        goto out_dsa_verify;
+    int_swap(kop.crk_param[3].crp_p, BN_num_bytes(dsa->pub_key));
+    kop.crk_param[4].crp_p =  OPENSSL_malloc(dlen);
+    if(NULL == kop.crk_param[4].crp_p) {
+        perror("cryptodev_dsa_verify: OPENSSL_malloc error");
+        goto out_dsa_verify;
+    }
+    memset(kop.crk_param[4].crp_p, 0, BN_num_bytes(dsa->q));
+    memcpy(kop.crk_param[4].crp_p, dgst, dlen);
+    kop.crk_param[4].crp_nbits = BN_num_bytes(dsa->q) * 8;
+    if (bn2crparam(sig->r, &kop.crk_param[5]))
+        goto out_dsa_verify;
+    int_swap(kop.crk_param[5].crp_p, BN_num_bytes(sig->r));
+    if (bn2crparam(sig->s, &kop.crk_param[6]))
+        goto out_dsa_verify;
+    int_swap(kop.crk_param[6].crp_p, BN_num_bytes(sig->s));
     kop.crk_iparams = 7;
 
-    if (cryptodev_asym(&kop, 0, NULL, 0, NULL) == 0) {
-        /*
-         * OCF success value is 0, if not zero, change dsaret to fail
-         */
-        if (0 != kop.crk_status)
+    if (ioctl(cfd, CIOCKEY, &kop)) {
+        dsaret = 0;
+		perror("\n cryptodev_dsa_verify failed \n");
+	}
+    else {
+        if (1 == kop.crk_status)
+            dsaret = 1;
+        else
             dsaret = 0;
-    } else {
-        dsaret = DSA_meth_get_verify(DSA_OpenSSL())(dgst, dlen, sig, dsa);
+    } 
+out_dsa_verify:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_dsa_verify: ioctl(CIOCFSESSION)");
     }
  err:
     kop.crk_param[0].crp_p = NULL;
     zapparams(&kop);
+    put_dev_crypto(cfd);
     return (dsaret);
 }
-#endif
 
-#ifndef OPENSSL_NO_DH
 static int
-cryptodev_mod_exp_dh(const DH *dh, BIGNUM *r, const BIGNUM *a,
-                     const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,
-                     BN_MONT_CTX *m_ctx)
+cryptodev_dsa_keygen(DSA *dsa)
 {
-    return (cryptodev_bn_mod_exp(r, a, p, m, ctx, m_ctx));
+    int ok = 0;
+    BIGNUM *pub_key = NULL, *priv_key = NULL;
+    struct session_op sess;
+    struct crypt_kop kop;
+    int cfd, priv_key_len, pub_key_len;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+    if (dsa->priv_key == NULL) {
+        if ((priv_key = BN_new()) == NULL)
+            goto err;
+    } else
+        priv_key = dsa->priv_key;
+
+    if (dsa->pub_key == NULL) {
+        if ((pub_key = BN_new()) == NULL)
+            goto err;
+    } else
+        pub_key = dsa->pub_key;
+
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+
+	sess.pk_cipher = CRYPTO_ASYMMETRIC_DH_GENERATE_KEY;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_dsa_keygen: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_DH_GENERATE_KEY;
+    /* Set parameter q */
+    if (bn2crparam(dsa->p, &kop.crk_param[0]))
+        goto out_dsa_keygen;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(dsa->p));
+    /* Set parameter r */
+    if (bn2crparam(dsa->q, &kop.crk_param[1]))
+        goto out_dsa_keygen;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(dsa->q));
+    /* Set parameter g */
+    if (bn2crparam(dsa->g, &kop.crk_param[2]))
+        goto out_dsa_keygen;
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(dsa->g));
+    kop.crk_iparams = 3;
+    priv_key_len = BN_num_bytes(dsa->q);
+    pub_key_len = BN_num_bytes(dsa->p);
+    kop.crk_param[kop.crk_iparams].crp_p = OPENSSL_malloc(priv_key_len);
+    if (NULL == kop.crk_param[kop.crk_iparams].crp_p) {
+        perror("cryptodev_dsa_keygen: OPENSSL_malloc error");
+        goto out_dsa_keygen;
+    }
+    kop.crk_param[kop.crk_iparams].crp_nbits = priv_key_len * 8;    
+    kop.crk_param[kop.crk_iparams + 1].crp_p = OPENSSL_malloc(pub_key_len);
+    if (NULL == kop.crk_param[kop.crk_iparams + 1].crp_p) {
+        perror("cryptodev_dsa_keygen: OPENSSL_malloc error");
+        goto out_dsa_keygen;
+    }
+    kop.crk_param[kop.crk_iparams + 1].crp_nbits = pub_key_len * 8;
+	kop.crk_oparams = 2;
+    if (ioctl(cfd, CIOCKEY, &kop)) {
+		perror("\n cryptodev_dsa_keygen failed \n");
+		goto out_dsa_keygen;
+	}
+    /* Get parameter s (Private key) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8, priv_key);
+    /* Get parameter w (Public key) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams + 1].crp_p, (kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8, pub_key);
+    
+    dsa->priv_key = priv_key;
+    dsa->pub_key = pub_key;
+    ok = 1;
+    
+out_dsa_keygen:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_dsa_keygen: ioctl(CIOCFSESSION)");
+    }
+    zapparams(&kop);
+ err:
+    if ((pub_key != NULL) && (dsa->pub_key == NULL))
+        BN_free(pub_key);
+    if ((priv_key != NULL) && (dsa->priv_key == NULL))
+        BN_free(priv_key);
+    put_dev_crypto(cfd);
+    return (ok);
+}
+#endif
+
+static ECDSA_SIG *cryptodev_ecdsa_sign_sig(const unsigned char *dgst, int dgst_len,
+                                const BIGNUM *in_kinv, const BIGNUM *in_r,
+                                EC_KEY *eckey)
+{
+    BIGNUM *r = NULL, *s = NULL, *m = NULL, *order = NULL;
+    BN_CTX *ctx = NULL;
+    const EC_GROUP *group = NULL;
+    ECDSA_SIG *ecdsaret = NULL;
+    const EC_POINT *generator = NULL;
+    const BIGNUM *priv_key = NULL;
+    int cfd, i, free_tmpbuff = 0;
+    unsigned char *tmp_buff = NULL;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+	if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+	
+    group = EC_KEY_get0_group(eckey);
+    priv_key = EC_KEY_get0_private_key(eckey);
+
+    if (group == NULL || priv_key == NULL) {
+        ECDSAerr(EC_F_ECDSA_DO_SIGN_EX, ERR_R_PASSED_NULL_PARAMETER);
+        goto err;
+    }
+
+    if ((ctx = BN_CTX_new()) == NULL || (order = BN_new()) == NULL  || (m = BN_new()) == NULL) {
+        ECDSAerr(EC_F_ECDSA_DO_SIGN_EX, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+    
+    generator = EC_GROUP_get0_generator(group);
+    if (generator == NULL) {
+        ECerr(EC_F_ECDSA_DO_SIGN_EX, EC_R_UNDEFINED_GENERATOR);
+        goto err;
+    }
+    if (!generator->Z_is_one) {
+        printf("\n cryptodev_ecdsa_sign_sig : Z of the generator is NOT 1! We don't support the case\n");
+        goto err;
+    }
+    
+    if (!EC_GROUP_get_order(group, order, ctx)) {
+        ECDSAerr(EC_F_ECDSA_DO_SIGN_EX, ERR_R_EC_LIB);
+        goto err;
+    }
+    /*
+     * Need to truncate digest if it is too long.
+     */
+    i = BN_num_bits(order);
+    if ( i >= (8 * dgst_len - 7) && i < 8 * dgst_len) {
+        if (!BN_bin2bn(dgst, dgst_len, m) || !BN_rshift(m, m, 8 - (i & 0x7))) {
+            ECDSAerr(EC_F_ECDSA_DO_SIGN_EX, ERR_R_BN_LIB);
+            goto err;
+        }
+        dgst_len = BN_num_bytes(m);
+        tmp_buff = OPENSSL_malloc(dgst_len);
+        if (NULL == tmp_buff) {
+            perror("cryptodev_ecdsa_sign_sig: OPENSSL_malloc error");
+            goto err;
+        }
+        BN_bn2bin(m, tmp_buff);
+        free_tmpbuff = 1;
+    }
+    else if (i < (8 * dgst_len - 7)) {
+        dgst_len = (i + 7) / 8; 
+        tmp_buff = dgst;
+    }
+    else
+        tmp_buff = dgst;
+
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_ECDSA_SIGN;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_ecdsa_sign_sig : ioctl(CIOCGSESSION)");
+		goto err;
+	}    
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECDSA_SIGN;
+    kop.crk_flags = curve2field(group->curve_name);
+    if (KCOP_FLAG_NONE == kop.crk_flags)
+        goto out_ecdsa_sign;
+    /* inputs: ecdsa->p ecdsa->q ecdsa->g ecdsa->priv_key dgst ecdsa->a,b*/    
+	/* Set parameter q */
+    if (bn2crparam(group->field, &kop.crk_param[0]))
+        goto out_ecdsa_sign;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(group->field));
+
+	/* Set parameter r */
+    if (bn2crparam(order, &kop.crk_param[1]))
+        goto out_ecdsa_sign;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(order));
+
+    /* Set parameter Gx,y */
+    kop.crk_param[2].crp_p = OPENSSL_malloc(BN_num_bytes(group->field)*2);
+    if (NULL == kop.crk_param[2].crp_p)
+        goto out_ecdsa_sign;
+    memset(kop.crk_param[2].crp_p, 0, BN_num_bytes(group->field)*2);
+    kop.crk_param[2].crp_nbits = BN_num_bytes(group->field) * 16;
+    memcpy(kop.crk_param[2].crp_p, generator->X->d, BN_num_bytes(generator->X));
+    memcpy(kop.crk_param[2].crp_p + BN_num_bytes(group->field), generator->Y->d, BN_num_bytes(generator->Y));
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(group->field));
+    int_swap(kop.crk_param[2].crp_p + BN_num_bytes(group->field), BN_num_bytes(group->field));
+
+    /* Set parameter private key */
+    kop.crk_param[3].crp_p = OPENSSL_malloc(BN_num_bytes(order));
+    if(NULL == kop.crk_param[3].crp_p)
+        goto out_ecdsa_sign;
+    memset(kop.crk_param[3].crp_p, 0, BN_num_bytes(order));
+    kop.crk_param[3].crp_nbits = BN_num_bytes(order) * 8;
+    memcpy(kop.crk_param[3].crp_p, priv_key->d, BN_num_bytes(priv_key));
+    int_swap(kop.crk_param[3].crp_p, BN_num_bytes(order));
+
+    /* Set parameter f (or m) */
+    kop.crk_param[4].crp_p = OPENSSL_malloc(BN_num_bytes(order));
+    if(NULL == kop.crk_param[4].crp_p)
+        goto out_ecdsa_sign;
+    memset(kop.crk_param[4].crp_p, 0, BN_num_bytes(order));
+    kop.crk_param[4].crp_nbits = BN_num_bytes(order) * 8;
+    memcpy(kop.crk_param[4].crp_p, tmp_buff, dgst_len);    
+
+    /* Set parameter a,b */
+    kop.crk_param[5].crp_p = OPENSSL_malloc(BN_num_bytes(group->field)*2);
+    if (NULL == kop.crk_param[5].crp_p)
+        goto out_ecdsa_sign;
+    memset(kop.crk_param[5].crp_p, 0, BN_num_bytes(group->field)*2);
+    kop.crk_param[5].crp_nbits = BN_num_bytes(group->field) * 16;	
+    memcpy(kop.crk_param[5].crp_p,group->a->d, BN_num_bytes(group->a));
+    memcpy(kop.crk_param[5].crp_p + BN_num_bytes(group->field), group->b->d, BN_num_bytes(group->b));
+    int_swap(kop.crk_param[5].crp_p, BN_num_bytes(group->field));
+    int_swap(kop.crk_param[5].crp_p + BN_num_bytes(group->field), BN_num_bytes(group->field));	
+    kop.crk_iparams = 6;
+
+    kop.crk_param[kop.crk_iparams].crp_p = OPENSSL_malloc(BN_num_bytes(order));
+    kop.crk_param[kop.crk_iparams].crp_nbits = BN_num_bytes(order) * 8;
+    kop.crk_param[kop.crk_iparams + 1].crp_p = OPENSSL_malloc(BN_num_bytes(order));
+    kop.crk_param[kop.crk_iparams + 1].crp_nbits = BN_num_bytes(order) * 8;
+    kop.crk_oparams = 2;
+
+    if (ioctl(cfd, CIOCKEY, &kop) == 0) {
+        ecdsaret = ECDSA_SIG_new();
+        if (ecdsaret == NULL) {
+            ECDSAerr(EC_F_ECDSA_DO_SIGN_EX, ERR_R_MALLOC_FAILURE);
+            goto out_ecdsa_sign;
+        }
+        ecdsaret->r = BN_new();
+        ecdsaret->s = BN_new();
+        if (ecdsaret->r == NULL || ecdsaret->s == NULL) {
+            ECerr(EC_F_ECDSA_DO_SIGN_EX, ERR_R_MALLOC_FAILURE);
+            goto out_ecdsa_sign;
+        }
+        r = ecdsaret->r;
+        s = ecdsaret->s;
+        if (r) {
+            BN_bin2bn(kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8, r);
+        }
+        if (s) {
+            BN_bin2bn(kop.crk_param[kop.crk_iparams + 1].crp_p, (kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8, s);
+        }
+    }
+out_ecdsa_sign:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_ecdsa_sign_sig : ioctl(CIOCFSESSION)");
+    }
+   
+    zapparams(&kop);
+ err:  
+    if (ctx)
+        BN_CTX_free(ctx);
+    if (m)
+        BN_clear_free(m);
+    if (free_tmpbuff)
+        OPENSSL_free(tmp_buff);
+    if (order)
+        BN_free(order);
+    put_dev_crypto(cfd);    
+    return (ecdsaret);
+}
+
+int cryptodev_ecdsa_sign(int type, const unsigned char *dgst, int dlen,
+                    unsigned char *sig, unsigned int *siglen,
+                    const BIGNUM *kinv, const BIGNUM *r, EC_KEY *eckey)
+{
+    ECDSA_SIG *s;
+    RAND_seed(dgst, dlen);
+    s = cryptodev_ecdsa_sign_sig(dgst, dlen, kinv, r, eckey);
+    if (s == NULL) {
+        *siglen = 0;
+        return 0;
+    }
+    *siglen = i2d_ECDSA_SIG(s, &sig);
+    ECDSA_SIG_free(s);
+    return 1;
 }
 
+
 static int
-cryptodev_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)
+cryptodev_ecdsa_verify_sig(const unsigned char *dgst, int dlen,
+                     const ECDSA_SIG *sig, EC_KEY *eckey)
 {
+    int cfd, i, free_tmpbuff = 0;
+    unsigned char *tmp_buff = NULL;
+    struct session_op sess;
     struct crypt_kop kop;
-    int dhret = 1;
-    int fd, keylen;
-    const BIGNUM *p = NULL;
-    const BIGNUM *priv_key = NULL;
-
-    if ((fd = get_asym_dev_crypto()) < 0) {
-        const DH_METHOD *meth = DH_OpenSSL();
+    int dsaret = 0;
+    BIGNUM *order = NULL, *m = NULL;
+    const EC_POINT *generator = NULL;
+    BN_CTX *ctx = NULL;
+    const EC_GROUP *group;
+    const EC_POINT *pub_key;
+
+    /* check input values */
+    if (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL ||
+        (pub_key = EC_KEY_get0_public_key(eckey)) == NULL || sig == NULL) {
+        ECDSAerr(EC_F_ECDSA_DO_VERIFY, EC_R_MISSING_PARAMETERS);
+        return -1;
+    }
 
-        return DH_meth_get_compute_key(meth)(key, pub_key, dh);
+    
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
     }
+    ctx = BN_CTX_new();
+    if (!ctx) {
+        ECDSAerr(EC_F_ECDSA_DO_VERIFY, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+    BN_CTX_start(ctx);
 
-    DH_get0_pqg(dh, &p, NULL, NULL);
-    DH_get0_key(dh, NULL, &priv_key);
+    generator = EC_GROUP_get0_generator(group);
+    if (generator == NULL) {
+        ECerr(EC_F_EC_WNAF_MUL, EC_R_UNDEFINED_GENERATOR);
+        goto err;
+    }
+    if (!(generator->Z_is_one)) {
+        printf("\n cryptodev_ecdsa_verify_sig : Z of the generator is NOT 1! We don't support the case\n");
+        goto err;
+    }
 
-    keylen = BN_num_bits(p);
+    order = BN_CTX_get(ctx);
+    m = BN_CTX_get(ctx);
+    if (!EC_GROUP_get_order(group, order, ctx))
+        goto err;
+    if (BN_is_zero(sig->r) || BN_is_negative(sig->r) ||
+        BN_ucmp(sig->r, order) >= 0 || BN_is_zero(sig->s) ||
+        BN_is_negative(sig->s) || BN_ucmp(sig->s, order) >= 0) {
+        ECDSAerr(EC_F_ECDSA_DO_VERIFY, EC_R_BAD_SIGNATURE);
+        dsaret = 0;                /* signature is invalid */
+        goto err;
+    }
 
+    /*
+      * Need to truncate digest if it is too long.
+      */
+    i = BN_num_bits(order);
+    if ( i >= (8 * dlen - 7) && i < 8 * dlen) {
+        if (!BN_bin2bn(dgst, dlen, m) || !BN_rshift(m, m, 8 - (i & 0x7))) {
+            ECDSAerr(EC_F_ECDSA_DO_SIGN_EX, ERR_R_BN_LIB);
+            goto err;
+        }
+        dlen = BN_num_bytes(m);
+        tmp_buff = OPENSSL_malloc(dlen);
+        if (NULL == tmp_buff) {
+            perror("cryptodev_ecdsa_verify_sig: OPENSSL_malloc error");
+            goto err;
+        }
+        BN_bn2bin(m, tmp_buff);
+        free_tmpbuff = 1;
+    }
+    else if (i < (8 * dlen - 7)) {
+        dlen = (i + 7) / 8; 
+        tmp_buff = dgst;
+    }
+    else
+        tmp_buff = dgst;
+    
+    memset(&sess, 0, sizeof(sess));
     memset(&kop, 0, sizeof(kop));
-    kop.crk_op = CRK_DH_COMPUTE_KEY;
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_ECDSA_VERIFY;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_ecdsa_verify_sig : ioctl(CIOCGSESSION)");
+		goto err;
+	}
+
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECDSA_VERIFY;
+    kop.crk_flags = curve2field(group->curve_name);
+    if (KCOP_FLAG_NONE == kop.crk_flags)
+        goto out_ecdsa_verify;
+    
+    /* inputs: ecdsa->q ecdsa->r ecdsa->g ecdsa->pub_key dgst sig->r sig->s ecdsa->a,b*/
+    /* Set parameter q */
+    if (bn2crparam(group->field, &kop.crk_param[0]))
+        goto out_ecdsa_verify;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(group->field));
+
+	/* Set parameter r */
+    if (bn2crparam(order, &kop.crk_param[1]))
+        goto out_ecdsa_verify;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(order));
+
+    /* Set parameter Gx,y */
+    kop.crk_param[2].crp_p = OPENSSL_malloc(BN_num_bytes(group->field)*2);
+    if (NULL == kop.crk_param[2].crp_p)
+        goto out_ecdsa_verify;
+    memset(kop.crk_param[2].crp_p, 0, BN_num_bytes(group->field)*2);
+    kop.crk_param[2].crp_nbits = BN_num_bytes(group->field) * 16;
+    memcpy(kop.crk_param[2].crp_p, generator->X->d, BN_num_bytes(generator->X));
+    memcpy(kop.crk_param[2].crp_p + BN_num_bytes(group->field), generator->Y->d, BN_num_bytes(generator->Y));
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(group->field));
+    int_swap(kop.crk_param[2].crp_p + BN_num_bytes(group->field), BN_num_bytes(group->field));	
+
+    /* Set parameter public key */
+    kop.crk_param[3].crp_p = OPENSSL_malloc(BN_num_bytes(group->field)*2);
+    if (NULL == kop.crk_param[3].crp_p)
+        goto out_ecdsa_verify;
+    memset(kop.crk_param[3].crp_p, 0, BN_num_bytes(group->field)*2);
+    kop.crk_param[3].crp_nbits = BN_num_bytes(group->field) * 16;
+    memcpy(kop.crk_param[3].crp_p, pub_key->X->d, BN_num_bytes(pub_key->X));
+    memcpy(kop.crk_param[3].crp_p + BN_num_bytes(group->field), pub_key->Y->d, BN_num_bytes(pub_key->Y));
+    int_swap(kop.crk_param[3].crp_p, BN_num_bytes(group->field));
+    int_swap(kop.crk_param[3].crp_p + BN_num_bytes(group->field), BN_num_bytes(group->field));
+
+    /* Set parameter f (or m) */
+    kop.crk_param[4].crp_p = OPENSSL_malloc(BN_num_bytes(order));    
+    if(NULL == kop.crk_param[4].crp_p)
+        goto out_ecdsa_verify;
+    memset(kop.crk_param[4].crp_p, 0, BN_num_bytes(order));
+    kop.crk_param[4].crp_nbits = BN_num_bytes(order) * 8;
+    memcpy(kop.crk_param[4].crp_p, tmp_buff, dlen);    
+
+    /* Set parameter c */
+    kop.crk_param[5].crp_p = OPENSSL_malloc(BN_num_bytes(order));
+    if (NULL == kop.crk_param[5].crp_p)
+        goto out_ecdsa_verify;
+    memset(kop.crk_param[5].crp_p, 0, BN_num_bytes(order));
+    kop.crk_param[5].crp_nbits = BN_num_bytes(order) * 8;
+    memcpy(kop.crk_param[5].crp_p, sig->r->d, BN_num_bytes(sig->r));	
+    int_swap(kop.crk_param[5].crp_p, BN_num_bytes(order));
+
+    /* Set parameter d */
+    kop.crk_param[6].crp_p = OPENSSL_malloc(BN_num_bytes(order));
+    if (NULL == kop.crk_param[6].crp_p)
+        goto out_ecdsa_verify;
+    memset(kop.crk_param[6].crp_p, 0, BN_num_bytes(order));
+    kop.crk_param[6].crp_nbits = BN_num_bytes(order) * 8;
+    memcpy(kop.crk_param[6].crp_p, sig->s->d, BN_num_bytes(sig->s));	
+    int_swap(kop.crk_param[6].crp_p, BN_num_bytes(order));
+
+    /* Set parameter a,b */
+    kop.crk_param[7].crp_p = OPENSSL_malloc(BN_num_bytes(group->field)*2);
+    if (NULL == kop.crk_param[7].crp_p)
+        goto out_ecdsa_verify;
+    memset(kop.crk_param[7].crp_p, 0, BN_num_bytes(group->field)*2);
+    kop.crk_param[7].crp_nbits = BN_num_bytes(group->field) * 16;
+    memcpy(kop.crk_param[7].crp_p,eckey->group->a->d, BN_num_bytes(eckey->group->a));
+    memcpy(kop.crk_param[7].crp_p + BN_num_bytes(group->field), eckey->group->b->d, BN_num_bytes(eckey->group->b));
+    int_swap(kop.crk_param[7].crp_p, BN_num_bytes(group->field));
+    int_swap(kop.crk_param[7].crp_p + BN_num_bytes(group->field), BN_num_bytes(group->field));	
+	
+    kop.crk_iparams = 8;
+
+    if (ioctl(cfd, CIOCKEY, &kop)) {
+        dsaret = 0;
+		perror("\n cryptodev_ecdsa_verify_sig failed \n");
+	}
+    else {
+    /*
+       * OCF success value is 0, if not zero, change dsaret to fail
+       */
+        if (1 == kop.crk_status)
+            dsaret = 1;
+        else
+            dsaret = 0;
+    } 
+out_ecdsa_verify:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_ecdsa_verify_sig : ioctl(CIOCFSESSION)");
+    }
+    zapparams(&kop);
+ err:
+    BN_CTX_end(ctx);
+    if (ctx != NULL)
+        BN_CTX_free(ctx);
+    if (free_tmpbuff)
+        OPENSSL_free(tmp_buff);
+    put_dev_crypto(cfd);
+    return (dsaret);
+}
+
+int cryptodev_ecdsa_verify(int type, const unsigned char *dgst, int dgst_len,
+                      const unsigned char *sigbuf, int sig_len, EC_KEY *eckey)
+{
+    ECDSA_SIG *s;
+    const unsigned char *p = sigbuf;
+    unsigned char *der = NULL;
+    int derlen = -1;
+    int ret = -1;
+
+    s = ECDSA_SIG_new();
+    if (s == NULL)
+        return (ret);
+    if (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL)
+        goto err;
+    /* Ensure signature uses DER and doesn't have trailing garbage */
+    derlen = i2d_ECDSA_SIG(s, &der);
+    if (derlen != sig_len || memcmp(sigbuf, der, derlen) != 0)
+        goto err;
+    ret = cryptodev_ecdsa_verify_sig(dgst, dgst_len, s, eckey);
+ err:
+    OPENSSL_clear_free(der, derlen);
+    ECDSA_SIG_free(s);
+    return (ret);
+}
+
+int cryptodev_has_ecc(void)
+{
+    if ((cryptodev_asymfeat & CRF_ECDSA_SIGN) && (cryptodev_asymfeat & CRF_ECDSA_VERIFY) \
+            && (cryptodev_asymfeat & CRF_ECDH_COMPUTE_KEY) && (cryptodev_asymfeat & CRF_ECDH_GENERATE_KEY))
+        return 1;
+    else
+        return 0;
+}
+int cryptodev_ec_keygen(EC_KEY *eckey)
+{
+    int ok = 0;
+    BIGNUM *priv_key = NULL, *order = NULL;
+    EC_POINT *pub_key = NULL;
+    const EC_POINT *generator = NULL;
+    struct session_op sess;
+	struct crypt_kop kop;
+    int cfd, priv_key_len, pub_key_len;
+    BN_CTX *ctx = NULL;
+
+    if (!eckey || !eckey->group) {
+        ECerr(EC_F_EC_KEY_GENERATE_KEY, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+
+    generator = EC_GROUP_get0_generator(eckey->group);
+    if (generator == NULL) {
+        ECerr(EC_F_EC_WNAF_MUL, EC_R_UNDEFINED_GENERATOR);
+        goto err;
+    }
+    if (!(generator->Z_is_one)) {
+        printf("\n cryptodev_ecdsa_keygen : Z of the generator is NOT 1! We don't support the case\n");
+        goto err;
+    }
 
-    /* inputs: dh->priv_key pub_key dh->p key */
-    if (bn2crparam(priv_key, &kop.crk_param[0]))
+    if ((order = BN_new()) == NULL)
+        goto err;
+    if ((ctx = BN_CTX_new()) == NULL)
         goto err;
-    if (bn2crparam(pub_key, &kop.crk_param[1]))
+    
+    if (eckey->priv_key == NULL) {
+        priv_key = BN_new();
+        if (priv_key == NULL)
+            goto err;
+    } else
+        priv_key = eckey->priv_key;
+
+    if (!EC_GROUP_get_order(eckey->group, order, ctx))
         goto err;
-    if (bn2crparam(p, &kop.crk_param[2]))
+
+    if (eckey->pub_key == NULL) {
+        pub_key = EC_POINT_new(eckey->group);
+        if (pub_key == NULL)
+            goto err;
+    } else
+        pub_key = eckey->pub_key;
+
+    memset(&sess, 0, sizeof(sess));
+	memset(&kop, 0, sizeof(kop));
+
+	sess.pk_cipher = CRYPTO_ASYMMETRIC_ECDH_GENERATE_KEY;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_ecdsa_keygen : ioctl(CIOCGSESSION)");
+		goto err;
+	}
+    kop.ses = sess.ses;
+	kop.crk_op = CRK_ECDH_GENERATE_KEY;
+    kop.crk_flags = curve2field(eckey->group->curve_name);
+    if (KCOP_FLAG_NONE == kop.crk_flags)
+        goto out_ec_keygen;
+    /* Set parameter q */
+    if (bn2crparam(eckey->group->field, &kop.crk_param[0]))
+        goto out_ec_keygen;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(eckey->group->field));
+	
+    /* Set parameter r */
+    if (bn2crparam(order, &kop.crk_param[1]))
+        goto out_ec_keygen;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(order));
+	
+    /* Set parameter Gx,y */
+    kop.crk_param[2].crp_p = OPENSSL_malloc(BN_num_bytes(eckey->group->field)*2);
+    if (NULL == kop.crk_param[2].crp_p)
+        goto out_ec_keygen;
+    memset(kop.crk_param[2].crp_p, 0, BN_num_bytes(eckey->group->field)*2);
+    kop.crk_param[2].crp_nbits = BN_num_bytes(eckey->group->field) * 16;
+    memcpy(kop.crk_param[2].crp_p, generator->X->d, BN_num_bytes(generator->X));
+    memcpy(kop.crk_param[2].crp_p + BN_num_bytes(eckey->group->field), generator->Y->d, BN_num_bytes(generator->Y));
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(eckey->group->field));
+    int_swap(kop.crk_param[2].crp_p + BN_num_bytes(eckey->group->field), BN_num_bytes(eckey->group->field));
+	
+    /* Set parameter a,b */
+    kop.crk_param[3].crp_p = OPENSSL_malloc(BN_num_bytes(eckey->group->field)*2);
+    if (NULL == kop.crk_param[3].crp_p)
+        goto out_ec_keygen;
+    memset(kop.crk_param[3].crp_p, 0, BN_num_bytes(eckey->group->field)*2);
+    kop.crk_param[3].crp_nbits = BN_num_bytes(eckey->group->field) * 16;
+    memcpy(kop.crk_param[3].crp_p,eckey->group->a->d, BN_num_bytes(eckey->group->a));
+    memcpy(kop.crk_param[3].crp_p + BN_num_bytes(eckey->group->field), eckey->group->b->d, BN_num_bytes(eckey->group->b));
+    int_swap(kop.crk_param[3].crp_p, BN_num_bytes(eckey->group->field));
+    int_swap(kop.crk_param[3].crp_p + BN_num_bytes(eckey->group->field), BN_num_bytes(eckey->group->field));
+	
+    kop.crk_iparams = 4;
+    priv_key_len = BN_num_bytes(order);
+    pub_key_len = 2 * BN_num_bytes(eckey->group->field);
+    kop.crk_param[kop.crk_iparams].crp_p = OPENSSL_malloc(priv_key_len);
+    kop.crk_param[kop.crk_iparams].crp_nbits = priv_key_len * 8;
+    kop.crk_param[kop.crk_iparams + 1].crp_p = OPENSSL_malloc(pub_key_len);
+    kop.crk_param[kop.crk_iparams + 1].crp_nbits = pub_key_len * 8;
+	kop.crk_oparams = 2;
+    if (ioctl(cfd, CIOCKEY, &kop)) {
+		perror("\n cryptodev_ecdsa_keygen failed \n");
+		goto out_ec_keygen;
+	}
+    /* Get parameter s (Private key) */
+	BN_bin2bn(kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8, priv_key);
+    /* Get parameter Wx,y (Public key) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams + 1].crp_p, (kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8/2, pub_key->X);
+	BN_bin2bn(kop.crk_param[kop.crk_iparams + 1].crp_p + (kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8/2, (kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8/2, pub_key->Y);
+    BN_set_word(pub_key->Z,1);
+    pub_key->Z_is_one = 1;
+    
+    eckey->priv_key = priv_key;
+    eckey->pub_key = pub_key;
+    ok = 1;
+    
+out_ec_keygen:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_ecdsa_keygen : ioctl(CIOCFSESSION)");
+    }
+    zapparams(&kop);
+ err:
+    if (order)
+        BN_free(order);
+    if (pub_key != NULL && eckey->pub_key == NULL)
+        EC_POINT_free(pub_key);
+    if (priv_key != NULL && eckey->priv_key == NULL)
+        BN_free(priv_key);
+    if (ctx != NULL)
+        BN_CTX_free(ctx);
+    put_dev_crypto(cfd);
+    return (ok);
+}
+
+#ifndef OPENSSL_NO_DH
+static int cryptodev_dh_generate_key(DH *dh)
+{
+    int ok = 0;
+    BIGNUM *pub_key = NULL, *priv_key = NULL;
+    struct session_op sess;
+    struct crypt_kop kop;
+    int cfd, priv_key_len, pub_key_len;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+    if (dh->priv_key == NULL) {
+        if ((priv_key = BN_new()) == NULL)
+            goto err;
+    } else
+        priv_key = dh->priv_key;
+
+    if (dh->pub_key == NULL) {
+        if ((pub_key = BN_new()) == NULL)
+            goto err;
+    } else
+        pub_key = dh->pub_key;
+
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_DH_GENERATE_KEY;
+    if (ioctl(cfd, CIOCGSESSION, &sess)) {
+        perror("cryptodev_dh_generate_key : ioctl(CIOCGSESSION)");
         goto err;
+    }
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_DH_GENERATE_KEY;
+    /* Set parameter q */
+    if (bn2crparam(dh->p, &kop.crk_param[0]))
+        goto out_dh_keygen;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(dh->p));
+    /* Set parameter r */
+    if(dh->q) {
+        if (bn2crparam(dh->q, &kop.crk_param[1]))
+            goto out_dh_keygen;
+        int_swap(kop.crk_param[1].crp_p, BN_num_bytes(dh->q));
+    }
+    else {
+        if (bn2crparam(dh->p, &kop.crk_param[1]))
+            goto out_dh_keygen;
+        int_swap(kop.crk_param[1].crp_p, BN_num_bytes(dh->p));
+    }
+    
+    /* Set parameter g */
+    if (bn2crparam(dh->g, &kop.crk_param[2]))
+        goto out_dh_keygen;
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(dh->g));
     kop.crk_iparams = 3;
+    if(dh->q)
+        priv_key_len = BN_num_bytes(dh->q);
+    else
+        priv_key_len = BN_num_bytes(dh->p);
+    pub_key_len = BN_num_bytes(dh->p);
+    kop.crk_param[kop.crk_iparams].crp_p = OPENSSL_malloc(priv_key_len);
+    kop.crk_param[kop.crk_iparams].crp_nbits = priv_key_len * 8;
+    kop.crk_param[kop.crk_iparams + 1].crp_p = OPENSSL_malloc(pub_key_len);
+    kop.crk_param[kop.crk_iparams + 1].crp_nbits = pub_key_len * 8;
+    kop.crk_oparams = 2;
+    if (ioctl(cfd, CIOCKEY, &kop)) {
+        perror("\n cryptodev_dh_generate_key failed \n");
+        goto out_dh_keygen;
+    }
+    /* Get parameter s (Private key) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8, priv_key);
+    /* Get parameter w (Public key) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams + 1].crp_p, (kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8, pub_key);
+    
+    dh->priv_key = priv_key;
+    dh->pub_key = pub_key;
+    ok = 1;
+    
+out_dh_keygen:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_dh_generate_key : ioctl(CIOCFSESSION)");
+    }
+    zapparams(&kop);
+ err:
+    if ((pub_key != NULL) && (dh->pub_key == NULL))
+        BN_free(pub_key);
+    if ((priv_key != NULL) && (dh->priv_key == NULL))
+        BN_free(priv_key);
+    put_dev_crypto(cfd);
+    return (ok);
+}
 
-    kop.crk_param[3].crp_p = (caddr_t) key;
-    kop.crk_param[3].crp_nbits = keylen * 8;
-    kop.crk_oparams = 1;
+static int cryptodev_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)
+{
+    int ok = 0;
+    BIGNUM *tmp = NULL;
+    BN_CTX *ctx = NULL;
 
-    if (ioctl(fd, CIOCKEY, &kop) == -1) {
-        const DH_METHOD *meth = DH_OpenSSL();
+    *ret = 0;
+    ctx = BN_CTX_new();
+    if (ctx == NULL)
+        goto err;
+    BN_CTX_start(ctx);
+    tmp = BN_CTX_get(ctx);
+    if (tmp == NULL || !BN_set_word(tmp, 1))
+        goto err;
+    if (BN_cmp(pub_key, tmp) <= 0)
+        *ret |= DH_CHECK_PUBKEY_TOO_SMALL;
+    if (BN_copy(tmp, dh->p) == NULL || !BN_sub_word(tmp, 1))
+        goto err;
+    if (BN_cmp(pub_key, tmp) >= 0)
+        *ret |= DH_CHECK_PUBKEY_TOO_LARGE;
 
-        dhret = DH_meth_get_compute_key(meth)(key, pub_key, dh);
+    if (dh->q != NULL) {
+        /* Check pub_key^q == 1 mod p */
+        if (!cryptodev_bn_mod_exp(tmp, pub_key, dh->q, dh->p))
+            goto err;
+        if (!BN_is_one(tmp))
+            *ret |= DH_CHECK_PUBKEY_INVALID;
     }
+
+    ok = 1;
  err:
-    kop.crk_param[3].crp_p = NULL;
+    if (ctx != NULL) {
+        BN_CTX_end(ctx);
+        BN_CTX_free(ctx);
+    }
+    return (ok);
+}
+static int
+cryptodev_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)
+{
+    struct session_op sess;
+    struct crypt_kop kop;
+    int dhret = -1;
+    int cfd, keylen;
+    int check_result;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+    if (BN_num_bits(dh->p) > HW_DH_MAX_MODULUS_BITS) {
+        DHerr(DH_F_COMPUTE_KEY, DH_R_MODULUS_TOO_LARGE);
+        return 0;
+    }
+    if (!cryptodev_check_pub_key(dh, pub_key, &check_result) || check_result) {
+        DHerr(DH_F_COMPUTE_KEY, DH_R_INVALID_PUBKEY);
+        return -1;
+    }
+
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_DH_COMPUTE_KEY;
+    if (ioctl(cfd, CIOCGSESSION, &sess)) {
+        perror("cryptodev_dh_compute_key : ioctl(CIOCGSESSION)");
+        goto err;
+    }    
+    
+    keylen = BN_num_bits(dh->p);
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_DH_COMPUTE_KEY;
+
+    /* inputs: dh->p dh->priv_key pub_key key */
+    if (bn2crparam(dh->p, &kop.crk_param[0]))
+        goto out_dh_compute_key;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(dh->p));
+    if (bn2crparam(dh->priv_key, &kop.crk_param[1]))
+        goto out_dh_compute_key;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(dh->priv_key));
+    if (bn2crparam(pub_key, &kop.crk_param[2]))
+        goto out_dh_compute_key;    
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(pub_key));
+    kop.crk_iparams = 3;
+
+    kop.crk_param[3].crp_p = OPENSSL_malloc((keylen + 7)/8);  
+    if(NULL == kop.crk_param[3].crp_p)
+        goto out_dh_compute_key;
+    kop.crk_param[3].crp_nbits = keylen;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop))
+        perror("\n cryptodev_dh_compute_key failed \n");
+    else {        
+        dhret = (keylen + 7)/ 8;
+        int_swap(kop.crk_param[3].crp_p, dhret);
+        memcpy(key, kop.crk_param[3].crp_p, dhret);        
+    }
+out_dh_compute_key:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_dh_compute_key : ioctl(CIOCFSESSION)");
+    }    
+err:
+    put_dev_crypto(cfd);
     zapparams(&kop);
     return (dhret);
 }
 
 #endif /* ndef OPENSSL_NO_DH */
+static int cryptodev_ecdh_compute_key(unsigned char **pout, size_t *outlen, const EC_POINT *pub_key,
+                            const EC_KEY *ecdh)
+{
+    const BIGNUM *priv_key;
+    const EC_GROUP *group;
+	BIGNUM *order = NULL;
+	BN_CTX *ctx = NULL;
+    struct session_op sess;
+    struct crypt_kop kop;
+    int cfd, keylen;
+    int ecdhret = -1;
+    unsigned char *out = NULL;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+   	ctx = BN_CTX_new();
+    if (!ctx) {
+        ECDSAerr(EC_F_ECDH_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+    BN_CTX_start(ctx);
+	
+    priv_key = EC_KEY_get0_private_key(ecdh);
+    if (priv_key == NULL) {
+        ECDHerr(EC_F_ECDH_COMPUTE_KEY, EC_R_NO_PRIVATE_VALUE);
+        goto err;
+    }
+
+    group = EC_KEY_get0_group(ecdh);
+    if (group == NULL) {
+        ECDSAerr(EC_F_ECDH_COMPUTE_KEY, EC_R_UNDEFINED_ORDER);
+        goto err;
+    }
+
+	order = BN_CTX_get(ctx);
+    if (!EC_GROUP_get_order(group, order, ctx))
+        goto err;
+	
+    if (pub_key == NULL) {
+        ECerr(EC_F_EC_WNAF_MUL, EC_R_MISSING_PARAMETERS);
+        goto err;
+    }
+    if (!(pub_key->Z_is_one)) {
+        printf("\n cryptodev_ecdh_compute_key : Z of the generator is NOT 1! We don't support the case\n");
+        goto err;
+    }
+   
+    keylen = BN_num_bits(group->field);
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_ECDH_COMPUTE_KEY;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_ecdh_compute_key : ioctl(CIOCGSESSION)");
+		goto err;
+	}
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECDH_COMPUTE_KEY;
+    kop.crk_flags = curve2field(group->curve_name);
+    if (KCOP_FLAG_NONE == kop.crk_flags)
+        goto out_ecdh_compute_key;
+
+    /* inputs: ecdh->q ecdh->priv_key pub_key ecdh->a,b*/  
+	/* Set parameter q */
+    if (bn2crparam(group->field, &kop.crk_param[0]))
+        goto out_ecdh_compute_key;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(group->field));
+	
+    /* Set parameter private key */
+    kop.crk_param[1].crp_p = OPENSSL_malloc(BN_num_bytes(order));
+    if(NULL == kop.crk_param[1].crp_p)
+        goto out_ecdh_compute_key;
+    memset(kop.crk_param[1].crp_p, 0, BN_num_bytes(order));
+    kop.crk_param[1].crp_nbits = BN_num_bytes(order) * 8;
+    memcpy(kop.crk_param[1].crp_p, priv_key->d, BN_num_bytes(priv_key));
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(order));
+
+    /* Set parameter public key */
+    kop.crk_param[2].crp_p = OPENSSL_malloc(BN_num_bytes(group->field)*2);
+    if (NULL == kop.crk_param[2].crp_p)
+        goto out_ecdh_compute_key;
+    memset(kop.crk_param[2].crp_p, 0, BN_num_bytes(group->field)*2);
+    kop.crk_param[2].crp_nbits = BN_num_bytes(group->field) * 16;
+    memcpy(kop.crk_param[2].crp_p, pub_key->X->d, BN_num_bytes(pub_key->X));
+    memcpy(kop.crk_param[2].crp_p + BN_num_bytes(group->field), pub_key->Y->d, BN_num_bytes(pub_key->Y));
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(group->field));
+    int_swap(kop.crk_param[2].crp_p + BN_num_bytes(group->field), BN_num_bytes(group->field));
+
+    /* Set parameter a,b */
+    kop.crk_param[3].crp_p = OPENSSL_malloc(BN_num_bytes(group->field)*2);
+    if (NULL == kop.crk_param[3].crp_p)
+        goto out_ecdh_compute_key;
+    memset(kop.crk_param[3].crp_p, 0, BN_num_bytes(group->field)*2);
+    kop.crk_param[3].crp_nbits = BN_num_bytes(group->field) * 16;
+    memcpy(kop.crk_param[3].crp_p, group->a->d, BN_num_bytes(group->a));
+    memcpy(kop.crk_param[3].crp_p + BN_num_bytes(group->field), group->b->d, BN_num_bytes(group->b));
+    int_swap(kop.crk_param[3].crp_p, BN_num_bytes(group->field));
+    int_swap(kop.crk_param[3].crp_p + BN_num_bytes(group->field), BN_num_bytes(group->field));
+    
+    kop.crk_iparams = 4;
+    kop.crk_param[4].crp_p = OPENSSL_malloc((keylen + 7)/8);
+    if(NULL == kop.crk_param[4].crp_p)
+        goto out_ecdh_compute_key;
+    kop.crk_param[4].crp_nbits = keylen;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop)) 
+        perror("\n cryptodev_ecdh_compute_key failed \n");
+    else {
+        ecdhret = (keylen + 7)/ 8;
+        int_swap(kop.crk_param[4].crp_p, ecdhret);        
+        if ((out = OPENSSL_malloc(ecdhret)) == NULL) {
+            perror("\n cryptodev_ecdh_compute_key failed \n");
+            goto out_ecdh_compute_key;
+        }
+        memcpy(out, kop.crk_param[4].crp_p, ecdhret);
+        *pout = out;
+        *outlen = ecdhret;
+    }
+
+out_ecdh_compute_key:
+
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_ecdh_compute_key : ioctl(CIOCFSESSION)");
+    }
+    zapparams(&kop);    
+err:
+	BN_CTX_end(ctx);
+    if (ctx != NULL)
+        BN_CTX_free(ctx);
+    put_dev_crypto(cfd);    
+    return (ecdhret);
+}
+
+static const EC_KEY_METHOD cryptodev_ec_key = {
+    "cryptodev EC_KEY method",
+    0,
+    0,0,0,0,0,0,
+    cryptodev_ec_keygen,
+    cryptodev_ecdh_compute_key,
+    cryptodev_ecdsa_sign,
+    NULL,
+    cryptodev_ecdsa_sign_sig,
+    cryptodev_ecdsa_verify,
+    cryptodev_ecdsa_verify_sig,
+#ifndef OPENSSL_NO_SM2
+    ECIES_encrypt,
+    NULL,
+    ECIES_decrypt,
+    NULL,
+#endif
+    cryptodev_bn_add_word,
+    cryptodev_bn_add,
+    cryptodev_bn_sub,
+    cryptodev_bn_mul2,
+    cryptodev_bn_mod_add,
+    cryptodev_bn_mod_sub,
+    cryptodev_bn_mod_mul,
+    cryptodev_bn_mod_sqr,
+    cryptodev_bn_mod_inverse,
+    cryptodev_bn_mod_ctx,
+    cryptodev_bn_nnmod,
+    cryptodev_ec_point_add,
+    cryptodev_ec_point_double,
+    cryptodev_ec_point_mul,
+    cryptodev_ec_check_point,
+};
+
+static int cryptodev_rand_bytes(unsigned char *buf, int num)
+{
+    int fd;
+	int cnt = 0;
+
+	fd = open("/dev/hwrng", O_RDONLY);
+	if(fd < 0) {
+		printf("hwrng open failed");
+		return -1;
+	}
+
+	do {
+		cnt = read(fd, buf, num);
+	} while(cnt != num);
+
+	close(fd);
+
+	return 1;
+}
+
+RAND_METHOD cryptodev_rand = {
+    NULL,
+    cryptodev_rand_bytes,
+    NULL,
+    NULL,
+    cryptodev_rand_bytes,
+    NULL
+};
 
 /*
  * ctrl right now is just a wrapper that doesn't do much
@@ -1656,7 +7561,7 @@ cryptodev_ctrl(ENGINE *e, int cmd, long
 void engine_load_cryptodev_int(void)
 {
     ENGINE *engine = ENGINE_new();
-    int fd;
+    int fd, rand_fd;
 
     if (engine == NULL)
         return;
@@ -1685,19 +7590,40 @@ void engine_load_cryptodev_int(void)
         ENGINE_free(engine);
         return;
     }
+    if (ENGINE_set_RAND(engine, &cryptodev_rand)) {
+        rand_fd = open("/dev/hwrng", O_RDONLY);
+    	if (rand_fd < 0) {
+    		perror("hwrng open failed");
+            const RAND_METHOD *rand_meth = RAND_OpenSSL();
+            cryptodev_rand.seed = rand_meth->seed;
+            cryptodev_rand.bytes = rand_meth->bytes;
+            cryptodev_rand.cleanup = rand_meth->cleanup;
+            cryptodev_rand.add = rand_meth->add;
+            cryptodev_rand.pseudorand = rand_meth->pseudorand;
+            cryptodev_rand.status = rand_meth->status;
+    	}
+    }
 
     cryptodev_rsa = RSA_meth_dup(RSA_PKCS1_OpenSSL());
     if (cryptodev_rsa != NULL) {
         RSA_meth_set1_name(cryptodev_rsa, "cryptodev RSA method");
         RSA_meth_set_flags(cryptodev_rsa, 0);
         if (ENGINE_set_RSA(engine, cryptodev_rsa)) {
-            if (cryptodev_asymfeat & CRF_MOD_EXP) {
-                RSA_meth_set_bn_mod_exp(cryptodev_rsa, cryptodev_bn_mod_exp);
-                if (cryptodev_asymfeat & CRF_MOD_EXP_CRT)
-                    RSA_meth_set_mod_exp(cryptodev_rsa, cryptodev_rsa_mod_exp);
-                else
-                    RSA_meth_set_mod_exp(cryptodev_rsa,
-                                         cryptodev_rsa_nocrt_mod_exp);
+            if ((cryptodev_asymfeat & CRF_RSA_PUBLIC) && (cryptodev_asymfeat & CRF_RSA_PRIVATE)) {
+                RSA_meth_set_pub_enc(cryptodev_rsa, cryptodev_rsa_public_encrypt);
+                RSA_meth_set_pub_dec(cryptodev_rsa, cryptodev_rsa_public_decrypt);
+                RSA_meth_set_priv_enc(cryptodev_rsa, cryptodev_rsa_private_encrypt);
+                RSA_meth_set_priv_dec(cryptodev_rsa, cryptodev_rsa_private_decrypt);
+                RSA_meth_set_keygen(cryptodev_rsa, cryptodev_rsa_keygen);
+                RSA_meth_set_mod_exp(cryptodev_rsa, NULL);
+                RSA_meth_set_bn_mod_exp(cryptodev_rsa, NULL);
+                RSA_meth_set_init(cryptodev_rsa, NULL);
+                RSA_meth_set_finish(cryptodev_rsa, NULL);
+                RSA_meth_set_flags(cryptodev_rsa, 0);
+                RSA_meth_set0_app_data(cryptodev_rsa, NULL);
+                RSA_meth_set_sign(cryptodev_rsa, NULL);
+                RSA_meth_set_verify(cryptodev_rsa, NULL);
+
             }
         }
     } else {
@@ -1711,15 +7637,19 @@ void engine_load_cryptodev_int(void)
         DSA_meth_set1_name(cryptodev_dsa, "cryptodev DSA method");
         DSA_meth_set_flags(cryptodev_dsa, 0);
         if (ENGINE_set_DSA(engine, cryptodev_dsa)) {
-            if (cryptodev_asymfeat & CRF_DSA_SIGN)
+            if ((cryptodev_asymfeat & CRF_DSA_SIGN) && (cryptodev_asymfeat & CRF_DSA_VERIFY)) {            
                 DSA_meth_set_sign(cryptodev_dsa, cryptodev_dsa_do_sign);
-            if (cryptodev_asymfeat & CRF_MOD_EXP) {
-                DSA_meth_set_bn_mod_exp(cryptodev_dsa,
-                                        cryptodev_dsa_bn_mod_exp);
-                DSA_meth_set_mod_exp(cryptodev_dsa, cryptodev_dsa_dsa_mod_exp);
-            }
-            if (cryptodev_asymfeat & CRF_DSA_VERIFY)
                 DSA_meth_set_verify(cryptodev_dsa, cryptodev_dsa_verify);
+                DSA_meth_set_keygen(cryptodev_dsa, cryptodev_dsa_keygen);
+                DSA_meth_set_sign_setup(cryptodev_dsa, NULL);
+                DSA_meth_set_mod_exp(cryptodev_dsa, NULL);
+                DSA_meth_set_bn_mod_exp(cryptodev_dsa, NULL);
+                DSA_meth_set_init(cryptodev_dsa, NULL);
+                DSA_meth_set_finish(cryptodev_dsa, NULL);
+                DSA_meth_set_flags(cryptodev_dsa, 0);
+                DSA_meth_set0_app_data(cryptodev_dsa, NULL);
+                DSA_meth_set_paramgen(cryptodev_dsa, NULL);
+            }
         }
     } else {
         ENGINE_free(engine);
@@ -1733,11 +7663,15 @@ void engine_load_cryptodev_int(void)
         DH_meth_set1_name(cryptodev_dh, "cryptodev DH method");
         DH_meth_set_flags(cryptodev_dh, 0);
         if (ENGINE_set_DH(engine, cryptodev_dh)) {
-            if (cryptodev_asymfeat & CRF_MOD_EXP) {
-                DH_meth_set_bn_mod_exp(cryptodev_dh, cryptodev_mod_exp_dh);
-                if (cryptodev_asymfeat & CRF_DH_COMPUTE_KEY)
-                    DH_meth_set_compute_key(cryptodev_dh,
-                                            cryptodev_dh_compute_key);
+            if ((cryptodev_asymfeat & CRF_DH_COMPUTE_KEY) && (cryptodev_asymfeat & CRF_DH_GENERATE_KEY)) {
+                DH_meth_set_generate_key(cryptodev_dh, cryptodev_dh_generate_key);
+                DH_meth_set_compute_key(cryptodev_dh, cryptodev_dh_compute_key);
+    			DH_meth_set_bn_mod_exp(cryptodev_dh, NULL);
+                DH_meth_set_init(cryptodev_dh, NULL);
+                DH_meth_set_finish(cryptodev_dh, NULL);
+                DH_meth_set_flags(cryptodev_dh, 0);
+                DH_meth_set0_app_data(cryptodev_dh, NULL);
+                DH_meth_set_generate_params(cryptodev_dh, NULL);
             }
         }
     } else {
@@ -1746,6 +7680,13 @@ void engine_load_cryptodev_int(void)
     }
 #endif
 
+    if (ENGINE_set_EC(engine, &cryptodev_ec_key)) {
+    	if (!((cryptodev_asymfeat & CRF_ECDSA_SIGN) && (cryptodev_asymfeat & CRF_ECDSA_VERIFY) \
+            && (cryptodev_asymfeat & CRF_ECDH_COMPUTE_KEY) && (cryptodev_asymfeat & CRF_ECDH_GENERATE_KEY))) {
+			ENGINE_set_EC(engine, EC_KEY_OpenSSL());
+        }
+    }
+
     ENGINE_add(engine);
     ENGINE_free(engine);
     ERR_clear_error();
diff -uprN gmssl-1.0/crypto/sm2/sm2_enc.c GmSSL-2.5.0_iMX/crypto/sm2/sm2_enc.c
--- gmssl-1.0/crypto/sm2/sm2_enc.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/sm2/sm2_enc.c	2020-11-09 10:59:49.719907221 +0800
@@ -55,7 +55,187 @@
 #include <openssl/kdf.h>
 #include "internal/o_str.h"
 #include "sm2_lcl.h"
+#ifdef HAVE_CRYPTODEV
+#include "../ec/ec_lcl.h"
+#endif
 
+#ifdef HAVE_CRYPTODEV
+SM2CiphertextValue *SM2_do_encrypt(const EVP_MD *md,
+	const unsigned char *in, size_t inlen, EC_KEY *ec_key)
+{
+	SM2CiphertextValue *ret = NULL;
+	SM2CiphertextValue *cv = NULL;
+	const EC_GROUP *group;
+	const EC_POINT *pub_key;
+	KDF_FUNC kdf;
+	EC_POINT *ephem_point = NULL;
+	EC_POINT *share_point = NULL;
+	BIGNUM *n = NULL;
+	BIGNUM *h = NULL;
+	BIGNUM *k = NULL;
+	BN_CTX *bn_ctx = NULL;
+	EVP_MD_CTX *md_ctx = NULL;
+
+	unsigned char buf[(OPENSSL_ECC_MAX_FIELD_BITS + 7)/4 + 1];
+	int nbytes;
+	size_t len;
+	size_t i;
+	unsigned int hashlen;
+
+	/* check arguments */
+	if (!md || !in || !ec_key) {
+		SM2err(SM2_F_SM2_DO_ENCRYPT, ERR_R_PASSED_NULL_PARAMETER);
+		return 0;
+	}
+
+	if (inlen <= 0 || inlen > SM2_MAX_PLAINTEXT_LENGTH) {
+		SM2err(SM2_F_SM2_DO_ENCRYPT, SM2_R_INVALID_PLAINTEXT_LENGTH);
+		return 0;
+	}
+
+	if (!(kdf = KDF_get_x9_63(md))) {
+		SM2err(SM2_F_SM2_DO_ENCRYPT, SM2_R_INVALID_DIGEST_ALGOR);
+		return 0;
+	}
+
+	if (!(group = EC_KEY_get0_group(ec_key))
+		|| !(pub_key = EC_KEY_get0_public_key(ec_key))) {
+		SM2err(SM2_F_SM2_DO_ENCRYPT, SM2_R_INVALID_EC_KEY);
+		return 0;
+	}
+
+	/* malloc */
+	if (!(cv = SM2CiphertextValue_new())
+		|| !(ephem_point = EC_POINT_new(group))
+		|| !(share_point = EC_POINT_new(group))
+		|| !(n = BN_new())
+		|| !(h = BN_new())
+		|| !(k = BN_new())
+		|| !(bn_ctx = BN_CTX_new())
+		|| !(md_ctx = EVP_MD_CTX_new())) {
+		SM2err(SM2_F_SM2_DO_ENCRYPT, ERR_R_MALLOC_FAILURE);
+		goto end;
+	}
+
+	if (!ASN1_OCTET_STRING_set(cv->ciphertext, NULL, (int)inlen)
+		|| !ASN1_OCTET_STRING_set(cv->hash, NULL, EVP_MD_size(md))) {
+		SM2err(SM2_F_SM2_DO_ENCRYPT, ERR_R_ASN1_LIB);
+		goto end;
+	}
+
+	/* init ec domain parameters */
+	if (!EC_GROUP_get_order(group, n, bn_ctx)) {
+		ECerr(EC_F_SM2_DO_ENCRYPT, EC_R_ERROR);
+		goto end;
+	}
+
+	if (!EC_GROUP_get_cofactor(group, h, bn_ctx)) {
+		ECerr(EC_F_SM2_DO_ENCRYPT, EC_R_ERROR);
+		goto end;
+	}
+
+	nbytes = (EC_GROUP_get_degree(group) + 7) / 8;
+
+	/* check [h]P_B != O */
+    if (NULL != ec_key->meth->EC_POINT_mul) {
+        share_point->flags |= SM2_FLG_CHECK_INFINITY;
+        if (!ec_key->meth->EC_POINT_mul(group, share_point, NULL, pub_key, h, bn_ctx)) {
+    		SM2err(SM2_F_SM2_DO_ENCRYPT, ERR_R_EC_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        SM2err(SM2_F_SM2_DO_ENCRYPT, ERR_R_EC_LIB);
+        goto end;
+    }
+	do
+	{
+		size_t size;
+
+		/* rand k in [1, n-1] */
+		do {
+			BN_rand_range(k, n);
+		} while (BN_is_zero(k));
+
+		/* compute ephem_point [k]G = (x1, y1) */
+        if (NULL != ec_key->meth->EC_POINT_mul) {
+            if (!ec_key->meth->EC_POINT_mul(group, ephem_point, k, NULL, NULL, bn_ctx)) {
+    			SM2err(SM2_F_SM2_DO_ENCRYPT, ERR_R_EC_LIB);
+    			goto end;
+    		}
+
+    		/* compute ECDH share_point [k]P_B = (x2, y2) */
+    		if (!ec_key->meth->EC_POINT_mul(group, share_point, NULL, pub_key, k, bn_ctx)) {
+    			SM2err(SM2_F_SM2_DO_ENCRYPT, ERR_R_EC_LIB);
+    			goto end;
+    		}
+            /* testing whether the share_point is on the elliptic curve( also not at infinity) */
+            if (NULL != ec_key->meth->EC_POINT_check) {
+                if (!ec_key->meth->EC_POINT_check(ec_key->group, share_point, bn_ctx)) {
+                    ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_POINT_IS_NOT_ON_CURVE);
+                    goto end;
+                }
+            }
+        }
+        else 
+            goto end;
+        
+		/* compute t = KDF(x2 || y2, klen) */
+		if (!(len = EC_POINT_point2oct(group, share_point,
+			POINT_CONVERSION_UNCOMPRESSED, buf, sizeof(buf), bn_ctx))) {
+			SM2err(SM2_F_SM2_DO_ENCRYPT, ERR_R_EC_LIB);
+			goto end;
+		}
+
+		size = cv->ciphertext->length;
+		kdf(buf + 1, len - 1, cv->ciphertext->data, &size);
+		if (size != inlen) {
+			SM2err(SM2_F_SM2_DO_ENCRYPT, SM2_R_KDF_FAILURE);
+			goto end;
+		}
+
+		/* ASN1_OCTET_STRING_is_zero in asn1.h and a_octet.c */
+	} while (ASN1_OCTET_STRING_is_zero(cv->ciphertext));
+
+	/* set x/yCoordinates as (x1, y1) */
+    if ((BN_copy(cv->xCoordinate, ephem_point->X) == NULL) || 
+        (BN_copy(cv->yCoordinate, ephem_point->Y) == NULL)) {
+        SM2err(SM2_F_SM2_DO_ENCRYPT, ERR_R_MALLOC_FAILURE);
+    	goto end;
+    }
+
+	/* ciphertext = t xor in */
+	for (i = 0; i < inlen; i++) {
+		cv->ciphertext->data[i] ^= in[i];
+	}
+
+	/* generate hash = Hash(x2 || M || y2) */
+	hashlen = cv->hash->length;
+	if (!EVP_DigestInit_ex(md_ctx, md, NULL)
+		|| !EVP_DigestUpdate(md_ctx, buf + 1, nbytes)
+		|| !EVP_DigestUpdate(md_ctx, in, inlen)
+		|| !EVP_DigestUpdate(md_ctx, buf + 1 + nbytes, nbytes)
+		|| !EVP_DigestFinal_ex(md_ctx, cv->hash->data, &hashlen)) {
+		SM2err(SM2_F_SM2_DO_ENCRYPT, ERR_R_EVP_LIB);
+		goto end;
+	}
+
+	ret = cv;
+	cv = NULL;
+
+end:
+	SM2CiphertextValue_free(cv);
+	EC_POINT_free(share_point);
+	EC_POINT_free(ephem_point);
+	BN_free(n);
+	BN_free(h);
+	BN_clear_free(k);
+	BN_CTX_free(bn_ctx);
+	EVP_MD_CTX_free(md_ctx);
+	return ret;
+}
+
+#else
 SM2CiphertextValue *SM2_do_encrypt(const EVP_MD *md,
 	const unsigned char *in, size_t inlen, EC_KEY *ec_key)
 {
@@ -226,7 +406,7 @@ end:
 	EVP_MD_CTX_free(md_ctx);
 	return ret;
 }
-
+#endif
 int SM2_encrypt(int type, const unsigned char *in, size_t inlen,
 	unsigned char *out, size_t *outlen, EC_KEY *ec_key)
 {
@@ -336,7 +516,160 @@ end:
 	SM2CiphertextValue_free(cv);
 	return ret;
 }
+#ifdef HAVE_CRYPTODEV
+int SM2_do_decrypt(const EVP_MD *md, const SM2CiphertextValue *cv,
+	unsigned char *out, size_t *outlen, EC_KEY *ec_key)
+{
+	int ret = 0;
+	const EC_GROUP *group;
+	const BIGNUM *pri_key;
+	KDF_FUNC kdf;
+	EC_POINT *point = NULL;
+	EC_POINT *tmp_point = NULL;
+	BIGNUM *n = NULL;
+	BIGNUM *h = NULL;
+	BN_CTX *bn_ctx = NULL;
+	EVP_MD_CTX *md_ctx = NULL;
+	unsigned char buf[(OPENSSL_ECC_MAX_FIELD_BITS + 7)/4 + 1];
+	unsigned char mac[EVP_MAX_MD_SIZE];
+	unsigned int maclen = sizeof(mac);
+	int nbytes, len, i;
+
+	/* check arguments */
+	if (!md || !cv || !outlen || !ec_key) {
+		SM2err(SM2_F_SM2_DO_DECRYPT, ERR_R_PASSED_NULL_PARAMETER);
+		return 0;
+	}
+
+	if (!(kdf = KDF_get_x9_63(md))) {
+		SM2err(SM2_F_SM2_DO_DECRYPT, SM2_R_INVALID_DIGEST_ALGOR);
+		return 0;
+	}
+
+	if (!cv->xCoordinate || !cv->yCoordinate || !cv->hash || !cv->ciphertext) {
+		SM2err(SM2_F_SM2_DO_DECRYPT, SM2_R_INVALID_CIPHERTEXT);
+		return 0;
+	}
+
+	if (cv->hash->length != EVP_MD_size(md)) {
+		SM2err(SM2_F_SM2_DO_DECRYPT, SM2_R_INVALID_CIPHERTEXT);
+		return 0;
+	}
+
+	if (cv->ciphertext->length <= 0
+		|| cv->ciphertext->length > SM2_MAX_PLAINTEXT_LENGTH) {
+		SM2err(SM2_F_SM2_DO_DECRYPT, SM2_R_INVALID_CIPHERTEXT);
+		return 0;
+	}
+
+	if (!(group = EC_KEY_get0_group(ec_key))
+		|| !(pri_key = EC_KEY_get0_private_key(ec_key))) {
+		SM2err(SM2_F_SM2_DO_DECRYPT, SM2_R_INVALID_EC_KEY);
+		return 0;
+	}
+
+	if (!out) {
+		*outlen = cv->ciphertext->length;
+		return 1;
+	}
+
+	/* malloc */
+	point = EC_POINT_new(group);
+	tmp_point = EC_POINT_new(group);
+	n = BN_new();
+	h = BN_new();
+	bn_ctx = BN_CTX_new();
+	md_ctx = EVP_MD_CTX_new();
+	if (!point || !n || !h || !bn_ctx || !md_ctx) {
+		SM2err(SM2_F_SM2_DO_DECRYPT, ERR_R_MALLOC_FAILURE);
+		goto end;
+	}
+
+	/* init ec domain parameters */
+	if (!EC_GROUP_get_order(group, n, bn_ctx)) {
+		SM2err(SM2_F_SM2_DO_DECRYPT, ERR_R_EC_LIB);
+		goto end;
+	}
+
+	if (!EC_GROUP_get_cofactor(group, h, bn_ctx)) {
+		SM2err(SM2_F_SM2_DO_DECRYPT, ERR_R_EC_LIB);
+		goto end;
+	}
+
+	nbytes = (EC_GROUP_get_degree(group) + 7) / 8;
+
+	/* get x/yCoordinates as C1 = (x1, y1) */
+    if ((BN_copy(point->X, cv->xCoordinate) == NULL) || 
+        (BN_copy(point->Y, cv->yCoordinate) == NULL))
+    	goto end;
+    /* check [h]C1 != O */
+    if (NULL != ec_key->meth->EC_POINT_mul) {
+        tmp_point->flags |= SM2_FLG_CHECK_INFINITY;
+    	if (!ec_key->meth->EC_POINT_mul(group, tmp_point, NULL, point, h, bn_ctx)) {
+    		SM2err(SM2_F_SM2_DO_DECRYPT, ERR_R_EC_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        SM2err(SM2_F_SM2_DO_DECRYPT, ERR_R_EC_LIB);
+        goto end;
+    }
+
+	/* compute ECDH [d]C1 = (x2, y2) */
+    if (NULL != ec_key->meth->EC_POINT_mul) {
+    	if (!ec_key->meth->EC_POINT_mul(group, point, NULL, point, pri_key, bn_ctx)) {
+    		SM2err(SM2_F_SM2_DO_DECRYPT, ERR_R_EC_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        SM2err(SM2_F_SM2_DO_DECRYPT, ERR_R_EC_LIB);
+        goto end;
+    }
+
+	if (!(len = EC_POINT_point2oct(group, point,
+		POINT_CONVERSION_UNCOMPRESSED, buf, sizeof(buf), bn_ctx))) {
+		SM2err(SM2_F_SM2_DO_DECRYPT, ERR_R_EC_LIB);
+		goto end;
+	}
+
+	/* compute t = KDF(x2 || y2, clen) */
+	*outlen = cv->ciphertext->length;
+	kdf(buf + 1, len - 1, out, outlen);
+
+
+	/* compute M = C2 xor t */
+	for (i = 0; i < cv->ciphertext->length; i++) {
+		out[i] ^= cv->ciphertext->data[i];
+	}
+
+	/* check hash == Hash(x2 || M || y2) */
+	if (!EVP_DigestInit_ex(md_ctx, md, NULL)
+		|| !EVP_DigestUpdate(md_ctx, buf + 1, nbytes)
+		|| !EVP_DigestUpdate(md_ctx, out, *outlen)
+		|| !EVP_DigestUpdate(md_ctx, buf + 1 + nbytes, nbytes)
+		|| !EVP_DigestFinal_ex(md_ctx, mac, &maclen)) {
+		SM2err(SM2_F_SM2_DO_DECRYPT, ERR_R_EVP_LIB);
+		goto end;
+	}
+
+	if (OPENSSL_memcmp(cv->hash->data, mac, maclen) != 0) {
+		SM2err(SM2_F_SM2_DO_DECRYPT, SM2_R_INVALID_CIPHERTEXT);
+		goto end;
+	}
+
+	ret = 1;
+end:
+	EC_POINT_free(point);
+	EC_POINT_free(tmp_point);
+	BN_free(n);
+	BN_free(h);
+	BN_CTX_free(bn_ctx);
+	EVP_MD_CTX_free(md_ctx);
+	return ret;
+}
 
+#else
 int SM2_do_decrypt(const EVP_MD *md, const SM2CiphertextValue *cv,
 	unsigned char *out, size_t *outlen, EC_KEY *ec_key)
 {
@@ -497,3 +830,4 @@ end:
 	EVP_MD_CTX_free(md_ctx);
 	return ret;
 }
+#endif
diff -uprN gmssl-1.0/crypto/sm2/sm2_exch.c GmSSL-2.5.0_iMX/crypto/sm2/sm2_exch.c
--- gmssl-1.0/crypto/sm2/sm2_exch.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/sm2/sm2_exch.c	2020-11-09 10:59:49.719907221 +0800
@@ -52,6 +52,9 @@
 #include <openssl/sm2.h>
 #include <openssl/kdf.h>
 #include "sm2_lcl.h"
+#ifdef HAVE_CRYPTODEV
+#include "../ec/ec_lcl.h"
+#endif
 
 int SM2_KAP_CTX_init(SM2_KAP_CTX *ctx,
 	EC_KEY *ec_key, const char *id, size_t idlen,
@@ -169,7 +172,431 @@ void SM2_KAP_CTX_cleanup(SM2_KAP_CTX *ct
 		memset(ctx, 0, sizeof(*ctx));
 	}
 }
+#ifdef HAVE_CRYPTODEV
+/* FIXME: ephem_point_len should be both input and output */
+int SM2_KAP_prepare(SM2_KAP_CTX *ctx, unsigned char *ephem_point,
+	size_t *ephem_point_len)
+{
+	int ret = 0;
+	const BIGNUM *prikey;
+	BIGNUM *h = NULL;
+	BIGNUM *r = NULL;
+	BIGNUM *x = NULL;
+
+	if (!(prikey = EC_KEY_get0_private_key(ctx->ec_key))) {
+		ECerr(EC_F_SM2_KAP_PREPARE, EC_R_SM2_KAP_NOT_INITED);
+		return 0;
+	}
+
+	h = BN_new();
+	r = BN_new();
+	x = BN_new();
+
+	if (!h || !r || !x) {
+		ECerr(EC_F_SM2_KAP_PREPARE, 0);
+		goto end;
+	}
+
+	/*
+	 * r = rand(1, n)
+	 * R = rG = (x, y)
+	 */
+
+	do {
+		if (!BN_rand_range(r, ctx->order)) {
+			ECerr(EC_F_SM2_KAP_PREPARE, EC_R_RANDOM_NUMBER_GENERATION_FAILED);
+			goto end;
+		}
+
+	} while (BN_is_zero(r));
+
+    if (NULL != ctx->ec_key->meth->EC_POINT_mul) {
+        if (!ctx->ec_key->meth->EC_POINT_mul(ctx->group, ctx->point, r, NULL, NULL, ctx->bn_ctx)) {
+    		ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_EC_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_EC_LIB);
+        goto end;
+    }
+        
+    if (BN_copy(x, ctx->point->X) == NULL) {
+        ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_MALLOC_FAILURE);
+    	goto end;
+    }
+
+	/*
+	 * w = ceil(keybits / 2) - 1
+	 * x = 2^w + (x and (2^w - 1)) = 2^w + (x mod 2^w)
+	 * t = (d + x * r) mod n
+	 * t = (h * t) mod n
+	 */
+
+	if (NULL == ctx->t) {
+		ECerr(EC_F_SM2_KAP_PREPARE, EC_R_SM2_KAP_NOT_INITED);
+		goto end;
+	}
+    if (NULL != ctx->ec_key->meth->BN_nnmod) {
+        if (!ctx->ec_key->meth->BN_nnmod(x, x, ctx->two_pow_w, ctx->bn_ctx)) {
+    		ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_BN_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_BN_LIB);
+        goto end;
+    }
+    
+    if (NULL != ctx->ec_key->meth->BN_add) {
+        if (!ctx->ec_key->meth->BN_add(x, x, ctx->two_pow_w)) {
+    		ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_BN_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_BN_LIB);
+        goto end;
+    }
+    
+    if (NULL != ctx->ec_key->meth->BN_mod_mul) {
+        if (!BN_mod_mul(ctx->t, x, r, ctx->order, ctx->bn_ctx)) {
+    		ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_BN_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_BN_LIB);
+        goto end;
+    }
+    
+    if (NULL != ctx->ec_key->meth->BN_mod_add) {
+        if (!ctx->ec_key->meth->BN_mod_add(ctx->t, ctx->t, prikey, ctx->order, ctx->bn_ctx)) {
+    		ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_BN_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_BN_LIB);
+        goto end;
+    }
+
+    if (!EC_GROUP_get_cofactor(ctx->group, h, ctx->bn_ctx)) {
+		ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_EC_LIB);
+		goto end;
+	}
+    
+    if (NULL != ctx->ec_key->meth->BN_mul) {
+        if (!ctx->ec_key->meth->BN_mul(ctx->t, ctx->t, h, ctx->bn_ctx)) {
+    		ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_BN_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_BN_LIB);
+        goto end;
+    }
+	/* encode R = (x, y) for output and local buffer */
+
+	// FIXME: ret is size_t and ret is the output length
+	ret = EC_POINT_point2oct(ctx->group, ctx->point, ctx->point_form,
+		ephem_point, *ephem_point_len, ctx->bn_ctx);
+
+	memcpy(ctx->pt_buf, ephem_point, ret);
+	*ephem_point_len = ret;
+	ret = 1;
+
+end:
+	if (h) BN_free(h);
+	if (r) BN_free(r);
+	if (x) BN_free(x);
+
+	return ret;
+}
+
+int SM2_KAP_compute_key(SM2_KAP_CTX *ctx, const unsigned char *remote_point,
+	size_t remote_point_len, unsigned char *key, size_t keylen,
+	unsigned char *checksum, size_t *checksumlen)
+{
+	int ret = 0;
+
+	EVP_MD_CTX *md_ctx = NULL;
+	BIGNUM *x = NULL;
+	unsigned char share_pt_buf[1 + (OPENSSL_ECC_MAX_FIELD_BITS+7)/4 + EVP_MAX_MD_SIZE * 2 + 100];
+	unsigned char remote_pt_buf[1 + (OPENSSL_ECC_MAX_FIELD_BITS+7)/4 + 111];
+	unsigned char dgst[EVP_MAX_MD_SIZE];
+	unsigned int dgstlen;
+	unsigned int len, bnlen;
+	size_t klen = keylen;
+
+	md_ctx = EVP_MD_CTX_new();
+	x = BN_new();
+	if (!md_ctx || !x) {
+		ECerr(EC_F_SM2_KAP_COMPUTE_KEY, 0);
+		goto end;
+	}
+
+	/*
+	 * decode point R = (x, y), encode (x, y)
+	 * x = 2^w + (x and (2^w - 1)) = 2^w + (x mod 2^w), w = ceil(keybits / 2) - 1
+	 * U = ht * (P + x * R)
+	 * check U != O
+	 */
+
+	if (!EC_POINT_oct2point(ctx->group, ctx->point,
+		remote_point, remote_point_len, ctx->bn_ctx)) {
+		ECerr(EC_F_SM2_KAP_COMPUTE_KEY, 0);
+		goto end;
+	}
+
+	if (!(len = EC_POINT_point2oct(ctx->group, ctx->point, POINT_CONVERSION_UNCOMPRESSED,
+		remote_pt_buf, sizeof(remote_pt_buf), ctx->bn_ctx))) {
+		ECerr(EC_F_SM2_KAP_COMPUTE_KEY, 0);
+		goto end;
+	}
+
+    if (BN_copy(x, ctx->point->X) == NULL)
+    	goto end;
 
+	/* x = 2^w + (x and (2^w - 1)) = 2^w + (x mod 2^w) */
+    if (NULL != ctx->ec_key->meth->BN_nnmod) {
+        if (!ctx->ec_key->meth->BN_nnmod(x, x, ctx->two_pow_w, ctx->bn_ctx)) {
+    		ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_BN_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_BN_LIB);
+        goto end;
+    }
+
+    if (NULL != ctx->ec_key->meth->BN_add) {
+        if (!ctx->ec_key->meth->BN_add(x, x, ctx->two_pow_w)) {
+    		ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_BN_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        ECerr(EC_F_SM2_KAP_PREPARE, ERR_R_BN_LIB);
+        goto end;
+    }
+
+
+	/* U = ht * (P + x * R), check U != O */
+    if (NULL != ctx->ec_key->meth->EC_POINT_mul) {
+        if (!ctx->ec_key->meth->EC_POINT_mul(ctx->group, ctx->point, NULL, ctx->point, x, ctx->bn_ctx)) {
+    		ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EC_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EC_LIB);
+        goto end;
+    }
+
+    if (NULL != ctx->ec_key->meth->EC_POINT_add) {
+        if (!ctx->ec_key->meth->EC_POINT_add(ctx->group, ctx->point, ctx->point,
+    		EC_KEY_get0_public_key(ctx->remote_pubkey), ctx->bn_ctx)) {
+    		ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EC_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EC_LIB);
+        goto end;
+    }
+
+    if (NULL != ctx->ec_key->meth->EC_POINT_mul) {
+        ctx->point->flags |= SM2_FLG_CHECK_INFINITY;
+        if (!ctx->ec_key->meth->EC_POINT_mul(ctx->group, ctx->point, NULL, ctx->point, ctx->t, ctx->bn_ctx)) {
+    		ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EC_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EC_LIB);
+        goto end;
+    }
+
+	/* encode U, append with ZA, ZB */
+
+	if (!(len = EC_POINT_point2oct(ctx->group, ctx->point, POINT_CONVERSION_UNCOMPRESSED,
+		share_pt_buf, sizeof(share_pt_buf), ctx->bn_ctx))) {
+		ECerr(EC_F_SM2_KAP_COMPUTE_KEY, 0);
+		goto end;
+	}
+
+	if (ctx->is_initiator) {
+		memcpy(share_pt_buf + len, ctx->id_dgst, ctx->id_dgstlen);
+		len += ctx->id_dgstlen;
+		memcpy(share_pt_buf + len, ctx->remote_id_dgst, ctx->remote_id_dgstlen);
+		len += ctx->remote_id_dgstlen;
+	} else {
+		memcpy(share_pt_buf + len, ctx->remote_id_dgst, ctx->remote_id_dgstlen);
+		len += ctx->remote_id_dgstlen;
+		memcpy(share_pt_buf + len, ctx->id_dgst, ctx->id_dgstlen);
+		len += ctx->id_dgstlen;
+	}
+
+	/* key = KDF(xu, yu, ZA, ZB) */
+
+
+	if (!ctx->kdf(share_pt_buf + 1, len - 1, key, &klen)) {
+		ECerr(EC_F_SM2_KAP_COMPUTE_KEY, 0);
+		goto end;
+	}
+
+	if (ctx->do_checksum) {
+
+		/* generate checksum S1 or SB start with 0x02
+		 * S1 = SB = Hash(0x02, yu, Hash(xu, ZA, ZB, x1, y1, x2, y2))
+		 */
+		if (!EVP_DigestInit_ex(md_ctx, ctx->checksum_md, NULL)) {
+			ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+			goto end;
+		}
+
+		bnlen = BN_num_bytes(ctx->order);
+
+		if (!EVP_DigestUpdate(md_ctx, share_pt_buf + 1, bnlen)) {
+			ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+			goto end;
+		}
+
+		if (ctx->is_initiator) {
+
+			/* update ZA,ZB,x1,y1,x2,y2 */
+			if (!EVP_DigestUpdate(md_ctx, ctx->id_dgst, ctx->id_dgstlen)) {
+				ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+				goto end;
+			}
+			if (!EVP_DigestUpdate(md_ctx, ctx->remote_id_dgst, ctx->remote_id_dgstlen)) {
+				ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+				goto end;
+			}
+			if (!EVP_DigestUpdate(md_ctx, ctx->pt_buf + 1, bnlen * 2)) {
+				ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+				goto end;
+			}
+			if (!EVP_DigestUpdate(md_ctx, remote_pt_buf + 1, bnlen * 2)) {
+				ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+				goto end;
+			}
+
+		} else {
+
+			if (!EVP_DigestUpdate(md_ctx, ctx->remote_id_dgst, ctx->remote_id_dgstlen)) {
+				ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+				goto end;
+			}
+			if (!EVP_DigestUpdate(md_ctx, ctx->id_dgst, ctx->id_dgstlen)) {
+				ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+				goto end;
+			}
+			if (!EVP_DigestUpdate(md_ctx, remote_pt_buf + 1, bnlen * 2)) {
+				ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+				goto end;
+			}
+			if (!EVP_DigestUpdate(md_ctx, ctx->pt_buf + 1, bnlen * 2)) {
+				ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+				goto end;
+			}
+		}
+
+		if (!EVP_DigestFinal_ex(md_ctx, dgst, &dgstlen)) {
+			ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+			goto end;
+		}
+		/* now dgst == H(xu,ZA,ZB,x1,y1,x2,y2)
+		 */
+
+		/* S1 = SB = Hash(0x02, yu, dgst) */
+
+		if (!EVP_DigestInit_ex(md_ctx, ctx->checksum_md, NULL)) {
+			ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+			goto end;
+		}
+
+		if (!EVP_DigestUpdate(md_ctx, "\x02", 1)) {
+			ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+			goto end;
+		}
+
+		if (!EVP_DigestUpdate(md_ctx, share_pt_buf + 1 + bnlen, bnlen)) {
+			ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+			goto end;
+		}
+
+		if (!EVP_DigestUpdate(md_ctx, dgst, dgstlen)) {
+			ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+			goto end;
+		}
+
+		/* output S1 to local buffer or SB to output */
+		if (ctx->is_initiator) {
+			if (!EVP_DigestFinal_ex(md_ctx, ctx->checksum, &len)) {
+				ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+				goto end;
+			}
+
+		} else {
+			if (!EVP_DigestFinal_ex(md_ctx, checksum, &len)) {
+				ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+				goto end;
+			}
+			*checksumlen = len;
+		}
+
+		/* generate checksum SA or S2 start with 0x03
+		 * SA = S2 = Hash(0x03, yu, dgst)
+		 */
+
+		if (!EVP_DigestInit_ex(md_ctx, ctx->checksum_md, NULL)) {
+			ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+			goto end;
+		}
+
+		if (!EVP_DigestUpdate(md_ctx, "\x03", 1)) {
+			ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+			goto end;
+		}
+
+		if (!EVP_DigestUpdate(md_ctx, share_pt_buf + 1 + bnlen, bnlen)) {
+			ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+			goto end;
+		}
+
+		if (!EVP_DigestUpdate(md_ctx, dgst, dgstlen)) {
+			ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+			goto end;
+		}
+
+		if (ctx->is_initiator) {
+			if (!EVP_DigestFinal_ex(md_ctx, checksum, &len)) {
+				ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+				goto end;
+			}
+			*checksumlen = len;
+
+		} else {
+			if (!EVP_DigestFinal_ex(md_ctx, ctx->checksum, &len)) {
+				ECerr(EC_F_SM2_KAP_COMPUTE_KEY, ERR_R_EVP_LIB);
+				goto end;
+			}
+		}
+
+
+	}
+
+	ret = 1;
+
+end:
+	EVP_MD_CTX_free(md_ctx);
+	BN_free(x);
+	return ret;
+}
+
+#else
 /* FIXME: ephem_point_len should be both input and output */
 int SM2_KAP_prepare(SM2_KAP_CTX *ctx, unsigned char *ephem_point,
 	size_t *ephem_point_len)
@@ -558,7 +985,7 @@ end:
 	BN_free(x);
 	return ret;
 }
-
+#endif
 int SM2_KAP_final_check(SM2_KAP_CTX *ctx, const unsigned char *checksum,
 	size_t checksumlen)
 {
diff -uprN gmssl-1.0/crypto/sm2/sm2_id.c GmSSL-2.5.0_iMX/crypto/sm2/sm2_id.c
--- gmssl-1.0/crypto/sm2/sm2_id.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/sm2/sm2_id.c	2020-11-09 10:59:49.719907221 +0800
@@ -60,10 +60,115 @@
 #include <openssl/rand.h>
 #include <openssl/x509.h>
 #include "sm2_lcl.h"
+#ifdef HAVE_CRYPTODEV
+#include "../ec/ec_lcl.h"
+#endif
 
 #define EC_MAX_NBYTES  ((OPENSSL_ECC_MAX_FIELD_BITS + 7)/8)
 
+#ifdef HAVE_CRYPTODEV
+int SM2_get_public_key_data(EC_KEY *ec_key, unsigned char *out, size_t *outlen)
+{
+	int ret = 0;
+	const EC_GROUP *group;
+	BN_CTX *bn_ctx = NULL;
+	BIGNUM *p;
+	BIGNUM *x;
+	BIGNUM *y;
+	int nbytes;
+	size_t len;
+
+	if (!ec_key || !outlen || !(group = EC_KEY_get0_group(ec_key))) {
+		ECerr(EC_F_SM2_GET_PUBLIC_KEY_DATA, ERR_R_PASSED_NULL_PARAMETER);
+		return 0;
+	}
+
+	/* degree is the bit length of field element, not the order of subgroup */
+	nbytes = (EC_GROUP_get_degree(group) + 7)/8;
+	len = nbytes * 6;
+
+	if (!out) {
+		*outlen = len;
+		return 1;
+	}
+	if (*outlen < len) {
+		ECerr(EC_F_SM2_GET_PUBLIC_KEY_DATA, EC_R_BUFFER_TOO_SMALL);
+		return 0;
+	}
+
+	if (!(bn_ctx = BN_CTX_new())) {
+		ECerr(EC_F_SM2_GET_PUBLIC_KEY_DATA,  ERR_R_MALLOC_FAILURE);
+		goto  end;
+	}
+
+	BN_CTX_start(bn_ctx);
+	p = BN_CTX_get(bn_ctx);
+	x = BN_CTX_get(bn_ctx);
+	y = BN_CTX_get(bn_ctx);
+	if (NULL == y || NULL == x || NULL == p) {
+		ECerr(EC_F_SM2_GET_PUBLIC_KEY_DATA,  ERR_R_MALLOC_FAILURE);
+		goto end;
+	}
+
+	memset(out, 0, len);
+
+	/* get curve coefficients */
+    if ((NULL == BN_copy(p, group->field)) || (NULL == BN_copy(x, group->a)) || (NULL == BN_copy(y, group->b)))
+        goto end;
+    
+		/* when coeffiient a is zero, BN_bn2bin/BN_num_bytes return 0 */
+	BN_bn2bin(x, out + nbytes - BN_num_bytes(x));
+	out += nbytes;
+
+	if (!BN_bn2bin(y, out + nbytes - BN_num_bytes(y))) {
+		ECerr(EC_F_SM2_GET_PUBLIC_KEY_DATA, ERR_R_BN_LIB);
+		goto end;
+	}
+	out += nbytes;
 
+	/* get curve generator coordinates */
+    if ( (NULL == BN_copy(x, (EC_GROUP_get0_generator(group))->X)) || (NULL == BN_copy(y, (EC_GROUP_get0_generator(group))->Y)))
+        goto end;
+	
+	if (!BN_bn2bin(x, out + nbytes - BN_num_bytes(x))) {
+		ECerr(EC_F_SM2_GET_PUBLIC_KEY_DATA, ERR_R_BN_LIB);
+		goto end;
+	}
+	out += nbytes;
+
+	if (!BN_bn2bin(y, out + nbytes - BN_num_bytes(y))) {
+		ECerr(EC_F_SM2_GET_PUBLIC_KEY_DATA, ERR_R_BN_LIB);
+		goto end;
+	}
+	out += nbytes;
+
+	/* get pub_key coorindates */
+    if ((( NULL == BN_copy(x, (EC_KEY_get0_public_key(ec_key))->X))) || (NULL == BN_copy(y, (EC_KEY_get0_public_key(ec_key))->Y)))
+        goto end;
+	
+	if (!BN_bn2bin(x, out + nbytes - BN_num_bytes(x))) {
+		ECerr(EC_F_SM2_GET_PUBLIC_KEY_DATA, ERR_R_BN_LIB);
+		goto end;
+	}
+	out += nbytes;
+
+	if (!BN_bn2bin(y, out + nbytes - BN_num_bytes(y))) {
+		ECerr(EC_F_SM2_GET_PUBLIC_KEY_DATA, ERR_R_BN_LIB);
+		goto end;
+	}
+
+	*outlen = len;
+	ret = 1;
+
+end:
+	if (bn_ctx) {
+		BN_CTX_end(bn_ctx);
+	}
+	BN_CTX_free(bn_ctx);
+	return ret;
+}
+
+#else
 int SM2_get_public_key_data(EC_KEY *ec_key, unsigned char *out, size_t *outlen)
 {
 	int ret = 0;
@@ -195,7 +300,7 @@ end:
 	BN_CTX_free(bn_ctx);
 	return ret;
 }
-
+#endif
 int SM2_compute_id_digest(const EVP_MD *md, const char *id, size_t idlen,
 	unsigned char *out, size_t *outlen, EC_KEY *ec_key)
 {
diff -uprN gmssl-1.0/crypto/sm2/sm2_kmeth.c GmSSL-2.5.0_iMX/crypto/sm2/sm2_kmeth.c
--- gmssl-1.0/crypto/sm2/sm2_kmeth.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/sm2/sm2_kmeth.c	2020-11-09 10:59:49.719907221 +0800
@@ -85,6 +85,22 @@ static const EC_KEY_METHOD gmssl_ec_key_
 	NULL,			/* do_encrypt */
 	SM2_decrypt,		/* decrypt */
 	NULL,			/* do_decrypt */
+#ifdef HAVE_CRYPTODEV
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+#endif
 };
 
 const EC_KEY_METHOD *EC_KEY_GmSSL(void)
diff -uprN gmssl-1.0/crypto/sm2/sm2_oct.c GmSSL-2.5.0_iMX/crypto/sm2/sm2_oct.c
--- gmssl-1.0/crypto/sm2/sm2_oct.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/sm2/sm2_oct.c	2020-11-09 10:59:49.719907221 +0800
@@ -56,15 +56,228 @@
 #include <openssl/objects.h>
 #include <openssl/obj_mac.h>
 #include "sm2_lcl.h"
+#ifdef HAVE_CRYPTODEV
+#include "../ec/ec_lcl.h"
+#endif
 
+#ifdef HAVE_CRYPTODEV
+int i2o_SM2CiphertextValue(const EC_GROUP *group, const SM2CiphertextValue *cv,
+	unsigned char **pout)
+{
+	int ret = 0, outlen = 0, nbytes;
+	EC_POINT *point = NULL;
+	BN_CTX *bn_ctx = NULL;
+	unsigned char *buf = NULL;
+	unsigned char *p;
+	size_t siz;
+
+	if (!group || !cv || !pout) {
+		SM2err(SM2_F_I2O_SM2CIPHERTEXTVALUE,
+			ERR_R_PASSED_NULL_PARAMETER);
+		return 0;
+	}
+
+	nbytes = (EC_GROUP_get_degree(group) + 7)/8;
+
+	if (!cv->xCoordinate || BN_num_bytes(cv->xCoordinate) > nbytes
+		|| !cv->yCoordinate || BN_num_bytes(cv->yCoordinate) > nbytes
+		|| ASN1_STRING_length(cv->hash) <= 0
+		|| ASN1_STRING_length(cv->hash) > EVP_MAX_MD_SIZE
+		|| ASN1_STRING_length(cv->ciphertext) <= 0) {
+		SM2err(SM2_F_I2O_SM2CIPHERTEXTVALUE, SM2_R_INVALID_CIPHERTEXT);
+		return 0;
+	}
+
+	/* prepare buffer */
+	if (*pout) {
+		p = *pout;
+
+	} else {
+		size_t buflen = 1 + nbytes * 2
+			+ ASN1_STRING_length(cv->ciphertext)
+			+ ASN1_STRING_length(cv->hash);
+
+		if (!(buf = OPENSSL_malloc(buflen))) {
+			SM2err(SM2_F_I2O_SM2CIPHERTEXTVALUE,
+				ERR_R_MALLOC_FAILURE);
+			return 0;
+		}
+
+		p = buf;
+	}
+
+	/* encode x, y */
+	if (!(point = EC_POINT_new(group)) || !(bn_ctx = BN_CTX_new())) {
+		SM2err(SM2_F_I2O_SM2CIPHERTEXTVALUE, ERR_R_MALLOC_FAILURE);
+		goto end;
+	}
+
+    if ((NULL == BN_copy(point->X, cv->xCoordinate)) || (NULL == BN_copy(point->Y, cv->yCoordinate))) {
+        SM2err(SM2_F_I2O_SM2CIPHERTEXTVALUE, ERR_R_MALLOC_FAILURE);
+        goto end;	
+    }
+
+	if (!(siz = EC_POINT_point2oct(group, point,
+		POINT_CONVERSION_UNCOMPRESSED, p, 1 + 2 * nbytes, bn_ctx))) {
+		SM2err(SM2_F_I2O_SM2CIPHERTEXTVALUE, ERR_R_EC_LIB);
+		goto end;
+	}
+	OPENSSL_assert(siz == 1 + 2 * nbytes);
+	p += siz;
+	outlen += siz;
+
+	/* encode ciphertext */
+	memcpy(p, ASN1_STRING_get0_data(cv->ciphertext),
+		ASN1_STRING_length(cv->ciphertext));
+	p += ASN1_STRING_length(cv->ciphertext);
+	outlen += ASN1_STRING_length(cv->ciphertext);
+
+	/* encode hash */
+	memcpy(p, ASN1_STRING_get0_data(cv->hash),
+		ASN1_STRING_length(cv->hash));
+	p += ASN1_STRING_length(cv->hash);
+	outlen += ASN1_STRING_length(cv->hash);
+
+	/* output */
+	if (*pout) {
+		*pout = p;
+	} else {
+		*pout = buf;
+		buf = NULL;
+	}
+	ret = outlen;
+
+end:
+	EC_POINT_free(point);
+	BN_CTX_free(bn_ctx);
+	return ret;
+}
+
+SM2CiphertextValue *o2i_SM2CiphertextValue(const EC_GROUP *group,
+	const EVP_MD *md, SM2CiphertextValue **pout,
+	const unsigned char **pin, long len)
+{
+	SM2CiphertextValue *ret = NULL;
+	SM2CiphertextValue *cv = NULL;
+	BN_CTX *bn_ctx = NULL;
+	EC_POINT *point = NULL;
+	const unsigned char *p;
+	int nbytes;
+
+	if (!group || !pin) {
+		SM2err(SM2_F_O2I_SM2CIPHERTEXTVALUE,
+			ERR_R_PASSED_NULL_PARAMETER);
+		return NULL;
+	}
+
+	nbytes = (EC_GROUP_get_degree(group) + 7)/8;
+
+	if (len <= 1 + nbytes * 2 + EVP_MD_size(md)) {
+		SM2err(SM2_F_O2I_SM2CIPHERTEXTVALUE,
+			SM2_R_INVALID_CIPHERTEXT);
+		return NULL;
+	}
+
+	if (pout && *pout) {
+		cv = *pout;
+	} else {
+		if (!(cv = SM2CiphertextValue_new())) {
+			SM2err(SM2_F_O2I_SM2CIPHERTEXTVALUE,
+				ERR_R_MALLOC_FAILURE);
+			goto end;
+		}
+	}
+
+	if (!(point = EC_POINT_new(group))
+		|| !(bn_ctx = BN_CTX_new())) {
+		SM2err(SM2_F_O2I_SM2CIPHERTEXTVALUE,
+			ERR_R_MALLOC_FAILURE);
+		goto end;
+	}
+
+	p = *pin;
+
+	/* set (x, y) */
+	if (!EC_POINT_oct2point(group, point, p, 1 + nbytes * 2, bn_ctx)) {
+		SM2err(SM2_F_O2I_SM2CIPHERTEXTVALUE,
+			SM2_R_INVALID_CIPHERTEXT);
+		goto end;
+	}
+	p += 1 + nbytes * 2;
+	len -= 1 + nbytes * 2;
+
+	if (!cv->xCoordinate) {
+		if (!(cv->xCoordinate = BN_new())) {
+			SM2err(SM2_F_O2I_SM2CIPHERTEXTVALUE,
+				ERR_R_MALLOC_FAILURE);
+			goto end;
+		}
+	}
+	if (!cv->yCoordinate) {
+		if (!(cv->yCoordinate = BN_new())) {
+			SM2err(SM2_F_O2I_SM2CIPHERTEXTVALUE,
+				ERR_R_MALLOC_FAILURE);
+			goto end;
+		}
+	}
+
+    if ((NULL == BN_copy(cv->xCoordinate, point->X)) || (NULL == BN_copy(cv->yCoordinate, point->Y))) {
+        SM2err(SM2_F_I2O_SM2CIPHERTEXTVALUE, ERR_R_MALLOC_FAILURE);
+        goto end;
+    }
+    
+	/* set ciphertext */
+	if (!cv->ciphertext) {
+		if (!(cv->ciphertext = ASN1_OCTET_STRING_new())) {
+			SM2err(SM2_F_O2I_SM2CIPHERTEXTVALUE,
+				ERR_R_MALLOC_FAILURE);
+			goto end;
+		}
+	}
+
+	if (!ASN1_OCTET_STRING_set(cv->ciphertext, p, len - EVP_MD_size(md))) {
+		SM2err(SM2_F_O2I_SM2CIPHERTEXTVALUE, ERR_R_ASN1_LIB);
+		goto end;
+	}
+	p += len - EVP_MD_size(md);
+
+	/* set hash */
+	if (!cv->hash) {
+		if (!(cv->hash = ASN1_OCTET_STRING_new())) {
+			SM2err(SM2_F_O2I_SM2CIPHERTEXTVALUE,
+				ERR_R_MALLOC_FAILURE);
+			goto end;
+		}
+	}
+
+	if (!ASN1_OCTET_STRING_set(cv->hash, p, EVP_MD_size(md))) {
+		SM2err(SM2_F_O2I_SM2CIPHERTEXTVALUE, ERR_R_ASN1_LIB);
+		goto end;
+	}
+	p += EVP_MD_size(md);
+
+	/* set result */
+	*pin = p;
+	ret = cv;
+	cv = NULL;
+
+end:
+	if ((cv != *pout) && (!ret))
+		SM2CiphertextValue_free(cv);
+
+	EC_POINT_free(point);
+	BN_CTX_free(bn_ctx);
+	return ret;
+}
 
+#else
 int i2o_SM2CiphertextValue(const EC_GROUP *group, const SM2CiphertextValue *cv,
 	unsigned char **pout)
 {
 	int ret = 0, outlen = 0, nbytes;
 	EC_POINT *point = NULL;
 	BN_CTX *bn_ctx = NULL;
-	unsigned char *buf;
+	unsigned char *buf = NULL;
 	unsigned char *p;
 	size_t siz;
 
@@ -282,3 +495,4 @@ end:
 	BN_CTX_free(bn_ctx);
 	return ret;
 }
+#endif
diff -uprN gmssl-1.0/crypto/sm2/sm2_sign.c GmSSL-2.5.0_iMX/crypto/sm2/sm2_sign.c
--- gmssl-1.0/crypto/sm2/sm2_sign.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/sm2/sm2_sign.c	2020-11-09 10:59:49.719907221 +0800
@@ -55,10 +55,11 @@
 #include <openssl/evp.h>
 #include <openssl/rand.h>
 #include <openssl/obj_mac.h>
+#ifdef HAVE_CRYPTODEV
 #include "../ec/ec_lcl.h"
+#endif
 
 static int sm2_sign_idx = -1;
-
 static void sm2_sign_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
 	int idx, long argl, void *argp)
 {
@@ -68,7 +69,874 @@ static void sm2_sign_free(void *parent,
 		CRYPTO_set_ex_data(ad, sm2_sign_idx, NULL);
 	}
 }
+#ifdef HAVE_CRYPTODEV
+static int sm2_sign_setup(EC_KEY *ec_key, BN_CTX *ctx_in, BIGNUM **kp, BIGNUM **xp)
+{
+	int ret = 0;
+	const EC_GROUP *ec_group;
+	BN_CTX *ctx = NULL;
+	BIGNUM *k = NULL;
+	BIGNUM *x = NULL;
+	BIGNUM *order = NULL;
+	EC_POINT *point = NULL;
+
+	if (ec_key == NULL || (ec_group = EC_KEY_get0_group(ec_key)) == NULL) {
+		SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);
+		return 0;
+	}
+
+	if (ctx_in == NULL)  {
+		if ((ctx = BN_CTX_new()) == NULL) {
+			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_MALLOC_FAILURE);
+			return 0;
+		}
+	}
+	else {
+		ctx = ctx_in;
+	}
+
+
+	k = BN_new();
+	x = BN_new();
+	order = BN_new();
+	if (!k || !x || !order) {
+		SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_MALLOC_FAILURE);
+		goto end;
+	}
+
+	if (!EC_GROUP_get_order(ec_group, order, ctx)) {
+		SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_EC_LIB);
+		goto end;
+	}
+
+	if ((point = EC_POINT_new(ec_group)) == NULL) {
+		SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_EC_LIB);
+		goto end;
+	}
+
+	/* do pre compute (1 + d)^-1 */
+	if (sm2_sign_idx < 0) {
+		if ((sm2_sign_idx = EC_KEY_get_ex_new_index(0, NULL, NULL, NULL,
+			sm2_sign_free)) < 0) {
+			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_EC_LIB);
+			goto end;
+		}
+	}
+
+	if (!EC_KEY_get_ex_data(ec_key, sm2_sign_idx)) {
+		BIGNUM *d = NULL;
+		if (!(d = BN_dup(EC_KEY_get0_private_key(ec_key)))) {
+			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_MALLOC_FAILURE);
+			goto end;
+		}
+		if (!BN_add_word(d, 1)) {
+			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_BN_LIB);
+			BN_clear_free(d);
+			goto end;
+		}
+        if (NULL != ec_key->meth->BN_mod_inverse) {
+    		if (!ec_key->meth->BN_mod_inverse(d, d, order, ctx)) {
+    			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_BN_LIB);
+    			BN_clear_free(d);
+    			goto end;
+    		}
+        }
+        else
+            goto end;	
+        
+		if (!EC_KEY_set_ex_data(ec_key, sm2_sign_idx, d)) {
+			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_EC_LIB);
+			goto end;
+		}
+	}
+
+	do {
+		/* get random k */
+		do {
+			if (!BN_rand_range(k, order)) {
+				SM2err(SM2_F_SM2_SIGN_SETUP,
+					SM2_R_RANDOM_NUMBER_GENERATION_FAILED);
+				goto end;
+			}
+
+		} while (BN_is_zero(k));
+
+		/* compute r the x-coordinate of generator * k */
+        if (NULL != ec_key->meth->EC_POINT_mul) {
+    		if (!ec_key->meth->EC_POINT_mul(ec_group, point, k, NULL, NULL, ctx)) {
+    			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_EC_LIB);
+    			goto end;
+    		}        
+        }
+        else
+            goto end;		
+
+        if (NULL == BN_copy(x, point->X))
+            goto end;
+        
+        if (NULL != ec_key->meth->BN_nnmod) {
+    		if (!ec_key->meth->BN_nnmod(x, x, order, ctx)) {
+    			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_BN_LIB);
+    			goto end;
+    		}        
+        }
+        else
+            goto end;
+
+	} while (BN_is_zero(x));
+
+	/* clear old values if necessary */
+	BN_clear_free(*kp);
+	BN_clear_free(*xp);
+
+	/* save the pre-computed values  */
+	*kp = k;
+	*xp = x;
+	ret = 1;
+
+end:
+	if (!ret) {
+		BN_clear_free(k);
+		BN_clear_free(x);
+	}
+	if (!ctx_in) {
+		BN_CTX_free(ctx);
+	}
+	BN_free(order);
+	EC_POINT_free(point);
+	return(ret);
+}
+
+static ECDSA_SIG *sm2_do_sign(const unsigned char *dgst, int dgstlen,
+	const BIGNUM *in_k, const BIGNUM *in_x, EC_KEY *ec_key)
+{
+	int ok = 0;
+	ECDSA_SIG *ret = NULL;
+	const EC_GROUP *ec_group;
+	const BIGNUM *priv_key;
+	const BIGNUM *ck;
+	BIGNUM *k = NULL;
+	BN_CTX *ctx = NULL;
+	BIGNUM *order = NULL;
+	BIGNUM *e = NULL;
+	BIGNUM *bn = NULL;
+
+	ec_group = EC_KEY_get0_group(ec_key);
+	priv_key = EC_KEY_get0_private_key(ec_key);
+	if (!ec_group || !priv_key) {
+		SM2err(SM2_F_SM2_DO_SIGN, ERR_R_PASSED_NULL_PARAMETER);
+		return NULL;
+	}
+
+	if (!(ret = ECDSA_SIG_new())) {
+		SM2err(SM2_F_SM2_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		return NULL;
+	}
+	ret->r = BN_new();
+	ret->s = BN_new();
+	ctx = BN_CTX_new();
+	order = BN_new();
+	e = BN_new();
+	bn = BN_new();
+	if (!ret->r || !ret->s || !ctx || !order || !e || !bn) {
+		SM2err(SM2_F_SM2_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto end;
+	}
+	if (!EC_GROUP_get_order(ec_group, order, ctx)) {
+		SM2err(SM2_F_SM2_DO_SIGN, ERR_R_EC_LIB);
+		goto end;
+	}
+
+	/* convert dgst to e */
+	if (!BN_bin2bn(dgst, dgstlen, e)) {
+		SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+		goto end;
+	}
+
+	do {
+		/* use or compute k and (kG).x */
+		if (!in_k || !in_x) {
+			if (!sm2_sign_setup(ec_key, ctx, &k, &ret->r)) {
+				SM2err(SM2_F_SM2_DO_SIGN, ERR_R_ECDSA_LIB);
+				goto end;
+			}
+			ck = k;
+		} else {
+			ck = in_k;
+			if (!BN_copy(ret->r, in_x)) {
+				SM2err(SM2_F_SM2_DO_SIGN, ERR_R_MALLOC_FAILURE);
+				goto end;
+			}
+		}
+
+		/* r = e + x (mod n) */        
+        if (NULL != ec_key->meth->BN_mod_add) {
+    		if (!ec_key->meth->BN_mod_add(ret->r, ret->r, e, order, ctx)) {
+    			SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+    			goto end;
+    		}
+
+    		if (!ec_key->meth->BN_mod_add(bn, ret->r, ck, order, ctx)) {
+    			SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+    			goto end;
+    		}        
+        }
+        else {
+            SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+            goto end;
+        }
+
+		/* check r != 0 && r + k != n */
+		if (BN_is_zero(ret->r) || BN_is_zero(bn)) {
+			if (in_k && in_x) {
+				SM2err(SM2_F_SM2_DO_SIGN, SM2_R_NEED_NEW_SETUP_VALUES);
+				goto end;
+			} else
+				continue;
+		}
+
+		/* s = ((1 + d)^-1 * (k - rd)) mod n */
+#if 0
+		if (!BN_one(bn)) {
+			SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+			goto end;
+		}
+        
+        if (NULL != ec_key->meth->BN_mod_add) {
+    		if (!ec_key->meth->BN_mod_add(ret->s, priv_key, bn, order, ctx)) {
+    			SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+    			goto end;
+    		}
+        }
+        else 
+            goto end;
+        
+        if (NULL != ec_key->meth->BN_mod_inverse) {
+    		if (!ec_key->meth->BN_mod_inverse(ret->s, ret->s, order, ctx)) {
+    			SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+    			goto end;
+    		}
+        }
+        else 
+            goto end;
+
+        
+        if (NULL != ec_key->meth->BN_mod_mul) {
+    		if (!ec_key->meth->BN_mod_mul(bn, ret->r, priv_key, order, ctx)) {
+    			SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+    			goto end;
+    		}
+        }
+        else 
+            goto end;
+        
+        if (NULL != ec_key->meth->BN_mod_sub) {
+    		if (!ec_key->meth->BN_mod_sub(bn, ck, bn, order, ctx)) {
+    			SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+    			goto end;
+    		}
+        }
+        else 
+            goto end;
+
+        if (NULL != ec_key->meth->BN_mod_mul) {
+    		if (!ec_key->meth->BN_mod_mul(ret->s, ret->s, bn, order, ctx)) {
+    			SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+    			goto end;
+    		}
+        }
+        else 
+            goto end;
+#else
+		/* s = d'(k + r) - r mod n */
+        if (NULL != ec_key->meth->BN_mod_mul) {
+    		if (!ec_key->meth->BN_mod_mul(ret->s, EC_KEY_get_ex_data(ec_key, sm2_sign_idx),
+    			bn, order, ctx)) {
+    			SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+    			goto end;
+    		}
+        }
+        else {
+            SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+            goto end;
+        }
+
+        if (NULL != ec_key->meth->BN_mod_sub) {
+    		if (!ec_key->meth->BN_mod_sub(ret->s, ret->s, ret->r, order, ctx)) {
+    			SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+    			goto end;
+    		}
+        }
+        else {
+            SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+            goto end;
+        }
+#endif
+
+		/* check s != 0 */
+		if (BN_is_zero(ret->s)) {
+			if (in_k && in_x) {
+				SM2err(SM2_F_SM2_DO_SIGN, SM2_R_NEED_NEW_SETUP_VALUES);
+				goto end;
+			}
+		} else {
+			break;
+		}
+
+	} while (1);
+
+	ok = 1;
+
+end:
+	if (!ok) {
+		ECDSA_SIG_free(ret);
+		ret = NULL;
+	}
+	BN_free(k);
+	BN_CTX_free(ctx);
+	BN_free(order);
+	BN_free(e);
+	BN_free(bn);
+
+	return ret;
+}
+
+int sm2_do_verify(const unsigned char *dgst, int dgstlen,
+	const ECDSA_SIG *sig, EC_KEY *ec_key)
+{
+	int ret = -1;
+	const EC_GROUP *ec_group;
+	const EC_POINT *pub_key;
+	EC_POINT *point = NULL;
+	BN_CTX *ctx = NULL;
+	BIGNUM *order = NULL;
+	BIGNUM *e = NULL;
+	BIGNUM *t = NULL;
+
+	if (!sig || !ec_key ||
+		!(ec_group = EC_KEY_get0_group(ec_key)) ||
+		!(pub_key  = EC_KEY_get0_public_key(ec_key))) {
+
+		SM2err(SM2_F_SM2_DO_VERIFY, SM2_R_MISSING_PARAMETERS);
+		return -1;
+	}
+
+	ctx = BN_CTX_new();
+	order = BN_new();
+	e = BN_new();
+	t = BN_new();
+	if (!ctx || !order || !e || !t) {
+		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_MALLOC_FAILURE);
+		goto end;
+	}
+	if (!EC_GROUP_get_order(ec_group, order, ctx)) {
+		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_EC_LIB);
+		goto end;
+	}
+
+	/* check r, s in [1, n-1] and r + s != 0 (mod n) */
+	if (BN_is_zero(sig->r) ||
+		BN_is_negative(sig->r) ||
+		BN_ucmp(sig->r, order) >= 0 ||
+		BN_is_zero(sig->s) ||
+		BN_is_negative(sig->s) ||
+		BN_ucmp(sig->s, order) >= 0) {
+
+		SM2err(SM2_F_SM2_DO_VERIFY, SM2_R_BAD_SIGNATURE);
+		ret = 0;
+		goto end;
+	}
+   
+	/* check t = r + s != 0 */
+     if (NULL != ec_key->meth->BN_mod_add) {
+        if (!ec_key->meth->BN_mod_add(t, sig->r, sig->s, order, ctx)) {
+        	SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_BN_LIB);
+        	goto end;
+        }
+    }
+    else {
+        SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_BN_LIB);
+        goto end;
+    }
+        
+	if (BN_is_zero(t)) {
+		ret = 0;
+		goto end;
+	}
+
+	/* convert digest to e */
+	if (!BN_bin2bn(dgst, dgstlen, e)) {
+		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_BN_LIB);
+		goto end;
+	}
+
+	/* compute (x, y) = sG + tP, P is pub_key */
+	if (!(point = EC_POINT_new(ec_group))) {
+		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_MALLOC_FAILURE);
+		goto end;
+	}
+    
+    if (NULL != ec_key->meth->EC_POINT_mul) {
+    	if (!ec_key->meth->EC_POINT_mul(ec_group, point, sig->s, pub_key, t, ctx)) {
+    		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_EC_LIB);
+    		goto end;
+    	}
+    }
+    else 
+        goto end;
+    
+    if (NULL == BN_copy(t, point->X))
+        goto end;
+    
+    if (NULL != ec_key->meth->BN_nnmod) {
+    	if (!ec_key->meth->BN_nnmod(t, t, order, ctx)) {
+    		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_BN_LIB);
+    		goto end;
+    	}
+    }
+    else 
+        goto end;
+
+	/* check (sG + tP).x + e  == sig.r */
+    
+    if (NULL != ec_key->meth->BN_mod_add) {
+    	if (!ec_key->meth->BN_mod_add(t, t, e, order, ctx)) {
+    		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_BN_LIB);
+    		goto end;
+    	}
+    }
+    else {
+        SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_BN_LIB);
+        goto end;
+    }
+    
+	if (BN_ucmp(t, sig->r) == 0) {
+		ret = 1;
+	} else {
+		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_BN_LIB);
+		ret = 0;
+	}
+
+end:
+	EC_POINT_free(point);
+	BN_free(order);
+	BN_free(e);
+	BN_free(t);
+	BN_CTX_free(ctx);
+	return ret;
+}
+static int sm2_sw_sign_setup(EC_KEY *ec_key, BN_CTX *ctx_in, BIGNUM **kp, BIGNUM **xp)
+{
+	int ret = 0;
+	const EC_GROUP *ec_group;
+	BN_CTX *ctx = NULL;
+	BIGNUM *k = NULL;
+	BIGNUM *x = NULL;
+	BIGNUM *order = NULL;
+	EC_POINT *point = NULL;
+
+	if (ec_key == NULL || (ec_group = EC_KEY_get0_group(ec_key)) == NULL) {
+		SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);
+		return 0;
+	}
+
+	if (ctx_in == NULL)  {
+		if ((ctx = BN_CTX_new()) == NULL) {
+			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_MALLOC_FAILURE);
+			return 0;
+		}
+	}
+	else {
+		ctx = ctx_in;
+	}
+
+
+	k = BN_new();
+	x = BN_new();
+	order = BN_new();
+	if (!k || !x || !order) {
+		SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_MALLOC_FAILURE);
+		goto end;
+	}
+
+	if (!EC_GROUP_get_order(ec_group, order, ctx)) {
+		SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_EC_LIB);
+		goto end;
+	}
+
+	if ((point = EC_POINT_new(ec_group)) == NULL) {
+		SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_EC_LIB);
+		goto end;
+	}
+
+	/* do pre compute (1 + d)^-1 */
+	if (sm2_sign_idx < 0) {
+		if ((sm2_sign_idx = EC_KEY_get_ex_new_index(0, NULL, NULL, NULL,
+			sm2_sign_free)) < 0) {
+			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_EC_LIB);
+			goto end;
+		}
+	}
+
+	if (!EC_KEY_get_ex_data(ec_key, sm2_sign_idx)) {
+		BIGNUM *d = NULL;
+		if (!(d = BN_dup(EC_KEY_get0_private_key(ec_key)))) {
+			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_MALLOC_FAILURE);
+			goto end;
+		}
+		if (!BN_add_word(d, 1)) {
+			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_BN_LIB);
+			BN_clear_free(d);
+			goto end;
+		}
+		if (!BN_mod_inverse(d, d, order, ctx)) {
+			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_BN_LIB);
+			BN_clear_free(d);
+			goto end;
+		}
+		if (!EC_KEY_set_ex_data(ec_key, sm2_sign_idx, d)) {
+			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_EC_LIB);
+			goto end;
+		}
+	}
+
+	do {
+		/* get random k */
+		do {
+			if (!BN_rand_range(k, order)) {
+				SM2err(SM2_F_SM2_SIGN_SETUP,
+					SM2_R_RANDOM_NUMBER_GENERATION_FAILED);
+				goto end;
+			}
+
+		} while (BN_is_zero(k));
+
+		/* compute r the x-coordinate of generator * k */
+		if (!EC_POINT_mul(ec_group, point, k, NULL, NULL, ctx)) {
+			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_EC_LIB);
+			goto end;
+		}
+
+		if (EC_METHOD_get_field_type(EC_GROUP_method_of(ec_group)) == NID_X9_62_prime_field) {
+			if (!EC_POINT_get_affine_coordinates_GFp(ec_group, point, x, NULL, ctx)) {
+				SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_EC_LIB);
+				goto end;
+			}
+		} else /* NID_X9_62_characteristic_two_field */ {
+			if (!EC_POINT_get_affine_coordinates_GF2m(ec_group, point, x, NULL, ctx)) {
+				SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_EC_LIB);
+				goto end;
+			}
+		}
+
+		if (!BN_nnmod(x, x, order, ctx)) {
+			SM2err(SM2_F_SM2_SIGN_SETUP, ERR_R_BN_LIB);
+			goto end;
+		}
+
+	} while (BN_is_zero(x));
+
+	/* clear old values if necessary */
+	BN_clear_free(*kp);
+	BN_clear_free(*xp);
+
+	/* save the pre-computed values  */
+	*kp = k;
+	*xp = x;
+	ret = 1;
+
+end:
+	if (!ret) {
+		BN_clear_free(k);
+		BN_clear_free(x);
+	}
+	if (!ctx_in) {
+		BN_CTX_free(ctx);
+	}
+	BN_free(order);
+	EC_POINT_free(point);
+	return(ret);
+}
+static ECDSA_SIG *sm2_sw_do_sign(const unsigned char *dgst, int dgstlen,
+	const BIGNUM *in_k, const BIGNUM *in_x, EC_KEY *ec_key)
+{
+	int ok = 0;
+	ECDSA_SIG *ret = NULL;
+	const EC_GROUP *ec_group;
+	const BIGNUM *priv_key;
+	const BIGNUM *ck;
+	BIGNUM *k = NULL;
+	BN_CTX *ctx = NULL;
+	BIGNUM *order = NULL;
+	BIGNUM *e = NULL;
+	BIGNUM *bn = NULL;
+
+	ec_group = EC_KEY_get0_group(ec_key);
+	priv_key = EC_KEY_get0_private_key(ec_key);
+	if (!ec_group || !priv_key) {
+		SM2err(SM2_F_SM2_DO_SIGN, ERR_R_PASSED_NULL_PARAMETER);
+		return NULL;
+	}
+
+	if (!(ret = ECDSA_SIG_new())) {
+		SM2err(SM2_F_SM2_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		return NULL;
+	}
+	ret->r = BN_new();
+	ret->s = BN_new();
+	ctx = BN_CTX_new();
+	order = BN_new();
+	e = BN_new();
+	bn = BN_new();
+	if (!ret->r || !ret->s || !ctx || !order || !e || !bn) {
+		SM2err(SM2_F_SM2_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto end;
+	}
+	if (!EC_GROUP_get_order(ec_group, order, ctx)) {
+		SM2err(SM2_F_SM2_DO_SIGN, ERR_R_EC_LIB);
+		goto end;
+	}
+
+	/* convert dgst to e */
+
+	if (!BN_bin2bn(dgst, dgstlen, e)) {
+		SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+		goto end;
+	}
+
+	do {
+		/* use or compute k and (kG).x */
+		if (!in_k || !in_x) {
+			if (!sm2_sw_sign_setup(ec_key, ctx, &k, &ret->r)) {
+				SM2err(SM2_F_SM2_DO_SIGN, ERR_R_ECDSA_LIB);
+				goto end;
+			}
+			ck = k;
+		} else {
+			ck = in_k;
+			if (!BN_copy(ret->r, in_x)) {
+				SM2err(SM2_F_SM2_DO_SIGN, ERR_R_MALLOC_FAILURE);
+				goto end;
+			}
+		}
+
+		/* r = e + x (mod n) */
+		if (!BN_mod_add(ret->r, ret->r, e, order, ctx)) {
+			SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+			goto end;
+		}
+
+		if (!BN_mod_add(bn, ret->r, ck, order, ctx)) {
+			SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+			goto end;
+		}
+
+		/* check r != 0 && r + k != n */
+		if (BN_is_zero(ret->r) || BN_is_zero(bn)) {
+			if (in_k && in_x) {
+				SM2err(SM2_F_SM2_DO_SIGN, SM2_R_NEED_NEW_SETUP_VALUES);
+				goto end;
+			} else
+				continue;
+		}
 
+		/* s = d'(k + r) - r mod n */
+		if (!BN_mod_mul(ret->s, EC_KEY_get_ex_data(ec_key, sm2_sign_idx),
+			bn, order, ctx)) {
+			SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+			goto end;
+		}
+		if (!BN_mod_sub(ret->s, ret->s, ret->r, order, ctx)) {
+			SM2err(SM2_F_SM2_DO_SIGN, ERR_R_BN_LIB);
+			goto end;
+		}
+
+		/* check s != 0 */
+		if (BN_is_zero(ret->s)) {
+			if (in_k && in_x) {
+				SM2err(SM2_F_SM2_DO_SIGN, SM2_R_NEED_NEW_SETUP_VALUES);
+				goto end;
+			}
+		} else {
+			break;
+		}
+
+	} while (1);
+
+	ok = 1;
+
+end:
+	if (!ok) {
+		ECDSA_SIG_free(ret);
+		ret = NULL;
+	}
+	BN_free(k);
+	BN_CTX_free(ctx);
+	BN_free(order);
+	BN_free(e);
+	BN_free(bn);
+
+	return ret;
+}
+int SM2_sw_sign(int type, const unsigned char *dgst, int dgstlen,
+	unsigned char *sig, unsigned int *siglen, EC_KEY *ec_key)
+{
+	ECDSA_SIG *s;
+
+	RAND_seed(dgst, dgstlen);
+
+	if (!(s = sm2_sw_do_sign(dgst, dgstlen, NULL, NULL, ec_key))) {
+		*siglen = 0;
+		return 0;
+	}
+
+	*siglen = i2d_ECDSA_SIG(s, &sig);
+	ECDSA_SIG_free(s);
+
+	return 1;
+}
+
+int sm2_sw_do_verify(const unsigned char *dgst, int dgstlen,
+	const ECDSA_SIG *sig, EC_KEY *ec_key)
+{
+	int ret = -1;
+	const EC_GROUP *ec_group;
+	const EC_POINT *pub_key;
+	EC_POINT *point = NULL;
+	BN_CTX *ctx = NULL;
+	BIGNUM *order = NULL;
+	BIGNUM *e = NULL;
+	BIGNUM *t = NULL;
+
+	if (!sig || !ec_key ||
+		!(ec_group = EC_KEY_get0_group(ec_key)) ||
+		!(pub_key  = EC_KEY_get0_public_key(ec_key))) {
+
+		SM2err(SM2_F_SM2_DO_VERIFY, SM2_R_MISSING_PARAMETERS);
+		return -1;
+	}
+
+	ctx = BN_CTX_new();
+	order = BN_new();
+	e = BN_new();
+	t = BN_new();
+	if (!ctx || !order || !e || !t) {
+		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_MALLOC_FAILURE);
+		goto end;
+	}
+	if (!EC_GROUP_get_order(ec_group, order, ctx)) {
+		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_EC_LIB);
+		goto end;
+	}
+
+
+	/* check r, s in [1, n-1] and r + s != 0 (mod n) */
+	if (BN_is_zero(sig->r) ||
+		BN_is_negative(sig->r) ||
+		BN_ucmp(sig->r, order) >= 0 ||
+		BN_is_zero(sig->s) ||
+		BN_is_negative(sig->s) ||
+		BN_ucmp(sig->s, order) >= 0) {
+
+		SM2err(SM2_F_SM2_DO_VERIFY, SM2_R_BAD_SIGNATURE);
+		ret = 0;
+		goto end;
+	}
+
+	/* check t = r + s != 0 */
+	if (!BN_mod_add(t, sig->r, sig->s, order, ctx)) {
+		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_BN_LIB);
+		goto end;
+	}
+	if (BN_is_zero(t)) {
+		ret = 0;
+		goto end;
+	}
+
+	/* convert digest to e */
+	if (!BN_bin2bn(dgst, dgstlen, e)) {
+		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_BN_LIB);
+		goto end;
+	}
+
+	/* compute (x, y) = sG + tP, P is pub_key */
+	if (!(point = EC_POINT_new(ec_group))) {
+		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_MALLOC_FAILURE);
+		goto end;
+	}
+	if (!EC_POINT_mul(ec_group, point, sig->s, pub_key, t, ctx)) {
+		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_EC_LIB);
+		goto end;
+	}
+	if (EC_METHOD_get_field_type(EC_GROUP_method_of(ec_group)) == NID_X9_62_prime_field) {
+		if (!EC_POINT_get_affine_coordinates_GFp(ec_group, point, t, NULL, ctx)) {
+			SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_EC_LIB);
+			goto end;
+		}
+	} else /* NID_X9_62_characteristic_two_field */ {
+		if (!EC_POINT_get_affine_coordinates_GF2m(ec_group, point, t, NULL, ctx)) {
+			SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_EC_LIB);
+			goto end;
+		}
+	}
+	if (!BN_nnmod(t, t, order, ctx)) {
+		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_BN_LIB);
+		goto end;
+	}
+
+	/* check (sG + tP).x + e  == sig.r */
+	if (!BN_mod_add(t, t, e, order, ctx)) {
+		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_BN_LIB);
+		goto end;
+	}
+	if (BN_ucmp(t, sig->r) == 0) {
+		ret = 1;
+	} else {
+		SM2err(SM2_F_SM2_DO_VERIFY, ERR_R_PASSED_INVALID_ARGUMENT);
+		ret = 0;
+	}
+
+end:
+	EC_POINT_free(point);
+	BN_free(order);
+	BN_free(e);
+	BN_free(t);
+	BN_CTX_free(ctx);
+	return ret;
+}
+int SM2_sw_verify(int type, const unsigned char *dgst, int dgstlen,
+	const unsigned char *sig, int siglen, EC_KEY *ec_key)
+{
+	ECDSA_SIG *s;
+	const unsigned char *p = sig;
+	unsigned char *der = NULL;
+	int derlen = -1;
+	int ret = -1;
+
+	if (!(s = ECDSA_SIG_new())) {
+		return ret;
+	}
+	if (!d2i_ECDSA_SIG(&s, &p, siglen)) {
+		goto err;
+	}
+	derlen = i2d_ECDSA_SIG(s, &der);
+	if (derlen != siglen || memcmp(sig, der, derlen)) {
+		goto err;
+	}
+
+	ret = sm2_sw_do_verify(dgst, dgstlen, s, ec_key);
+
+err:
+	if (derlen > 0) {
+		OPENSSL_cleanse(der, derlen);
+		OPENSSL_free(der);
+	}
+
+	ECDSA_SIG_free(s);
+	return ret;
+}
+
+#else
 static int sm2_sign_setup(EC_KEY *ec_key, BN_CTX *ctx_in, BIGNUM **kp, BIGNUM **xp)
 {
 	int ret = 0;
@@ -513,7 +1381,7 @@ end:
 	BN_CTX_free(ctx);
 	return ret;
 }
-
+#endif
 int SM2_sign_setup(EC_KEY *ec_key, BN_CTX *ctx_in, BIGNUM **kp, BIGNUM **xp)
 {
 	return sm2_sign_setup(ec_key, ctx_in, kp, xp);
diff -uprN gmssl-1.0/crypto/sm9/sm9_lcl.h GmSSL-2.5.0_iMX/crypto/sm9/sm9_lcl.h
--- gmssl-1.0/crypto/sm9/sm9_lcl.h	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/sm9/sm9_lcl.h	2020-11-09 10:59:49.719907221 +0800
@@ -52,7 +52,9 @@
 
 #include <openssl/err.h>
 #include <openssl/sm9.h>
-#include "../../e_os.h"
+#ifdef HAVE_CRYPTODEV
+#include "../ec/ec_lcl.h"
+#endif
 
 /* private key extract algorithms */
 #define SM9_HID_SIGN		0x01
@@ -197,6 +199,26 @@ int sm9_check_hash1(int nid);
 int sm9_check_encrypt_scheme(int nid);
 int sm9_check_sign_scheme(int nid);
 
+#ifdef HAVE_CRYPTODEV
+extern EC_KEY *ec_key;
+#define BN_add_word ec_key->meth->BN_add_word
+#define BN_add ec_key->meth->BN_add
+#define BN_sub ec_key->meth->BN_sub
+#define BN_mul ec_key->meth->BN_mul
+#define BN_mod_add ec_key->meth->BN_mod_add
+#define BN_mod_sub ec_key->meth->BN_mod_sub
+#define BN_mod_mul ec_key->meth->BN_mod_mul
+#define BN_mod_sqr ec_key->meth->BN_mod_sqr
+#define BN_mod_inverse ec_key->meth->BN_mod_inverse
+#undef BN_mod
+#define BN_mod ec_key->meth->BN_mod
+#define BN_nnmod ec_key->meth->BN_nnmod
+#define EC_POINT_add ec_key->meth->EC_POINT_add
+#define EC_POINT_double ec_key->meth->EC_POINT_double
+#define EC_POINT_mul ec_key->meth->EC_POINT_mul
+#define EC_POINT_check ec_key->meth->EC_POINT_check
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff -uprN gmssl-1.0/crypto/sm9/sm9_params.c GmSSL-2.5.0_iMX/crypto/sm9/sm9_params.c
--- gmssl-1.0/crypto/sm9/sm9_params.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/sm9/sm9_params.c	2020-11-09 10:59:49.719907221 +0800
@@ -145,6 +145,86 @@ static const BN_ULONG _sm9bn256v1_fast_f
 };
 
 #elif BN_BITS2 == 32
+#ifndef HW_ENDIAN_SWAP
+static BN_ULONG _sm9bn256v1_prime[BN_SM9_BN256_TOP] = {
+	0xE351457D, 0xE56F9B27, 0x1A7AEEDB, 0x21F2934B,
+	0xF58EC745, 0xD603AB4F, 0x02A3A6F1, 0xB6400000,
+};
+
+static BN_ULONG _sm9bn256v1_order[BN_SM9_BN256_TOP] = {
+	0xD69ECF25, 0xE56EE19C, 0x18EA8BEE, 0x49F2934B,
+	0xF58EC744, 0xD603AB4F, 0x02A3A6F1, 0xB6400000,
+};
+
+static BN_ULONG _sm9bn256v1_order_minus_one[BN_SM9_BN256_TOP] = {
+	0xD69ECF24, 0xE56EE19C, 0x18EA8BEE, 0x49F2934B,
+	0xF58EC744, 0xD603AB4F, 0x02A3A6F1, 0xB6400000,
+};
+
+static BN_ULONG _sm9bn256v1_loop[BN_SM9_LOOP_TOP] = {
+	0x0215D93E, 0x40000000, 0x02,
+};
+
+static BN_ULONG _sm9bn256v1_x2[][BN_SM9_BN256_TOP] = {
+	{0xAF82D65B, 0xF9B7213B, 0xD19C17AB, 0xEE265948,
+	 0xD34EC120, 0xD2AAB97F, 0x92130B08, 0x37227552},
+	{0xD8806141, 0x54806C11, 0x0F5E93C4, 0xF1DD2C19,
+	 0xB441A01F, 0x597B6027, 0x78640C98, 0x85AEF3D0}
+};
+
+static BN_ULONG _sm9bn256v1_y2[][BN_SM9_BN256_TOP] = {
+	{0xC999A7C7, 0x6215BBA5, 0xA71A0811, 0x47EFBA98,
+	 0x3D278FF2, 0x5F317015, 0x19BE3DA6, 0xA7CF28D5},
+	{0x84EBEB96, 0x856DC76B, 0xA347C8BD, 0x0736A96F,
+	 0x2CBEE6ED, 0x66BA0D26, 0x2E845C12, 0x17509B09}
+};
+
+static BN_ULONG _sm9bn256v1_final_expo[BN_SM9_FINAL_EXPO_TOP] = {
+	0x0D042330, 0x2FACDD0F, 0x4AC0B748, 0xB19FE176,
+	0x864E1676, 0xC6135FEC, 0x7E824DC7, 0x8E4890AB,
+	0xE2D0B969, 0x5B83E3D7, 0x225955B0, 0xCBD806A8,
+	0xA4B5F799, 0x6FE5E935, 0xD4C31B8F, 0x0B48EE8F,
+	0xE843D1FA, 0x8478B1A3, 0xFE39F256, 0xBB6793F9,
+	0x13D719F2, 0xB7605589, 0xB1B62D11, 0xEFE915CA,
+	0x1D978AD0, 0x1D16182C, 0xA78C62F3, 0x5BBD6C4A,
+	0x9E53535A, 0xF703B00C, 0xD64089BD, 0x0F4C6983,
+	0x87BF2203, 0xC3E3945F, 0xD729E88D, 0xE804F361,
+	0x4AA170BA, 0x6B948EBD, 0xCA2042C3, 0x4550E98D,
+	0x82F7DD63, 0x5A54D51E, 0x412315EC, 0x2FB14FC5,
+	0x19F32C69, 0xE2C3601D, 0x58AAC66E, 0x335D59C3,
+	0x583D5AA1, 0x96FD3135, 0xFF56FA06, 0xB78BD480,
+	0x4C04689A, 0xA4DEFA39, 0x9EC19BA7, 0xCB5A6B4B,
+	0x739295ED, 0x80357732, 0x0632C9CC, 0x3BED65F0,
+	0xA23AFA5A, 0x93DC562F, 0x598EEE9B, 0xF1C8D7D0,
+	0x80EE9629, 0xB97559B1, 0x10455806, 0x5ED57CD4,
+	0xA1387366, 0x239E0CB2, 0x9CEB7907, 0x96F69126,
+	0x974B7BA1, 0x93B5122D, 0x6C5042CB, 0xBE8CB047,
+	0x4067AA64, 0x9BF41BCB, 0x19DBA153, 0xDD9D1D30,
+	0xACA54D38, 0xC16BE7FB, 0x86411255, 0xACEF6F4E,
+	0x43ADE454, 0x1A09A6AE, 0xB1259499, 0x061835E8,
+};
+
+static BN_ULONG _sm9bn256v1_fast_final_expo_p2[][BN_SM9_FAST_FINAL_EXPO_P2_TOP] = {
+	{0x7BE65334, 0xD5FC1196, 0x4F8B78F4, 0x78027235,
+	 0x02A3A6F2, 0xF3000000},
+	{0x676AF249, 0x0F738991, 0xCAEF75E7, 0xA9F02115,
+	 0xF2EB2052, 0xE303AB4F, 0x02A3A6F0, 0xB6400000},
+	{0x7BE65333, 0xD5FC1196, 0x4F8B78F4, 0x78027235,
+	 0x02A3A6F2, 0xF3000000},
+	{0x676AF24A, 0x0F738991, 0xCAEF75E7, 0xA9F02115,
+	 0xF2EB2052, 0xE303AB4F, 0x02A3A6F0, 0xB6400000}
+};
+
+static BN_ULONG _sm9bn256v1_fast_final_expo_p3[BN_SM9_FAST_FINAL_EXPO_P3_TOP] = {
+	0x93152855, 0xA9B2ADA5, 0xA74DDFB7, 0x44BF9D0F,
+	0xC6D9188C, 0x83687EE0, 0xAA8A4748, 0xE0D49DE3,
+	0xCDB13FE5, 0x0DA3D71B, 0xFDB6B0A1, 0xA5782C82,
+	0x9B0D8649, 0x7C0CA02D, 0x9029E471, 0xBA4CADE0,
+	0x930846F1, 0xDC53E586, 0x7B497A0A, 0xD62CD8FB,
+	0xB31FE2B0, 0xF12FCAD3, 0x04034E2A, 0x5C5E4524,
+};
+
+#else
 static const BN_ULONG _sm9bn256v1_prime[BN_SM9_BN256_TOP] = {
 	0xE351457D, 0xE56F9B27, 0x1A7AEEDB, 0x21F2934B,
 	0xF58EC745, 0xD603AB4F, 0x02A3A6F1, 0xB6400000,
@@ -222,7 +302,7 @@ static const BN_ULONG _sm9bn256v1_fast_f
 	0x930846F1, 0xDC53E586, 0x7B497A0A, 0xD62CD8FB,
 	0xB31FE2B0, 0xF12FCAD3, 0x04034E2A, 0x5C5E4524,
 };
-
+#endif
 #else
 # error "unsupported BN_BITS2"
 #endif
diff -uprN gmssl-1.0/crypto/sm9/sm9_rate.c GmSSL-2.5.0_iMX/crypto/sm9/sm9_rate.c
--- gmssl-1.0/crypto/sm9/sm9_rate.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/sm9/sm9_rate.c	2020-11-09 10:59:49.719907221 +0800
@@ -53,22 +53,22 @@
 #include <openssl/bn.h>
 #include <openssl/ec.h>
 #include <openssl/err.h>
+#ifdef HAVE_CRYPTODEV
+#include <openssl/engine.h>
+#endif
 #include "sm9_lcl.h"
 
+#ifdef HAVE_CRYPTODEV
+ENGINE *e = NULL;
+EC_KEY *ec_key = NULL;
+#endif
 
 static int fp2_init(fp2_t a, BN_CTX *ctx)
 {
 	a[0] = NULL;
 	a[1] = NULL;
-	a[0] = BN_CTX_get(ctx);
-	a[1] = BN_CTX_get(ctx);
-	/*
-	if (!a[1]) {
-		BN_free(a[0]);
-		a[0] = NULL;
-		return 0;
-	}
-	*/
+	a[0] = BN_new();
+	a[1] = BN_new();
 	return 1;
 }
 
@@ -177,7 +177,7 @@ static int fp2_equ_hex(const fp2_t a, co
 static int fp2_add_word(fp2_t r, const fp2_t a, unsigned long b, const BIGNUM *p, BN_CTX *ctx)
 {
 	BIGNUM *w = NULL;
-	if (!(w = BN_CTX_get(ctx))
+	if (!(w = BN_new())
 		|| !BN_set_word(w, b)
 		|| !BN_mod_add(r[0], a[0], w, p, ctx)
 		|| !BN_copy(r[1], a[1])) {
@@ -230,9 +230,9 @@ static int fp2_mul(fp2_t r, const fp2_t
 	BIGNUM *t = NULL;
 	BIGNUM *r0 = NULL;
 	BIGNUM *r1 = NULL;
-	if (!(t = BN_CTX_get(ctx))
-		|| !(r0 = BN_CTX_get(ctx))
-		|| !(r1 = BN_CTX_get(ctx))
+	if (!(t = BN_new())
+		|| !(r0 = BN_new())
+		|| !(r1 = BN_new())
 
 		/* r0 = a0 * b0 - 2 * a1 * b1 */
 		|| !BN_mod_mul(r0, a[0], b[0], p, ctx)
@@ -263,9 +263,9 @@ static int fp2_mul_u(fp2_t r, const fp2_
 	BIGNUM *r0 = NULL;
 	BIGNUM *r1 = NULL;
 	BIGNUM *t = NULL;
-	if (!(r0 = BN_CTX_get(ctx))
-		|| !(r1 = BN_CTX_get(ctx))
-		|| !(t = BN_CTX_get(ctx))
+	if (!(r0 = BN_new())
+		|| !(r1 = BN_new())
+		|| !(t = BN_new())
 
 		/* r0 = -2 * (a0 * b1 + a1 * b0) */
 		|| !BN_mod_mul(r0, a[0], b[1], p, ctx)
@@ -297,8 +297,8 @@ static int fp2_mul_num(fp2_t r, const fp
 {
 	BIGNUM *r0 = NULL;
 	BIGNUM *r1 = NULL;
-	if (!(r0 = BN_CTX_get(ctx))
-		|| !(r1 = BN_CTX_get(ctx))
+	if (!(r0 = BN_new())
+		|| !(r1 = BN_new())
 		
 		|| !BN_mod_mul(r0, a[0], n, p, ctx)
 		|| !BN_mod_mul(r1, a[1], n, p, ctx)
@@ -319,9 +319,9 @@ static int fp2_sqr(fp2_t r, const fp2_t
 	BIGNUM *r0 = NULL;
 	BIGNUM *r1 = NULL;
 	BIGNUM *t = NULL;
-	if (!(r0 = BN_CTX_get(ctx))
-		|| !(r1 = BN_CTX_get(ctx))
-		||!(t = BN_CTX_get(ctx))
+	if (!(r0 = BN_new())
+		|| !(r1 = BN_new())
+		||!(t = BN_new())
 		/* r0 = a0^2 - 2 * a1^2 */
 		|| !BN_mod_sqr(r0, a[0], p, ctx)
 		|| !BN_mod_sqr(t, a[1], p, ctx)
@@ -349,9 +349,9 @@ static int fp2_sqr_u(fp2_t r, const fp2_
 	BIGNUM *r0 = NULL;
 	BIGNUM *r1 = NULL;
 	BIGNUM *t = NULL;
-	if (!(r0 = BN_CTX_get(ctx))
-		|| !(r1 = BN_CTX_get(ctx))
-		|| !(t = BN_CTX_get(ctx))
+	if (!(r0 = BN_new())
+		|| !(r1 = BN_new())
+		|| !(t = BN_new())
 		/* r0 = -4 * a0 * a1 */
 		|| !BN_mod_mul(r0, a[0], a[1], p, ctx)
 		|| !BN_mod_add(r0, r0, r0, p, ctx)
@@ -400,8 +400,8 @@ static int fp2_inv(fp2_t r, const fp2_t
 	} else {
 		BIGNUM *k = NULL;
 		BIGNUM *t = NULL;
-		if (!(k = BN_CTX_get(ctx))
-			|| !(t = BN_CTX_get(ctx))
+		if (!(k = BN_new())
+			|| !(t = BN_new())
 
 			/* k = (a[0]^2 + 2 * a[1]^2)^-1 */
 			|| !BN_mod_sqr(k, a[0], p, ctx)
@@ -1766,6 +1766,21 @@ static int fp12_test(const BIGNUM *p, BN
 int point_init(point_t *P, BN_CTX *ctx)
 {
 	int r;
+#ifdef HAVE_CRYPTODEV 
+    if (NULL == ec_key) {
+        ENGINE_load_builtin_engines();
+        if (!(e = ENGINE_by_id("cryptodev")))
+            return 0;
+        if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+            ENGINE_free(e);
+            return 0;
+        }
+        ec_key = EC_KEY_new_method(e);
+        if (NULL == ec_key)
+            return 0;
+    }
+#endif
+
 	r = fp2_init(P->X, ctx);
 	r &= fp2_init(P->Y, ctx);
 	r &= fp2_init(P->Z, ctx);
@@ -2509,7 +2524,7 @@ static int fast_final_expo(fp12_t r, con
 static int rate(fp12_t f, const point_t *Q, const BIGNUM *xP, const BIGNUM *yP,
 	const BIGNUM *a, const BIGNUM *k, const BIGNUM *p, BN_CTX *ctx)
 {
-	int ret = 0;
+	int ret = 1;
 	int i, n;
 	point_t T, Q1, Q2;
 	fp12_t g;
@@ -2631,19 +2646,46 @@ int rate_pairing(fp12_t r, const point_t
 #else
 	k = SM9_get0_fast_final_exponent_p3();
 #endif
-	xP = BN_CTX_get(ctx);
-	yP = BN_CTX_get(ctx);
+	xP = BN_new();
+	yP = BN_new();
 
+#ifdef HAVE_CRYPTODEV
+    if (!P) {
+        if(NULL == BN_copy(xP, EC_GROUP_get0_generator(group)->X)) {
+            EC_GROUP_free(group);
+            goto end;
+        }
+        if(NULL == BN_copy(yP, EC_GROUP_get0_generator(group)->Y)){
+            EC_GROUP_free(group);
+            goto end;
+        }
+        BN_set_word(EC_GROUP_get0_generator(group)->Z,1);
+	} else {
+    	if(NULL == BN_copy(xP, P->X)){
+            EC_GROUP_free(group);
+            goto end;
+        }
+        if(NULL == BN_copy(yP, P->Y)){
+            EC_GROUP_free(group);
+            goto end;
+        }
+        BN_set_word(P->Z,1);
+	}
+#else
 	if (!P) {
 		EC_POINT_get_affine_coordinates_GFp(group,
 			EC_GROUP_get0_generator(group), xP, yP, ctx);
 	} else {
 		EC_POINT_get_affine_coordinates_GFp(group, P, xP, yP, ctx);
 	}
-
+#endif
 	if (!Q) {
 		point_t P2;
-		point_init(&P2, ctx);
+		ret = point_init(&P2, ctx);
+        if (!ret) {
+            EC_GROUP_free(group);
+            goto end;
+        }
 		point_set_affine_coordinates_bignums(&P2,
 			SM9_get0_generator2_x0(),
 			SM9_get0_generator2_x1(),
@@ -2656,7 +2698,7 @@ int rate_pairing(fp12_t r, const point_t
 	} else {
 		rate(r, Q, xP, yP, a, k, p, ctx);
 	}
-
+end:
 	BN_free(xP);
 	BN_free(yP);
 	return ret;
diff -uprN gmssl-1.0/crypto/sm9/sm9_sign.c GmSSL-2.5.0_iMX/crypto/sm9/sm9_sign.c
--- gmssl-1.0/crypto/sm9/sm9_sign.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/crypto/sm9/sm9_sign.c	2020-11-09 10:59:49.719907221 +0800
@@ -89,7 +89,11 @@ SM9Signature *SM9_SignFinal(EVP_MD_CTX *
 	SM9Signature *sig = NULL;
 	const BIGNUM *p = SM9_get0_prime();
 	const BIGNUM *n = SM9_get0_order();
+#ifdef HAVE_CRYPTODEV
+    int point_form = POINT_CONVERSION_UNCOMPRESSED;
+#else
 	int point_form = POINT_CONVERSION_COMPRESSED;
+#endif
 	/* buf for w and prefix zeros of ct1/2 */
 	unsigned char buf[384] = {0};
 	unsigned int len;
diff -uprN gmssl-1.0/e_os.h GmSSL-2.5.0_iMX/e_os.h
--- gmssl-1.0/e_os.h	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/e_os.h	2020-11-09 10:59:49.719907221 +0800
@@ -43,7 +43,7 @@ extern "C" {
 # endif
 
 # define osslargused(x)      (void)x
-# define OPENSSL_CONF        "openssl.cnf"
+# define OPENSSL_CONF        "gmssl.cnf"
 
 # ifndef DEVRANDOM
 /*
diff -uprN gmssl-1.0/include/openssl/bn.h GmSSL-2.5.0_iMX/include/openssl/bn.h
--- gmssl-1.0/include/openssl/bn.h	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/include/openssl/bn.h	2020-11-09 10:59:49.719907221 +0800
@@ -466,6 +466,8 @@ const BIGNUM *BN_get0_nist_prime_384(voi
 const BIGNUM *BN_get0_nist_prime_521(void);
 # ifndef OPENSSL_NO_SM2
 const BIGNUM *BN_get0_sm2_prime_256(void);
+const BIGNUM *BN_get0_sm2_a_256(void);
+const BIGNUM *BN_get0_sm2_b_256(void);
 # endif
 
 int (*BN_nist_mod_func(const BIGNUM *p)) (BIGNUM *r, const BIGNUM *a,
diff -uprN gmssl-1.0/include/openssl/cryptodev.h GmSSL-2.5.0_iMX/include/openssl/cryptodev.h
--- gmssl-1.0/include/openssl/cryptodev.h	1970-01-01 08:00:00.000000000 +0800
+++ GmSSL-2.5.0_iMX/include/openssl/cryptodev.h	2020-11-09 10:59:49.719907221 +0800
@@ -0,0 +1,407 @@
+/* This is a source compatible implementation with the original API of
+ * cryptodev by Angelos D. Keromytis, found at openbsd cryptodev.h.
+ * Placed under public domain */
+
+#ifndef L_CRYPTODEV_H
+#define L_CRYPTODEV_H
+
+#include <linux/types.h>
+#ifndef __KERNEL__
+#define __user
+#endif
+
+/* API extensions for linux */
+#define CRYPTO_HMAC_MAX_KEY_LEN		512
+#define CRYPTO_CIPHER_MAX_KEY_LEN	64
+
+/* All the supported algorithms
+ */
+enum cryptodev_crypto_op_t {
+	CRYPTO_DES_CBC = 1,
+	CRYPTO_3DES_CBC = 2,
+	CRYPTO_BLF_CBC = 3,
+	CRYPTO_CAST_CBC = 4,
+	CRYPTO_SKIPJACK_CBC = 5,
+	CRYPTO_MD5_HMAC = 6,
+	CRYPTO_SHA1_HMAC = 7,
+	CRYPTO_RIPEMD160_HMAC = 8,
+	CRYPTO_MD5_KPDK = 9,
+	CRYPTO_SHA1_KPDK = 10,
+	CRYPTO_RIJNDAEL128_CBC = 11,
+	CRYPTO_AES_CBC = CRYPTO_RIJNDAEL128_CBC,
+	CRYPTO_ARC4 = 12,
+	CRYPTO_MD5 = 13,
+	CRYPTO_SHA1 = 14,
+	CRYPTO_DEFLATE_COMP = 15,
+	CRYPTO_NULL = 16,
+	CRYPTO_LZS_COMP = 17,
+	CRYPTO_SHA2_256_HMAC = 18,
+	CRYPTO_SHA2_384_HMAC = 19,
+	CRYPTO_SHA2_512_HMAC = 20,
+	CRYPTO_AES_CTR = 21,
+	CRYPTO_AES_XTS = 22,
+	CRYPTO_AES_ECB = 23,
+	CRYPTO_AES_GCM = 50,
+	CRYPTO_AES_CCM = 51,
+	CRYPTO_AES_CFB128 = 52,
+	CRYPTO_AES_OFB = 53,
+	CRYPTO_AES_CMAC = 54,
+	CRYPTO_AES_XCBC_MAC = 55,
+
+	CRYPTO_DES_ECB = 80,
+	CRYPTO_DES_CFB,
+	CRYPTO_DES_OFB,
+	CRYPTO_3DES_ECB,
+	CRYPTO_3DES_CFB,
+	CRYPTO_3DES_OFB,
+
+	CRYPTO_CAMELLIA_CBC = 101,
+	CRYPTO_RIPEMD160,
+	CRYPTO_SHA2_224,
+	CRYPTO_SHA2_256,
+	CRYPTO_SHA2_384,
+	CRYPTO_SHA2_512,
+	CRYPTO_SHA2_224_HMAC,
+
+	CRYPTO_PKHA_MOD_EXP = 200,
+	CRYPTO_PKHA_MOD_EXP_CRT = 201,
+	CRYPTO_PKHA_MOD_ADD = 202,
+	CRYPTO_PKHA_MOD_SUB1 = 203,
+	CRYPTO_PKHA_MOD_SUB2 = 204,
+	CRYPTO_PKHA_MOD_MUL = 205,
+	CRYPTO_PKHA_MOD_RED = 206,
+	CRYPTO_PKHA_MOD_INV = 207,
+	CRYPTO_PKHA_GCD = 208,
+	CRYPTO_PKHA_PRIMALITY_TEST = 209,
+	CRYPTO_PKHA_MOD_R2 = 210,
+	CRYPTO_PKHA_CLEAR_MEM = 211,
+	CRYPTO_PKHA_COPY_MEM = 212,
+	CRYPTO_PKHA_ECC_ADD = 213,
+	CRYPTO_PKHA_ECC_DOUBLE = 214,
+	CRYPTO_PKHA_ECC_MUL = 215,
+	CRYPTO_PKHA_ECC_IS_INFINITY = 216,
+	CRYPTO_PKHA_ECC_CHECK_POINT = 217,
+	CRYPTO_ASYMMETRIC_DSA_SIGN = 300,
+	CRYPTO_ASYMMETRIC_DSA_VERIFY = 301,
+	CRYPTO_ASYMMETRIC_ECDSA_SIGN = 302,
+	CRYPTO_ASYMMETRIC_ECDSA_VERIFY = 303,
+	CRYPTO_ASYMMETRIC_DH_GENERATE_KEY = 304,
+	CRYPTO_ASYMMETRIC_ECDH_GENERATE_KEY = 305,
+	CRYPTO_ASYMMETRIC_DH_COMPUTE_KEY = 306,
+	CRYPTO_ASYMMETRIC_ECDH_COMPUTE_KEY = 307,
+	CRYPTO_ASYMMETRIC_RSA_PUBLIC = 308,
+	CRYPTO_ASYMMETRIC_RSA_PRIVATE = 309,
+	CRYPTO_ASYMMETRIC_RSA_GENERATE_KEY = 310,
+	CRYPTO_MP_SIGN = 311,
+	CRYPTO_MP_GET_PUBK = 312,
+	CRYPTO_CV2X_NISTP256_VERIFY = 313,
+	CRYPTO_CV2X_BP_P256R1_VERIFY = 314,
+	CRYPTO_CV2X_SM2_VERIFY = 315,
+	CRYPTO_ALGORITHM_ALL, /* Keep updated - see below */
+};
+
+#define	CRYPTO_ALGORITHM_MAX	(CRYPTO_ALGORITHM_ALL - 1)
+
+/* Values for ciphers */
+#define DES_BLOCK_LEN		8
+#define DES3_BLOCK_LEN		8
+#define RIJNDAEL128_BLOCK_LEN	16
+#define AES_BLOCK_LEN		RIJNDAEL128_BLOCK_LEN
+#define CAMELLIA_BLOCK_LEN      16
+#define BLOWFISH_BLOCK_LEN	8
+#define SKIPJACK_BLOCK_LEN	8
+#define CAST128_BLOCK_LEN	8
+
+/* the maximum of the above */
+#define EALG_MAX_BLOCK_LEN	16
+
+/* Values for hashes/MAC */
+#define AALG_MAX_RESULT_LEN		64
+
+/* maximum length of verbose alg names (depends on CRYPTO_MAX_ALG_NAME) */
+#define CRYPTODEV_MAX_ALG_NAME		64
+
+#define HASH_MAX_LEN 64
+
+/* input of CIOCGSESSION */
+struct session_op {
+	/* Specify either cipher or mac
+	 */
+	__u32	cipher;		/* cryptodev_crypto_op_t */
+	__u32	mac;		/* cryptodev_crypto_op_t */
+	__u32	pk_cipher;	/* cryptodev_crk_op_t */
+
+	__u32	keylen;
+	__u8	__user *key;
+	__u32	mackeylen;
+	__u8	__user *mackey;
+
+	__u32	ses;		/* session identifier */
+};
+
+struct session_info_op {
+	__u32 ses;		/* session identifier */
+
+	/* verbose names for the requested ciphers */
+	struct alg_info {
+		char cra_name[CRYPTODEV_MAX_ALG_NAME];
+		char cra_driver_name[CRYPTODEV_MAX_ALG_NAME];
+	} cipher_info, hash_info;
+
+	__u16	alignmask;	/* alignment constraints */
+	__u32   flags;          /* SIOP_FLAGS_* */
+};
+
+/* If this flag is set then this algorithm uses
+ * a driver only available in kernel (software drivers,
+ * or drivers based on instruction sets do not set this flag).
+ *
+ * If multiple algorithms are involved (as in AEAD case), then
+ * if one of them is kernel-driver-only this flag will be set.
+ */
+#define SIOP_FLAG_KERNEL_DRIVER_ONLY 1
+
+#define	COP_ENCRYPT	0
+#define COP_DECRYPT	1
+
+/* input of CIOCCRYPT */
+struct crypt_op {
+	__u32	ses;		/* session identifier */
+	__u16	op;		/* COP_ENCRYPT or COP_DECRYPT */
+	__u16	flags;		/* see COP_FLAG_* */
+	__u32	len;		/* length of source data */
+	__u8	__user *src;	/* source data */
+	__u8	__user *dst;	/* pointer to output data */
+	/* pointer to output data for hash/MAC operations */
+	__u8	__user *mac;
+	/* initialization vector for encryption operations */
+	__u8	__user *iv;
+};
+
+/* input of CIOCAUTHCRYPT */
+struct crypt_auth_op {
+	__u32	ses;		/* session identifier */
+	__u16	op;		/* COP_ENCRYPT or COP_DECRYPT */
+	__u16	flags;		/* see COP_FLAG_AEAD_* */
+	__u32	len;		/* length of source data */
+	__u32	auth_len;	/* length of auth data */
+	__u8	__user *auth_src;	/* authenticated-only data */
+
+	/* The current implementation is more efficient if data are
+	 * encrypted in-place (src==dst). */
+	__u8	__user *src;	/* data to be encrypted and authenticated */
+	__u8	__user *dst;	/* pointer to output data. Must have
+	                         * space for tag. For TLS this should be at least 
+	                         * len + tag_size + block_size for padding */
+
+	__u8    __user *tag;    /* where the tag will be copied to. TLS mode
+                                 * doesn't use that as tag is copied to dst.
+                                 * SRTP mode copies tag there. */
+	__u32	tag_len;	/* the length of the tag. Use zero for digest size or max tag. */
+
+	/* initialization vector for encryption operations */
+	__u8	__user *iv;
+	__u32   iv_len;
+};
+
+/* In plain AEAD mode the following are required:
+ *  flags   : 0
+ *  iv      : the initialization vector (12 bytes)
+ *  auth_len: the length of the data to be authenticated
+ *  auth_src: the data to be authenticated
+ *  len     : length of data to be encrypted
+ *  src     : the data to be encrypted
+ *  dst     : space to hold encrypted data. It must have
+ *            at least a size of len + tag_size.
+ *  tag_size: the size of the desired authentication tag or zero to use
+ *            the maximum tag output.
+ *
+ * Note tag isn't being used because the Linux AEAD interface
+ * copies the tag just after data.
+ */
+
+/* In TLS mode (used for CBC ciphers that required padding) 
+ * the following are required:
+ *  flags   : COP_FLAG_AEAD_TLS_TYPE
+ *  iv      : the initialization vector
+ *  auth_len: the length of the data to be authenticated only
+ *  len     : length of data to be encrypted
+ *  auth_src: the data to be authenticated
+ *  src     : the data to be encrypted
+ *  dst     : space to hold encrypted data (preferably in-place). It must have
+ *            at least a size of len + tag_size + blocksize.
+ *  tag_size: the size of the desired authentication tag or zero to use
+ *            the default mac output.
+ *
+ * Note that the padding used is the minimum padding.
+ */
+
+/* In SRTP mode the following are required:
+ *  flags   : COP_FLAG_AEAD_SRTP_TYPE
+ *  iv      : the initialization vector
+ *  auth_len: the length of the data to be authenticated. This must
+ *            include the SRTP header + SRTP payload (data to be encrypted) + rest
+ *            
+ *  len     : length of data to be encrypted
+ *  auth_src: pointer the data to be authenticated. Should point at the same buffer as src.
+ *  src     : pointer to the data to be encrypted.
+ *  dst     : This is mandatory to be the same as src (in-place only).
+ *  tag_size: the size of the desired authentication tag or zero to use
+ *            the default mac output.
+ *  tag     : Pointer to an address where the authentication tag will be copied.
+ */
+
+
+/* struct crypt_op flags */
+
+#define COP_FLAG_NONE		(0 << 0) /* totally no flag */
+#define COP_FLAG_UPDATE		(1 << 0) /* multi-update hash mode */
+#define COP_FLAG_FINAL		(1 << 1) /* multi-update final hash mode */
+#define COP_FLAG_WRITE_IV	(1 << 2) /* update the IV during operation */
+#define COP_FLAG_NO_ZC		(1 << 3) /* do not zero-copy */
+#define COP_FLAG_AEAD_TLS_TYPE  (1 << 4) /* authenticate and encrypt using the 
+                                          * TLS protocol rules */
+#define COP_FLAG_AEAD_SRTP_TYPE  (1 << 5) /* authenticate and encrypt using the 
+                                           * SRTP protocol rules */
+#define COP_FLAG_RESET		(1 << 6) /* multi-update reset the state.
+                                          * should be used in combination
+                                          * with COP_FLAG_UPDATE */
+
+
+/* Stuff for bignum arithmetic and public key
+ * cryptography - not supported yet by linux
+ * cryptodev.
+ */
+
+#define	CRYPTO_ALG_FLAG_SUPPORTED	1
+#define	CRYPTO_ALG_FLAG_RNG_ENABLE	2
+#define	CRYPTO_ALG_FLAG_DSA_SHA		4
+
+struct crparam {
+	__u8	*crp_p;
+	__u32	crp_nbits;
+};
+
+#define CRK_MAXPARAM	8
+
+/* struct crypt_kop crk_flags */
+#define KCOP_FLAG_NONE					(0 << 0) /* totally no flag */
+#define KCOP_FLAG_INTEGER_ARITH			(1 << 0) /* ECC prime  field */
+#define KCOP_FLAG_F2M_ARITH				(1 << 1) /* ECC binary field */
+#define KCOP_FLAG_R2INPUT				(1 << 2) /* Indicates whether the term (R2 mod N) be supplied as an input */
+#define KCOP_FLAG_MONTGOMERY_FORMAT		(1 << 3) /* Montgomery format */
+#define KCOP_FLAG_TIMING_EQUALIZATION	(1 << 4) /* Timing equalization */
+#define KCOP_FLAG_MP_CSEL_P256			(1 << 5) /* Curve Select : P256 */
+#define KCOP_FLAG_MP_CSEL_P384			(1 << 6) /* Curve Select : P384 */
+#define KCOP_FLAG_MP_CSEL_P521			(1 << 7) /* Curve Select : P521 */
+
+/* input of CIOCKEY */
+struct crypt_kop {
+	__u32	ses;		/* session identifier */
+	__u32	crk_op;		/* cryptodev_crk_op_t */
+	__u32	crk_flags;  /* public key cipher operation flags */
+	__u32	crk_status;
+	__u16	crk_iparams;
+	__u16	crk_oparams;
+	__u32	crk_pad1;
+	struct crparam	crk_param[CRK_MAXPARAM];
+};
+
+enum cryptodev_crk_op_t {
+	CRK_MOD_EXP = 0,
+	CRK_MOD_EXP_CRT = 1,
+	CRK_MOD_ADD = 2,
+	CRK_MOD_SUB1 = 3,
+	CRK_MOD_SUB2 = 4,
+	CRK_MOD_MUL = 5,
+	CRK_MOD_RED = 6,
+	CRK_MOD_INV = 7,
+	CRK_GCD = 8,
+	CRK_PRIMALITY_TEST = 9,
+	CRK_MOD_R2 = 10,
+	CRK_CLEAR_MEM = 11,
+	CRK_COPY_MEM = 12,
+	CRK_ECC_ADD = 13,	
+	CRK_ECC_DOUBLE = 14,
+	CRK_ECC_MUL = 15,
+	CRK_ECC_MUL_IS_INFINITY = 16,
+	CRK_ECC_CHECK_POINT = 17,
+	CRK_DSA_SIGN = 18,
+	CRK_DSA_VERIFY = 19,
+	CRK_ECDSA_SIGN = 20,
+	CRK_ECDSA_VERIFY = 21,
+	CRK_DH_COMPUTE_KEY = 22,
+	CRK_ECDH_COMPUTE_KEY = 23,
+	CRK_DH_GENERATE_KEY = 24,
+	CRK_ECDH_GENERATE_KEY = 25,
+	CRK_RSA_PUBLIC = 26,
+	CRK_RSA_PRIVATE = 27,
+	CRK_RSA_GENERATE_KEY = 28,
+	CRK_MP_SIGN = 29,
+	CRK_MP_GET_PUBK = 30,
+	CRK_CV2X_VERIFY = 31,
+	CRK_ALGORITHM_ALL
+};
+
+#define CRK_ALGORITHM_MAX	(CRK_ALGORITHM_ALL-1)
+
+/* features to be queried with CIOCASYMFEAT ioctl
+ */
+#define CRF_MOD_EXP				(1 << CRK_MOD_EXP)
+#define CRF_MOD_EXP_CRT			(1 << CRK_MOD_EXP_CRT)
+#define CRF_MOD_ADD    			(1 << CRK_MOD_ADD)
+#define CRF_MOD_SUB1    		(1 << CRK_MOD_SUB1)
+#define CRF_MOD_SUB2    		(1 << CRK_MOD_SUB2)
+#define CRF_MOD_MUL     		(1 << CRK_MOD_MUL)
+#define CRF_MOD_RED     		(1 << CRK_MOD_RED)
+#define CRF_MOD_INV   			(1 << CRK_MOD_INV)
+#define CRF_GCD             	(1 << CRK_GCD)
+#define CRF_PRIMALITY_TEST  	(1 << CRK_PRIMALITY_TEST)
+#define CRF_MOD_R2          	(1 << CRK_MOD_R2)
+#define CRF_CLEAR_MEM  			(1 << CRK_CLEAR_MEM)
+#define CRF_COPY_MEM   			(1 << CRK_COPY_MEM)
+#define CRF_ECC_ADD      		(1 << CRK_ECC_ADD)
+#define CRF_ECC_DOUBLE    		(1 << CRK_ECC_DOUBLE)
+#define CRF_ECC_MUL         	(1 << CRK_ECC_MUL)
+#define CRF_ECC_MUL_IS_INFINITY	(1 << CRK_ECC_MUL_IS_INFINITY)
+#define CRF_ECC_CHECK_POINT    	(1 << CRK_ECC_CHECK_POINT)
+#define CRF_DSA_SIGN			(1 << CRK_DSA_SIGN)
+#define CRF_DSA_VERIFY			(1 << CRK_DSA_VERIFY)
+#define CRF_ECDSA_SIGN			(1 << CRK_ECDSA_SIGN)
+#define CRF_ECDSA_VERIFY		(1 << CRK_ECDSA_VERIFY)
+#define CRF_DH_COMPUTE_KEY		(1 << CRK_DH_COMPUTE_KEY)
+#define CRF_ECDH_COMPUTE_KEY	(1 << CRK_ECDH_COMPUTE_KEY)
+#define CRF_DH_GENERATE_KEY		(1 << CRK_DH_GENERATE_KEY)
+#define CRF_ECDH_GENERATE_KEY 	(1 << CRK_ECDH_GENERATE_KEY)
+#define CRF_RSA_PUBLIC			(1 << CRK_RSA_PUBLIC)
+#define CRF_RSA_PRIVATE			(1 << CRK_RSA_PRIVATE)
+#define CRF_RSA_GENERATE_KEY	(1 << CRK_RSA_GENERATE_KEY)
+#define CRF_MP_SIGN				(1 << CRK_MP_SIGN)
+#define CRF_MP_GET_PUBK			(1 << CRK_MP_GET_PUBK)
+#define CRF_CV2X_VERIFY			(1 << CRK_CV2X_VERIFY)
+
+
+/* ioctl's. Compatible with old linux cryptodev.h
+ */
+#define CRIOGET         _IOWR('c', 101, __u32)
+#define CIOCGSESSION    _IOWR('c', 102, struct session_op)
+#define CIOCFSESSION    _IOW('c', 103, __u32)
+#define CIOCCRYPT       _IOWR('c', 104, struct crypt_op)
+#define CIOCKEY         _IOWR('c', 105, struct crypt_kop)
+#define CIOCASYMFEAT    _IOR('c', 106, __u32)
+#define CIOCGSESSINFO	_IOWR('c', 107, struct session_info_op)
+
+/* to indicate that CRIOGET is not required in linux
+ */
+#define CRIOGET_NOT_NEEDED 1
+
+/* additional ioctls for AEAD */
+#define CIOCAUTHCRYPT   _IOWR('c', 109, struct crypt_auth_op)
+
+/* additional ioctls for asynchronous operation.
+ * These are conditionally enabled since version 1.6.
+ */
+#define CIOCASYNCCRYPT    _IOW('c', 110, struct crypt_op)
+#define CIOCASYNCFETCH    _IOR('c', 111, struct crypt_op)
+
+#endif /* L_CRYPTODEV_H */
diff -uprN gmssl-1.0/include/openssl/ec.h GmSSL-2.5.0_iMX/include/openssl/ec.h
--- gmssl-1.0/include/openssl/ec.h	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/include/openssl/ec.h	2020-11-09 10:59:49.719907221 +0800
@@ -379,6 +379,14 @@ EC_GROUP *EC_GROUP_new_from_ecpkparamete
 ECPKPARAMETERS *EC_GROUP_get_ecpkparameters(const EC_GROUP *group,
                                             ECPKPARAMETERS *params);
 
+#ifdef HAVE_CRYPTODEV
+#define EC_PROJECTIVE_COORDINATES	0x10000001
+#define EC_AFFINE_COORDINATES		0x10000002
+int EC_GROUP_set_coordinates(int coordinate);
+void EC_GROUP_restore_coordinates(int coordinate);
+int EC_GROUP_get_coordinates(const EC_GROUP *group);
+#endif
+
 /********************************************************************/
 /*               handling of internal curves                        */
 /********************************************************************/
diff -uprN gmssl-1.0/include/openssl/sm2.h GmSSL-2.5.0_iMX/include/openssl/sm2.h
--- gmssl-1.0/include/openssl/sm2.h	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/include/openssl/sm2.h	2020-11-09 10:59:49.719907221 +0800
@@ -106,6 +106,10 @@ int SM2_sign(int type, const unsigned ch
 	unsigned char *sig, unsigned int *siglen, EC_KEY *eckey);
 int SM2_verify(int type, const unsigned char *dgst, int dgstlen,
 	const unsigned char *sig, int siglen, EC_KEY *ec_key);
+int SM2_sw_verify(int type, const unsigned char *dgst, int dgstlen,
+	const unsigned char *sig, int siglen, EC_KEY *ec_key);
+int SM2_sw_sign(int type, const unsigned char *dgst, int dgstlen,
+	unsigned char *sig, unsigned int *siglen, EC_KEY *ec_key);
 
 /* SM2 Public Key Encryption */
 
diff -uprN gmssl-1.0/test/build.info GmSSL-2.5.0_iMX/test/build.info
--- gmssl-1.0/test/build.info	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/test/build.info	2020-11-09 10:59:49.719907221 +0800
@@ -21,7 +21,7 @@ IF[{- !$disabled{tests} -}]
           pailliertest cpktest otptest gmapitest ec2test \
           bfibetest bb1ibetest sm9test \
           saftest sdftest skftest softest zuctest \
-          serpenttest specktest base58test ecrstest
+          serpenttest specktest base58test ecrstest cv2x_benchmark
 
   SOURCE[aborttest]=aborttest.c
   INCLUDE[aborttest]=../include
@@ -380,6 +380,10 @@ IF[{- !$disabled{tests} -}]
   INCLUDE[ecrstest]=../include
   DEPEND[ecrstest]=../libcrypto
 
+  SOURCE[cv2x_benchmark]=cv2x_benchmark.c
+  INCLUDE[cv2x_benchmark]=../include ../crypto/include
+  DEPEND[cv2x_benchmark]=../libcrypto
+
   IF[{- !$disabled{shared} -}]
     PROGRAMS_NO_INST=shlibloadtest
     SOURCE[shlibloadtest]=shlibloadtest.c
diff -uprN gmssl-1.0/test/cv2x_benchmark.c GmSSL-2.5.0_iMX/test/cv2x_benchmark.c
--- gmssl-1.0/test/cv2x_benchmark.c	1970-01-01 08:00:00.000000000 +0800
+++ GmSSL-2.5.0_iMX/test/cv2x_benchmark.c	2020-11-09 10:59:49.719907221 +0800
@@ -0,0 +1,1592 @@
+/* ====================================================================
+ * Copyright (c) 2014 - 2016 The GmSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the GmSSL Project.
+ *    (http://gmssl.org/)"
+ *
+ * 4. The name "GmSSL Project" must not be used to endorse or promote
+ *    products derived from this software without prior written
+ *    permission. For written permission, please contact
+ *    guanzhi1980@gmail.com.
+ *
+ * 5. Products derived from this software may not be called "GmSSL"
+ *    nor may "GmSSL" appear in their names without prior written
+ *    permission of the GmSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the GmSSL Project
+ *    (http://gmssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE GmSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE GmSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "../e_os.h"
+#ifndef HAVE_CRYPTODEV
+int main(int argc, char **argv)
+{
+	printf("NO cryptodev support\n");
+	return 0;
+}
+#else
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <openssl/objects.h>
+#include <openssl/bn.h>
+#include <openssl/crypto.h>
+
+# include <openssl/cryptodev.h>
+# include <openssl/bn.h>
+# include <openssl/ec.h>
+# include <openssl/evp.h>
+# include <openssl/rand.h>
+# include <openssl/engine.h>
+# include <openssl/sm2.h>
+# include <openssl/crypto.h>
+# include <openssl/bio.h>
+# include <openssl/err.h>
+
+# include "../crypto/sm2/sm2_lcl.h"
+# include "../crypto/ec/ec_lcl.h"
+# include "../crypto/bn/bn_lcl.h"
+
+//#define CV2X_VERBOSE
+#define MESSAGE_NUM 5000
+
+enum verify_component {
+	SW_COMPONENT = 1,	
+	HW_COMPONENT,
+};
+#define L_LEN 32
+#define N_LEN 32
+#define MSG_LEN 32
+typedef	unsigned char	bool;
+enum {
+	false	= 0,
+	true	= 1
+};
+
+typedef struct {	
+    EC_KEY *ec_key;	
+    unsigned char digest[MSG_LEN];
+    unsigned char *signature;
+    unsigned int sig_len;
+    unsigned char r[L_LEN];
+    unsigned char s[L_LEN];
+    unsigned char Wx[L_LEN];
+    unsigned char Wy[L_LEN];
+    bool result;
+    enum verify_component component;	
+} _cv2x_data;
+
+typedef struct node {
+    _cv2x_data message_data;
+    struct node* next;
+} _cv2x_node;
+
+
+typedef struct queue_node_t {
+    _cv2x_data *message_data;
+    struct queue_node_t *prev;
+} queue_node;
+
+
+typedef struct {
+    pthread_mutex_t lock;            
+    queue_node *head;
+    queue_node *tail;
+    int size;
+    int limit;
+    int cfd;
+    int nid;
+    struct session_op sess;
+}  cv2x_message_queue;
+
+static pthread_t hw_thread;
+static pthread_t sw_thread;
+
+static _cv2x_node* add(_cv2x_node* node) {
+	_cv2x_node* temp = (_cv2x_node*) OPENSSL_malloc(sizeof (_cv2x_node));
+	if (NULL == temp) {
+		return NULL;
+	}
+	temp->next = node;
+	node = temp;
+	return node;
+}
+
+
+
+
+static _cv2x_node *free_list(_cv2x_node *head) {
+	_cv2x_node *tmpPtr = head;
+	_cv2x_node *followPtr;
+	while (tmpPtr != NULL) {
+		followPtr = tmpPtr;
+		tmpPtr = tmpPtr->next;
+		OPENSSL_free(followPtr);
+	}
+	return NULL;
+}
+
+
+static bool Enqueue(cv2x_message_queue *pQueue, queue_node *item) {
+    /* Bad parameter */
+    if ((pQueue == NULL) || (item == NULL))
+        return false;
+
+    /*the queue is empty*/
+    item->prev = NULL;
+    if (pQueue->size == 0) {
+        pQueue->head = item;
+        pQueue->tail = item;
+
+    } 
+    else {
+        /*adding item to the end of the queue*/
+        pQueue->tail->prev = item;
+        pQueue->tail = item;
+    }
+    pQueue->size++;
+    return true;
+}
+
+static bool queue_is_empty(cv2x_message_queue *pQueue) {
+    if (pQueue == NULL) 
+        return false;
+
+    if (pQueue->size == 0)
+        return true;
+    else 
+        return false;
+}
+
+static queue_node * Dequeue(cv2x_message_queue *pQueue) {
+	/*the queue is empty or bad param*/
+    queue_node *item;
+    if (true == queue_is_empty(pQueue))
+        return NULL;
+    item = pQueue->head;
+    pQueue->head = (pQueue->head)->prev;
+    pQueue->size--;
+    return item;
+}
+
+static void destruct_queue(cv2x_message_queue *queue) {
+    queue_node *pN;
+    while (false == queue_is_empty(queue)) {
+        pN = Dequeue(queue);
+        OPENSSL_free(pN);
+    }
+    OPENSSL_free(queue);
+}
+
+
+
+static cv2x_message_queue *construct_queue(int fd) {
+    cv2x_message_queue *queue = (cv2x_message_queue*) OPENSSL_malloc(sizeof (cv2x_message_queue));
+    if (queue == NULL) {
+        return NULL;
+    }
+
+    queue->size = 0;
+    queue->head = NULL;
+    queue->tail = NULL;
+
+    pthread_mutex_init(&(queue->lock), NULL);
+    queue->cfd = fd;
+
+    return queue;
+}
+
+static void cv2x_verify_task(cv2x_message_queue* pQ)
+{
+    queue_node *pN = NULL;
+    _cv2x_data *data = NULL;
+    struct crypt_kop kop;
+    int i = 0;
+
+    pthread_t thisth = pthread_self();
+
+    if (thisth == hw_thread) {
+        memset(&kop, 0, sizeof(kop));
+        kop.ses = pQ->sess.ses;
+        kop.crk_op = CRK_CV2X_VERIFY;
+
+        if (NID_sm2p256v1 != pQ->nid) {
+            kop.crk_param[0].crp_p = OPENSSL_malloc(L_LEN*2);
+            if (NULL == kop.crk_param[0].crp_p) {
+                printf("\n Function:%s Line %d No memory available!\r\n",__func__,__LINE__);
+                return;
+            }
+            memset(kop.crk_param[0].crp_p, 0, L_LEN*2);
+            kop.crk_param[0].crp_nbits = L_LEN * 16;
+
+            kop.crk_param[1].crp_p = OPENSSL_malloc(N_LEN);
+            if (NULL == kop.crk_param[1].crp_p) {
+                printf("\n Function:%s Line %d No memory available!\r\n",__func__,__LINE__);
+                return;
+            }
+            memset(kop.crk_param[1].crp_p, 0, N_LEN);
+            kop.crk_param[1].crp_nbits = N_LEN * 8;
+
+            kop.crk_param[2].crp_p = OPENSSL_malloc(N_LEN);
+            if (NULL == kop.crk_param[2].crp_p) {
+                printf("\n Function:%s Line %d No memory available!\r\n",__func__,__LINE__);
+                return;
+            }
+            memset(kop.crk_param[2].crp_p, 0, N_LEN);
+            kop.crk_param[2].crp_nbits = N_LEN * 8;
+
+            kop.crk_param[3].crp_p = OPENSSL_malloc(N_LEN);
+            if (NULL == kop.crk_param[3].crp_p) {
+                printf("\n Function:%s Line %d No memory available!\r\n",__func__,__LINE__);
+                return;
+            }
+            memset(kop.crk_param[3].crp_p, 0, N_LEN);
+            kop.crk_param[3].crp_nbits = N_LEN * 8;
+
+            kop.crk_iparams = 4;
+        }
+        else {
+            kop.crk_param[0].crp_p = OPENSSL_malloc(L_LEN);
+            if (NULL == kop.crk_param[0].crp_p) {
+                printf("\n Function:%s Line %d No memory available!\r\n",__func__,__LINE__);
+                return;
+            }
+            memset(kop.crk_param[0].crp_p, 0, L_LEN);
+            kop.crk_param[0].crp_nbits = L_LEN * 8;
+
+            kop.crk_param[1].crp_p = OPENSSL_malloc(L_LEN);
+            if (NULL == kop.crk_param[1].crp_p) {
+                printf("\n Function:%s Line %d No memory available!\r\n",__func__,__LINE__);
+                return;
+            }
+            memset(kop.crk_param[1].crp_p, 0, L_LEN);
+            kop.crk_param[1].crp_nbits = L_LEN * 8;
+
+            kop.crk_param[2].crp_p = OPENSSL_malloc(L_LEN);
+            if (NULL == kop.crk_param[2].crp_p) {
+                printf("\n Function:%s Line %d No memory available!\r\n",__func__,__LINE__);
+                return;
+            }
+            memset(kop.crk_param[2].crp_p, 0, L_LEN);
+            kop.crk_param[2].crp_nbits = L_LEN * 8;
+
+            kop.crk_param[3].crp_p = OPENSSL_malloc(L_LEN);
+            if (NULL == kop.crk_param[3].crp_p) {
+                printf("\n Function:%s Line %d No memory available!\r\n",__func__,__LINE__);
+                return;
+            }
+            memset(kop.crk_param[3].crp_p, 0, L_LEN);
+            kop.crk_param[3].crp_nbits = L_LEN * 8;
+
+            
+            kop.crk_param[4].crp_p = OPENSSL_malloc(L_LEN);
+            if (NULL == kop.crk_param[3].crp_p) {
+                printf("\n Function:%s Line %d No memory available!\r\n",__func__,__LINE__);
+                return;
+            }
+            memset(kop.crk_param[4].crp_p, 0, L_LEN);
+            kop.crk_param[4].crp_nbits = L_LEN * 8;
+
+            kop.crk_iparams = 5;
+
+        }
+    }
+	
+	while(1) {
+		
+		pthread_mutex_lock(&pQ->lock);
+		if(queue_is_empty(pQ))
+		{
+			pthread_mutex_unlock(&pQ->lock);
+			return; 
+		}
+		pN = Dequeue(pQ);
+		pthread_mutex_unlock(&pQ->lock);
+		
+		if(!pN)
+    		return;
+		
+		data = pN->message_data;
+		
+		if(thisth == sw_thread) {
+			/* verify signature */
+            if (NID_sm2p256v1 != pQ->nid) {
+                if (ECDSA_verify(0, data->digest, MSG_LEN, data->signature, data->sig_len, data->ec_key) != 1)
+                    data->result = false;
+                else
+                    data->result = true;
+            }
+            else {                
+                if (SM2_sw_verify(NID_undef, data->digest, MSG_LEN, data->signature, data->sig_len, data->ec_key) != 1)
+                    data->result = false;
+                else
+                    data->result = true;
+            }
+		}
+        else if(thisth == hw_thread) {
+            /* verify signature */
+            kop.crk_status = 0;
+            if (NID_sm2p256v1 != pQ->nid) {
+                memcpy(kop.crk_param[0].crp_p, data->Wx, L_LEN);
+                memcpy(kop.crk_param[0].crp_p + L_LEN, data->Wy, L_LEN);
+                memcpy(kop.crk_param[1].crp_p, data->digest, N_LEN);
+                memcpy(kop.crk_param[2].crp_p, data->r, N_LEN);
+                memcpy(kop.crk_param[3].crp_p, data->s, N_LEN);
+                if (0 == ioctl(pQ->cfd, CIOCKEY, &kop) && 1 == kop.crk_status)
+                    data->result = true;
+                else
+                    data->result = false;
+            }
+            else {
+                memcpy(kop.crk_param[0].crp_p, data->Wx, L_LEN);
+                memcpy(kop.crk_param[1].crp_p, data->Wy, L_LEN);
+                memcpy(kop.crk_param[2].crp_p, data->digest, N_LEN);
+                memcpy(kop.crk_param[3].crp_p, data->r, N_LEN);
+                memcpy(kop.crk_param[4].crp_p, data->s, N_LEN);
+                if (0 == ioctl(pQ->cfd, CIOCKEY, &kop) && 1 == kop.crk_status)
+                    data->result = true;
+                else
+                    data->result = false;
+            }
+		}
+		
+	}
+    if (thisth == hw_thread) {
+        for (i = 0; i < kop.crk_iparams; i++) {
+            OPENSSL_free(kop.crk_param[i].crp_p);
+        }
+    }
+}
+static int cv2x_bn2buffer(const BIGNUM *a, unsigned char *b, int bytes)
+{
+    int i, j, k;
+    if (b == NULL)
+        return (1);
+
+    for (i = 0, j = 0; i < a->top; i++) {
+        for (k = 0; k < BN_BITS2 / 8; k++) {
+            if ((j + k) >= bytes)
+                return (0);
+            b[j + k] = a->d[i] >> (k * 8);
+        }
+        j += BN_BITS2 / 8;
+    }
+    return (0);
+}
+
+static inline int cv2x_int_swap(unsigned char *A, unsigned short sizeA)
+{
+	int i;
+	unsigned char *p;
+	
+	p = (unsigned char *)OPENSSL_malloc(sizeA);
+	
+	if (!p)
+		return -1;
+
+	memcpy(p, A, sizeA);
+
+	for(i = 0; i < sizeA; i++)
+		A[i] = p[sizeA - 1 - i];
+
+	OPENSSL_free(p);
+
+	return 0;
+}
+
+int cv2x_BPp256r1(int cfd, BN_CTX *ctx, BIO *out)
+{
+    EC_GROUP *group = NULL;    
+    int ret = 0, i = 0, cv2x_verify_fail = 0;
+    int orig_coordinate = 0;
+    ECDSA_SIG *ecdsa_sig = NULL;
+    const unsigned char *sig_ptr = NULL;
+    const BIGNUM *sig_r, *sig_s;
+    BIGNUM *x_ec_key = NULL, *y_ec_key = NULL;
+    _cv2x_data *cv2x_BPp256r1_message[MESSAGE_NUM] = {0};
+    struct timeval starttime, endtime;
+    double timeuse;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    static cv2x_message_queue *pQ = NULL;
+    static _cv2x_node *head = NULL;
+    _cv2x_node *temp = NULL;
+    queue_node *pN = NULL; 
+    
+    orig_coordinate = EC_GROUP_set_coordinates(EC_PROJECTIVE_COORDINATES);
+    group = EC_GROUP_new_by_curve_name(NID_brainpoolP256r1);
+    EC_GROUP_restore_coordinates(orig_coordinate);
+    if (group == NULL)
+        goto BPp256r1_err;
+    if ((x_ec_key = BN_new()) == NULL)
+        goto BPp256r1_err;
+    if ((y_ec_key = BN_new()) == NULL)
+        goto BPp256r1_err;
+
+/*+++++++++++++++++++++++ Using SW engine to verify C-V2X message ++++++++++++++++++++++++++*/    
+    BIO_printf(out, "\n C-V2X BPp256r1 benchmark pre-start: sign message \n\n ");
+    (void)BIO_flush(out);
+    for (i = 0; i < MESSAGE_NUM; i++) {
+        if ((cv2x_BPp256r1_message[i] = OPENSSL_malloc(sizeof(_cv2x_data))) == NULL) {
+            BIO_printf(out, "No memory available");
+            goto BPp256r1_err;
+        }
+        memset(cv2x_BPp256r1_message[i], 0, sizeof(_cv2x_data));
+        if (RAND_bytes(cv2x_BPp256r1_message[i]->digest, MSG_LEN) <= 0) {
+            BIO_printf(out, "ERROR: unable to get random data in cv2x_BPp256r1()\n");
+            goto BPp256r1_err;
+        }
+        /* create new ecdsa key (== EC_KEY) */
+        if ((cv2x_BPp256r1_message[i]->ec_key = EC_KEY_new()) == NULL) {
+            BIO_printf(out, "fail to create new key in cv2x_BPp256r1()\n");
+            goto BPp256r1_err;
+        }
+        if (EC_KEY_set_group(cv2x_BPp256r1_message[i]->ec_key, group) == 0) {
+            BIO_printf(out, "fail to set group for new key in cv2x_BPp256r1()\n");
+            goto BPp256r1_err;
+        }
+        /* create key */
+        if (!EC_KEY_generate_key(cv2x_BPp256r1_message[i]->ec_key)) {
+            BIO_printf(out, "generate key failed in cv2x_BPp256r1()\n");
+            goto BPp256r1_err;
+        }
+        (void)BIO_flush(out);
+        /* check key */
+        if (!EC_KEY_check_key(cv2x_BPp256r1_message[i]->ec_key)) {
+            BIO_printf(out, "check key failed in cv2x_BPp256r1()\n");
+            goto BPp256r1_err;
+        }
+        /* create signature */
+        cv2x_BPp256r1_message[i]->sig_len = ECDSA_size(cv2x_BPp256r1_message[i]->ec_key);
+        if ((cv2x_BPp256r1_message[i]->signature = OPENSSL_malloc(cv2x_BPp256r1_message[i]->sig_len)) == NULL) {
+            BIO_printf(out, "No memory available");
+            goto BPp256r1_err;
+        }
+        if (!ECDSA_sign(NID_undef, cv2x_BPp256r1_message[i]->digest, MSG_LEN, cv2x_BPp256r1_message[i]->signature, &cv2x_BPp256r1_message[i]->sig_len, cv2x_BPp256r1_message[i]->ec_key)) {
+            BIO_printf(out, "sign failed in cv2x_BPp256r1()\n");
+            goto BPp256r1_err;
+        }
+        (void)BIO_flush(out);
+        sig_ptr = cv2x_BPp256r1_message[i]->signature;
+        if ((ecdsa_sig = d2i_ECDSA_SIG(NULL, &sig_ptr, cv2x_BPp256r1_message[i]->sig_len)) == NULL) {
+            BIO_printf(out, " failed\n");
+            goto BPp256r1_err;
+        }
+
+        ECDSA_SIG_get0(ecdsa_sig, &sig_r, &sig_s);
+        cv2x_bn2buffer(sig_r, cv2x_BPp256r1_message[i]->r, L_LEN);
+        cv2x_int_swap(cv2x_BPp256r1_message[i]->r, L_LEN);
+        cv2x_bn2buffer(sig_s, cv2x_BPp256r1_message[i]->s, L_LEN);
+        cv2x_int_swap(cv2x_BPp256r1_message[i]->s, L_LEN);
+        if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field) {
+            if (!EC_POINT_get_affine_coordinates_GFp
+                (group, EC_KEY_get0_public_key(cv2x_BPp256r1_message[i]->ec_key), x_ec_key, y_ec_key, ctx))
+                goto BPp256r1_err;
+        }
+        cv2x_bn2buffer(x_ec_key, cv2x_BPp256r1_message[i]->Wx, L_LEN);
+        cv2x_int_swap(cv2x_BPp256r1_message[i]->Wx, L_LEN);
+        cv2x_bn2buffer(y_ec_key, cv2x_BPp256r1_message[i]->Wy, L_LEN);
+        cv2x_int_swap(cv2x_BPp256r1_message[i]->Wy, L_LEN);
+#ifdef CV2X_VERBOSE
+        BIO_printf(out, "\n private key: ");
+        BN_print(out, EC_KEY_get0_private_key(cv2x_BPp256r1_message[i]->ec_key));
+        BIO_printf(out, "\n");
+        BIO_printf(out, "public key (x,y): ");
+        BN_print(out, x_ec_key);
+        BIO_printf(out, ",");
+        BN_print(out, y_ec_key);
+        BIO_printf(out, "\n");
+        BIO_printf(out, "signature (r,s): ");
+        BN_print(out, sig_r);
+        BIO_printf(out, ",");
+        BN_print(out, sig_s);
+        BIO_printf(out, "\n");
+#endif
+        
+        (void)BIO_flush(out);
+        ECDSA_SIG_free(ecdsa_sig);
+        ecdsa_sig = NULL;
+    }
+    BIO_printf(out, "\n C-V2X BPp256r1 SW verify benchmark: ");
+    (void)BIO_flush(out);
+    gettimeofday(&starttime, NULL);
+    for (i = 0; i < MESSAGE_NUM; i++) {
+        /* verify signature */
+        if (ECDSA_verify(0, cv2x_BPp256r1_message[i]->digest, MSG_LEN, cv2x_BPp256r1_message[i]->signature, cv2x_BPp256r1_message[i]->sig_len, cv2x_BPp256r1_message[i]->ec_key) != 1) {
+            cv2x_BPp256r1_message[i]->result = false;
+            cv2x_verify_fail++;
+        }
+        else
+            cv2x_BPp256r1_message[i]->result = true;
+    }
+    gettimeofday(&endtime, NULL);
+	timeuse = (double)(endtime.tv_sec - starttime.tv_sec) + (double)((endtime.tv_usec - starttime.tv_usec) / 1000000);
+    BIO_printf(out, "\n C-V2X BPp256r1 SW verify benchmark: %d messages took %f second", MESSAGE_NUM, timeuse);
+    BIO_printf(out, "\n C-V2X BPp256r1 SW verify benchmark: Average %.2f verification/second with verification failures: %d ", (double)MESSAGE_NUM/timeuse, cv2x_verify_fail);
+    (void)BIO_flush(out);
+
+    cv2x_verify_fail = 0;
+
+/*+++++++++++++++++++++++ Using cryptodev engine (by CAAM) to verify C-V2X message ++++++++++++++++++++++++++*/ 
+    BIO_printf(out, "\n\n\n C-V2X BPp256r1 HW verify benchmark: ");
+    (void)BIO_flush(out);
+
+    memset(&sess, 0, sizeof(sess));	
+
+	sess.pk_cipher = CRYPTO_CV2X_BP_P256R1_VERIFY;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		 BIO_printf(out, "ioctl(CIOCGSESSION) failed");
+		goto BPp256r1_err;
+	}
+    memset(&kop, 0, sizeof(kop));
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_CV2X_VERIFY;
+
+    kop.crk_param[0].crp_p = OPENSSL_malloc(L_LEN*2);
+    if (NULL == kop.crk_param[0].crp_p) {
+        BIO_printf(out, "No memory available");
+        goto BPp256r1_err;
+    }
+    memset(kop.crk_param[0].crp_p, 0, L_LEN*2);
+    kop.crk_param[0].crp_nbits = L_LEN * 16;
+
+    kop.crk_param[1].crp_p = OPENSSL_malloc(N_LEN);
+    if (NULL == kop.crk_param[1].crp_p) {
+        BIO_printf(out, "No memory available");
+        goto BPp256r1_err;
+    }
+    memset(kop.crk_param[1].crp_p, 0, N_LEN);
+    kop.crk_param[1].crp_nbits = N_LEN * 8;
+
+    kop.crk_param[2].crp_p = OPENSSL_malloc(N_LEN);
+    if (NULL == kop.crk_param[2].crp_p) {
+        BIO_printf(out, "No memory available");
+        goto BPp256r1_err;
+    }
+    memset(kop.crk_param[2].crp_p, 0, N_LEN);
+    kop.crk_param[2].crp_nbits = N_LEN * 8;
+
+    kop.crk_param[3].crp_p = OPENSSL_malloc(N_LEN);
+    if (NULL == kop.crk_param[3].crp_p) {
+        BIO_printf(out, "No memory available");
+        goto BPp256r1_err;
+    }
+    memset(kop.crk_param[3].crp_p, 0, N_LEN);
+    kop.crk_param[3].crp_nbits = N_LEN * 8;
+
+    kop.crk_iparams = 4;
+    gettimeofday(&starttime, NULL);
+    for (i = 0; i < MESSAGE_NUM; i++) {
+        /* verify signature */
+        kop.crk_status = 0;
+        memcpy(kop.crk_param[0].crp_p, cv2x_BPp256r1_message[i]->Wx, L_LEN);
+        memcpy(kop.crk_param[0].crp_p + L_LEN, cv2x_BPp256r1_message[i]->Wy, L_LEN);
+        memcpy(kop.crk_param[1].crp_p, cv2x_BPp256r1_message[i]->digest, N_LEN);
+        memcpy(kop.crk_param[2].crp_p, cv2x_BPp256r1_message[i]->r, N_LEN);
+        memcpy(kop.crk_param[3].crp_p, cv2x_BPp256r1_message[i]->s, N_LEN);
+        if (0 == ioctl(cfd, CIOCKEY, &kop) && 1 == kop.crk_status) 
+            cv2x_BPp256r1_message[i]->result = true;
+        else {
+            cv2x_BPp256r1_message[i]->result = false;
+            cv2x_verify_fail++;
+        }
+    }
+    gettimeofday(&endtime, NULL);
+	timeuse = (double)(endtime.tv_sec - starttime.tv_sec) + (double)((endtime.tv_usec - starttime.tv_usec) / 1000000);
+    BIO_printf(out, "\n C-V2X BPp256r1 HW verify benchmark: %d messages took %f second", MESSAGE_NUM, timeuse);
+    BIO_printf(out, "\n C-V2X BPp256r1 HW verify benchmark: Average %.2f verification/second with verification failures: %d ", (double)MESSAGE_NUM/timeuse, cv2x_verify_fail);
+    (void)BIO_flush(out);
+
+    for (i = 0; i < kop.crk_iparams; i++) {
+        OPENSSL_free(kop.crk_param[i].crp_p);
+    }
+    cv2x_verify_fail = 0;
+
+/*+++++++++++++++++++++++ Using SW + Cryptodev engine to verify C-V2X message ++++++++++++++++++++++++++*/ 
+
+    BIO_printf(out, "\n\n\n C-V2X BPp256r1 HW+SW verify benchmark: ");
+    (void)BIO_flush(out);
+
+    pQ = construct_queue(cfd);
+    memcpy(&(pQ->sess), &sess, sizeof(sess));
+    pQ->nid = NID_brainpoolP256r1;
+
+    for (i = 0; i < MESSAGE_NUM*2; i++) {        
+        if ((pN = OPENSSL_malloc(sizeof(queue_node))) == NULL) {
+            BIO_printf(out, "No memory available");
+            goto BPp256r1_err;
+        }
+        memset(pN, 0, sizeof(queue_node));
+        head = add(head);
+        if (NULL == head) {
+            BIO_printf(out, "No memory available");
+            goto BPp256r1_err;
+        }
+        pN->message_data = &(head->message_data);
+        if (RAND_bytes(pN->message_data->digest, MSG_LEN) <= 0) {
+            BIO_printf(out, "ERROR: unable to get random data in cv2x_BPp256r1()\n");
+            goto BPp256r1_err;
+        }
+        /* create new ecdsa key (== EC_KEY) */
+        if ((pN->message_data->ec_key = EC_KEY_new()) == NULL) {
+            BIO_printf(out, "fail to create new key in cv2x_BPp256r1()\n");
+            goto BPp256r1_err;
+        }
+        if (EC_KEY_set_group(pN->message_data->ec_key, group) == 0) {
+            BIO_printf(out, "fail to set group for new key in cv2x_BPp256r1()\n");
+            goto BPp256r1_err;
+        }
+        /* create key */
+        if (!EC_KEY_generate_key(pN->message_data->ec_key)) {
+            BIO_printf(out, "generate key failed in cv2x_BPp256r1()\n");
+            goto BPp256r1_err;
+        }
+        (void)BIO_flush(out);
+        /* check key */
+        if (!EC_KEY_check_key(pN->message_data->ec_key)) {
+            BIO_printf(out, "check key failed in cv2x_BPp256r1()\n");
+            goto BPp256r1_err;
+        }
+        /* create signature */
+        pN->message_data->sig_len = ECDSA_size(pN->message_data->ec_key);
+        if ((pN->message_data->signature = OPENSSL_malloc(pN->message_data->sig_len)) == NULL) {
+            BIO_printf(out, "No memory available");
+            goto BPp256r1_err;
+        }
+        if (!ECDSA_sign(NID_undef, pN->message_data->digest, MSG_LEN, pN->message_data->signature, &pN->message_data->sig_len, pN->message_data->ec_key)) {
+            BIO_printf(out, "sign failed in cv2x_BPp256r1()\n");
+            goto BPp256r1_err;
+        }
+        (void)BIO_flush(out);
+        sig_ptr = pN->message_data->signature;
+        if ((ecdsa_sig = d2i_ECDSA_SIG(NULL, &sig_ptr, pN->message_data->sig_len)) == NULL) {
+            BIO_printf(out, " failed\n");
+            goto BPp256r1_err;
+        }
+
+        ECDSA_SIG_get0(ecdsa_sig, &sig_r, &sig_s);
+        cv2x_bn2buffer(sig_r, pN->message_data->r, L_LEN);
+        cv2x_int_swap(pN->message_data->r, L_LEN);
+        cv2x_bn2buffer(sig_s, pN->message_data->s, L_LEN);
+        cv2x_int_swap(pN->message_data->s, L_LEN);
+        if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field) {
+            if (!EC_POINT_get_affine_coordinates_GFp
+                (group, EC_KEY_get0_public_key(pN->message_data->ec_key), x_ec_key, y_ec_key, ctx))
+                goto BPp256r1_err;
+        }
+        cv2x_bn2buffer(x_ec_key, pN->message_data->Wx, L_LEN);
+        cv2x_int_swap(pN->message_data->Wx, L_LEN);
+        cv2x_bn2buffer(y_ec_key, pN->message_data->Wy, L_LEN);
+        cv2x_int_swap(pN->message_data->Wy, L_LEN);
+#ifdef CV2X_VERBOSE
+        BIO_printf(out, "\n private key: ");
+        BN_print(out, EC_KEY_get0_private_key(pN->message_data->ec_key));
+        BIO_printf(out, "\n");
+        BIO_printf(out, "public key (x,y): ");
+        BN_print(out, x_ec_key);
+        BIO_printf(out, ",");
+        BN_print(out, y_ec_key);
+        BIO_printf(out, "\n");
+        BIO_printf(out, "signature (r,s): ");
+        BN_print(out, sig_r);
+        BIO_printf(out, ",");
+        BN_print(out, sig_s);
+        BIO_printf(out, "\n");
+#endif
+        
+        (void)BIO_flush(out);
+        ECDSA_SIG_free(ecdsa_sig);
+        ecdsa_sig = NULL;    
+        Enqueue(pQ, pN);
+    }
+    gettimeofday(&starttime, NULL);
+
+    if(pthread_create(&sw_thread, NULL, (void*)cv2x_verify_task, pQ)) {
+		BIO_printf(out, "Error creating sw_thread\n");
+		goto BPp256r1_err;
+	}
+
+	if(pthread_create(&hw_thread, NULL, (void*)cv2x_verify_task, pQ)) {
+		BIO_printf(out, "Error creating hw_thread\n");
+		goto BPp256r1_err;
+	}
+
+	if(pthread_join(hw_thread, NULL)) {
+		BIO_printf(out, "Error joining hw_thread\n");
+		goto BPp256r1_err;
+	}
+
+	if(pthread_join(sw_thread, NULL)) {
+		BIO_printf(out, "Error joining sw_thread\n");
+		goto BPp256r1_err;
+	}
+    
+    gettimeofday(&endtime, NULL);
+    for (temp = head; temp; temp = temp->next) {
+        if (false == temp->message_data.result)
+            cv2x_verify_fail++;
+    }
+	timeuse = (double)(endtime.tv_sec - starttime.tv_sec) + (double)((endtime.tv_usec - starttime.tv_usec) / 1000000);
+    BIO_printf(out, "\n C-V2X BPp256r1 HW+SW verify benchmark: %d messages took %f second", MESSAGE_NUM*2, timeuse);
+    BIO_printf(out, "\n C-V2X BPp256r1 HW+SW verify benchmark: Average %.2f verification/second with verification failures: %d ", (double)(MESSAGE_NUM*2)/timeuse, cv2x_verify_fail);
+    (void)BIO_flush(out);
+    ret = 1;    
+BPp256r1_err:
+    EC_GROUP_free(group);
+    BN_free(x_ec_key);
+    BN_free(y_ec_key);
+    if (ecdsa_sig)
+        ECDSA_SIG_free(ecdsa_sig);
+    for (i = 0; i < MESSAGE_NUM; i++) {
+        OPENSSL_free(cv2x_BPp256r1_message[i]->signature);
+        EC_KEY_free(cv2x_BPp256r1_message[i]->ec_key);
+        OPENSSL_free(cv2x_BPp256r1_message[i]);
+    }
+    if (pQ)
+        destruct_queue(pQ);
+    if (head)
+        free_list(head);
+    /* Finish session */
+	if (0 != sess.ses && ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		BIO_printf(out, "ioctl(CIOCFSESSION) failed");
+	}
+    return ret;
+}
+
+int cv2x_NISTp256(int cfd, BN_CTX *ctx, BIO *out)
+{
+    EC_GROUP *group = NULL;    
+    int ret = 0, i = 0, cv2x_verify_fail = 0;
+    int orig_coordinate = 0;
+    ECDSA_SIG *ecdsa_sig = NULL;
+    const unsigned char *sig_ptr = NULL;
+    const BIGNUM *sig_r, *sig_s;
+    BIGNUM *x_ec_key = NULL, *y_ec_key = NULL;
+    _cv2x_data *cv2x_NISTp256_message[MESSAGE_NUM] = {0};
+    struct timeval starttime, endtime;
+    double timeuse;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    static cv2x_message_queue *pQ = NULL;
+    static _cv2x_node *head = NULL;
+    _cv2x_node *temp = NULL;
+    queue_node *pN = NULL; 
+    
+    orig_coordinate = EC_GROUP_set_coordinates(EC_PROJECTIVE_COORDINATES);
+    group = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);
+    EC_GROUP_restore_coordinates(orig_coordinate);
+    if (group == NULL)
+        goto NISTp256_err;
+    if ((x_ec_key = BN_new()) == NULL)
+        goto NISTp256_err;
+    if ((y_ec_key = BN_new()) == NULL)
+        goto NISTp256_err;
+
+/*+++++++++++++++++++++++ Using SW engine to verify C-V2X message ++++++++++++++++++++++++++*/    
+    BIO_printf(out, "\n\n\n C-V2X NISTp256 benchmark pre-start: sign message \n\n ");
+    (void)BIO_flush(out);
+    for (i = 0; i < MESSAGE_NUM; i++) {
+        if ((cv2x_NISTp256_message[i] = OPENSSL_malloc(sizeof(_cv2x_data))) == NULL) {
+            BIO_printf(out, "No memory available");
+            goto NISTp256_err;
+        }
+        memset(cv2x_NISTp256_message[i], 0, sizeof(_cv2x_data));
+        if (RAND_bytes(cv2x_NISTp256_message[i]->digest, MSG_LEN) <= 0) {
+            BIO_printf(out, "ERROR: unable to get random data in cv2x_NISTp256()\n");
+            goto NISTp256_err;
+        }
+        /* create new ecdsa key (== EC_KEY) */
+        if ((cv2x_NISTp256_message[i]->ec_key = EC_KEY_new()) == NULL) {
+            BIO_printf(out, "fail to create new key in cv2x_NISTp256()\n");
+            goto NISTp256_err;
+        }
+        if (EC_KEY_set_group(cv2x_NISTp256_message[i]->ec_key, group) == 0) {
+            BIO_printf(out, "fail to set group for new key in cv2x_NISTp256()\n");
+            goto NISTp256_err;
+        }
+        /* create key */
+        if (!EC_KEY_generate_key(cv2x_NISTp256_message[i]->ec_key)) {
+            BIO_printf(out, "generate key failed in cv2x_NISTp256()\n");
+            goto NISTp256_err;
+        }
+        (void)BIO_flush(out);
+        /* check key */
+        if (!EC_KEY_check_key(cv2x_NISTp256_message[i]->ec_key)) {
+            BIO_printf(out, "check key failed in cv2x_NISTp256()\n");
+            goto NISTp256_err;
+        }
+        /* create signature */
+        cv2x_NISTp256_message[i]->sig_len = ECDSA_size(cv2x_NISTp256_message[i]->ec_key);
+        if ((cv2x_NISTp256_message[i]->signature = OPENSSL_malloc(cv2x_NISTp256_message[i]->sig_len)) == NULL) {
+            BIO_printf(out, "No memory available");
+            goto NISTp256_err;
+        }
+        if (!ECDSA_sign(NID_undef, cv2x_NISTp256_message[i]->digest, MSG_LEN, cv2x_NISTp256_message[i]->signature, &cv2x_NISTp256_message[i]->sig_len, cv2x_NISTp256_message[i]->ec_key)) {
+            BIO_printf(out, "sign failed in cv2x_NISTp256()\n");
+            goto NISTp256_err;
+        }
+        (void)BIO_flush(out);
+        sig_ptr = cv2x_NISTp256_message[i]->signature;
+        if ((ecdsa_sig = d2i_ECDSA_SIG(NULL, &sig_ptr, cv2x_NISTp256_message[i]->sig_len)) == NULL) {
+            BIO_printf(out, " failed\n");
+            goto NISTp256_err;
+        }
+
+        ECDSA_SIG_get0(ecdsa_sig, &sig_r, &sig_s);
+        cv2x_bn2buffer(sig_r, cv2x_NISTp256_message[i]->r, L_LEN);
+        cv2x_int_swap(cv2x_NISTp256_message[i]->r, L_LEN);
+        cv2x_bn2buffer(sig_s, cv2x_NISTp256_message[i]->s, L_LEN);
+        cv2x_int_swap(cv2x_NISTp256_message[i]->s, L_LEN);
+        if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field) {
+            if (!EC_POINT_get_affine_coordinates_GFp
+                (group, EC_KEY_get0_public_key(cv2x_NISTp256_message[i]->ec_key), x_ec_key, y_ec_key, ctx))
+                goto NISTp256_err;
+        }
+        cv2x_bn2buffer(x_ec_key, cv2x_NISTp256_message[i]->Wx, L_LEN);
+        cv2x_int_swap(cv2x_NISTp256_message[i]->Wx, L_LEN);
+        cv2x_bn2buffer(y_ec_key, cv2x_NISTp256_message[i]->Wy, L_LEN);
+        cv2x_int_swap(cv2x_NISTp256_message[i]->Wy, L_LEN);
+#ifdef CV2X_VERBOSE
+        BIO_printf(out, "\n private key: ");
+        BN_print(out, EC_KEY_get0_private_key(cv2x_NISTp256_message[i]->ec_key));
+        BIO_printf(out, "\n");
+        BIO_printf(out, "public key (x,y): ");
+        BN_print(out, x_ec_key);
+        BIO_printf(out, ",");
+        BN_print(out, y_ec_key);
+        BIO_printf(out, "\n");
+        BIO_printf(out, "signature (r,s): ");
+        BN_print(out, sig_r);
+        BIO_printf(out, ",");
+        BN_print(out, sig_s);
+        BIO_printf(out, "\n");
+#endif
+        
+        (void)BIO_flush(out);
+        ECDSA_SIG_free(ecdsa_sig);
+        ecdsa_sig = NULL;
+    }
+    BIO_printf(out, "\n C-V2X NISTp256 SW verify benchmark: ");
+    (void)BIO_flush(out);
+    gettimeofday(&starttime, NULL);
+    for (i = 0; i < MESSAGE_NUM; i++) {
+        /* verify signature */
+        if (ECDSA_verify(0, cv2x_NISTp256_message[i]->digest, MSG_LEN, cv2x_NISTp256_message[i]->signature, cv2x_NISTp256_message[i]->sig_len, cv2x_NISTp256_message[i]->ec_key) != 1) {
+            cv2x_NISTp256_message[i]->result = false;
+            cv2x_verify_fail++;
+        }
+        else
+            cv2x_NISTp256_message[i]->result = true;
+    }
+    gettimeofday(&endtime, NULL);
+    timeuse = (double)(endtime.tv_sec - starttime.tv_sec) + (double)((endtime.tv_usec - starttime.tv_usec) / 1000000);
+    BIO_printf(out, "\n C-V2X NISTp256 SW verify benchmark: %d messages took %f second", MESSAGE_NUM, timeuse);
+    BIO_printf(out, "\n C-V2X NISTp256 SW verify benchmark: Average %.2f verification/second with verification failures: %d ", (double)MESSAGE_NUM/timeuse, cv2x_verify_fail);
+    (void)BIO_flush(out);
+
+    cv2x_verify_fail = 0;
+
+/*+++++++++++++++++++++++ Using cryptodev engine (by CAAM) to verify C-V2X message ++++++++++++++++++++++++++*/ 
+    BIO_printf(out, "\n\n\n C-V2X NISTp256 HW verify benchmark: ");
+    (void)BIO_flush(out);
+
+    memset(&sess, 0, sizeof(sess)); 
+
+    sess.pk_cipher = CRYPTO_CV2X_NISTP256_VERIFY;
+    if (ioctl(cfd, CIOCGSESSION, &sess)) {
+         BIO_printf(out, "ioctl(CIOCGSESSION) failed");
+        goto NISTp256_err;
+    }
+    memset(&kop, 0, sizeof(kop));
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_CV2X_VERIFY;
+
+    kop.crk_param[0].crp_p = OPENSSL_malloc(L_LEN*2);
+    if (NULL == kop.crk_param[0].crp_p) {
+        BIO_printf(out, "No memory available");
+        goto NISTp256_err;
+    }
+    memset(kop.crk_param[0].crp_p, 0, L_LEN*2);
+    kop.crk_param[0].crp_nbits = L_LEN * 16;
+
+    kop.crk_param[1].crp_p = OPENSSL_malloc(N_LEN);
+    if (NULL == kop.crk_param[1].crp_p) {
+        BIO_printf(out, "No memory available");
+        goto NISTp256_err;
+    }
+    memset(kop.crk_param[1].crp_p, 0, N_LEN);
+    kop.crk_param[1].crp_nbits = N_LEN * 8;
+
+    kop.crk_param[2].crp_p = OPENSSL_malloc(N_LEN);
+    if (NULL == kop.crk_param[2].crp_p) {
+        BIO_printf(out, "No memory available");
+        goto NISTp256_err;
+    }
+    memset(kop.crk_param[2].crp_p, 0, N_LEN);
+    kop.crk_param[2].crp_nbits = N_LEN * 8;
+
+    kop.crk_param[3].crp_p = OPENSSL_malloc(N_LEN);
+    if (NULL == kop.crk_param[3].crp_p) {
+        BIO_printf(out, "No memory available");
+        goto NISTp256_err;
+    }
+    memset(kop.crk_param[3].crp_p, 0, N_LEN);
+    kop.crk_param[3].crp_nbits = N_LEN * 8;
+
+    kop.crk_iparams = 4;
+    gettimeofday(&starttime, NULL);
+    for (i = 0; i < MESSAGE_NUM; i++) {
+        /* verify signature */
+        kop.crk_status = 0;
+        memcpy(kop.crk_param[0].crp_p, cv2x_NISTp256_message[i]->Wx, L_LEN);
+        memcpy(kop.crk_param[0].crp_p + L_LEN, cv2x_NISTp256_message[i]->Wy, L_LEN);
+        memcpy(kop.crk_param[1].crp_p, cv2x_NISTp256_message[i]->digest, N_LEN);
+        memcpy(kop.crk_param[2].crp_p, cv2x_NISTp256_message[i]->r, N_LEN);
+        memcpy(kop.crk_param[3].crp_p, cv2x_NISTp256_message[i]->s, N_LEN);
+        if (0 == ioctl(cfd, CIOCKEY, &kop) && 1 == kop.crk_status) 
+            cv2x_NISTp256_message[i]->result = true;
+        else {
+            cv2x_NISTp256_message[i]->result = false;
+            cv2x_verify_fail++;
+        }
+    }
+    gettimeofday(&endtime, NULL);
+    timeuse = (double)(endtime.tv_sec - starttime.tv_sec) + (double)((endtime.tv_usec - starttime.tv_usec) / 1000000);
+    BIO_printf(out, "\n C-V2X NISTp256 HW verify benchmark: %d messages took %f second", MESSAGE_NUM, timeuse);
+    BIO_printf(out, "\n C-V2X NISTp256 HW verify benchmark: Average %.2f verification/second with verification failures: %d ", (double)MESSAGE_NUM/timeuse, cv2x_verify_fail);
+    (void)BIO_flush(out);
+
+    for (i = 0; i < kop.crk_iparams; i++) {
+        OPENSSL_free(kop.crk_param[i].crp_p);
+    }
+    cv2x_verify_fail = 0;
+
+/*+++++++++++++++++++++++ Using SW + Cryptodev engine to verify C-V2X message ++++++++++++++++++++++++++*/ 
+
+    BIO_printf(out, "\n\n\n C-V2X NISTp256 HW+SW verify benchmark: ");
+    (void)BIO_flush(out);
+
+    pQ = construct_queue(cfd);
+    memcpy(&(pQ->sess), &sess, sizeof(sess));
+    pQ->nid = NID_X9_62_prime256v1;
+
+    for (i = 0; i < MESSAGE_NUM*2; i++) {        
+        if ((pN = OPENSSL_malloc(sizeof(queue_node))) == NULL) {
+            BIO_printf(out, "No memory available");
+            goto NISTp256_err;
+        }
+        memset(pN, 0, sizeof(queue_node));
+        head = add(head);
+        if (NULL == head) {
+            BIO_printf(out, "No memory available");
+            goto NISTp256_err;
+        }
+        pN->message_data = &(head->message_data);
+        if (RAND_bytes(pN->message_data->digest, MSG_LEN) <= 0) {
+            BIO_printf(out, "ERROR: unable to get random data in cv2x_NISTp256()\n");
+            goto NISTp256_err;
+        }
+        /* create new ecdsa key (== EC_KEY) */
+        if ((pN->message_data->ec_key = EC_KEY_new()) == NULL) {
+            BIO_printf(out, "fail to create new key in cv2x_NISTp256()\n");
+            goto NISTp256_err;
+        }
+        if (EC_KEY_set_group(pN->message_data->ec_key, group) == 0) {
+            BIO_printf(out, "fail to set group for new key in cv2x_NISTp256()\n");
+            goto NISTp256_err;
+        }
+        /* create key */
+        if (!EC_KEY_generate_key(pN->message_data->ec_key)) {
+            BIO_printf(out, "generate key failed in cv2x_NISTp256()\n");
+            goto NISTp256_err;
+        }
+        (void)BIO_flush(out);
+        /* check key */
+        if (!EC_KEY_check_key(pN->message_data->ec_key)) {
+            BIO_printf(out, "check key failed in cv2x_NISTp256()\n");
+            goto NISTp256_err;
+        }
+        /* create signature */
+        pN->message_data->sig_len = ECDSA_size(pN->message_data->ec_key);
+        if ((pN->message_data->signature = OPENSSL_malloc(pN->message_data->sig_len)) == NULL) {
+            BIO_printf(out, "No memory available");
+            goto NISTp256_err;
+        }
+        if (!ECDSA_sign(NID_undef, pN->message_data->digest, MSG_LEN, pN->message_data->signature, &pN->message_data->sig_len, pN->message_data->ec_key)) {
+            BIO_printf(out, "sign failed in cv2x_NISTp256()\n");
+            goto NISTp256_err;
+        }
+        (void)BIO_flush(out);
+        sig_ptr = pN->message_data->signature;
+        if ((ecdsa_sig = d2i_ECDSA_SIG(NULL, &sig_ptr, pN->message_data->sig_len)) == NULL) {
+            BIO_printf(out, " failed\n");
+            goto NISTp256_err;
+        }
+
+        ECDSA_SIG_get0(ecdsa_sig, &sig_r, &sig_s);
+        cv2x_bn2buffer(sig_r, pN->message_data->r, L_LEN);
+        cv2x_int_swap(pN->message_data->r, L_LEN);
+        cv2x_bn2buffer(sig_s, pN->message_data->s, L_LEN);
+        cv2x_int_swap(pN->message_data->s, L_LEN);
+        if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field) {
+            if (!EC_POINT_get_affine_coordinates_GFp
+                (group, EC_KEY_get0_public_key(pN->message_data->ec_key), x_ec_key, y_ec_key, ctx))
+                goto NISTp256_err;
+        }
+        cv2x_bn2buffer(x_ec_key, pN->message_data->Wx, L_LEN);
+        cv2x_int_swap(pN->message_data->Wx, L_LEN);
+        cv2x_bn2buffer(y_ec_key, pN->message_data->Wy, L_LEN);
+        cv2x_int_swap(pN->message_data->Wy, L_LEN);
+#ifdef CV2X_VERBOSE
+        BIO_printf(out, "\n private key: ");
+        BN_print(out, EC_KEY_get0_private_key(pN->message_data->ec_key));
+        BIO_printf(out, "\n");
+        BIO_printf(out, "public key (x,y): ");
+        BN_print(out, x_ec_key);
+        BIO_printf(out, ",");
+        BN_print(out, y_ec_key);
+        BIO_printf(out, "\n");
+        BIO_printf(out, "signature (r,s): ");
+        BN_print(out, sig_r);
+        BIO_printf(out, ",");
+        BN_print(out, sig_s);
+        BIO_printf(out, "\n");
+#endif
+        
+        (void)BIO_flush(out);
+        ECDSA_SIG_free(ecdsa_sig);
+        ecdsa_sig = NULL;    
+        Enqueue(pQ, pN);
+    }
+    gettimeofday(&starttime, NULL);
+
+    if(pthread_create(&sw_thread, NULL, (void*)cv2x_verify_task, pQ)) {
+        BIO_printf(out, "Error creating sw_thread\n");
+        goto NISTp256_err;
+    }
+
+    if(pthread_create(&hw_thread, NULL, (void*)cv2x_verify_task, pQ)) {
+        BIO_printf(out, "Error creating hw_thread\n");
+        goto NISTp256_err;
+    }
+
+    if(pthread_join(hw_thread, NULL)) {
+        BIO_printf(out, "Error joining hw_thread\n");
+        goto NISTp256_err;
+    }
+
+    if(pthread_join(sw_thread, NULL)) {
+        BIO_printf(out, "Error joining sw_thread\n");
+        goto NISTp256_err;
+    }
+    
+    gettimeofday(&endtime, NULL);
+    for (temp = head; temp; temp = temp->next) {
+        if (false == temp->message_data.result)
+            cv2x_verify_fail++;
+    }
+    timeuse = (double)(endtime.tv_sec - starttime.tv_sec) + (double)((endtime.tv_usec - starttime.tv_usec) / 1000000);
+    BIO_printf(out, "\n C-V2X NISTp256 HW+SW verify benchmark: %d messages took %f second", MESSAGE_NUM*2, timeuse);
+    BIO_printf(out, "\n C-V2X NISTp256 HW+SW verify benchmark: Average %.2f verification/second with verification failures: %d ", (double)(MESSAGE_NUM*2)/timeuse, cv2x_verify_fail);
+    (void)BIO_flush(out);
+    ret = 1;    
+NISTp256_err:
+    EC_GROUP_free(group);
+    BN_free(x_ec_key);
+    BN_free(y_ec_key);
+    if (ecdsa_sig)
+        ECDSA_SIG_free(ecdsa_sig);
+    for (i = 0; i < MESSAGE_NUM; i++) {
+        OPENSSL_free(cv2x_NISTp256_message[i]->signature);
+        EC_KEY_free(cv2x_NISTp256_message[i]->ec_key);
+        OPENSSL_free(cv2x_NISTp256_message[i]);
+    }
+    if (pQ)
+        destruct_queue(pQ);
+    if (head)
+        free_list(head);
+    /* Finish session */
+    if (0 != sess.ses && ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        BIO_printf(out, "ioctl(CIOCFSESSION) failed");
+    }
+    return ret;
+}
+
+
+int cv2x_SM2p256(int cfd, BN_CTX *ctx, BIO *out)
+{
+    EC_GROUP *group = NULL;    
+    int ret = 0, i = 0, cv2x_verify_fail = 0;
+    int orig_coordinate = 0;
+    ECDSA_SIG *ecdsa_sig = NULL;
+    const unsigned char *sig_ptr = NULL;
+    const BIGNUM *sig_r, *sig_s;
+    BIGNUM *x_ec_key = NULL, *y_ec_key = NULL;
+    _cv2x_data *cv2x_SM2p256_message[MESSAGE_NUM] = {0};
+    struct timeval starttime, endtime;
+    double timeuse;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    static cv2x_message_queue *pQ = NULL;
+    static _cv2x_node *head = NULL;
+    _cv2x_node *temp = NULL;
+    queue_node *pN = NULL; 
+    
+    orig_coordinate = EC_GROUP_set_coordinates(EC_PROJECTIVE_COORDINATES);
+    group = EC_GROUP_new_by_curve_name(NID_sm2p256v1);
+    EC_GROUP_restore_coordinates(orig_coordinate);
+    if (group == NULL)
+        goto SM2p256_err;
+    if ((x_ec_key = BN_new()) == NULL)
+        goto SM2p256_err;
+    if ((y_ec_key = BN_new()) == NULL)
+        goto SM2p256_err;
+
+/*+++++++++++++++++++++++ Using SW engine to verify C-V2X message ++++++++++++++++++++++++++*/    
+    BIO_printf(out, "\n\n\n C-V2X SM2p256 benchmark pre-start: sign message \n\n ");
+    (void)BIO_flush(out);
+    for (i = 0; i < MESSAGE_NUM; i++) {
+        if ((cv2x_SM2p256_message[i] = OPENSSL_malloc(sizeof(_cv2x_data))) == NULL) {
+            BIO_printf(out, "No memory available");
+            goto SM2p256_err;
+        }
+        memset(cv2x_SM2p256_message[i], 0, sizeof(_cv2x_data));
+        if (RAND_bytes(cv2x_SM2p256_message[i]->digest, MSG_LEN) <= 0) {
+            BIO_printf(out, "ERROR: unable to get random data in cv2x_SM2p256()\n");
+            goto SM2p256_err;
+        }
+        /* create new ecdsa key (== EC_KEY) */
+        if ((cv2x_SM2p256_message[i]->ec_key = EC_KEY_new()) == NULL) {
+            BIO_printf(out, "fail to create new key in cv2x_SM2p256()\n");
+            goto SM2p256_err;
+        }
+        if (EC_KEY_set_group(cv2x_SM2p256_message[i]->ec_key, group) == 0) {
+            BIO_printf(out, "fail to set group for new key in cv2x_SM2p256()\n");
+            goto SM2p256_err;
+        }
+        /* create key */
+        if (!EC_KEY_generate_key(cv2x_SM2p256_message[i]->ec_key)) {
+            BIO_printf(out, "generate key failed in cv2x_SM2p256()\n");
+            goto SM2p256_err;
+        }
+        (void)BIO_flush(out);
+        /* check key */
+        if (!EC_KEY_check_key(cv2x_SM2p256_message[i]->ec_key)) {
+            BIO_printf(out, "check key failed in cv2x_SM2p256()\n");
+            goto SM2p256_err;
+        }
+        /* create signature */
+        cv2x_SM2p256_message[i]->sig_len = ECDSA_size(cv2x_SM2p256_message[i]->ec_key);
+        if ((cv2x_SM2p256_message[i]->signature = OPENSSL_malloc(cv2x_SM2p256_message[i]->sig_len)) == NULL) {
+            BIO_printf(out, "No memory available");
+            goto SM2p256_err;
+        }
+        if (!SM2_sw_sign(NID_undef, cv2x_SM2p256_message[i]->digest, MSG_LEN, cv2x_SM2p256_message[i]->signature, &cv2x_SM2p256_message[i]->sig_len, cv2x_SM2p256_message[i]->ec_key)) {    
+            BIO_printf(out, "sign failed in cv2x_SM2p256()\n");
+            goto SM2p256_err;
+        }
+        (void)BIO_flush(out);
+        sig_ptr = cv2x_SM2p256_message[i]->signature;
+        if ((ecdsa_sig = d2i_ECDSA_SIG(NULL, &sig_ptr, cv2x_SM2p256_message[i]->sig_len)) == NULL) {
+            BIO_printf(out, " failed\n");
+            goto SM2p256_err;
+        }
+
+        ECDSA_SIG_get0(ecdsa_sig, &sig_r, &sig_s);
+        cv2x_bn2buffer(sig_r, cv2x_SM2p256_message[i]->r, L_LEN);
+        cv2x_int_swap(cv2x_SM2p256_message[i]->r, L_LEN);
+        cv2x_bn2buffer(sig_s, cv2x_SM2p256_message[i]->s, L_LEN);
+        cv2x_int_swap(cv2x_SM2p256_message[i]->s, L_LEN);
+        if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field) {
+            if (!EC_POINT_get_affine_coordinates_GFp
+                (group, EC_KEY_get0_public_key(cv2x_SM2p256_message[i]->ec_key), x_ec_key, y_ec_key, ctx))
+                goto SM2p256_err;
+        }
+        cv2x_bn2buffer(x_ec_key, cv2x_SM2p256_message[i]->Wx, L_LEN);
+        cv2x_int_swap(cv2x_SM2p256_message[i]->Wx, L_LEN);
+        cv2x_bn2buffer(y_ec_key, cv2x_SM2p256_message[i]->Wy, L_LEN);
+        cv2x_int_swap(cv2x_SM2p256_message[i]->Wy, L_LEN);
+#ifdef CV2X_VERBOSE
+        BIO_printf(out, "\n private key: ");
+        BN_print(out, EC_KEY_get0_private_key(cv2x_SM2p256_message[i]->ec_key));
+        BIO_printf(out, "\n");
+        BIO_printf(out, "public key (x,y): ");
+        BN_print(out, x_ec_key);
+        BIO_printf(out, ",");
+        BN_print(out, y_ec_key);
+        BIO_printf(out, "\n");
+        BIO_printf(out, "signature (r,s): ");
+        BN_print(out, sig_r);
+        BIO_printf(out, ",");
+        BN_print(out, sig_s);
+        BIO_printf(out, "\n");
+#endif
+        
+        (void)BIO_flush(out);
+        ECDSA_SIG_free(ecdsa_sig);
+        ecdsa_sig = NULL;
+    }
+
+    BIO_printf(out, "\n C-V2X SM2p256 SW verify benchmark: ");
+    (void)BIO_flush(out);
+    gettimeofday(&starttime, NULL);
+    for (i = 0; i < MESSAGE_NUM; i++) {
+        /* verify signature */
+        if (SM2_sw_verify(NID_undef, cv2x_SM2p256_message[i]->digest, MSG_LEN, cv2x_SM2p256_message[i]->signature, cv2x_SM2p256_message[i]->sig_len, cv2x_SM2p256_message[i]->ec_key) != 1) {
+            cv2x_SM2p256_message[i]->result = false;
+            cv2x_verify_fail++;
+        }
+        else
+            cv2x_SM2p256_message[i]->result = true;
+    }
+    gettimeofday(&endtime, NULL);
+	timeuse = (double)(endtime.tv_sec - starttime.tv_sec) + (double)((endtime.tv_usec - starttime.tv_usec) / 1000000);
+    BIO_printf(out, "\n C-V2X SM2p256 SW verify benchmark: %d messages took %f second", MESSAGE_NUM, timeuse);
+    BIO_printf(out, "\n C-V2X SM2p256 SW verify benchmark: Average %.2f verification/second with verification failures: %d ", (double)MESSAGE_NUM/timeuse, cv2x_verify_fail);
+    (void)BIO_flush(out);
+
+    cv2x_verify_fail = 0;
+/*+++++++++++++++++++++++ Using cryptodev engine (by CAAM) to verify C-V2X message ++++++++++++++++++++++++++*/ 
+    BIO_printf(out, "\n\n\n C-V2X SM2p256 HW verify benchmark: ");
+    (void)BIO_flush(out);
+
+    memset(&sess, 0, sizeof(sess));	
+
+	sess.pk_cipher = CRYPTO_CV2X_SM2_VERIFY;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		 BIO_printf(out, "ioctl(CIOCGSESSION) failed");
+		goto SM2p256_err;
+	}
+    memset(&kop, 0, sizeof(kop));
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_CV2X_VERIFY;
+
+    kop.crk_param[0].crp_p = OPENSSL_malloc(L_LEN);
+    if (NULL == kop.crk_param[0].crp_p) {
+        BIO_printf(out, "No memory available");
+        goto SM2p256_err;
+    }
+    memset(kop.crk_param[0].crp_p, 0, L_LEN);
+    kop.crk_param[0].crp_nbits = L_LEN * 8;
+
+    kop.crk_param[1].crp_p = OPENSSL_malloc(L_LEN);
+    if (NULL == kop.crk_param[1].crp_p) {
+        BIO_printf(out, "No memory available");
+        goto SM2p256_err;
+    }
+    memset(kop.crk_param[1].crp_p, 0, L_LEN);
+    kop.crk_param[1].crp_nbits = L_LEN * 8;
+
+    kop.crk_param[2].crp_p = OPENSSL_malloc(L_LEN);
+    if (NULL == kop.crk_param[2].crp_p) {
+        BIO_printf(out, "No memory available");
+        goto SM2p256_err;
+    }
+    memset(kop.crk_param[2].crp_p, 0, L_LEN);
+    kop.crk_param[2].crp_nbits = L_LEN * 8;
+
+    kop.crk_param[3].crp_p = OPENSSL_malloc(L_LEN);
+    if (NULL == kop.crk_param[3].crp_p) {
+        BIO_printf(out, "No memory available");
+        goto SM2p256_err;
+    }
+    memset(kop.crk_param[3].crp_p, 0, L_LEN);
+    kop.crk_param[3].crp_nbits = L_LEN * 8;
+
+    kop.crk_param[4].crp_p = OPENSSL_malloc(L_LEN);
+    if (NULL == kop.crk_param[4].crp_p) {
+        BIO_printf(out, "No memory available");
+        goto SM2p256_err;
+    }
+    memset(kop.crk_param[4].crp_p, 0, L_LEN);
+    kop.crk_param[4].crp_nbits = L_LEN * 8;
+
+    kop.crk_iparams = 5;
+    gettimeofday(&starttime, NULL);
+    for (i = 0; i < MESSAGE_NUM; i++) {
+        /* verify signature */
+		kop.crk_status = 0;
+        memcpy(kop.crk_param[0].crp_p, cv2x_SM2p256_message[i]->Wx, L_LEN);
+        memcpy(kop.crk_param[1].crp_p, cv2x_SM2p256_message[i]->Wy, L_LEN);
+        memcpy(kop.crk_param[2].crp_p, cv2x_SM2p256_message[i]->digest, N_LEN);
+        memcpy(kop.crk_param[3].crp_p, cv2x_SM2p256_message[i]->r, N_LEN);
+        memcpy(kop.crk_param[4].crp_p, cv2x_SM2p256_message[i]->s, N_LEN);
+        if (0 == ioctl(cfd, CIOCKEY, &kop) && 1 == kop.crk_status)
+            cv2x_SM2p256_message[i]->result = true;
+        else {
+            cv2x_SM2p256_message[i]->result = false;
+            cv2x_verify_fail++;
+        }
+    }
+    gettimeofday(&endtime, NULL);
+	timeuse = (double)(endtime.tv_sec - starttime.tv_sec) + (double)((endtime.tv_usec - starttime.tv_usec) / 1000000);
+    BIO_printf(out, "\n C-V2X SM2p256 HW verify benchmark: %d messages took %f second", MESSAGE_NUM, timeuse);
+    BIO_printf(out, "\n C-V2X SM2p256 HW verify benchmark: Average %.2f verification/second with verification failures: %d ", (double)MESSAGE_NUM/timeuse, cv2x_verify_fail);
+    (void)BIO_flush(out);
+
+    for (i = 0; i < kop.crk_iparams; i++) {
+        OPENSSL_free(kop.crk_param[i].crp_p);
+    }
+    cv2x_verify_fail = 0;    
+    /*+++++++++++++++++++++++ Using SW + Cryptodev engine to verify C-V2X message ++++++++++++++++++++++++++*/ 
+
+    BIO_printf(out, "\n\n\n C-V2X SM2p256 HW+SW verify benchmark: ");
+    (void)BIO_flush(out);
+
+    pQ = construct_queue(cfd);
+    memcpy(&(pQ->sess), &sess, sizeof(sess));
+    pQ->nid = NID_sm2p256v1;
+
+    for (i = 0; i < MESSAGE_NUM*2; i++) {        
+        if ((pN = OPENSSL_malloc(sizeof(queue_node))) == NULL) {
+            BIO_printf(out, "No memory available");
+            goto SM2p256_err;
+        }
+        memset(pN, 0, sizeof(queue_node));
+        head = add(head);
+        if (NULL == head) {
+            BIO_printf(out, "No memory available");
+            goto SM2p256_err;
+        }
+        pN->message_data = &(head->message_data);
+        if (RAND_bytes(pN->message_data->digest, MSG_LEN) <= 0) {
+            BIO_printf(out, "ERROR: unable to get random data in cv2x_SM2p256()\n");
+            goto SM2p256_err;
+        }
+        /* create new ecdsa key (== EC_KEY) */
+        if ((pN->message_data->ec_key = EC_KEY_new()) == NULL) {
+            BIO_printf(out, "fail to create new key in cv2x_SM2p256()\n");
+            goto SM2p256_err;
+        }
+        if (EC_KEY_set_group(pN->message_data->ec_key, group) == 0) {
+            BIO_printf(out, "fail to set group for new key in cv2x_SM2p256()\n");
+            goto SM2p256_err;
+        }
+        /* create key */
+        if (!EC_KEY_generate_key(pN->message_data->ec_key)) {
+            BIO_printf(out, "generate key failed in cv2x_SM2p256()\n");
+            goto SM2p256_err;
+        }
+        (void)BIO_flush(out);
+        /* check key */
+        if (!EC_KEY_check_key(pN->message_data->ec_key)) {
+            BIO_printf(out, "check key failed in cv2x_SM2p256()\n");
+            goto SM2p256_err;
+        }
+        /* create signature */
+        pN->message_data->sig_len = ECDSA_size(pN->message_data->ec_key);
+        if ((pN->message_data->signature = OPENSSL_malloc(pN->message_data->sig_len)) == NULL) {
+            BIO_printf(out, "No memory available");
+            goto SM2p256_err;
+        }
+        if (!SM2_sw_sign(NID_undef,  pN->message_data->digest, MSG_LEN,  pN->message_data->signature, & pN->message_data->sig_len, pN->message_data->ec_key)) {
+            BIO_printf(out, "sign failed in cv2x_SM2p256()\n");
+            goto SM2p256_err;
+        }
+        (void)BIO_flush(out);
+        sig_ptr = pN->message_data->signature;
+        if ((ecdsa_sig = d2i_ECDSA_SIG(NULL, &sig_ptr, pN->message_data->sig_len)) == NULL) {
+            BIO_printf(out, " failed\n");
+            goto SM2p256_err;
+        }
+
+        ECDSA_SIG_get0(ecdsa_sig, &sig_r, &sig_s);
+        cv2x_bn2buffer(sig_r, pN->message_data->r, L_LEN);
+        cv2x_int_swap(pN->message_data->r, L_LEN);
+        cv2x_bn2buffer(sig_s, pN->message_data->s, L_LEN);
+        cv2x_int_swap(pN->message_data->s, L_LEN);
+        if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field) {
+            if (!EC_POINT_get_affine_coordinates_GFp
+                (group, EC_KEY_get0_public_key(pN->message_data->ec_key), x_ec_key, y_ec_key, ctx))
+                goto SM2p256_err;
+        }
+        cv2x_bn2buffer(x_ec_key, pN->message_data->Wx, L_LEN);
+        cv2x_int_swap(pN->message_data->Wx, L_LEN);
+        cv2x_bn2buffer(y_ec_key, pN->message_data->Wy, L_LEN);
+        cv2x_int_swap(pN->message_data->Wy, L_LEN);
+#ifdef CV2X_VERBOSE
+        BIO_printf(out, "\n private key: ");
+        BN_print(out, EC_KEY_get0_private_key(pN->message_data->ec_key));
+        BIO_printf(out, "\n");
+        BIO_printf(out, "public key (x,y): ");
+        BN_print(out, x_ec_key);
+        BIO_printf(out, ",");
+        BN_print(out, y_ec_key);
+        BIO_printf(out, "\n");
+        BIO_printf(out, "signature (r,s): ");
+        BN_print(out, sig_r);
+        BIO_printf(out, ",");
+        BN_print(out, sig_s);
+        BIO_printf(out, "\n");
+#endif
+        
+        (void)BIO_flush(out);
+        ECDSA_SIG_free(ecdsa_sig);
+        ecdsa_sig = NULL;    
+        Enqueue(pQ, pN);
+    }
+    gettimeofday(&starttime, NULL);
+
+    if(pthread_create(&sw_thread, NULL, (void*)cv2x_verify_task, pQ)) {
+		BIO_printf(out, "Error creating sw_thread\n");
+		goto SM2p256_err;
+	}
+
+	if(pthread_create(&hw_thread, NULL, (void*)cv2x_verify_task, pQ)) {
+		BIO_printf(out, "Error creating hw_thread\n");
+		goto SM2p256_err;
+	}
+
+	if(pthread_join(hw_thread, NULL)) {
+		BIO_printf(out, "Error joining hw_thread\n");
+		goto SM2p256_err;
+	}
+
+	if(pthread_join(sw_thread, NULL)) {
+		BIO_printf(out, "Error joining sw_thread\n");
+		goto SM2p256_err;
+	}
+    
+    gettimeofday(&endtime, NULL);
+    for (temp = head; temp; temp = temp->next) {
+        if (false == temp->message_data.result)
+            cv2x_verify_fail++;
+    }
+	timeuse = (double)(endtime.tv_sec - starttime.tv_sec) + (double)((endtime.tv_usec - starttime.tv_usec) / 1000000);
+    BIO_printf(out, "\n C-V2X SM2p256 HW+SW verify benchmark: %d messages took %f second", MESSAGE_NUM*2, timeuse);
+    BIO_printf(out, "\n C-V2X SM2p256 HW+SW verify benchmark: Average %.2f verification/second with verification failures: %d ", (MESSAGE_NUM*2)/timeuse, cv2x_verify_fail);
+    (void)BIO_flush(out);
+    
+    ret = 1; 
+SM2p256_err:
+    EC_GROUP_free(group);
+    BN_free(x_ec_key);
+    BN_free(y_ec_key);
+    if (ecdsa_sig)
+        ECDSA_SIG_free(ecdsa_sig);
+    for (i = 0; i < MESSAGE_NUM; i++) {
+        OPENSSL_free(cv2x_SM2p256_message[i]->signature);
+        EC_KEY_free(cv2x_SM2p256_message[i]->ec_key);
+        OPENSSL_free(cv2x_SM2p256_message[i]);
+    }
+    if (pQ)
+        destruct_queue(pQ);
+    if (head)
+        free_list(head);
+    /* Finish session */
+	if (0 != sess.ses && ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		BIO_printf(out, "ioctl(CIOCFSESSION) failed");
+	}
+    return ret;
+}
+
+static const char rnd_seed[] = "C-V2X benchmark for i.MX "
+    "think it has entropy";
+static unsigned int cryptodev_asymfeat = 0;
+
+int main(void)
+{
+    int ret = 1;
+    BIO *out;
+    char *p;
+    BN_CTX *ctx = NULL;
+    int fd = -1;	
+    
+    out = BIO_new_fp(stdout, BIO_NOCLOSE | BIO_FP_TEXT);
+
+    if ((ctx = BN_CTX_new()) == NULL)
+        goto err;
+
+    p = getenv("OPENSSL_DEBUG_MEMORY");
+    if (p != NULL && strcmp(p, "on") == 0)
+        CRYPTO_set_mem_debug(1);
+
+    /* Open the crypto device */
+	fd = open("/dev/crypto", O_RDWR, 0);
+	if (fd < 0) {
+		BIO_printf(out, "fail to open(/dev/crypto)");
+		goto err;
+	}
+
+	if (ioctl(fd, CIOCASYMFEAT, &cryptodev_asymfeat) == -1) {
+		BIO_printf(out, "fail to get asymmetric feat");
+    }
+    /* initialize the prng */
+    RAND_seed(rnd_seed, sizeof(rnd_seed));
+
+    if (!cv2x_BPp256r1(fd, ctx, out)) {
+        BIO_printf(out, "\n C-V2X BPp256r1 benchmark test failed\n");
+        goto err;
+    }
+
+    if (!cv2x_NISTp256(fd, ctx, out)) {
+        BIO_printf(out, "\n C-V2X NISTp256 benchmark test failed\n");
+        goto err;
+    }
+
+    if (!cv2x_SM2p256(fd, ctx, out)) {
+        BIO_printf(out, "\n C-V2X SM2p256 benchmark test failed\n");
+        goto err;
+    }
+    
+    ret = 0;
+err:
+    
+    if (ret)
+        BIO_printf(out, "\n C-V2X benchmark test failed\n");
+    else
+        BIO_printf(out, "\n C-V2X benchmark test passed\n");
+    if (ret)
+        ERR_print_errors(out);
+    if (close(fd))
+		BIO_printf(out, "fail to close(fd)");
+
+#ifndef OPENSSL_NO_CRYPTO_MDEBUG
+    if (CRYPTO_mem_leaks(out) <= 0)
+        ret = 1;
+#endif
+    BN_CTX_free(ctx);
+    BIO_free(out);
+    
+    return ret;    
+}
+
+#endif
diff -uprN gmssl-1.0/test/dhtest.c GmSSL-2.5.0_iMX/test/dhtest.c
--- gmssl-1.0/test/dhtest.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/test/dhtest.c	2020-11-09 10:59:49.719907221 +0800
@@ -27,6 +27,9 @@ int main(int argc, char *argv[])
 }
 #else
 # include <openssl/dh.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
 
 static int cb(int p, int n, BN_GENCB *arg);
 
@@ -48,10 +51,24 @@ int main(int argc, char *argv[])
     unsigned char *bbuf = NULL;
     int i, alen, blen, aout, bout;
     int ret = 1;
-    BIO *out = NULL;
+    BIO *out = NULL;    
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE *e = NULL;
+#endif
 
     CRYPTO_set_mem_debug(1);
     CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE_load_builtin_engines();
+    if (!(e = ENGINE_by_id("cryptodev")))
+        return 1;
+    if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+        ENGINE_free(e);
+        return 1;
+    }
+    if (e)
+        ENGINE_free(e);
+#endif
 
     RAND_seed(rnd_seed, sizeof rnd_seed);
 
@@ -152,6 +169,9 @@ int main(int argc, char *argv[])
     (void)BIO_flush(out);
     ERR_print_errors_fp(stderr);
 
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE_cleanup();
+#endif
     OPENSSL_free(abuf);
     OPENSSL_free(bbuf);
     DH_free(b);
@@ -467,7 +487,27 @@ static const rfc5114_td rfctd[] = {
         make_rfc5114_td(2048_224),
         make_rfc5114_td(2048_256)
 };
+#ifdef HAVE_CRYPTODEV
+static inline int int_swap(unsigned char *A, unsigned short sizeA)
+{
+	int i;
+	unsigned char *p;
+	
+	p = (unsigned char *)malloc(sizeA);
+	
+	if (!p)
+		return -1;
+
+	memcpy(p, A, sizeA);
 
+	for(i = 0; i < sizeA; i++)
+		A[i] = p[sizeA - 1 - i];
+
+	free(p);
+
+	return 0;
+}
+#endif
 static int run_rfc5114_tests(void)
 {
     int i;
@@ -520,7 +560,10 @@ static int run_rfc5114_tests(void)
         DH_get0_key(dhA, &pub_key_tmp, NULL);
         if (DH_compute_key(Z2, pub_key_tmp, dhB) == -1)
             goto bad_err;
-
+#ifdef HAVE_CRYPTODEV        
+        int_swap(Z1,td->Z_len);
+        int_swap(Z2,td->Z_len);
+#endif
         if (memcmp(Z1, td->Z, td->Z_len))
             goto err;
         if (memcmp(Z2, td->Z, td->Z_len))
diff -uprN gmssl-1.0/test/dsatest.c GmSSL-2.5.0_iMX/test/dsatest.c
--- gmssl-1.0/test/dsatest.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/test/dsatest.c	2020-11-09 10:59:49.719907221 +0800
@@ -29,6 +29,9 @@ int main(int argc, char *argv[])
 }
 #else
 # include <openssl/dsa.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
 
 static int dsa_cb(int p, int n, BN_GENCB *arg);
 
@@ -85,13 +88,28 @@ int main(int argc, char **argv)
     unsigned long h;
     unsigned char sig[256];
     unsigned int siglen;
-    const BIGNUM *p = NULL, *q = NULL, *g = NULL;
+    const BIGNUM *p = NULL, *q = NULL, *g = NULL;    
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE *e = NULL;
+#endif
 
     if (bio_err == NULL)
         bio_err = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);
 
     CRYPTO_set_mem_debug(1);
     CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+    
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE_load_builtin_engines();
+    if (!(e = ENGINE_by_id("cryptodev")))
+        return 1;
+    if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+        ENGINE_free(e);
+        return 1;
+    }
+    if (e)
+        ENGINE_free(e);
+#endif
 
     RAND_seed(rnd_seed, sizeof rnd_seed);
 
@@ -149,13 +167,21 @@ int main(int argc, char **argv)
 
     DSA_generate_key(dsa);
     DSA_sign(0, str1, 20, sig, &siglen, dsa);
-    if (DSA_verify(0, str1, 20, sig, siglen, dsa) == 1)
+    if (DSA_verify(0, str1, 20, sig, siglen, dsa) == 1) {
         ret = 1;
+        printf("DSA verify successfully.\n");
+    }
+    else
+        printf("DSA verify failure.  No DSA verify will be done.\n");
 
  end:
     if (!ret)
         ERR_print_errors(bio_err);
     DSA_free(dsa);
+    
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE_cleanup();
+#endif
     BN_GENCB_free(cb);
 
 #ifndef OPENSSL_NO_CRYPTO_MDEBUG
diff -uprN gmssl-1.0/test/ecdhtest.c GmSSL-2.5.0_iMX/test/ecdhtest.c
--- gmssl-1.0/test/ecdhtest.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/test/ecdhtest.c	2020-11-09 10:59:49.719907221 +0800
@@ -45,6 +45,9 @@ int main(int argc, char *argv[])
 }
 #else
 # include <openssl/ec.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
 
 static const char rnd_seed[] =
     "string to make the random number generator think it has entropy";
@@ -546,12 +549,28 @@ int main(int argc, char *argv[])
 {
     BN_CTX *ctx = NULL;
     int nid, ret = 1;
+#ifndef HAVE_CRYPTODEV
     EC_builtin_curve *curves = NULL;
     size_t crv_len = 0, n = 0;
+#endif
     BIO *out;
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE *e = NULL;
+#endif
 
     CRYPTO_set_mem_debug(1);
     CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE_load_builtin_engines();
+    if (!(e = ENGINE_by_id("cryptodev")))
+        return 1;
+    if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+        ENGINE_free(e);
+        return 1;
+    }
+    if (e)
+        ENGINE_free(e);
+#endif
 
     RAND_seed(rnd_seed, sizeof rnd_seed);
 
@@ -562,7 +581,7 @@ int main(int argc, char *argv[])
 
     if ((ctx = BN_CTX_new()) == NULL)
         goto err;
-
+#ifndef HAVE_CRYPTODEV
     /* get a list of all internal curves */
     crv_len = EC_get_builtin_curves(NULL, 0);
     curves = OPENSSL_malloc(sizeof(*curves) * crv_len);
@@ -596,10 +615,110 @@ int main(int argc, char *argv[])
     }
 
     ret = 0;
+#else
+    if (!test_ecdh_curve(NID_X9_62_prime192v1, ctx, out)) /* NIST Prime-Curve P-192 */
+        goto err;
+    if (!test_ecdh_curve(NID_secp224r1, ctx, out)) /* NIST Prime-Curve P-224 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_prime256v1, ctx, out)) /* NIST Prime-Curve P-256 */
+        goto err;
+    if (!test_ecdh_curve(NID_secp384r1, ctx, out)) /* NIST Prime-Curve P-384 */
+        goto err;
+    if (!test_ecdh_curve(NID_secp521r1, ctx, out)) /* NIST Prime-Curve P-521 */
+        goto err; 
+    if (!test_ecdh_curve(NID_brainpoolP160r1, ctx, out)) /* Brainpool Prime-Curve brainpoolP160r1 */
+        goto err;
+    if (!test_ecdh_curve(NID_brainpoolP160t1, ctx, out)) /* Brainpool Prime-Curve brainpoolP160t1 */
+        goto err;
+    if (!test_ecdh_curve(NID_brainpoolP192r1, ctx, out)) /* Brainpool Prime-Curve brainpoolP192r1 */
+        goto err;
+    if (!test_ecdh_curve(NID_brainpoolP192t1, ctx, out)) /* Brainpool Prime-Curve brainpoolP192t1 */
+        goto err;
+    if (!test_ecdh_curve(NID_brainpoolP224r1, ctx, out)) /* Brainpool Prime-Curve brainpoolP224r1 */
+        goto err;
+    if (!test_ecdh_curve(NID_brainpoolP224t1, ctx, out)) /* Brainpool Prime-Curve brainpoolP224t1 */
+        goto err;
+    if (!test_ecdh_curve(NID_brainpoolP256r1, ctx, out)) /* Brainpool Prime-Curve brainpoolP256r1 */
+        goto err;
+    if (!test_ecdh_curve(NID_brainpoolP256t1, ctx, out)) /* Brainpool Prime-Curve brainpoolP256t1 */
+        goto err;
+    if (!test_ecdh_curve(NID_brainpoolP320r1, ctx, out)) /* Brainpool Prime-Curve brainpoolP320r1 */
+        goto err;
+    if (!test_ecdh_curve(NID_brainpoolP320t1, ctx, out)) /* Brainpool Prime-Curve brainpoolP320t1 */
+        goto err;
+    if (!test_ecdh_curve(NID_brainpoolP384r1, ctx, out)) /* Brainpool Prime-Curve brainpoolP384r1 */
+        goto err;
+    if (!test_ecdh_curve(NID_brainpoolP384t1, ctx, out)) /* Brainpool Prime-Curve brainpoolP384t1 */
+        goto err;
+    if (!test_ecdh_curve(NID_brainpoolP512r1, ctx, out)) /* Brainpool Prime-Curve brainpoolP512r1 */
+        goto err;
+    if (!test_ecdh_curve(NID_brainpoolP512t1, ctx, out)) /* Brainpool Prime-Curve brainpoolP512t1 */
+        goto err;
+#ifndef OPENSSL_NO_EC2M
+    if (!test_ecdh_curve(NID_sect163k1, ctx, out)) /* NIST Binary-Curve K-163 */
+        goto err;
+    if (!test_ecdh_curve(NID_sect163r2, ctx, out)) /* NIST Binary-Curve B-163 */
+        goto err;
+    if (!test_ecdh_curve(NID_sect233k1, ctx, out)) /* NIST Binary-Curve K-233 */
+        goto err;
+    if (!test_ecdh_curve(NID_sect233r1, ctx, out)) /* NIST Binary-Curve B-233 */
+        goto err;
+    if (!test_ecdh_curve(NID_sect283k1, ctx, out)) /* NIST Binary-Curve K-283 */
+        goto err;
+    if (!test_ecdh_curve(NID_sect283r1, ctx, out)) /* NIST Binary-Curve B-283 */
+        goto err;
+    if (!test_ecdh_curve(NID_sect409k1, ctx, out)) /* NIST Binary-Curve K-409 */
+        goto err;
+    if (!test_ecdh_curve(NID_sect409r1, ctx, out)) /* NIST Binary-Curve B-409 */
+        goto err;
+    if (!test_ecdh_curve(NID_sect571k1, ctx, out)) /* NIST Binary-Curve K-571 */
+        goto err;
+    if (!test_ecdh_curve(NID_sect571r1, ctx, out)) /* NIST Binary-Curve B-571 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2pnb163v1, ctx, out)) /* X9.62 Binary-Curve 163 v1 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2pnb163v2, ctx, out)) /* X9.62 Binary-Curve 163 v2 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2pnb163v3, ctx, out)) /* X9.62 Binary-Curve 163 v3 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2pnb176v1, ctx, out)) /* X9.62 Binary-Curve 176 v1 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2tnb191v1, ctx, out)) /* X9.62 Binary-Curve 191 v1 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2tnb191v2, ctx, out)) /* X9.62 Binary-Curve 191 v2 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2tnb191v3, ctx, out)) /* X9.62 Binary-Curve 191 v3 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2pnb208w1, ctx, out)) /* X9.62 Binary-Curve 208 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2tnb239v1, ctx, out)) /* X9.62 Binary-Curve 239 v1 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2tnb239v2, ctx, out)) /* X9.62 Binary-Curve 239 v2 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2tnb239v3, ctx, out)) /* X9.62 Binary-Curve 239 v3 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2pnb272w1, ctx, out)) /* X9.62 Binary-Curve 272 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2pnb304w1, ctx, out)) /* X9.62 Binary-Curve 304 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2tnb359v1, ctx, out)) /* X9.62 Binary-Curve 359 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2pnb368w1, ctx, out)) /* X9.62 Binary-Curve 368 */
+        goto err;
+    if (!test_ecdh_curve(NID_X9_62_c2tnb431r1, ctx, out)) /* X9.62 Binary-Curve 431 */
+        goto err;
+#endif
+
+#endif
 
  err:
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE_cleanup();
+#endif
     ERR_print_errors_fp(stderr);
+#ifndef HAVE_CRYPTODEV
     OPENSSL_free(curves);
+#endif
     BN_CTX_free(ctx);
     BIO_free(out);
 
diff -uprN gmssl-1.0/test/ecdsatest.c GmSSL-2.5.0_iMX/test/ecdsatest.c
--- gmssl-1.0/test/ecdsatest.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/test/ecdsatest.c	2020-11-09 10:59:49.719907221 +0800
@@ -143,7 +143,9 @@ int x9_62_test_internal(BIO *out, int ni
     EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();
     EC_KEY *key = NULL;
     ECDSA_SIG *signature = NULL;
+#ifdef OPENSSL_NO_ENGINE
     BIGNUM *r = NULL, *s = NULL;
+#endif
     BIGNUM *kinv = NULL, *rp = NULL;
     const BIGNUM *sig_r, *sig_s;
 
@@ -174,7 +176,8 @@ int x9_62_test_internal(BIO *out, int ni
     if (signature == NULL)
         goto x962_int_err;
     BIO_printf(out, ".");
-    (void)BIO_flush(out);
+    (void)BIO_flush(out);    
+#ifdef OPENSSL_NO_ENGINE
     /* compare the created signature with the expected signature */
     if ((r = BN_new()) == NULL || (s = BN_new()) == NULL)
         goto x962_int_err;
@@ -183,6 +186,7 @@ int x9_62_test_internal(BIO *out, int ni
     ECDSA_SIG_get0(signature, &sig_r, &sig_s);
     if (BN_cmp(sig_r, r) || BN_cmp(sig_s, s))
         goto x962_int_err;
+#endif
     BIO_printf(out, ".");
     (void)BIO_flush(out);
     /* verify the signature */
@@ -198,8 +202,10 @@ int x9_62_test_internal(BIO *out, int ni
         BIO_printf(out, " failed\n");
     EC_KEY_free(key);
     ECDSA_SIG_free(signature);
+#ifdef OPENSSL_NO_ENGINE
     BN_free(r);
     BN_free(s);
+#endif
     EVP_MD_CTX_free(md_ctx);
     BN_clear_free(kinv);
     BN_clear_free(rp);
@@ -293,7 +299,12 @@ int test_builtin(BIO *out)
         unsigned char dirt, offset;
 
         nid = curves[n].nid;
+#ifndef HAVE_CRYPTODEV
         if (nid == NID_ipsec4 || nid == NID_X25519)
+#else
+        if (nid == NID_ipsec4 || nid == NID_X25519 || nid == NID_sect163r1 || nid == NID_sect163r2 || nid == NID_sect193r1 || nid == NID_sect193r2 || nid == NID_sect233r1
+             || nid == NID_sect283r1 || nid == NID_sect409r1 || (n > 36 && n < 55) || nid == NID_wap_wsg_idm_ecid_wtls5 || nid == NID_wap_wsg_idm_ecid_wtls11 || nid == NID_sm9bn256v1)
+#endif
             continue;
         /* create new ecdsa key (== EC_KEY) */
         if ((eckey = EC_KEY_new()) == NULL)
@@ -484,24 +495,43 @@ int main(void)
     int ret = 1;
     BIO *out;
     char *p;
-
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE *e = NULL;
+#endif
     out = BIO_new_fp(stdout, BIO_NOCLOSE | BIO_FP_TEXT);
 
     p = getenv("OPENSSL_DEBUG_MEMORY");
     if (p != NULL && strcmp(p, "on") == 0)
         CRYPTO_set_mem_debug(1);
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE_load_builtin_engines();
+    if (!(e = ENGINE_by_id("cryptodev")))
+        return 1;
+    if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+        ENGINE_free(e);
+        return 1;
+    }
+    if (e)
+        ENGINE_free(e);
+#endif
 
     /* initialize the prng */
     RAND_seed(rnd_seed, sizeof(rnd_seed));
 
+#ifdef OPENSSL_NO_ENGINE
     /* the tests */
     if (!x9_62_tests(out))
         goto err;
+#endif
     if (!test_builtin(out))
         goto err;
 
     ret = 0;
  err:
+    
+#ifndef OPENSSL_NO_ENGINE
+     ENGINE_cleanup();
+#endif
     if (ret)
         BIO_printf(out, "\nECDSA test failed\n");
     else
diff -uprN gmssl-1.0/test/eciestest.c GmSSL-2.5.0_iMX/test/eciestest.c
--- gmssl-1.0/test/eciestest.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/test/eciestest.c	2020-11-09 10:59:49.723907234 +0800
@@ -63,7 +63,9 @@ int main(int argc, char **argv)
 # include <openssl/evp.h>
 # include <openssl/err.h>
 # include <openssl/ecies.h>
-
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
 static int ECIES_test(int verbose)
 {
 	int ret = 0;
@@ -73,6 +75,20 @@ static int ECIES_test(int verbose)
 	unsigned char *cbuf = NULL;
 	unsigned char *pbuf = NULL;
 	size_t clen, plen;
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE *e = NULL;
+
+    ENGINE_load_builtin_engines();
+    if (!(e = ENGINE_by_id("cryptodev")))
+        return 1;
+    if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+        ENGINE_free(e);
+        return 1;
+    }
+    if (e)
+        ENGINE_free(e);
+#endif
+
 
 	/* generate key pair */
 	if (!(ec_key = EC_KEY_new_by_curve_name(NID_secp192k1))) {
@@ -142,6 +158,9 @@ static int ECIES_test(int verbose)
 		printf("%s() %s\n", __FUNCTION__,
 			ret == 1 ? "passed" : "failed");
 	}
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE_cleanup();
+#endif
 
 end:
 	EC_KEY_free(ec_key);
diff -uprN gmssl-1.0/test/rsa_test.c GmSSL-2.5.0_iMX/test/rsa_test.c
--- gmssl-1.0/test/rsa_test.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/test/rsa_test.c	2020-11-09 10:59:49.723907234 +0800
@@ -26,6 +26,9 @@ int main(int argc, char *argv[])
 }
 #else
 # include <openssl/rsa.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
 
 # define SetKey \
     RSA_set0_key(key,                                           \
@@ -232,12 +235,31 @@ int main(int argc, char *argv[])
     int plen;
     int clen = 0;
     int num;
-    int n;
+    int n;    
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE *e = NULL;
+    int ret = 0, rsa_num = 0;
+    unsigned char buf[64], buf2[1024+8+1];
+#endif
 
     CRYPTO_set_mem_debug(1);
     CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE_load_builtin_engines();
+    if (!(e = ENGINE_by_id("cryptodev")))
+        return 1;
+    if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+        ENGINE_free(e);
+        return 1;
+    }
+    if (e)
+        ENGINE_free(e);
+#endif
 
     RAND_seed(rnd_seed, sizeof rnd_seed); /* or OAEP may fail */
+#ifndef OPENSSL_NO_ENGINE
+    RAND_pseudo_bytes(buf, 36);
+#endif
 
     plen = sizeof(ptext_ex) - 1;
 
@@ -259,8 +281,8 @@ int main(int argc, char *argv[])
                                  RSA_PKCS1_PADDING);
         if (num != clen) {
             printf("PKCS#1 v1.5 encryption failed!\n");
-            err = 1;
-            goto oaep;
+            err = 1;            
+            goto SSLV23;            
         }
 
         num = RSA_private_decrypt(num, ctext, ptext, key, RSA_PKCS1_PADDING);
@@ -269,8 +291,25 @@ int main(int argc, char *argv[])
             err = 1;
         } else
             printf("PKCS #1 v1.5 encryption/decryption ok\n");
+SSLV23:   
+        printf("\n");
+        num = RSA_public_encrypt(plen, ptext_ex, ctext, key,
+                                         RSA_SSLV23_PADDING);
+        if (num != clen) {
+            printf("SSL v23 encryption failed!\n");
+            err = 1;
+            goto oaep;
+        }
 
- oaep:
+        num = RSA_private_decrypt(num, ctext, ptext, key, RSA_SSLV23_PADDING);
+        if (num != plen || memcmp(ptext, ptext_ex, num) != 0) {
+            printf("SSL v23 decryption failed!\n");
+            err = 1;
+        } else
+            printf("SSL v23 encryption/decryption ok\n");
+
+ oaep:    
+        printf("\n");
         ERR_clear_error();
         num = RSA_public_encrypt(plen, ptext_ex, ctext, key,
                                  RSA_PKCS1_OAEP_PADDING);
@@ -289,6 +328,11 @@ int main(int argc, char *argv[])
         if (num != plen || memcmp(ptext, ptext_ex, num) != 0) {
             printf("OAEP decryption (encrypted data) failed!\n");
             err = 1;
+#ifndef OPENSSL_NO_ENGINE
+        } else
+            printf("OAEP encryption/decryption ok\n");
+            
+#else
         } else if (memcmp(ctext, ctext_ex, num) == 0)
             printf("OAEP test vector %d passed!\n", v);
 
@@ -305,6 +349,7 @@ int main(int argc, char *argv[])
             err = 1;
         } else
             printf("OAEP encryption/decryption ok\n");
+#endif
 
         /* Try decrypting corrupted ciphertexts. */
         for (n = 0; n < clen; ++n) {
@@ -330,9 +375,24 @@ int main(int argc, char *argv[])
             }
         }
 
- next:
+ next:    
+        printf("\n");
+        memset(buf2,0,1024+8+1);
+        ret = RSA_sign(NID_md5_sha1, buf, 36, buf2, &rsa_num, key);
+        if (ret == 0) {
+            printf("RSA sign failure.  No RSA sign will be done.\n");
+        }
+        ret = RSA_verify(NID_md5_sha1, buf, 36, buf2, rsa_num, key);
+        if (ret <= 0) {
+            printf("RSA verify failure.  No RSA verify will be done.\n");
+        }
+        else
+            printf("No.%d RSA verify successfully.\n",v+1);
         RSA_free(key);
     }
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE_cleanup();
+#endif
 
 #ifndef OPENSSL_NO_CRYPTO_MDEBUG
     if (CRYPTO_mem_leaks_fp(stderr) <= 0)
diff -uprN gmssl-1.0/test/sm2test.c GmSSL-2.5.0_iMX/test/sm2test.c
--- gmssl-1.0/test/sm2test.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/test/sm2test.c	2020-11-09 10:59:49.723907234 +0800
@@ -67,6 +67,10 @@ int main(int argc, char **argv)
 # include <openssl/sm2.h>
 # include "../crypto/sm2/sm2_lcl.h"
 
+#ifdef HAVE_CRYPTODEV
+# include "../crypto/ec/ec_lcl.h"
+#endif
+
 
 # define VERBOSE 1
 
@@ -234,7 +238,108 @@ err:
 
 	return group;
 }
+#ifdef HAVE_CRYPTODEV
+static EC_GROUP *new_hw_ec_group(int is_prime_field,
+	const char *p_hex, const char *a_hex, const char *b_hex,
+	const char *x_hex, const char *y_hex, const char *n_hex, const char *h_hex)
+{
+	int ok = 0;
+	EC_GROUP *group = NULL;
+	BN_CTX *ctx = NULL;
+	BIGNUM *p = NULL;
+	BIGNUM *a = NULL;
+	BIGNUM *b = NULL;
+	BIGNUM *x = NULL;
+	BIGNUM *y = NULL;
+	BIGNUM *n = NULL;
+	BIGNUM *h = NULL;
+	EC_POINT *G = NULL;
+	point_conversion_form_t form = SM2_DEFAULT_POINT_CONVERSION_FORM;
+	int flag = 0;
+
+	if (!(ctx = BN_CTX_new())) {
+		goto err;
+	}
+
+	if (!BN_hex2bn(&p, p_hex) ||
+	    !BN_hex2bn(&a, a_hex) ||
+	    !BN_hex2bn(&b, b_hex) ||
+	    !BN_hex2bn(&x, x_hex) ||
+	    !BN_hex2bn(&y, y_hex) ||
+	    !BN_hex2bn(&n, n_hex) ||
+	    !BN_hex2bn(&h, h_hex)) {
+		goto err;
+	}
+
+	if (is_prime_field) {
+		if (!(group = EC_GROUP_new_curve_GFp(p, a, b, ctx))) {
+			goto err;
+		}
+        group->curve_name = NID_sm2p256v1;
+		if (!(G = EC_POINT_new(group))) {
+			goto err;
+		}
+        if (NULL == BN_copy(group->field, p))
+            goto err;
+        if(NULL == BN_copy(group->a,a))
+            goto err;
+        if(NULL == BN_copy(group->b,b))
+            goto err;
+        if(NULL == BN_copy(G->X,x))
+            goto err;
+        if(NULL == BN_copy(G->Y,y))
+            goto err;
+        BN_set_word(G->Z,1);
+        G->Z_is_one = 1;
+	}
+    else {
+		if (!(group = EC_GROUP_new_curve_GF2m(p, a, b, ctx))) {
+			goto err;
+		}
+		if (!(G = EC_POINT_new(group))) {
+			goto err;
+		}
+        if (NULL == BN_copy(group->field, p))
+            goto err;
+        if(NULL == BN_copy(group->a,a))
+            goto err;
+        if(NULL == BN_copy(group->b,b))
+            goto err;
+        if(NULL == BN_copy(G->X,x))
+            goto err;
+        if(NULL == BN_copy(G->Y,y))
+            goto err;
+        BN_set_word(G->Z,1);
+        G->Z_is_one = 1;
+	}
 
+	if (!EC_GROUP_set_generator(group, G, n, h)) {
+		goto err;
+	}
+
+	EC_GROUP_set_asn1_flag(group, flag);
+	EC_GROUP_set_point_conversion_form(group, form);
+
+	ok = 1;
+err:
+	BN_CTX_free(ctx);
+	BN_free(p);
+	BN_free(a);
+	BN_free(b);
+	BN_free(x);
+	BN_free(y);
+	BN_free(n);
+	BN_free(h);
+	EC_POINT_free(G);
+	if (!ok && group) {
+		ERR_print_errors_fp(stderr);
+		EC_GROUP_free(group);
+		group = NULL;
+	}
+
+	return group;
+}
+#endif
 static EC_KEY *new_ec_key(const EC_GROUP *group,
 	const char *sk, const char *xP, const char *yP,
 	const char *id, const EVP_MD *id_md)
@@ -272,9 +377,25 @@ static EC_KEY *new_ec_key(const EC_GROUP
 		if (!BN_hex2bn(&y, yP)) {
 			goto end;
 		}
+#ifdef HAVE_CRYPTODEV
+		if (EC_AFFINE_COORDINATES == EC_GROUP_get_coordinates(ec_key->group)) {
+		    ec_key->pub_key = EC_POINT_new(ec_key->group);
+		    if ((BN_copy(ec_key->pub_key->X, x) == NULL) || 
+		        (BN_copy(ec_key->pub_key->Y, y) == NULL))
+		    	goto end;
+		    if (EC_KEY_check_key(ec_key) == 0)
+		        goto end;
+		}
+		else {
+		    if (!EC_KEY_set_public_key_affine_coordinates(ec_key, x, y)) {
+				goto end;
+			}
+		}
+#else
 		if (!EC_KEY_set_public_key_affine_coordinates(ec_key, x, y)) {
 			goto end;
 		}
+#endif
 	}
 
 	/*
@@ -415,7 +536,113 @@ err:
 	if (ss) BN_free(ss);
 	return ret;
 }
+#ifdef HAVE_CRYPTODEV
+static int sw_test_sm2_sign(const EC_GROUP *group, const EC_GROUP *sw_group,
+	const char *sk, const char *xP, const char *yP,
+	const char *id, const char *Z,
+	const char *M, const char *e,
+	const char *k, const char *r, const char *s)
+{
+	int ret = 0;
+	int verbose = VERBOSE;
+	const EVP_MD *id_md = EVP_sm3();
+	const EVP_MD *msg_md = EVP_sm3();
+	int type = NID_undef;
+	unsigned char dgst[EVP_MAX_MD_SIZE];
+	size_t dgstlen;
+	unsigned char sig[256];
+	unsigned int siglen;
+	const unsigned char *p;
+	EC_KEY *ec_key = NULL;
+	EC_KEY *pubkey = NULL;
+	ECDSA_SIG *sm2sig = NULL;
+	BIGNUM *rr = NULL;
+	BIGNUM *ss = NULL;
+	const BIGNUM *sig_r;
+	const BIGNUM *sig_s;
+    int orig_coordinate = 0;
+
+	change_rand(k);
+	orig_coordinate = EC_GROUP_set_coordinates(EC_AFFINE_COORDINATES);
+	if (!(ec_key = new_ec_key(group, sk, xP, yP, id, id_md))) {
+		fprintf(stderr, "error: %s %d\n", __FUNCTION__, __LINE__);
+		goto err;
+	}
+	EC_GROUP_restore_coordinates(orig_coordinate);
+	if (verbose > 1) {
+		EC_KEY_print_fp(stdout, ec_key, 4);
+	}
+
+	dgstlen = sizeof(dgst);
+	if (!SM2_compute_id_digest(id_md, id, strlen(id), dgst, &dgstlen, ec_key)) {
+		fprintf(stderr, "error: %s %d\n", __FUNCTION__, __LINE__);
+		goto err;
+	}
+
+	if (verbose > 1) {
+		int j;
+		printf("id=%s\n", id);
+		printf("zid(xx):");
+		for (j = 0; j < dgstlen; j++) { printf("%02x", dgst[j]); } printf("\n");
+	}
+
+	dgstlen = sizeof(dgst);
+	if (!SM2_compute_message_digest(id_md, msg_md,
+		(const unsigned char *)M, strlen(M), id, strlen(id),
+		dgst, &dgstlen, ec_key)) {
+		fprintf(stderr, "error: %s %d\n", __FUNCTION__, __LINE__);
+		goto err;
+	}
+
+	/* sign */
+	siglen = sizeof(sig);
+	if (!SM2_sign(type, dgst, dgstlen, sig, &siglen, ec_key)) {
+		fprintf(stderr, "error: %s %d\n", __FUNCTION__, __LINE__);
+		goto err;
+	}
+
+	p = sig;
+	if (!(sm2sig = d2i_ECDSA_SIG(NULL, &p, siglen))) {
+		fprintf(stderr, "error: %s %d\n", __FUNCTION__, __LINE__);
+		goto err;
+	}
+	if (!BN_hex2bn(&rr, r) || !BN_hex2bn(&ss, s)) {
+		fprintf(stderr, "error: %s %d\n", __FUNCTION__, __LINE__);
+		goto err;
+	}
+
+	ECDSA_SIG_get0(sm2sig, &sig_r, &sig_s);
+
+	if (BN_cmp(sig_r, rr) || BN_cmp(sig_s, ss)) {
+		fprintf(stderr, "error: %s %d\n", __FUNCTION__, __LINE__);
+		goto err;
+	}
+
+	orig_coordinate = EC_GROUP_set_coordinates(EC_PROJECTIVE_COORDINATES);
+	/* verify */
+	if (!(pubkey = new_ec_key(sw_group, NULL, xP, yP, id, id_md))) {
+		fprintf(stderr, "error: %s %d\n", __FUNCTION__, __LINE__);
+		goto err;
+	}
+	EC_GROUP_restore_coordinates(orig_coordinate);
+
+	if (1 != SM2_sw_verify(type, dgst, dgstlen, sig, siglen, pubkey)) {
+		fprintf(stderr, "error: %s %d\n", __FUNCTION__, __LINE__);
+		goto err;
+	}
+
+	ret = 1;
+err:
+	restore_rand();
+	if (ec_key) EC_KEY_free(ec_key);
+	if (pubkey) EC_KEY_free(pubkey);
+	if (sm2sig) ECDSA_SIG_free(sm2sig);
+	if (rr) BN_free(rr);
+	if (ss) BN_free(ss);
+	return ret;
+}
 
+#endif
 static int test_sm2_enc(const EC_GROUP *group, const EVP_MD *md,
 	const char *d, const char *xP, const char *yP,
 	const char *M, const char *k, const char *C)
@@ -577,7 +804,22 @@ int main(int argc, char **argv)
 	EC_GROUP *sm2p256test = NULL;
 	EC_GROUP *sm2b193test = NULL;
 	EC_GROUP *sm2b257test = NULL;
-
+#ifdef HAVE_CRYPTODEV
+    ENGINE *e = NULL;
+    EC_GROUP *sw_sm2p256test = NULL;
+	EC_GROUP *sm2p256v1test = NULL;
+    int orig_coordinate = 0;
+
+    ENGINE_load_builtin_engines();
+    if (!(e = ENGINE_by_id("cryptodev")))
+        return 1;
+    if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+        ENGINE_free(e);
+        return 1;
+    }
+    if (e)
+        ENGINE_free(e);
+#endif
 	RAND_seed(rnd_seed, sizeof(rnd_seed));
 
 	sm2p192test = new_ec_group(1,
@@ -588,16 +830,43 @@ int main(int argc, char **argv)
 		"02BB3A02D4AAADACAE24817A4CA3A1B014B5270432DB27D2",
 		"BDB6F4FE3E8B1D9E0DA8C0D40FC962195DFAE76F56564677",
 		"1");
-
-	sm2p256test = new_ec_group(1,
-		"8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3",
-		"787968B4FA32C3FD2417842E73BBFEFF2F3C848B6831D7E0EC65228B3937E498",
-		"63E4C6D3B23B0C849CF84241484BFE48F61D59A5B16BA06E6E12D1DA27C5249A",
-		"421DEBD61B62EAB6746434EBC3CC315E32220B3BADD50BDC4C4E6C147FEDD43D",
-		"0680512BCBB42C07D47349D2153B70C4E5D7FDFCBFA36EA1A85841B9E46E09A2",
-		"8542D69E4C044F18E8B92435BF6FF7DD297720630485628D5AE74EE7C32E79B7",
-		"1");
-
+#ifdef HAVE_CRYPTODEV
+    sm2p256test = new_hw_ec_group(1,
+        "8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3",
+        "787968B4FA32C3FD2417842E73BBFEFF2F3C848B6831D7E0EC65228B3937E498",
+        "63E4C6D3B23B0C849CF84241484BFE48F61D59A5B16BA06E6E12D1DA27C5249A",
+        "421DEBD61B62EAB6746434EBC3CC315E32220B3BADD50BDC4C4E6C147FEDD43D",
+        "0680512BCBB42C07D47349D2153B70C4E5D7FDFCBFA36EA1A85841B9E46E09A2",
+        "8542D69E4C044F18E8B92435BF6FF7DD297720630485628D5AE74EE7C32E79B7",
+        "1");
+	sm2p256v1test = new_hw_ec_group(1,
+        "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF",
+        "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC",
+        "28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93",
+        "32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7",
+        "BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0",
+        "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123",
+        "1");
+    orig_coordinate = EC_GROUP_set_coordinates(EC_PROJECTIVE_COORDINATES);
+    sw_sm2p256test = new_ec_group(1,
+        "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF",
+        "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC",
+        "28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93",
+        "32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7",
+        "BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0",
+        "FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123",
+        "1");
+    EC_GROUP_restore_coordinates(orig_coordinate);
+#else
+    sm2p256test = new_ec_group(1,
+        "8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3",
+        "787968B4FA32C3FD2417842E73BBFEFF2F3C848B6831D7E0EC65228B3937E498",
+        "63E4C6D3B23B0C849CF84241484BFE48F61D59A5B16BA06E6E12D1DA27C5249A",
+        "421DEBD61B62EAB6746434EBC3CC315E32220B3BADD50BDC4C4E6C147FEDD43D",
+        "0680512BCBB42C07D47349D2153B70C4E5D7FDFCBFA36EA1A85841B9E46E09A2",
+        "8542D69E4C044F18E8B92435BF6FF7DD297720630485628D5AE74EE7C32E79B7",
+        "1");
+#endif
 	sm2b193test = new_ec_group(0,
 		"2000000000000000000000000000000000000000000008001",
 		"0",
@@ -638,8 +907,27 @@ int main(int argc, char **argv)
 	} else {
 		printf("sm2 sign p256 passed\n");
 	}
+#ifdef HAVE_CRYPTODEV
+    if (!sw_test_sm2_sign(
+		sm2p256v1test, sw_sm2p256test,
+		"3945208F7B2144B13F36E38AC6D39F95889393692860B51A42FB81EF4DF7C5B8",
+		"09F9DF311E5421A150DD7D161E4BC5C672179FAD1833FC076BB08FF356F35020",
+		"CCEA490CE26775A52DC6EA718CC1AA600AED05FBF35E084A6632F6072DA9AD13",
+		"1234567812345678",
+		"F4A38489E32B45B6F876E3AC2168CA392362DC8F23459C1D1146FC3DBFB7BC9A",
+		"message digest",
+		"B524F552CD82B8B028476E005C377FB19A87E6FC682D48BB5D42E3D9B9EFFE76",
+		"59276E27D506861A16680F3AD9C02DCCEF3CC1FA3CDBE4CE6D54B80DEAC1BC21",
+		"F5A03B0648D2C4630EEAC513E1BB81A15944DA3827D5B74143AC7EACEEE720B3",
+		"B1B6AA29DF212FD8763182BC0D421CA1BB9038FD1F7F42D4840B69C485BBC1AA")) {
+		printf("sm2 sign p256 failed\n");
+		err++;
+	} else {
+		printf("sm2 sign and sw verify p256 passed\n");
+	}
+#endif
 
-
+#ifndef HAVE_CRYPTODEV
 	if (!test_sm2_sign(
 		sm2b257test,
 		"771EF3DBFF5F1CDC32B9C572930476191998B2BF7CB981D7F5B39202645F0931",
@@ -657,7 +945,7 @@ int main(int argc, char **argv)
 	} else {
 		printf("sm2 sign b257 passed\n");
 	}
-
+#endif
 	if (!test_sm2_enc(
 		sm2p256test, EVP_sm3(),
 		"1649AB77A00637BD5E2EFE283FBF353534AA7F7CB89463F208DDBC2920BB0DA0",
@@ -676,6 +964,7 @@ int main(int argc, char **argv)
 		printf("sm2 enc p256 passed\n");
 	}
 
+#ifndef HAVE_CRYPTODEV
 	if (!test_sm2_enc(
 		sm2b257test, EVP_sm3(),
 		"56A270D17377AA9A367CFA82E46FA5267713A9B91101D0777B07FCE018C757EB",
@@ -693,7 +982,7 @@ int main(int argc, char **argv)
 	} else {
 		printf("sm2 enc b257 passed\n");
 	}
-
+#endif
 	if (!test_sm2_kap(
 		sm2p256test,
 		"ALICE123@YAHOO.COM",
@@ -716,7 +1005,7 @@ int main(int argc, char **argv)
 	} else {
 		printf("sm2 kap p256 passed\n");
 	}
-
+#ifndef HAVE_CRYPTODEV
 	/* ZA will not pass! */
 	if (!test_sm2_kap(
 		sm2b257test,
@@ -740,8 +1029,11 @@ int main(int argc, char **argv)
 	} else {
 		printf("sm2 kap b257 passed\n");
 	}
-
+#endif
 end:
+#ifndef HAVE_CRYPTODEV
+    ENGINE_cleanup();
+#endif
 	EC_GROUP_free(sm2p192test);
 	EC_GROUP_free(sm2p256test);
 	EC_GROUP_free(sm2b193test);
diff -uprN gmssl-1.0/test/sm9test.c GmSSL-2.5.0_iMX/test/sm9test.c
--- gmssl-1.0/test/sm9test.c	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/test/sm9test.c	2020-11-09 10:59:49.723907234 +0800
@@ -158,6 +158,8 @@ static int sm9test_sign(const char *id,
 	SM9PrivateKey *sk = NULL;
 	unsigned char sig[256];
 	size_t siglen = sizeof(sig);
+    struct timeval starttime, endtime;
+    unsigned long timeuse;
 	/* test vector */
 	char *ks =	"0130E78459D78545CB54C587E02CF480CE0B66340F319F348A1D5B1F2DC5F4";
 	char *Ppubs =	"04"
@@ -228,12 +230,15 @@ static int sm9test_sign(const char *id,
 		/* sign with test vector */
 		change_rand(r);
 	}
-
+    gettimeofday(&starttime, NULL);
 	if (!SM9_sign(NID_sm3, msg, msglen, sig, &siglen, sk)) {
 		ERR_print_errors_fp(stderr);
 		goto end;
 	}
-
+    gettimeofday(&endtime, NULL);
+    timeuse = 1000000 * (endtime.tv_sec - starttime.tv_sec) + endtime.tv_usec - starttime.tv_usec;
+    printf("\nSM9 sign:  %lu ms\n",  timeuse/1000);
+    
 	if (use_test_vector) {
 		const unsigned char *p = sig;
 		SM9Signature *sig = NULL;
@@ -256,7 +261,7 @@ static int sm9test_sign(const char *id,
 			err++;
 		}
 
-		if (!hexequbin(S_comp, ASN1_STRING_get0_data(sig->pointS),
+		if (!hexequbin(S, ASN1_STRING_get0_data(sig->pointS),
 			ASN1_STRING_length(sig->pointS))) {
 			fprintf(stderr, "%s %d: sig->S failed\n", __FILE__, __LINE__);
 			err++;
@@ -265,12 +270,16 @@ static int sm9test_sign(const char *id,
 		SM9Signature_free(sig);
 		BN_free(bn);
 	}
-
+    
+    gettimeofday(&starttime, NULL);
 	ret = SM9_verify(NID_sm3, msg, msglen, sig, siglen, mpk, id, strlen(id));
 	if (ret < 0) {
 		ERR_print_errors_fp(stderr);
 		goto end;
 	}
+    gettimeofday(&endtime, NULL);
+    timeuse = 1000000 * (endtime.tv_sec - starttime.tv_sec) + endtime.tv_usec - starttime.tv_usec;
+    printf("\nSM9 verify:  %lu ms\n",  timeuse/1000);
 
 end:
 	SM9PublicParameters_free(mpk);
@@ -289,6 +298,8 @@ static int sm9test_wrap(const char *id)
 	unsigned char key2[56] = {0};
 	unsigned char C[65];
 	size_t Clen;
+    struct timeval starttime, endtime;
+    unsigned long timeuse;
 
 	if (!SM9_setup(NID_sm9bn256v1, NID_sm9encrypt, NID_sm9hash1_with_sm3, &mpk, &msk)) {
 		goto end;
@@ -296,12 +307,22 @@ static int sm9test_wrap(const char *id)
 	if (!(sk = SM9_extract_private_key(msk, id, strlen(id)))) {
 		goto end;
 	}
+    gettimeofday(&starttime, NULL);
 	if (!SM9_wrap_key(NID_sm9kdf_with_sm3, key, sizeof(key), C, &Clen, mpk, id, strlen(id))) {
 		goto end;
 	}
+    gettimeofday(&endtime, NULL);
+    timeuse = 1000000 * (endtime.tv_sec - starttime.tv_sec) + endtime.tv_usec - starttime.tv_usec;
+    printf("\nSM9 wrap key:  %lu ms\n",  timeuse/1000);
+
+    gettimeofday(&starttime, NULL);
 	if (!SM9_unwrap_key(NID_sm9kdf_with_sm3, key2, sizeof(key2), C, sizeof(C), sk)) {
 		goto end;
 	}
+    gettimeofday(&endtime, NULL);
+    timeuse = 1000000 * (endtime.tv_sec - starttime.tv_sec) + endtime.tv_usec - starttime.tv_usec;
+    printf("\nSM9 unwrap key:  %lu ms\n",  timeuse/1000);
+    
 	if (memcmp(key, key2, sizeof(key2)) != 0) {
 		goto end;
 	}
@@ -338,6 +359,8 @@ static int sm9test_exch(const char *idA,
 	unsigned char SA[32];
 	unsigned char SB[32];
 	unsigned char S2[32];
+    struct timeval starttime, endtime;
+    unsigned long timeuse;
 
 	if (!SM9_setup(NID_sm9bn256v1, NID_sm9keyagreement, NID_sm9hash1_with_sm3, &mpk, &msk)
 		|| !(skA = SM9_extract_private_key(msk, idA, strlen(idA)))
@@ -346,6 +369,7 @@ static int sm9test_exch(const char *idA,
 		goto end;
 	}
 
+    gettimeofday(&starttime, NULL);
 	if (!SM9_generate_key_exchange(RA, &RAlen, rA, gA, &gAlen, idB, strlen(idB), skA, 1)
 		|| !SM9_generate_key_exchange(RB, &RBlen, rB, gB, &gBlen, idA, strlen(idA), skB, 0)
 		|| !SM9_compute_share_key_B(type, SKB, sizeof(SKB), SB, S2, rB, RB, RA, gB, idA, strlen(idA), skB)
@@ -353,7 +377,10 @@ static int sm9test_exch(const char *idA,
 		ERR_print_errors_fp(stderr);
 		goto end;
 	}
-
+    gettimeofday(&endtime, NULL);
+    timeuse = 1000000 * (endtime.tv_sec - starttime.tv_sec) + endtime.tv_usec - starttime.tv_usec;
+    printf("\nSM9 key exchange:  %lu ms\n",  timeuse/1000);
+    
 	if (memcmp(SKA, SKA, sizeof(SKA)) != 0 || memcmp(SA, S2, sizeof(SA)) != 0) {
 		goto end;
 	}
@@ -373,7 +400,9 @@ static int sm9test_enc(const char *id, c
 	SM9PrivateKey *sk = NULL;
 	unsigned char mbuf[1024] = {0};
 	unsigned char cbuf[1024] = {0};
-	size_t clen, mlen;
+	size_t clen = 1024, mlen = 1024;
+    struct timeval starttime, endtime;
+    unsigned long timeuse;
 
 	if (!SM9_setup(NID_sm9bn256v1, NID_sm9encrypt, NID_sm9hash1_with_sm3, &mpk, &msk)) {
 		ERR_print_errors_fp(stderr);
@@ -383,16 +412,27 @@ static int sm9test_enc(const char *id, c
 		ERR_print_errors_fp(stderr);
 		goto end;
 	}
+
+    gettimeofday(&starttime, NULL);
 	if (!SM9_encrypt(NID_sm9encrypt_with_sm3_xor, data, datalen,
 		cbuf, &clen, mpk, id, strlen(id))) {
 		ERR_print_errors_fp(stderr);
 		goto end;
 	}
+    gettimeofday(&endtime, NULL);
+    timeuse = 1000000 * (endtime.tv_sec - starttime.tv_sec) + endtime.tv_usec - starttime.tv_usec;
+    printf("\nSM9 encrypt:  %lu ms\n",  timeuse/1000);
+
+    gettimeofday(&starttime, NULL);
 	if (!SM9_decrypt(NID_sm9encrypt_with_sm3_xor, cbuf, clen,
 		mbuf, &mlen, sk)) {
 		ERR_print_errors_fp(stderr);
 		goto end;
 	}
+    gettimeofday(&endtime, NULL);
+    timeuse = 1000000 * (endtime.tv_sec - starttime.tv_sec) + endtime.tv_usec - starttime.tv_usec;
+    printf("\nSM9 decrypt:  %lu ms\n",  timeuse/1000);
+    
 	if (mlen != datalen || memcmp(mbuf, data, datalen) != 0) {
 		goto end;
 	}
@@ -416,25 +456,29 @@ int main(int argc, char **argv)
 		printf("sm9 sign tests failed\n");
 		err++;
 	}
-	printf("sm9 sign tests passed\n");
+    else
+    	printf("sm9 sign tests passed\n");
 
 	if (!sm9test_exch(id, "guan@pku.edu.cn")) {
 		printf("sm9 exch tests failed\n");
 		err++;
 	}
-	printf("sm9 exch tests passed\n");
+    else
+    	printf("sm9 exch tests passed\n");
 
 	if (!sm9test_wrap(id)) {
 		printf("sm9 key wrap tests failed\n");
 		err++;
 	}
-	printf("sm9 key wrap tests passed\n");
+    else
+    	printf("sm9 key wrap tests passed\n");
 
 	if (!sm9test_enc(id, in, sizeof(in)-1)) {
 		printf("sm9 encrypt tests failed\n");
 		err++;
 	}
-	printf("sm9 encrypt tests passed\n");
+    else
+    	printf("sm9 encrypt tests passed\n");
 
 	return err;
 }
diff -uprN gmssl-1.0/util/libcrypto.num GmSSL-2.5.0_iMX/util/libcrypto.num
--- gmssl-1.0/util/libcrypto.num	2019-03-15 11:06:24.000000000 +0800
+++ GmSSL-2.5.0_iMX/util/libcrypto.num	2020-11-09 10:59:49.723907234 +0800
@@ -5048,3 +5048,10 @@ i2d_OCSP_RESPID
 PKCS12_AUTHSAFES_it                     4885	1_1_0d	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 PKCS12_AUTHSAFES_it                     4885	1_1_0d	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
 PEM_read_bio_CMS                        4886	1_1_0d	EXIST::FUNCTION:CMS
+BN_get0_sm2_a_256                       4887	1_1_0d	EXIST::FUNCTION:SM2
+BN_get0_sm2_b_256                       4888	1_1_0d	EXIST::FUNCTION:SM2
+EC_GROUP_set_coordinates                4889	1_1_0d	EXIST::FUNCTION:EC
+EC_GROUP_restore_coordinates            4890	1_1_0d	EXIST::FUNCTION:EC
+EC_GROUP_get_coordinates                4891	1_1_0d	EXIST::FUNCTION:EC
+SM2_sw_verify                             	 4892	1_1_0d	EXIST::FUNCTION:SM2
+SM2_sw_sign                             	 	 4893	1_1_0d	EXIST::FUNCTION:SM2
