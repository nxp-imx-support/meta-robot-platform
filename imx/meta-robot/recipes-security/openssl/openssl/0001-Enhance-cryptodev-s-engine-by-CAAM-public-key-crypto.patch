From d3f4ba18ae0eaff04b1610d312fa14ff8e72cb58 Mon Sep 17 00:00:00 2001
From: zxd2021-iMX <xiaodong.zhang@nxp.com>
Date: Mon, 27 Mar 2023 16:59:30 +0800
Subject: [PATCH] Enhance cryptodev's engine by CAAM public key cryptography
 operations

Signed-off-by: nxa22940 <xiaodong.zhang@nxp.com>
---
 apps/speed.c           |  339 ++-
 crypto/ec/ec_curve.c   |   32 +-
 crypto/ec/ec_key.c     |   36 +
 crypto/ec/ec_local.h   |   20 +
 crypto/sm2/sm2_crypt.c |   38 +-
 crypto/sm2/sm2_sign.c  |   94 +-
 engines/e_devcrypto.c  | 6108 ++++++++++++++++++++++++++++++++++++++--
 test/dsatest.c         |   23 +-
 test/ecdsatest.c       |   37 +-
 test/rsa_test.c        |   53 +-
 10 files changed, 6486 insertions(+), 294 deletions(-)

diff --git a/apps/speed.c b/apps/speed.c
index cace25eda1..60a7245d54 100644
--- a/apps/speed.c
+++ b/apps/speed.c
@@ -353,8 +353,12 @@ static const OPT_PAIR dsa_choices[DSA_NUM] = {
 static double dsa_results[DSA_NUM][2];  /* 2 ops: sign then verify */
 
 enum {
-    R_RSA_512, R_RSA_1024, R_RSA_2048, R_RSA_3072, R_RSA_4096, R_RSA_7680,
-    R_RSA_15360, RSA_NUM
+    R_RSA_512, R_RSA_1024, R_RSA_2048, R_RSA_3072, R_RSA_4096,
+#ifdef OPENSSL_NO_DEVCRYPTOENG
+    R_RSA_7680,
+    R_RSA_15360,
+#endif
+    RSA_NUM
 };
 static const OPT_PAIR rsa_choices[RSA_NUM] = {
     {"rsa512", R_RSA_512},
@@ -362,8 +366,10 @@ static const OPT_PAIR rsa_choices[RSA_NUM] = {
     {"rsa2048", R_RSA_2048},
     {"rsa3072", R_RSA_3072},
     {"rsa4096", R_RSA_4096},
+#ifdef OPENSSL_NO_DEVCRYPTOENG
     {"rsa7680", R_RSA_7680},
     {"rsa15360", R_RSA_15360}
+#endif
 };
 
 static double rsa_results[RSA_NUM][2];  /* 2 ops: sign then verify */
@@ -388,12 +394,39 @@ enum ec_curves_t {
     R_EC_P160, R_EC_P192, R_EC_P224, R_EC_P256, R_EC_P384, R_EC_P521,
 #ifndef OPENSSL_NO_EC2M
     R_EC_K163, R_EC_K233, R_EC_K283, R_EC_K409, R_EC_K571,
+#ifdef OPENSSL_NO_DEVCRYPTOENG
     R_EC_B163, R_EC_B233, R_EC_B283, R_EC_B409, R_EC_B571,
+#endif
 #endif
     R_EC_BRP256R1, R_EC_BRP256T1, R_EC_BRP384R1, R_EC_BRP384T1,
     R_EC_BRP512R1, R_EC_BRP512T1, ECDSA_NUM
 };
 /* list of ecdsa curves */
+
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+static OPT_PAIR ecdsa_choices[ECDSA_NUM] = {
+    {"ecdsap160", R_EC_P160},
+    {"ecdsap192", R_EC_P192},
+    {"ecdsap224", R_EC_P224},
+    {"ecdsap256", R_EC_P256},
+    {"ecdsap384", R_EC_P384},
+    {"ecdsap521", R_EC_P521},
+# ifndef OPENSSL_NO_EC2M
+    {"ecdsak163", R_EC_K163},
+    {"ecdsak233", R_EC_K233},
+    {"ecdsak283", R_EC_K283},
+    {"ecdsak409", R_EC_K409},
+    {"ecdsak571", R_EC_K571},
+# endif
+    {"ecdsabrp256r1", R_EC_BRP256R1},
+    {"ecdsabrp256t1", R_EC_BRP256T1},
+    {"ecdsabrp384r1", R_EC_BRP384R1},
+    {"ecdsabrp384t1", R_EC_BRP384T1},
+    {"ecdsabrp512r1", R_EC_BRP512R1},
+    {"ecdsabrp512t1", R_EC_BRP512T1}
+};
+enum { EC_NUM = ECDSA_NUM };
+#else
 static const OPT_PAIR ecdsa_choices[ECDSA_NUM] = {
     {"ecdsap160", R_EC_P160},
     {"ecdsap192", R_EC_P192},
@@ -421,7 +454,31 @@ static const OPT_PAIR ecdsa_choices[ECDSA_NUM] = {
     {"ecdsabrp512t1", R_EC_BRP512T1}
 };
 enum { R_EC_X25519 = ECDSA_NUM, R_EC_X448, EC_NUM };
+#endif
 /* list of ecdh curves, extension of |ecdsa_choices| list above */
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+static const OPT_PAIR ecdh_choices[EC_NUM] = {
+    {"ecdhp160", R_EC_P160},
+    {"ecdhp192", R_EC_P192},
+    {"ecdhp224", R_EC_P224},
+    {"ecdhp256", R_EC_P256},
+    {"ecdhp384", R_EC_P384},
+    {"ecdhp521", R_EC_P521},
+#ifndef OPENSSL_NO_EC2M
+    {"ecdhk163", R_EC_K163},
+    {"ecdhk233", R_EC_K233},
+    {"ecdhk283", R_EC_K283},
+    {"ecdhk409", R_EC_K409},
+    {"ecdhk571", R_EC_K571},
+#endif
+    {"ecdhbrp256r1", R_EC_BRP256R1},
+    {"ecdhbrp256t1", R_EC_BRP256T1},
+    {"ecdhbrp384r1", R_EC_BRP384R1},
+    {"ecdhbrp384t1", R_EC_BRP384T1},
+    {"ecdhbrp512r1", R_EC_BRP512R1},
+    {"ecdhbrp512t1", R_EC_BRP512T1},
+};
+#else
 static const OPT_PAIR ecdh_choices[EC_NUM] = {
     {"ecdhp160", R_EC_P160},
     {"ecdhp192", R_EC_P192},
@@ -450,15 +507,17 @@ static const OPT_PAIR ecdh_choices[EC_NUM] = {
     {"ecdhx25519", R_EC_X25519},
     {"ecdhx448", R_EC_X448}
 };
+#endif
 
 static double ecdh_results[EC_NUM][1];      /* 1 op: derivation */
 static double ecdsa_results[ECDSA_NUM][2];  /* 2 ops: sign then verify */
 
 enum { R_EC_Ed25519, R_EC_Ed448, EdDSA_NUM };
 static const OPT_PAIR eddsa_choices[EdDSA_NUM] = {
+#ifndef OPENSSL_NO_DEVCRYPTOENG    
     {"ed25519", R_EC_Ed25519},
     {"ed448", R_EC_Ed448}
-
+#endif
 };
 static double eddsa_results[EdDSA_NUM][2];    /* 2 ops: sign then verify */
 
@@ -469,7 +528,8 @@ static const OPT_PAIR sm2_choices[SM2_NUM] = {
 };
 # define SM2_ID        "TLSv1.3+GM+Cipher+Suite"
 # define SM2_ID_LEN    sizeof("TLSv1.3+GM+Cipher+Suite") - 1
-static double sm2_results[SM2_NUM][2];    /* 2 ops: sign then verify */
+static double sm2sign_results[SM2_NUM][2];    /* 2 ops: sign then verify */
+static double sm2enc_results[SM2_NUM][2];    /* 2 ops: sign then verify */
 #endif /* OPENSSL_NO_SM2 */
 
 #define COND(unused_cond) (run && count < INT_MAX)
@@ -498,6 +558,9 @@ typedef struct loopargs_st {
     EVP_MD_CTX *sm2_ctx[SM2_NUM];
     EVP_MD_CTX *sm2_vfy_ctx[SM2_NUM];
     EVP_PKEY *sm2_pkey[SM2_NUM];
+    EVP_PKEY_CTX *sm2_enc_ctx[SM2_NUM];
+    EVP_PKEY *sm2_enc_pkey[SM2_NUM];
+    size_t cipherlen;
 #endif
     unsigned char *secret_a;
     unsigned char *secret_b;
@@ -1057,7 +1120,7 @@ static int EdDSA_verify_loop(void *args)
 }
 
 #ifndef OPENSSL_NO_SM2
-static long sm2_c[SM2_NUM][2];
+static long sm2sign_c[SM2_NUM][2];
 static int SM2_sign_loop(void *args)
 {
     loopargs_t *tempargs = *(loopargs_t **) args;
@@ -1069,7 +1132,7 @@ static int SM2_sign_loop(void *args)
     EVP_PKEY **sm2_pkey = tempargs->sm2_pkey;
     const size_t max_size = EVP_PKEY_get_size(sm2_pkey[testnum]);
 
-    for (count = 0; COND(sm2_c[testnum][0]); count++) {
+    for (count = 0; COND(sm2sign_c[testnum][0]); count++) {
         sm2sigsize = max_size;
 
         if (!EVP_DigestSignInit(sm2ctx[testnum], NULL, EVP_sm3(),
@@ -1104,7 +1167,7 @@ static int SM2_verify_loop(void *args)
     int ret, count;
     EVP_PKEY **sm2_pkey = tempargs->sm2_pkey;
 
-    for (count = 0; COND(sm2_c[testnum][1]); count++) {
+    for (count = 0; COND(sm2sign_c[testnum][1]); count++) {
         if (!EVP_DigestVerifyInit(sm2ctx[testnum], NULL, EVP_sm3(),
                                   NULL, sm2_pkey[testnum])) {
             BIO_printf(bio_err, "SM2 verify init failure\n");
@@ -1123,6 +1186,73 @@ static int SM2_verify_loop(void *args)
     }
     return count;
 }
+
+static long sm2enc_c[SM2_NUM][2];
+static int SM2_encrypt_loop(void *args)
+{
+    loopargs_t *tempargs = *(loopargs_t **) args;
+    unsigned char *buf = tempargs->buf;
+    EVP_PKEY_CTX **sm2ctx = tempargs->sm2_enc_ctx;
+    unsigned char *sm2cipher = tempargs->buf2;
+    size_t sm2ciphersize = tempargs->cipherlen;
+    int ret = 0, count;
+    OSSL_PARAM sparams[2] = {OSSL_PARAM_END, OSSL_PARAM_END};
+
+    sparams[0] = OSSL_PARAM_construct_utf8_string(OSSL_ASYM_CIPHER_PARAM_DIGEST,
+                                             "SM3", 0);
+    for (count = 0; COND(sm2enc_c[testnum][0]); count++) {
+        if (!EVP_PKEY_encrypt_init(sm2ctx[testnum])) {
+            BIO_printf(bio_err, "SM2 init encrypt failure\n");
+            ERR_print_errors(bio_err);
+            count = -1;
+            break;
+        }
+        EVP_PKEY_CTX_set_params(sm2ctx[testnum], sparams);
+        ret = EVP_PKEY_encrypt(sm2ctx[testnum], sm2cipher, &sm2ciphersize, buf,
+                                        32);
+        if (ret == 0) {
+            BIO_printf(bio_err, "SM2 encrypt failure\n");
+            ERR_print_errors(bio_err);
+            count = -1;
+            break;
+        }
+        /* update the latest returned size and always use the fixed buffer size */
+        tempargs->cipherlen = sm2ciphersize;
+    }
+
+    return count;
+}
+
+static int SM2_decrypt_loop(void *args)
+{
+    loopargs_t *tempargs = *(loopargs_t **) args;
+    unsigned char *buf = tempargs->buf;
+    EVP_PKEY_CTX **sm2ctx = tempargs->sm2_enc_ctx;
+    unsigned char *sm2cipher = tempargs->buf2;
+    size_t sm2cipherlen = tempargs->buflen;
+    int ret = 0, count;
+    OSSL_PARAM sparams[2] = {OSSL_PARAM_END, OSSL_PARAM_END};
+
+    for (count = 0; COND(sm2enc_c[testnum][1]); count++) {
+        if (!EVP_PKEY_decrypt_init(sm2ctx[testnum])) {
+            BIO_printf(bio_err, "SM2 decrypt init failure\n");
+            ERR_print_errors(bio_err);
+            count = -1;
+            break;
+        }
+        EVP_PKEY_CTX_set_params(sm2ctx[testnum], sparams);
+        ret = EVP_PKEY_decrypt(sm2ctx[testnum], buf, &sm2cipherlen, sm2cipher,
+                                        tempargs->cipherlen);
+        if (ret != 1) {
+            BIO_printf(bio_err, "SM2 decrypt failure\n");
+            ERR_print_errors(bio_err);
+            count = -1;
+            break;
+        }
+    }
+    return count;
+}
+
 #endif                         /* OPENSSL_NO_SM2 */
 
 static int run_benchmark(int async_jobs,
@@ -1400,6 +1530,20 @@ int speed_main(int argc, char **argv)
         0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, /* key2 */
         0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34  /* key3 */
     };
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+    static const struct {
+        const unsigned char *data;
+        unsigned int length;
+        unsigned int bits;
+    } rsa_keys[] = {
+        {   test512,   sizeof(test512),   512 },
+        {  test1024,  sizeof(test1024),  1024 },
+        {  test2048,  sizeof(test2048),  2048 },
+        {  test3072,  sizeof(test3072),  3072 },
+        {  test4096,  sizeof(test4096),  4096 },
+    };
+
+#else
     static const struct {
         const unsigned char *data;
         unsigned int length;
@@ -1413,6 +1557,7 @@ int speed_main(int argc, char **argv)
         {  test7680,  sizeof(test7680),  7680 },
         { test15360, sizeof(test15360), 15360 }
     };
+#endif
     uint8_t rsa_doit[RSA_NUM] = { 0 };
     int primes = RSA_DEFAULT_PRIME_NUM;
 #ifndef OPENSSL_NO_DH
@@ -1441,6 +1586,29 @@ int speed_main(int argc, char **argv)
      * lists accordingly.
      */
     static const EC_CURVE ec_curves[EC_NUM] = {
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+        /* Prime Curves */
+        {"secp160r1", NID_secp160r1, 160},
+        {"nistp192", NID_X9_62_prime192v1, 192},
+        {"nistp224", NID_secp224r1, 224},
+        {"nistp256", NID_X9_62_prime256v1, 256},
+        {"nistp384", NID_secp384r1, 384},
+        {"nistp521", NID_secp521r1, 521},
+# ifndef OPENSSL_NO_EC2M
+        /* Binary Curves */
+        {"nistk163", NID_sect163k1, 163},
+        {"nistk233", NID_sect233k1, 233},
+        {"nistk283", NID_sect283k1, 283},
+        {"nistk409", NID_sect409k1, 409},
+        {"nistk571", NID_sect571k1, 571},
+# endif
+        {"brainpoolP256r1", NID_brainpoolP256r1, 256},
+        {"brainpoolP256t1", NID_brainpoolP256t1, 256},
+        {"brainpoolP384r1", NID_brainpoolP384r1, 384},
+        {"brainpoolP384t1", NID_brainpoolP384t1, 384},
+        {"brainpoolP512r1", NID_brainpoolP512r1, 512},
+        {"brainpoolP512t1", NID_brainpoolP512t1, 512},
+#else
         /* Prime Curves */
         {"secp160r1", NID_secp160r1, 160},
         {"nistp192", NID_X9_62_prime192v1, 192},
@@ -1470,11 +1638,14 @@ int speed_main(int argc, char **argv)
         /* Other and ECDH only ones */
         {"X25519", NID_X25519, 253},
         {"X448", NID_X448, 448}
+#endif
     };
     static const EC_CURVE ed_curves[EdDSA_NUM] = {
+#ifndef OPENSSL_NO_DEVCRYPTOENG
         /* EdDSA */
         {"Ed25519", NID_ED25519, 253, 64},
         {"Ed448", NID_ED448, 456, 114}
+#endif
     };
 #ifndef OPENSSL_NO_SM2
     static const EC_CURVE sm2_curves[SM2_NUM] = {
@@ -1488,12 +1659,13 @@ int speed_main(int argc, char **argv)
     uint8_t eddsa_doit[EdDSA_NUM] = { 0 };
 
     /* checks declared curves against choices list. */
+#ifdef OPENSSL_NO_DEVCRYPTOENG    
     OPENSSL_assert(ed_curves[EdDSA_NUM - 1].nid == NID_ED448);
     OPENSSL_assert(strcmp(eddsa_choices[EdDSA_NUM - 1].name, "ed448") == 0);
 
     OPENSSL_assert(ec_curves[EC_NUM - 1].nid == NID_X448);
     OPENSSL_assert(strcmp(ecdh_choices[EC_NUM - 1].name, "ecdhx448") == 0);
-
+#endif
     OPENSSL_assert(ec_curves[ECDSA_NUM - 1].nid == NID_brainpoolP512t1);
     OPENSSL_assert(strcmp(ecdsa_choices[ECDSA_NUM - 1].name, "ecdsabrp512t1") == 0);
 
@@ -2921,7 +3093,7 @@ skip_hmac:
                 op_count = 1;
             } else {
                 pkey_print_message("sign", sm2_curves[testnum].name,
-                                   sm2_c[testnum][0],
+                                   sm2sign_c[testnum][0],
                                    sm2_curves[testnum].bits, seconds.sm2);
                 Time_F(START);
                 count = run_benchmark(async_jobs, SM2_sign_loop, loopargs);
@@ -2932,7 +3104,7 @@ skip_hmac:
                            "%ld %u bits %s signs in %.2fs \n",
                            count, sm2_curves[testnum].bits,
                            sm2_curves[testnum].name, d);
-                sm2_results[testnum][0] = (double)count / d;
+                sm2sign_results[testnum][0] = (double)count / d;
                 op_count = count;
             }
 
@@ -2951,7 +3123,7 @@ skip_hmac:
                 sm2_doit[testnum] = 0;
             } else {
                 pkey_print_message("verify", sm2_curves[testnum].name,
-                                   sm2_c[testnum][1],
+                                   sm2sign_c[testnum][1],
                                    sm2_curves[testnum].bits, seconds.sm2);
                 Time_F(START);
                 count = run_benchmark(async_jobs, SM2_verify_loop, loopargs);
@@ -2961,7 +3133,121 @@ skip_hmac:
                            : "%ld %u bits %s verify in %.2fs\n",
                            count, sm2_curves[testnum].bits,
                            sm2_curves[testnum].name, d);
-                sm2_results[testnum][1] = (double)count / d;
+                sm2sign_results[testnum][1] = (double)count / d;
+            }
+
+            if (op_count <= 1) {
+                /* if longer than 10s, don't do any more */
+                for (testnum++; testnum < SM2_NUM; testnum++)
+                    sm2_doit[testnum] = 0;
+            }
+        }
+    }
+
+    for (testnum = 0; testnum < SM2_NUM; testnum++) {
+        int st = 1;
+        EVP_PKEY *sm2_pkey = NULL;
+        OSSL_PARAM sparams[2] = {OSSL_PARAM_END, OSSL_PARAM_END};
+
+        if (!sm2_doit[testnum])
+            continue;           /* Ignore Curve */
+        /* Init signing and verification */
+        for (i = 0; i < loopargs_len; i++) {
+            EVP_PKEY_CTX *pctx = NULL;
+            st = 0;
+
+            sm2_pkey = NULL;
+
+            st = !((pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_SM2, NULL)) == NULL
+                || EVP_PKEY_keygen_init(pctx) <= 0
+                || EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx,
+                    sm2_curves[testnum].nid) <= 0
+                || EVP_PKEY_keygen(pctx, &sm2_pkey) <= 0);
+            EVP_PKEY_CTX_free(pctx);
+            if (st == 0)
+                break;
+
+            st = 0; /* set back to zero */
+            /* attach it sooner to rely on main final cleanup */
+            loopargs[i].sm2_enc_pkey[testnum] = sm2_pkey;
+            loopargs[i].cipherlen = loopargs[i].buflen;
+            
+            loopargs[i].sm2_enc_ctx[testnum] = EVP_PKEY_CTX_new(sm2_pkey, NULL);
+            if (loopargs[i].sm2_enc_ctx[testnum] == NULL)
+                break;            
+            st = 1;         /* mark loop as succeeded */
+        }
+        if (st == 0) {
+            BIO_printf(bio_err, "SM2 init failure.\n");
+            ERR_print_errors(bio_err);
+            op_count = 1;
+        } else {
+            for (i = 0; i < loopargs_len; i++) {
+                /* Perform SM2 v test */
+                if (!EVP_PKEY_encrypt_init(loopargs[i].sm2_enc_ctx[testnum])) {
+                    break;
+                }
+                if (!EVP_PKEY_CTX_set_params(loopargs[i].sm2_enc_ctx[testnum], sparams)) {
+                    break;
+                }
+                st = EVP_PKEY_encrypt(loopargs[i].sm2_enc_ctx[testnum], loopargs[i].buf2, &loopargs[i].cipherlen, loopargs[i].buf,
+                                        32);
+                if (st == 0)
+                    break;
+            }
+            if (st == 0) {
+                BIO_printf(bio_err,
+                           "SM2 encrypt failure.  No SM2 encrypt will be done.\n");
+                ERR_print_errors(bio_err);
+                op_count = 1;
+            } else {
+                pkey_print_message("encrypt", sm2_curves[testnum].name,
+                                   sm2enc_c[testnum][0],
+                                   sm2_curves[testnum].bits, seconds.sm2);
+                Time_F(START);
+                count = run_benchmark(async_jobs, SM2_encrypt_loop, loopargs);
+                d = Time_F(STOP);
+
+                BIO_printf(bio_err,
+                           mr ? "+R10:%ld:%u:%s:%.2f\n" :
+                           "%ld %u bits %s encrypt in %.2fs \n",
+                           count, sm2_curves[testnum].bits,
+                           sm2_curves[testnum].name, d);
+                sm2enc_results[testnum][0] = (double)count / d;
+                op_count = count;
+            }            
+            
+            /* Perform SM2 decrypt test */
+            for (i = 0; i < loopargs_len; i++) {
+                if (!EVP_PKEY_decrypt_init(loopargs[i].sm2_enc_ctx[testnum])) {
+                    break;
+                }
+                if (!EVP_PKEY_CTX_set_params(loopargs[i].sm2_enc_ctx[testnum], sparams)) {
+                    break;
+                }
+                st = EVP_PKEY_decrypt(loopargs[i].sm2_enc_ctx[testnum], loopargs[i].buf, &loopargs[i].buflen, loopargs[i].buf2,
+                                        loopargs[i].cipherlen);
+                if (st != 1)
+                    break;
+            }
+            if (st != 1) {
+                BIO_printf(bio_err,
+                           "SM2 decrypt failure.  No SM2 decrypt will be done.\n");
+                ERR_print_errors(bio_err);
+                sm2_doit[testnum] = 0;
+            } else {
+                pkey_print_message("decrypt", sm2_curves[testnum].name,
+                                   sm2enc_c[testnum][1],
+                                   sm2_curves[testnum].bits, seconds.sm2);
+                Time_F(START);
+                count = run_benchmark(async_jobs, SM2_decrypt_loop, loopargs);
+                d = Time_F(STOP);
+                BIO_printf(bio_err,
+                           mr ? "+R11:%ld:%u:%s:%.2f\n"
+                           : "%ld %u bits %s decrypt in %.2fs\n",
+                           count, sm2_curves[testnum].bits,
+                           sm2_curves[testnum].name, d);
+                sm2enc_results[testnum][1] = (double)count / d;
             }
 
             if (op_count <= 1) {
@@ -3297,12 +3583,27 @@ skip_hmac:
         if (mr)
             printf("+F7:%u:%u:%s:%f:%f\n",
                    k, sm2_curves[k].bits, sm2_curves[k].name,
-                   sm2_results[k][0], sm2_results[k][1]);
+                   sm2sign_results[k][0], sm2sign_results[k][1]);
+        else
+            printf("%4u bits SM2 (%s) %8.4fs %8.4fs %8.1f %8.1f\n",
+                   sm2_curves[k].bits, sm2_curves[k].name,
+                   1.0 / sm2sign_results[k][0], 1.0 / sm2sign_results[k][1],
+                   sm2sign_results[k][0], sm2sign_results[k][1]);
+        testnum = 1;
+        if (testnum && !mr) {
+            printf("%27sencrypt   decrypt encrypt/s decrypt/s\n", " ");
+            testnum = 0;
+        }
+
+        if (mr)
+            printf("+F7:%u:%u:%s:%f:%f\n",
+                   k, sm2_curves[k].bits, sm2_curves[k].name,
+                   sm2enc_results[k][0], sm2enc_results[k][1]);
         else
             printf("%4u bits SM2 (%s) %8.4fs %8.4fs %8.1f %8.1f\n",
                    sm2_curves[k].bits, sm2_curves[k].name,
-                   1.0 / sm2_results[k][0], 1.0 / sm2_results[k][1],
-                   sm2_results[k][0], sm2_results[k][1]);
+                   1.0 / sm2enc_results[k][0], 1.0 / sm2enc_results[k][1],
+                   sm2enc_results[k][0], sm2enc_results[k][1]);
     }
 #endif
 #ifndef OPENSSL_NO_DH
@@ -3376,6 +3677,8 @@ skip_hmac:
             EVP_MD_CTX_free(loopargs[i].sm2_vfy_ctx[k]);
             /* free pkey */
             EVP_PKEY_free(loopargs[i].sm2_pkey[k]);
+            EVP_PKEY_CTX_free(loopargs[i].sm2_enc_ctx[k]);
+            EVP_PKEY_free(loopargs[i].sm2_enc_pkey[k]);
         }
 #endif
         OPENSSL_free(loopargs[i].secret_a);
@@ -3603,10 +3906,12 @@ static int do_multi(int multi, int size_num)
                 sstrsep(&p, sep);
 
                 d = atof(sstrsep(&p, sep));
-                sm2_results[k][0] += d;
+                sm2sign_results[k][0] += d;
+                sm2enc_results[k][0] += d;
 
                 d = atof(sstrsep(&p, sep));
-                sm2_results[k][1] += d;
+                sm2sign_results[k][1] += d;
+                sm2enc_results[k][1] += d;
 # endif /* OPENSSL_NO_SM2 */
 # ifndef OPENSSL_NO_DH
             } else if (strncmp(buf, "+F8:", 4) == 0) {
diff --git a/crypto/ec/ec_curve.c b/crypto/ec/ec_curve.c
index b5b2f3342d..ad96bb84c0 100644
--- a/crypto/ec/ec_curve.c
+++ b/crypto/ec/ec_curve.c
@@ -3193,7 +3193,18 @@ static EC_GROUP *ec_group_new_from_data(OSSL_LIB_CTX *libctx,
 #endif
 
     EC_GROUP_set_curve_name(group, curve.nid);
-
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+        extern int cryptodev_has_pkc(void);
+        extern int cryptodev_pkc_unsupported_curve(int nid);
+        if (cryptodev_has_pkc() && 0 == cryptodev_pkc_unsupported_curve(curve.nid)) {
+            if (NULL == BN_copy(group->field, p))
+                goto err;
+            if(NULL == BN_copy(group->a,a))
+                goto err;
+            if(NULL == BN_copy(group->b,b))
+                goto err;
+        }
+#endif
     if ((P = EC_POINT_new(group)) == NULL) {
         ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
@@ -3204,10 +3215,29 @@ static EC_GROUP *ec_group_new_from_data(OSSL_LIB_CTX *libctx,
         ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+        if (cryptodev_has_pkc() && 0 == cryptodev_pkc_unsupported_curve(curve.nid)) {
+            if(NULL == BN_copy(P->X,x)) {
+                ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
+                goto err;
+            }
+            if(NULL == BN_copy(P->Y,y)) {
+                ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
+                goto err;
+            }
+            BN_set_word(P->Z,1);
+            P->Z_is_one = 1;
+        }
+        else if (!EC_POINT_set_affine_coordinates(group, P, x, y, ctx)) {
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
+            goto err;
+        }
+#else   
     if (!EC_POINT_set_affine_coordinates(group, P, x, y, ctx)) {
         ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
+#endif    
     if ((order = BN_bin2bn(params + 5 * param_len, param_len, NULL)) == NULL
         || !BN_set_word(x, (BN_ULONG)data->cofactor)) {
         ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
diff --git a/crypto/ec/ec_key.c b/crypto/ec/ec_key.c
index 59862884a9..c799e0540f 100644
--- a/crypto/ec/ec_key.c
+++ b/crypto/ec/ec_key.c
@@ -26,6 +26,11 @@
 #include "prov/providercommon.h"
 #include "crypto/bn.h"
 
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+extern int cryptodev_has_pkc(void);
+extern int cryptodev_pkc_unsupported_curve(int nid);
+#endif
+
 static int ecdsa_keygen_pairwise_test(EC_KEY *eckey, OSSL_CALLBACK *cb,
                                       void *cbarg);
 
@@ -526,8 +531,19 @@ int ossl_ec_key_public_check(const EC_KEY *eckey, BN_CTX *ctx)
     EC_POINT *point = NULL;
     const BIGNUM *order = NULL;
 
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+    if (!(cryptodev_has_pkc() && 0 == cryptodev_pkc_unsupported_curve(eckey->group->curve_name))) {
+        if (!ossl_ec_key_public_check_quick(eckey, ctx))
+            return 0;
+    }
+    else if (eckey == NULL || eckey->group == NULL || eckey->pub_key == NULL) {
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+#else
     if (!ossl_ec_key_public_check_quick(eckey, ctx))
         return 0;
+#endif
 
     point = EC_POINT_new(eckey->group);
     if (point == NULL)
@@ -538,6 +554,19 @@ int ossl_ec_key_public_check(const EC_KEY *eckey, BN_CTX *ctx)
         ERR_raise(ERR_LIB_EC, EC_R_INVALID_GROUP_ORDER);
         goto err;
     }
+    /* testing whether the pub_key is on the elliptic curve(also not at infinity) . */
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+    if (cryptodev_has_pkc() && 0 == cryptodev_pkc_unsupported_curve(eckey->group->curve_name)) {        
+        if (NULL != eckey->meth->EC_POINT_check) {
+            if (!eckey->meth->EC_POINT_check(eckey->group, eckey->pub_key, ctx)) {
+                 ERR_raise(ERR_LIB_EC, EC_R_POINT_IS_NOT_ON_CURVE);
+                goto err;
+            }
+        }
+        ret = 1;
+        goto err;
+    }
+#endif
     /* 5.6.2.3.3 (Step 4) : pub_key * order is the point at infinity. */
     if (!EC_POINT_mul(eckey->group, point, NULL, eckey->pub_key, order, ctx)) {
         ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
@@ -640,6 +669,13 @@ int ossl_ec_key_simple_check_key(const EC_KEY *eckey)
     if (!ossl_ec_key_public_check(eckey, ctx))
         goto err;
 
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+    if (cryptodev_has_pkc() && 0 == cryptodev_pkc_unsupported_curve(eckey->group->curve_name)) {
+        ok = 1;
+        goto err;
+    }
+#endif
+
     if (eckey->priv_key != NULL) {
         if (!ossl_ec_key_private_check(eckey)
             || !ossl_ec_key_pairwise_check(eckey, ctx))
diff --git a/crypto/ec/ec_local.h b/crypto/ec/ec_local.h
index f34e06aea8..6b69459ad0 100644
--- a/crypto/ec/ec_local.h
+++ b/crypto/ec/ec_local.h
@@ -658,6 +658,26 @@ struct ec_key_method_st {
                   const unsigned char *sigbuf, int sig_len, EC_KEY *eckey);
     int (*verify_sig)(const unsigned char *dgst, int dgst_len,
                       const ECDSA_SIG *sig, EC_KEY *eckey);
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+    int (*BN_add_word)(BIGNUM *a, BN_ULONG w);
+    int (*BN_add)(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+    int (*BN_sub)(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+    int (*BN_mul)(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
+    int (*BN_mod_add)(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
+    int (*BN_mod_sub)(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
+    int (*BN_mod_mul)(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
+    int (*BN_mod_sqr)(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
+    BIGNUM *(*BN_mod_inverse)(BIGNUM *ret, const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx);
+    int (*BN_mod)(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx);
+    int (*BN_nnmod)(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx);
+    int (*EC_POINT_add)(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
+                     const EC_POINT *b, BN_CTX *ctx);
+    int (*EC_POINT_double)(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
+                     BN_CTX *ctx);
+    int (*EC_POINT_mul)(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,
+                     const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);    
+    int (*EC_POINT_check)(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx);
+#endif
 };
 
 #define EC_KEY_METHOD_DYNAMIC   1
diff --git a/crypto/sm2/sm2_crypt.c b/crypto/sm2/sm2_crypt.c
index 5318c6199f..56e009270b 100644
--- a/crypto/sm2/sm2_crypt.c
+++ b/crypto/sm2/sm2_crypt.c
@@ -24,6 +24,9 @@
 #include <openssl/asn1.h>
 #include <openssl/asn1t.h>
 #include <string.h>
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+#include "../ec/ec_local.h"
+#endif
 
 typedef struct SM2_Ciphertext_st SM2_Ciphertext;
 DECLARE_ASN1_FUNCTIONS(SM2_Ciphertext)
@@ -183,7 +186,21 @@ int ossl_sm2_encrypt(const EC_KEY *key,
         ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
     }
-
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+    if (NULL != key->meth->EC_POINT_mul) {
+        if (!key->meth->EC_POINT_mul(group, kG, k, NULL, NULL, ctx)
+            || ((BN_copy(x1, kG->X) == NULL) || (BN_copy(y1, kG->Y) == NULL))
+            || !key->meth->EC_POINT_mul(group, kP, NULL, P, k, ctx)
+            || ((BN_copy(x2, kP->X) == NULL) || (BN_copy(y2, kP->Y) == NULL))) {
+            ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
+            goto done;
+        }
+    }
+    else {
+        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
+        goto done;
+    }
+#else
     if (!EC_POINT_mul(group, kG, k, NULL, NULL, ctx)
             || !EC_POINT_get_affine_coordinates(group, kG, x1, y1, ctx)
             || !EC_POINT_mul(group, kP, NULL, P, k, ctx)
@@ -191,7 +208,7 @@ int ossl_sm2_encrypt(const EC_KEY *key,
         ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
         goto done;
     }
-
+#endif
     if (BN_bn2binpad(x2, x2y2, field_size) < 0
             || BN_bn2binpad(y2, x2y2 + field_size, field_size) < 0) {
         ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
@@ -347,6 +364,21 @@ int ossl_sm2_decrypt(const EC_KEY *key,
         goto done;
     }
 
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+    if (NULL != key->meth->EC_POINT_mul) {
+        if (((BN_copy(C1->X, sm2_ctext->C1x) == NULL) || (BN_copy(C1->Y, sm2_ctext->C1y) == NULL))
+            || !key->meth->EC_POINT_mul(group, C1, NULL, C1, EC_KEY_get0_private_key(key),
+                             ctx)
+            || ((BN_copy(x2, C1->X) == NULL) || (BN_copy(y2, C1->Y) == NULL))) {
+            ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
+            goto done;
+        }
+    }
+    else {
+        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
+        goto done;
+    }
+#else
     if (!EC_POINT_set_affine_coordinates(group, C1, sm2_ctext->C1x,
                                          sm2_ctext->C1y, ctx)
             || !EC_POINT_mul(group, C1, NULL, C1, EC_KEY_get0_private_key(key),
@@ -355,7 +387,7 @@ int ossl_sm2_decrypt(const EC_KEY *key,
         ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
         goto done;
     }
-
+#endif
     if (BN_bn2binpad(x2, x2y2, field_size) < 0
             || BN_bn2binpad(y2, x2y2 + field_size, field_size) < 0
             || !ossl_ecdh_kdf_X9_63(msg_mask, msg_len, x2y2, 2 * field_size,
diff --git a/crypto/sm2/sm2_sign.c b/crypto/sm2/sm2_sign.c
index 88c67edfdb..3f43408014 100644
--- a/crypto/sm2/sm2_sign.c
+++ b/crypto/sm2/sm2_sign.c
@@ -19,6 +19,9 @@
 #include <openssl/evp.h>
 #include <openssl/bn.h>
 #include <string.h>
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+#include "../ec/ec_local.h"
+#endif
 
 int ossl_sm2_compute_z_digest(uint8_t *out,
                               const EVP_MD *digest,
@@ -253,6 +256,50 @@ static ECDSA_SIG *sm2_sig_gen(const EC_KEY *key, const BIGNUM *e)
             goto done;
         }
 
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+        if (NULL != key->meth->EC_POINT_mul) {
+            if (!key->meth->EC_POINT_mul(group, kG, k, NULL, NULL, ctx)
+                    || (BN_copy(x1, kG->X) == NULL)
+                    || !key->meth->BN_mod_add(r, e, x1, order, ctx)) {
+                ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
+                goto done;
+            }
+        }
+        else {
+            ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
+            goto done;
+        }
+        /* try again if r == 0 or r+k == n */
+        if (BN_is_zero(r))
+            continue;
+        if (NULL != key->meth->BN_add) {
+            if (!key->meth->BN_add(rk, r, k)) {
+                ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
+                goto done;
+            }
+        }
+        else {
+            ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
+            goto done;
+        } 
+
+        if (BN_cmp(rk, order) == 0)
+            continue;
+        if (NULL != key->meth->BN_add) {
+            if (!key->meth->BN_add(s, dA, BN_value_one())
+                    || !key->meth->BN_mod_inverse(s, s, order, ctx)
+                    || !key->meth->BN_mod_mul(tmp, dA, r, order, ctx)
+                    || !key->meth->BN_sub(tmp, k, tmp)
+                    || !key->meth->BN_mod_mul(s, s, tmp, order, ctx)) {
+                ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+                goto done;
+            }
+        }
+        else {
+            ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+            goto done;
+        }
+#else
         if (!EC_POINT_mul(group, kG, k, NULL, NULL, ctx)
                 || !EC_POINT_get_affine_coordinates(group, kG, x1, NULL,
                                                     ctx)
@@ -281,6 +328,7 @@ static ECDSA_SIG *sm2_sig_gen(const EC_KEY *key, const BIGNUM *e)
             ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
             goto done;
         }
+#endif
 
         /* try again if s == 0 */
         if (BN_is_zero(s))
@@ -340,11 +388,11 @@ static int sm2_sig_verify(const EC_KEY *key, const ECDSA_SIG *sig,
     /*
      * B1: verify whether r' in [1,n-1], verification failed if not
      * B2: verify whether s' in [1,n-1], verification failed if not
-     * B3: set M'~=ZA || M'
-     * B4: calculate e'=Hv(M'~)
-     * B5: calculate t = (r' + s') modn, verification failed if t=0
+     * B3: set M' ~= ZA || M'
+     * B4: calculate e' = Hv(M'~)
+     * B5: calculate t = (r' + s') mod n, verification failed if t=0
      * B6: calculate the point (x1', y1')=[s']G + [t]PA
-     * B7: calculate R=(e'+x1') modn, verification pass if yes, otherwise failed
+     * B7: calculate R=(e'+x1') mod n, verification pass if yes, otherwise failed
      */
 
     ECDSA_SIG_get0(sig, &r, &s);
@@ -356,17 +404,52 @@ static int sm2_sig_verify(const EC_KEY *key, const ECDSA_SIG *sig,
         ERR_raise(ERR_LIB_SM2, SM2_R_BAD_SIGNATURE);
         goto done;
     }
-
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+    if (NULL != key->meth->BN_mod_add) {
+        if (!key->meth->BN_mod_add(t, r, s, order, ctx)) {
+            ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+            goto done;
+        }
+    }
+    else {
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+        goto done;
+    }
+#else
     if (!BN_mod_add(t, r, s, order, ctx)) {
         ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
         goto done;
     }
+#endif
 
     if (BN_is_zero(t)) {
         ERR_raise(ERR_LIB_SM2, SM2_R_BAD_SIGNATURE);
         goto done;
     }
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+    if (NULL != key->meth->EC_POINT_mul) {
+        if (!key->meth->EC_POINT_mul(group, pt, s, EC_KEY_get0_public_key(key), t, ctx)
+            || (BN_copy(x1, pt->X) == NULL)) {
+            ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
+            goto done;
+        }
+    }
+    else {
+        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
+        goto done;
+    }
 
+    if (NULL != key->meth->BN_mod_add) {
+        if (!key->meth->BN_mod_add(t, e, x1, order, ctx)) {
+            ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+            goto done;
+        }
+    }
+    else {
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
+        goto done;
+    }
+#else
     if (!EC_POINT_mul(group, pt, s, EC_KEY_get0_public_key(key), t, ctx)
             || !EC_POINT_get_affine_coordinates(group, pt, x1, NULL, ctx)) {
         ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
@@ -377,6 +460,7 @@ static int sm2_sig_verify(const EC_KEY *key, const ECDSA_SIG *sig,
         ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
         goto done;
     }
+#endif
 
     if (BN_cmp(r, t) == 0)
         ret = 1;
diff --git a/engines/e_devcrypto.c b/engines/e_devcrypto.c
index 02f3abcc0a..93790c5fca 100644
--- a/engines/e_devcrypto.c
+++ b/engines/e_devcrypto.c
@@ -23,11 +23,24 @@
 #include <openssl/evp.h>
 #include <openssl/err.h>
 #include <openssl/engine.h>
+#include <openssl/rand.h>
 #include <openssl/objects.h>
 #include "crypto/cryptodev.h"
 #include "internal/nelem.h"
+#include <openssl/ec.h>
+#include "internal/constant_time.h"
+#include "../crypto/bn/bn_local.h"
+#include "../crypto/rsa/rsa_local.h"
+#ifndef OPENSSL_NO_DSA
+#include "../crypto/dsa/dsa_local.h"
+#endif
+#ifndef OPENSSL_NO_DH
+#include "../crypto/dh/dh_local.h"
+#endif
+#include "../crypto/ec/ec_local.h"
 
 /* #define ENGINE_DEVCRYPTO_DEBUG */
+#define TLS1_1_VERSION  0x0302
 
 #if CRYPTO_ALGORITHM_MIN < CRYPTO_ALGORITHM_MAX
 # define CHECK_BSD_STYLE_MACROS
@@ -45,12 +58,128 @@ typedef struct session2_op session_op_t;
 typedef struct session_op session_op_t;
 #endif
 
+#define HW_MAX_MODULUS_SIZE_BITS   4096
+#define HW_RSA_MAX_PUBEXP_BITS    4096
+#define HW_DH_MAX_MODULUS_BITS    8192
+#define CRYPTODEV_MAX_SIZE 1024 /* Maximum number of bytes for cryptodev. */
+
+#define HW_BASE_bits            (128)                 /* base size with bit unit (32 ~ 1024) */
+#define HW_BASE_chars           (HW_BASE_bits / 8)   /* base size with char unit */
+#define HW_BASE_sections        (HW_BASE_bits / BN_BITS2 /*  32bit */)  /* base size with limb unit */
+
+#define QUAD_BYTES            	72
+#define QUAD0_BYTE_OFFSET   	0
+#define QUAD1_BYTE_OFFSET   	(QUAD_BYTES * 1)
+#define QUAD2_BYTE_OFFSET   	(QUAD_BYTES * 2)
+#define QUAD3_BYTE_OFFSET   	(QUAD_BYTES * 3)
+
+#define SM2_FLG_CHECK_INFINITY       0x80000000
+
+/* input the size with unit of unsigned int */
+#if (HW_BASE_sections == 1)
+#define TO_HW_BASE_SIZE(size_int)  (size_int)
+#elif (HW_BASE_sections == 2)
+#define TO_HW_BASE_SIZE(size_int) (( (size_int)  + /*(HW_BASE_sections - 1)*/1 ) >> 1 )
+#elif (HW_BASE_sections == 4)
+#define TO_HW_BASE_SIZE(size_int) (( (size_int)  + /*(HW_BASE_sections - 1)*/3 ) >> 2 )
+#elif (HW_BASE_sections == 8)
+#define TO_HW_BASE_SIZE(size_int) (( (size_int)  + /*(HW_BASE_sections - 1)*/7 ) >> 3 )
+#elif (HW_BASE_sections == 16)
+#define TO_HW_BASE_SIZE(size_int) (( (size_int)  + /*(HW_BASE_sections - 1)*/15 ) >> 4 ) // >> 4 for 16 uint32 , >> 5 for 32 uint32
+#elif (HW_BASE_sections == 32)
+#define TO_HW_BASE_SIZE(size_int) (( (size_int)  + /*(HW_BASE_sections - 1)*/31 ) >> 5 ) // >> 4 for 16 uint32 , >> 5 for 32 uint32
+#else
+#error "This HW base size dosen't be supported"
+#endif  /* HW_BASE_sections */
+
+typedef	unsigned char	bool;
+enum {
+	false	= 0,
+	true	= 1
+};
+typedef struct _cryptodev_ecc_point_t
+{
+    unsigned char *x; /* X coordinate (affine) */
+    unsigned short x_size;
+    unsigned char *y; /* Y coordinate (affine) */
+    unsigned short y_size;
+} cryptodev_ecc_point_t;
+
+int cryptodev_ec_keygen(EC_KEY *eckey);
+static unsigned int cryptodev_asymfeat = 0;
+static RSA_METHOD *cryptodev_rsa = NULL;
+#ifndef OPENSSL_NO_DSA
+static DSA_METHOD *cryptodev_dsa = NULL;
+#endif
+#ifndef OPENSSL_NO_DH
+static DH_METHOD *cryptodev_dh = NULL;
+#endif
+
+static int bn2crparam(const BIGNUM *a, struct crparam *crp);
+static int crparam2bn(struct crparam *crp, BIGNUM *a);
+static void zapparams(struct crypt_kop *kop);
+static int curve2field(int curve_nid);
+static int cryptodev_bn_is_prime(BIGNUM *X);
+static int cryptodev_bn_generate_prime(BIGNUM *PRIME,int rsabits);
+static int cryptodev_bn_check_small_factors( const BIGNUM *X );
+static int cryptodev_bn_mod(BIGNUM *R, const BIGNUM *A, const BIGNUM *N);
+static int cryptodev_bn_gcd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+static int cryptodev_bn_inv_mod( BIGNUM *X, const BIGNUM *A, const BIGNUM *N);
+static int cryptodev_bn_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+static int cryptodev_bn_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+static int cryptodev_bn_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+static int cryptodev_bn_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+static int cryptodev_bn_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
+static int cryptodev_bn_mul2(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
+static int cryptodev_bn_mod_exp(BIGNUM *R, const BIGNUM *A, const BIGNUM *B, const BIGNUM *N);
+static inline int cryptodev_bn_int_cmp(const BIGNUM *a, int i);
+static inline int cryptodev_bn_int_add(BIGNUM *r, BIGNUM *a, int i);
+static int cryptodev_rsa_keygen (RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
+static int cryptodev_bn_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx);
+static int cryptodev_bn_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
+static int cryptodev_bn_mod_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
+static int cryptodev_bn_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx);
+static BIGNUM *cryptodev_bn_mod_inverse(BIGNUM *ret, const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx);
+static int cryptodev_ec_point_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
+                 const EC_POINT *b, BN_CTX *ctx);
+static int cryptodev_ec_point_double(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
+                 BN_CTX *ctx);
+static int cryptodev_ec_point_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,
+                 const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);
+#ifndef OPENSSL_NO_DSA
+static DSA_SIG *cryptodev_dsa_do_sign(const unsigned char *dgst, int dlen,
+                                      DSA *dsa);
+static int cryptodev_dsa_verify(const unsigned char *dgst, int dgst_len,
+                                DSA_SIG *sig, DSA *dsa);
+static int cryptodev_dsa_keygen(DSA *dsa);
+#endif
+static ECDSA_SIG *cryptodev_ecdsa_sign_sig(const unsigned char *dgst, int dgst_len,
+                                const BIGNUM *in_kinv, const BIGNUM *in_r, EC_KEY *eckey);
+static int cryptodev_ecdsa_verify(int type, const unsigned char *dgst, int dgst_len,
+                      const unsigned char *sigbuf, int sig_len, EC_KEY *eckey);
+
+#ifndef OPENSSL_NO_DH
+static int cryptodev_dh_generate_key(DH *dh);
+static int cryptodev_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh);
+#endif
+static int cryptodev_ecdh_compute_key(unsigned char **pout, size_t *outlen, const EC_POINT *pub_key,
+                            const EC_KEY *ecdh);
+
 /*
  * ONE global file descriptor for all sessions.  This allows operations
  * such as digest session data copying (see digest_copy()), but is also
  * saner...  why re-open /dev/crypto for every session?
  */
-static int cfd = -1;
+static int cfd = -1, rand_fd = 0;
+static int get_dev_crypto(void)
+{
+    return (cfd);
+}
+
+static void put_dev_crypto(int fd)
+{
+
+}
 #define DEVCRYPTO_REQUIRE_ACCELERATED 0 /* require confirmation of acceleration */
 #define DEVCRYPTO_USE_SOFTWARE        1 /* allow software drivers */
 #define DEVCRYPTO_REJECT_SOFTWARE     2 /* only disallow confirmed software drivers */
@@ -107,10 +236,14 @@ struct cipher_ctx {
     session_op_t sess;
     int op;                      /* COP_ENCRYPT or COP_DECRYPT */
     unsigned long mode;          /* EVP_CIPH_*_MODE */
+    unsigned char *aad;
+    unsigned int aad_len;
+    unsigned int len;
 
     /* to handle ctr mode being a stream cipher */
     unsigned char partial[EVP_MAX_BLOCK_LENGTH];
     unsigned int blocksize, num;
+    unsigned int tls_ver;
 };
 
 static const struct cipher_data_st {
@@ -120,49 +253,71 @@ static const struct cipher_data_st {
     int ivlen;
     int flags;
     int devcryptoid;
+    int mackeylen;
 } cipher_data[] = {
 #ifndef OPENSSL_NO_DES
-    { NID_des_cbc, 8, 8, 8, EVP_CIPH_CBC_MODE, CRYPTO_DES_CBC },
-    { NID_des_ede3_cbc, 8, 24, 8, EVP_CIPH_CBC_MODE, CRYPTO_3DES_CBC },
+    { NID_des_ecb, 8, 8, 8, EVP_CIPH_ECB_MODE, CRYPTO_DES_ECB, 0 },
+    { NID_des_cbc, 8, 8, 8, EVP_CIPH_CBC_MODE, CRYPTO_DES_CBC, 0 },    
+    { NID_des_cfb64, 8, 8, 8, EVP_CIPH_CFB_MODE, CRYPTO_DES_CFB, 0 },
+    { NID_des_ofb64, 8, 8, 8, EVP_CIPH_OFB_MODE, CRYPTO_DES_OFB, 0 },
+    { NID_des_ede3_ecb, 8, 24, 8, EVP_CIPH_ECB_MODE, CRYPTO_3DES_ECB, 0 },
+    { NID_des_ede3_cbc, 8, 24, 8, EVP_CIPH_CBC_MODE, CRYPTO_3DES_CBC, 0 },
+    { NID_des_ede3_cfb64, 8, 24, 8, EVP_CIPH_CFB_MODE, CRYPTO_3DES_CFB, 0 },
+    { NID_des_ede3_ofb64, 8, 24, 8, EVP_CIPH_OFB_MODE, CRYPTO_3DES_OFB, 0 },
 #endif
 #ifndef OPENSSL_NO_BF
-    { NID_bf_cbc, 8, 16, 8, EVP_CIPH_CBC_MODE, CRYPTO_BLF_CBC },
+    { NID_bf_cbc, 8, 16, 8, EVP_CIPH_CBC_MODE, CRYPTO_BLF_CBC, 0 },
 #endif
 #ifndef OPENSSL_NO_CAST
-    { NID_cast5_cbc, 8, 16, 8, EVP_CIPH_CBC_MODE, CRYPTO_CAST_CBC },
+    { NID_cast5_cbc, 8, 16, 8, EVP_CIPH_CBC_MODE, CRYPTO_CAST_CBC, 0 },
 #endif
-    { NID_aes_128_cbc, 16, 128 / 8, 16, EVP_CIPH_CBC_MODE, CRYPTO_AES_CBC },
-    { NID_aes_192_cbc, 16, 192 / 8, 16, EVP_CIPH_CBC_MODE, CRYPTO_AES_CBC },
-    { NID_aes_256_cbc, 16, 256 / 8, 16, EVP_CIPH_CBC_MODE, CRYPTO_AES_CBC },
+    { NID_aes_128_cbc, 16, 128 / 8, 16, EVP_CIPH_CBC_MODE, CRYPTO_AES_CBC, 0 },
+    { NID_aes_192_cbc, 16, 192 / 8, 16, EVP_CIPH_CBC_MODE, CRYPTO_AES_CBC, 0 },
+    { NID_aes_256_cbc, 16, 256 / 8, 16, EVP_CIPH_CBC_MODE, CRYPTO_AES_CBC, 0 },  
+    { NID_aes_128_cfb128, 16, 128 / 8, 16, EVP_CIPH_CFB_MODE, CRYPTO_AES_CFB128, 0 },
+    { NID_aes_192_cfb128, 16, 192 / 8, 16, EVP_CIPH_CFB_MODE, CRYPTO_AES_CFB128, 0 },
+    { NID_aes_256_cfb128, 16, 256 / 8, 16, EVP_CIPH_CFB_MODE, CRYPTO_AES_CFB128, 0 },
+    { NID_aes_128_ofb128, 16, 128 / 8, 16, EVP_CIPH_OFB_MODE, CRYPTO_AES_OFB, 0 },
+    { NID_aes_192_ofb128, 16, 192 / 8, 16, EVP_CIPH_OFB_MODE, CRYPTO_AES_OFB, 0 },
+    { NID_aes_256_ofb128, 16, 256 / 8, 16, EVP_CIPH_OFB_MODE, CRYPTO_AES_OFB, 0 },
+    { NID_aes_128_cbc_hmac_sha1, 16, 16, 16,
+            EVP_CIPH_CBC_MODE | EVP_CIPH_FLAG_AEAD_CIPHER,
+            CRYPTO_TLS11_AES_CBC_HMAC_SHA1, 20 },
+    { NID_aes_256_cbc_hmac_sha1, 16, 32, 16,
+            EVP_CIPH_CBC_MODE | EVP_CIPH_FLAG_AEAD_CIPHER,
+            CRYPTO_TLS11_AES_CBC_HMAC_SHA1, 20 },
+    { NID_aes_128_cbc_hmac_sha256, 16, 16, 16,
+           EVP_CIPH_CBC_MODE | EVP_CIPH_FLAG_AEAD_CIPHER,
+           CRYPTO_TLS12_AES_CBC_HMAC_SHA256, 32 },
+    { NID_aes_256_cbc_hmac_sha256, 16, 32, 16,
+           EVP_CIPH_CBC_MODE | EVP_CIPH_FLAG_AEAD_CIPHER,
+           CRYPTO_TLS12_AES_CBC_HMAC_SHA256, 32 },
 #ifndef OPENSSL_NO_RC4
-    { NID_rc4, 1, 16, 0, EVP_CIPH_STREAM_CIPHER, CRYPTO_ARC4 },
-#endif
-#if !defined(CHECK_BSD_STYLE_MACROS) || defined(CRYPTO_AES_CTR)
-    { NID_aes_128_ctr, 16, 128 / 8, 16, EVP_CIPH_CTR_MODE, CRYPTO_AES_CTR },
-    { NID_aes_192_ctr, 16, 192 / 8, 16, EVP_CIPH_CTR_MODE, CRYPTO_AES_CTR },
-    { NID_aes_256_ctr, 16, 256 / 8, 16, EVP_CIPH_CTR_MODE, CRYPTO_AES_CTR },
-#endif
-#if 0                            /* Not yet supported */
-    { NID_aes_128_xts, 16, 128 / 8 * 2, 16, EVP_CIPH_XTS_MODE, CRYPTO_AES_XTS },
-    { NID_aes_256_xts, 16, 256 / 8 * 2, 16, EVP_CIPH_XTS_MODE, CRYPTO_AES_XTS },
-#endif
-#if !defined(CHECK_BSD_STYLE_MACROS) || defined(CRYPTO_AES_ECB)
-    { NID_aes_128_ecb, 16, 128 / 8, 0, EVP_CIPH_ECB_MODE, CRYPTO_AES_ECB },
-    { NID_aes_192_ecb, 16, 192 / 8, 0, EVP_CIPH_ECB_MODE, CRYPTO_AES_ECB },
-    { NID_aes_256_ecb, 16, 256 / 8, 0, EVP_CIPH_ECB_MODE, CRYPTO_AES_ECB },
-#endif
-#if 0                            /* Not yet supported */
-    { NID_aes_128_gcm, 16, 128 / 8, 16, EVP_CIPH_GCM_MODE, CRYPTO_AES_GCM },
-    { NID_aes_192_gcm, 16, 192 / 8, 16, EVP_CIPH_GCM_MODE, CRYPTO_AES_GCM },
-    { NID_aes_256_gcm, 16, 256 / 8, 16, EVP_CIPH_GCM_MODE, CRYPTO_AES_GCM },
+    { NID_rc4, 1, 16, 0, EVP_CIPH_STREAM_CIPHER, CRYPTO_ARC4, 0 },
 #endif
+    { NID_aes_128_ctr, 16, 128 / 8, 16, EVP_CIPH_CTR_MODE, CRYPTO_AES_CTR, 0 },
+    { NID_aes_192_ctr, 16, 192 / 8, 16, EVP_CIPH_CTR_MODE, CRYPTO_AES_CTR, 0 },
+    { NID_aes_256_ctr, 16, 256 / 8, 16, EVP_CIPH_CTR_MODE, CRYPTO_AES_CTR, 0 },
+    { NID_aes_128_ecb, 16, 128 / 8, 0, EVP_CIPH_ECB_MODE, CRYPTO_AES_ECB, 0 },
+    { NID_aes_192_ecb, 16, 192 / 8, 0, EVP_CIPH_ECB_MODE, CRYPTO_AES_ECB, 0 },
+    { NID_aes_256_ecb, 16, 256 / 8, 0, EVP_CIPH_ECB_MODE, CRYPTO_AES_ECB, 0 },
+#if 0    
+    { NID_aes_128_xts, 16, 128 / 8 * 2, 16, EVP_CIPH_XTS_MODE, CRYPTO_AES_XTS, 0 },
+    { NID_aes_256_xts, 16, 256 / 8 * 2, 16, EVP_CIPH_XTS_MODE, CRYPTO_AES_XTS, 0 },
+    { NID_aes_128_gcm, 16, 128 / 8, 16, EVP_CIPH_GCM_MODE, CRYPTO_AES_GCM, 0 },
+    { NID_aes_192_gcm, 16, 192 / 8, 16, EVP_CIPH_GCM_MODE, CRYPTO_AES_GCM, 0 },
+    { NID_aes_256_gcm, 16, 256 / 8, 16, EVP_CIPH_GCM_MODE, CRYPTO_AES_GCM, 0 },
+    { NID_aes_128_ccm, 16, 128 / 8, 16, EVP_CIPH_CCM_MODE, CRYPTO_AES_CCM, 0 },
+    { NID_aes_192_ccm, 16, 192 / 8, 16, EVP_CIPH_CCM_MODE, CRYPTO_AES_CCM, 0 },
+    { NID_aes_256_ccm, 16, 256 / 8, 16, EVP_CIPH_CCM_MODE, CRYPTO_AES_CCM, 0 },
+#endif    
 #ifndef OPENSSL_NO_CAMELLIA
     { NID_camellia_128_cbc, 16, 128 / 8, 16, EVP_CIPH_CBC_MODE,
-      CRYPTO_CAMELLIA_CBC },
+      CRYPTO_CAMELLIA_CBC, 0 },
     { NID_camellia_192_cbc, 16, 192 / 8, 16, EVP_CIPH_CBC_MODE,
-      CRYPTO_CAMELLIA_CBC },
+      CRYPTO_CAMELLIA_CBC, 0 },
     { NID_camellia_256_cbc, 16, 256 / 8, 16, EVP_CIPH_CBC_MODE,
-      CRYPTO_CAMELLIA_CBC },
+      CRYPTO_CAMELLIA_CBC, 0 },
 #endif
 };
 
@@ -197,6 +352,193 @@ static const struct cipher_data_st *get_cipher_data(int nid)
     return &cipher_data[get_cipher_data_index(nid)];
 }
 
+/*
+ * Save the encryption key provided by upper layers. This function is called
+ * by EVP_CipherInit_ex to initialize the algorithm's extra data. We can't do
+ * much here because the mac key is not available. The next call should/will
+ * be to cryptodev_cbc_hmac_sha1_ctrl with parameter
+ * EVP_CTRL_AEAD_SET_MAC_KEY, to set the hmac key. There we call CIOCGSESSION
+ * with both the crypto and hmac keys.
+ */
+static int cryptodev_init_aead_key(EVP_CIPHER_CTX *ctx,
+                const unsigned char *key, const unsigned char *iv, int enc)
+{
+    struct cipher_ctx *state = EVP_CIPHER_CTX_get_cipher_data(ctx);
+    struct session_op *sess = &state->sess;
+    int cipher = -1, i;
+
+    for (i = 0; cipher_data[i].devcryptoid; i++) {
+        if (EVP_CIPHER_CTX_nid(ctx) == cipher_data[i].nid &&
+            EVP_CIPHER_CTX_iv_length(ctx) <= cipher_data[i].ivlen &&
+            EVP_CIPHER_CTX_key_length(ctx) == cipher_data[i].keylen) {
+            cipher = cipher_data[i].devcryptoid;
+            break;
+        }
+    }
+
+    if (!cipher_data[i].devcryptoid)
+        return (0);
+
+    memset(sess, 0, sizeof(*sess));
+
+    sess->key = (void *) key;
+    sess->keylen = EVP_CIPHER_CTX_key_length(ctx);
+    sess->cipher = cipher;
+
+    /* for whatever reason, (1) means success */
+    return 1;
+}
+
+static int cryptodev_aead_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                 const unsigned char *in, size_t len)
+{
+    struct crypt_auth_op cryp;
+    struct cipher_ctx *state = EVP_CIPHER_CTX_get_cipher_data(ctx);
+    struct session_op *sess = &state->sess;
+    const void *iiv;
+    unsigned char save_iv[EVP_MAX_IV_LENGTH];
+
+    if (cfd < 0)
+        return (0);
+    if (!len)
+        return (1);
+    if ((len % EVP_CIPHER_CTX_block_size(ctx)) != 0)
+        return (0);
+
+    memset(&cryp, 0, sizeof(cryp));
+
+    if (EVP_CIPHER_CTX_iv_length(ctx) > 0) {
+        if (!EVP_CIPHER_CTX_encrypting(ctx)) {
+            iiv = in + len - EVP_CIPHER_CTX_iv_length(ctx);
+            memcpy(save_iv, iiv, EVP_CIPHER_CTX_iv_length(ctx));
+
+            if (state->tls_ver >= TLS1_1_VERSION) {
+                memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), in,
+                       EVP_CIPHER_CTX_iv_length(ctx));
+                in += EVP_CIPHER_CTX_iv_length(ctx);
+                out += EVP_CIPHER_CTX_iv_length(ctx);
+                len -= EVP_CIPHER_CTX_iv_length(ctx);
+            }
+        }
+        cryp.iv = (void *) EVP_CIPHER_CTX_iv(ctx);
+    } else
+        cryp.iv = NULL;
+
+    /* TODO: make a seamless integration with cryptodev flags */
+    switch (EVP_CIPHER_CTX_nid(ctx)) {
+    case NID_aes_128_cbc_hmac_sha1:
+    case NID_aes_256_cbc_hmac_sha1:
+    case NID_aes_128_cbc_hmac_sha256:
+    case NID_aes_256_cbc_hmac_sha256:
+        cryp.flags = COP_FLAG_AEAD_TLS_TYPE;
+    }
+    cryp.ses = sess->ses;
+    cryp.len = state->len;
+    cryp.src = (void *) in;
+    cryp.dst = (void *) out;
+    cryp.auth_src = state->aad;
+    cryp.auth_len = state->aad_len;
+
+    cryp.op = EVP_CIPHER_CTX_encrypting(ctx) ? COP_ENCRYPT : COP_DECRYPT;
+
+    if (ioctl(cfd, CIOCAUTHCRYPT, &cryp) == -1) {
+        /*
+         * XXX need better errror handling this can fail for a number of
+         * different reasons.
+         */
+        return 0;
+    }
+
+    if (EVP_CIPHER_CTX_iv_length(ctx) > 0) {
+        if (EVP_CIPHER_CTX_encrypting(ctx))
+            iiv = out + len - EVP_CIPHER_CTX_iv_length(ctx);
+        else
+            iiv = save_iv;
+
+        memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), iiv,
+               EVP_CIPHER_CTX_iv_length(ctx));
+    }
+    return 1;
+}
+
+static int cryptodev_cbc_hmac_sha1_ctrl(EVP_CIPHER_CTX *ctx, int type,
+                                        int arg, void *ptr)
+{
+    switch (type) {
+    case EVP_CTRL_AEAD_SET_MAC_KEY:
+        {
+        /* TODO: what happens with hmac keys larger than 64 bytes? */
+            struct cipher_ctx *state =
+                EVP_CIPHER_CTX_get_cipher_data(ctx);
+            struct session_op *sess = &state->sess;
+
+            /* the rest should have been set in cryptodev_init_aead_key */
+            sess->mackey = ptr;
+            sess->mackeylen = arg;
+            if (ioctl(cfd, CIOCGSESSION, sess) == -1)
+                return 0;
+
+            return 1;
+        }
+    case EVP_CTRL_AEAD_TLS1_AAD:
+        {
+            /* ptr points to the associated data buffer of 13 bytes */
+            struct cipher_ctx *state =
+                EVP_CIPHER_CTX_get_cipher_data(ctx);
+            unsigned char *p = ptr;
+            unsigned int cryptlen = p[arg - 2] << 8 | p[arg - 1];
+            unsigned int maclen;
+            unsigned int blocksize = EVP_CIPHER_CTX_block_size(ctx);
+            int ret;
+
+            state->tls_ver = p[arg - 4] << 8 | p[arg - 3];
+            state->aad = ptr;
+            state->aad_len = arg;
+
+            /* TODO: this should be an extension of EVP_CIPHER struct */
+            switch (EVP_CIPHER_CTX_nid(ctx)) {
+            case NID_aes_128_cbc_hmac_sha1:
+            case NID_aes_256_cbc_hmac_sha1:
+                maclen = SHA_DIGEST_LENGTH;
+                break;
+            case NID_aes_128_cbc_hmac_sha256:
+            case NID_aes_256_cbc_hmac_sha256:
+                maclen = SHA256_DIGEST_LENGTH;
+                break;
+            default:
+            /*
+             * Only above 4 supported NIDs are used to enter to this
+             * function. If any other NID reaches this function,
+             * there's a grave coding error further down.
+             */
+                assert("Code that never should be reached" == NULL);
+                return -1;
+            }
+
+            /* space required for encryption (not only TLS padding) */
+            if (EVP_CIPHER_CTX_encrypting(ctx)) {
+                if (state->tls_ver >= TLS1_1_VERSION) {
+                    p[arg - 2] = (cryptlen - blocksize) >> 8;
+                    p[arg - 1] = (cryptlen - blocksize);
+                }
+                ret = (int)(((cryptlen + maclen +
+                      blocksize) & -blocksize) - cryptlen);
+            } else {
+                if (state->tls_ver >= TLS1_1_VERSION) {
+                    cryptlen -= blocksize;
+                    p[arg - 2] = cryptlen >> 8;
+                    p[arg - 1] = cryptlen;
+                }
+                ret = maclen;
+            }
+            state->len = cryptlen;
+            return ret;
+        }
+    default:
+        return -1;
+    }
+}
+
 /*
  * Following are the three necessary functions to map OpenSSL functionality
  * with cryptodev.
@@ -219,7 +561,10 @@ static int cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     cipher_ctx->sess.cipher = cipher_d->devcryptoid;
     cipher_ctx->sess.keylen = cipher_d->keylen;
     cipher_ctx->sess.key = (void *)key;
-    cipher_ctx->op = enc ? COP_ENCRYPT : COP_DECRYPT;
+    if (EVP_CIPH_CTR_MODE == EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)))
+        cipher_ctx->op = COP_ENCRYPT;
+    else
+        cipher_ctx->op = enc ? COP_ENCRYPT : COP_DECRYPT;
     cipher_ctx->mode = cipher_d->flags & EVP_CIPH_MODE;
     cipher_ctx->blocksize = cipher_d->blocksize;
 #ifdef CIOCGSESSION2
@@ -258,26 +603,22 @@ static int cipher_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     cryp.dst = (void *)out;
     cryp.iv = (void *)iv;
     cryp.op = cipher_ctx->op;
-#if !defined(COP_FLAG_WRITE_IV)
-    cryp.flags = 0;
-
-    ivlen = EVP_CIPHER_CTX_get_iv_length(ctx);
-    if (ivlen > 0)
-        switch (cipher_ctx->mode) {
-        case EVP_CIPH_CBC_MODE:
-            assert(inl >= ivlen);
-            if (!EVP_CIPHER_CTX_is_encrypting(ctx)) {
-                ivptr = in + inl - ivlen;
-                memcpy(saved_iv, ivptr, ivlen);
-            }
-            break;
-
-        case EVP_CIPH_CTR_MODE:
-            break;
-
-        default: /* should not happen */
-            return 0;
+#if !defined(COP_FLAG_WRITE_IV)    
+    if (EVP_CIPH_CTR_MODE == EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)))
+    	cryp.flags = COP_FLAG_WRITE_IV;
+	else
+        cryp.flags = 0;
+
+    ivlen = EVP_CIPHER_CTX_get_iv_length(ctx);    
+    if (ivlen > 0) {
+        if ((EVP_CIPH_CTR_MODE != cipher_ctx->mode) && (!EVP_CIPHER_CTX_encrypting(ctx))) {
+            ivptr = in + inl - ivlen;
+            memcpy(saved_iv, ivptr, ivlen);
         }
+    }
+    else
+        cryp.iv = NULL;
+    
 #else
     cryp.flags = COP_FLAG_WRITE_IV;
 #endif
@@ -288,9 +629,8 @@ static int cipher_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     }
 
 #if !defined(COP_FLAG_WRITE_IV)
-    if (ivlen > 0)
-        switch (cipher_ctx->mode) {
-        case EVP_CIPH_CBC_MODE:
+    if (ivlen > 0)        
+        if (EVP_CIPH_CTR_MODE != cipher_ctx->mode) {        
             assert(inl >= ivlen);
             if (EVP_CIPHER_CTX_is_encrypting(ctx))
                 ivptr = out + inl - ivlen;
@@ -298,68 +638,12 @@ static int cipher_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                 ivptr = saved_iv;
 
             memcpy(iv, ivptr, ivlen);
-            break;
-
-        case EVP_CIPH_CTR_MODE:
-            nblocks = (inl + cipher_ctx->blocksize - 1)
-                      / cipher_ctx->blocksize;
-            do {
-                ivlen--;
-                nblocks += iv[ivlen];
-                iv[ivlen] = (uint8_t) nblocks;
-                nblocks >>= 8;
-            } while (ivlen);
-            break;
-
-        default: /* should not happen */
-            return 0;
         }
 #endif
 
     return 1;
 }
 
-static int ctr_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                         const unsigned char *in, size_t inl)
-{
-    struct cipher_ctx *cipher_ctx =
-        (struct cipher_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
-    size_t nblocks, len;
-
-    /* initial partial block */
-    while (cipher_ctx->num && inl) {
-        (*out++) = *(in++) ^ cipher_ctx->partial[cipher_ctx->num];
-        --inl;
-        cipher_ctx->num = (cipher_ctx->num + 1) % cipher_ctx->blocksize;
-    }
-
-    /* full blocks */
-    if (inl > (unsigned int) cipher_ctx->blocksize) {
-        nblocks = inl/cipher_ctx->blocksize;
-        len = nblocks * cipher_ctx->blocksize;
-        if (cipher_do_cipher(ctx, out, in, len) < 1)
-            return 0;
-        inl -= len;
-        out += len;
-        in += len;
-    }
-
-    /* final partial block */
-    if (inl) {
-        memset(cipher_ctx->partial, 0, cipher_ctx->blocksize);
-        if (cipher_do_cipher(ctx, cipher_ctx->partial, cipher_ctx->partial,
-            cipher_ctx->blocksize) < 1)
-            return 0;
-        while (inl--) {
-            out[cipher_ctx->num] = in[cipher_ctx->num]
-                                   ^ cipher_ctx->partial[cipher_ctx->num];
-            cipher_ctx->num++;
-        }
-    }
-
-    return 1;
-}
-
 static int cipher_ctrl(EVP_CIPHER_CTX *ctx, int type, int p1, void* p2)
 {
     struct cipher_ctx *cipher_ctx =
@@ -463,6 +747,7 @@ static void prepare_cipher_methods(void)
          */
         sess.cipher = cipher_data[i].devcryptoid;
         sess.keylen = cipher_data[i].keylen;
+        sess.mackeylen = cipher_data[i].mackeylen;
 
 #ifdef CIOCGSESSION2
         /*
@@ -490,10 +775,17 @@ static void prepare_cipher_methods(void)
 
         cipher_mode = cipher_data[i].flags & EVP_CIPH_MODE;
 
-        do_cipher = (cipher_mode == EVP_CIPH_CTR_MODE ?
-                                              ctr_do_cipher :
-                                              cipher_do_cipher);
+        do_cipher = cipher_do_cipher;
 
+        if (cipher_data[i].nid == NID_aes_128_cbc_hmac_sha1
+                || cipher_data[i].nid == NID_aes_256_cbc_hmac_sha1
+                || cipher_data[i].nid == NID_aes_128_cbc_hmac_sha256
+                || cipher_data[i].nid == NID_aes_256_cbc_hmac_sha256) {
+                init = cryptodev_init_aead_key;
+                do_cipher = cryptodev_aead_cipher;
+                ctrl = cryptodev_cbc_hmac_sha1_ctrl;
+                flags = cipher_data[i].flags;
+        }
         if ((known_cipher_methods[i] =
                  EVP_CIPHER_meth_new(cipher_data[i].nid,
                                      cipher_mode == EVP_CIPH_CTR_MODE ? 1 :
@@ -538,11 +830,17 @@ static void prepare_cipher_methods(void)
             }
 #endif /* CIOCGSESSINFO */
         }
+
+        if (cipher_data[i].nid == NID_aes_128_cbc_hmac_sha1
+                || cipher_data[i].nid == NID_aes_256_cbc_hmac_sha1
+                || cipher_data[i].nid == NID_aes_128_cbc_hmac_sha256
+                || cipher_data[i].nid == NID_aes_256_cbc_hmac_sha256)
+                EVP_add_cipher(known_cipher_methods[i]);
+
         ioctl(cfd, CIOCFSESSION, &sess.ses);
-        if (devcrypto_test_cipher(i)) {
+        if (devcrypto_test_cipher(i))
             known_cipher_nids[known_cipher_nids_amount++] =
                 cipher_data[i].nid;
-        }
     }
 }
 
@@ -708,18 +1006,16 @@ static const struct digest_data_st {
     { NID_ripemd160, /* RIPEMD160_CBLOCK */ 64, 20, CRYPTO_RIPEMD160 },
 # endif
 #endif
-#if !defined(CHECK_BSD_STYLE_MACROS) || defined(CRYPTO_SHA2_224)
     { NID_sha224, SHA256_CBLOCK, 224 / 8, CRYPTO_SHA2_224 },
-#endif
-#if !defined(CHECK_BSD_STYLE_MACROS) || defined(CRYPTO_SHA2_256)
     { NID_sha256, SHA256_CBLOCK, 256 / 8, CRYPTO_SHA2_256 },
-#endif
-#if !defined(CHECK_BSD_STYLE_MACROS) || defined(CRYPTO_SHA2_384)
     { NID_sha384, SHA512_CBLOCK, 384 / 8, CRYPTO_SHA2_384 },
-#endif
-#if !defined(CHECK_BSD_STYLE_MACROS) || defined(CRYPTO_SHA2_512)
-    { NID_sha512, SHA512_CBLOCK, 512 / 8, CRYPTO_SHA2_512 },
-#endif
+    { NID_sha512, SHA512_CBLOCK, 512 / 8, CRYPTO_SHA2_512 },    
+    { NID_hmacWithMD5, 64, 16, CRYPTO_MD5_HMAC },
+    { NID_hmacWithSHA1, SHA_CBLOCK, 20, CRYPTO_SHA1_HMAC },
+    { NID_hmacWithSHA224, SHA256_CBLOCK, 224 / 8, CRYPTO_SHA2_224_HMAC },
+    { NID_hmacWithSHA256, SHA256_CBLOCK, 256 / 8, CRYPTO_SHA2_256_HMAC },
+    { NID_hmacWithSHA384, SHA512_CBLOCK, 384 / 8, CRYPTO_SHA2_384_HMAC },
+    { NID_hmacWithSHA512, SHA512_CBLOCK, 512 / 8, CRYPTO_SHA2_512_HMAC },
 };
 
 static size_t find_digest_data_index(int nid)
@@ -787,6 +1083,7 @@ static int digest_op(struct digest_ctx *ctx, const void *src, size_t srclen,
     cryp.src = (void *)src;
     cryp.dst = NULL;
     cryp.mac = res;
+    cryp.op = COP_ENCRYPT;
     cryp.flags = flags;
     return ioctl(cfd, CIOCCRYPT, &cryp);
 }
@@ -1224,174 +1521,5461 @@ static int devcrypto_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))
     return 0;
 }
 
-/******************************************************************************
- *
- * LOAD / UNLOAD
- *
- *****/
-
 /*
- * Opens /dev/crypto
+ * Convert a BIGNUM to the representation that /dev/crypto needs.
+ * Upon completion of use, the caller is responsible for freeing
+ * crp->crp_p.
  */
-static int open_devcrypto(void)
+static int bn2crparam(const BIGNUM *a, struct crparam *crp)
 {
-    int fd;
+    int i, j, k;
+    ssize_t bytes, bits;
+    u_char *b;
 
-    if (cfd >= 0)
-        return 1;
+    crp->crp_p = NULL;
+    crp->crp_nbits = 0;
 
-    if ((fd = open("/dev/crypto", O_RDWR, 0)) < 0) {
-#ifndef ENGINE_DEVCRYPTO_DEBUG
-        if (errno != ENOENT)
-#endif
-            fprintf(stderr, "Could not open /dev/crypto: %s\n", strerror(errno));
-        return 0;
-    }
+    bits = BN_num_bits(a);
+    bytes = (bits + 7) / 8;
 
-#ifdef CRIOGET
-    if (ioctl(fd, CRIOGET, &cfd) < 0) {
-        fprintf(stderr, "Could not create crypto fd: %s\n", strerror(errno));
-        close(fd);
-        cfd = -1;
-        return 0;
-    }
-    close(fd);
-#else
-    cfd = fd;
-#endif
+    b = OPENSSL_malloc(bytes);
+    if (b == NULL)
+        return (1);
+    memset(b, 0, bytes);
 
-    return 1;
+    crp->crp_p = (caddr_t) b;
+    crp->crp_nbits = bits;
+
+    for (i = 0, j = 0; i < a->top; i++) {
+        for (k = 0; k < BN_BITS2 / 8; k++) {
+            if ((j + k) >= bytes)
+                return (0);
+            b[j + k] = a->d[i] >> (k * 8);
+        }
+        j += BN_BITS2 / 8;
+    }
+    return (0);
 }
 
-static int close_devcrypto(void)
+
+/* Convert a /dev/crypto parameter to a BIGNUM */
+static int crparam2bn(struct crparam *crp, BIGNUM *a)
 {
-    int ret;
+    u_int8_t *pd;
+    int i, bytes;
 
-    if (cfd < 0)
-        return 1;
-    ret = close(cfd);
-    cfd = -1;
-    if (ret != 0) {
-        fprintf(stderr, "Error closing /dev/crypto: %s\n", strerror(errno));
-        return 0;
-    }
-    return 1;
+    bytes = (crp->crp_nbits + 7) / 8;
+
+    if (bytes == 0)
+        return (-1);
+
+    if ((pd = (u_int8_t *)OPENSSL_malloc(bytes)) == NULL)
+        return (-1);
+
+    for (i = 0; i < bytes; i++)
+        pd[i] = crp->crp_p[bytes - i - 1];
+
+    BN_bin2bn(pd, bytes, a);
+    OPENSSL_free(pd);
+
+    return (0);
 }
 
-static int devcrypto_unload(ENGINE *e)
+static void zapparams(struct crypt_kop *kop)
 {
-    destroy_all_cipher_methods();
-#ifdef IMPLEMENT_DIGEST
-    destroy_all_digest_methods();
-#endif
+    int i;
 
-    close_devcrypto();
+    for (i = 0; i < kop->crk_iparams + kop->crk_oparams; i++) {
+        OPENSSL_free(kop->crk_param[i].crp_p);
+        kop->crk_param[i].crp_p = NULL;
+        kop->crk_param[i].crp_nbits = 0;
+    }
+}
 
-    return 1;
+static int curve2field(int curve_nid)
+{
+    switch (curve_nid) {
+        case NID_secp160k1:
+        case NID_secp160r1:
+        case NID_secp160r2:
+        case NID_secp192k1:
+        case NID_secp224k1:
+        case NID_secp224r1:
+        case NID_secp256k1:
+        case NID_secp384r1:
+        case NID_secp521r1:
+        case NID_X9_62_prime192v1:
+        case NID_X9_62_prime192v2:
+        case NID_X9_62_prime192v3:
+        case NID_X9_62_prime239v1:
+        case NID_X9_62_prime239v2:
+        case NID_X9_62_prime239v3:
+        case NID_X9_62_prime256v1:
+        case NID_wap_wsg_idm_ecid_wtls6:
+        case NID_wap_wsg_idm_ecid_wtls7:
+        case NID_wap_wsg_idm_ecid_wtls8:
+        case NID_wap_wsg_idm_ecid_wtls9:
+        case NID_wap_wsg_idm_ecid_wtls12:
+        case NID_brainpoolP160r1:
+        case NID_brainpoolP160t1:
+        case NID_brainpoolP192r1:
+        case NID_brainpoolP192t1:
+        case NID_brainpoolP224r1:
+        case NID_brainpoolP224t1:
+        case NID_brainpoolP256r1:
+        case NID_brainpoolP256t1:
+        case NID_brainpoolP320r1:
+        case NID_brainpoolP320t1:
+        case NID_brainpoolP384r1:
+        case NID_brainpoolP384t1:
+        case NID_brainpoolP512r1:
+        case NID_brainpoolP512t1:
+        case NID_sm2:
+            return KCOP_FLAG_INTEGER_ARITH;
+        case NID_sect163k1:
+        case NID_sect163r1:
+        case NID_sect163r2:
+        case NID_sect193r1:
+        case NID_sect193r2:
+        case NID_sect233k1:
+        case NID_sect233r1:
+        case NID_sect239k1:
+        case NID_sect283k1:
+        case NID_sect283r1:
+        case NID_sect409k1:
+        case NID_sect409r1:
+        case NID_sect571k1:
+        case NID_sect571r1:
+        case NID_X9_62_c2pnb163v1:
+        case NID_X9_62_c2pnb163v2:
+        case NID_X9_62_c2pnb163v3:
+        case NID_X9_62_c2pnb176v1:
+        case NID_X9_62_c2tnb191v1:
+        case NID_X9_62_c2tnb191v2:
+        case NID_X9_62_c2tnb191v3:
+        case NID_X9_62_c2pnb208w1:
+        case NID_X9_62_c2tnb239v1:
+        case NID_X9_62_c2tnb239v2:
+        case NID_X9_62_c2tnb239v3:
+        case NID_X9_62_c2pnb272w1:
+        case NID_X9_62_c2pnb304w1:
+        case NID_X9_62_c2tnb359v1:
+        case NID_X9_62_c2pnb368w1:
+        case NID_X9_62_c2tnb431r1:
+        case NID_wap_wsg_idm_ecid_wtls1:
+        case NID_wap_wsg_idm_ecid_wtls3:
+        case NID_wap_wsg_idm_ecid_wtls4:
+        case NID_wap_wsg_idm_ecid_wtls5:
+        case NID_wap_wsg_idm_ecid_wtls10:
+        case NID_wap_wsg_idm_ecid_wtls11:
+            return KCOP_FLAG_F2M_ARITH;
+        default:
+            return KCOP_FLAG_NONE;
+    }
 }
 
-static int bind_devcrypto(ENGINE *e) {
+#define BITS_TO_CHARS(i)   (((i) + 7) / 8)       
+#define BITS_TO_UINT32(i)  (((i) + 31) / 32)    
+#define CHARS_TO_UINT32(i) (((i) + 3) / 4)   
+#define CHARS_TO_BITS(i)   (i * 8)                          
 
-    if (!ENGINE_set_id(e, engine_devcrypto_id)
-        || !ENGINE_set_name(e, "/dev/crypto engine")
-        || !ENGINE_set_destroy_function(e, devcrypto_unload)
-        || !ENGINE_set_cmd_defns(e, devcrypto_cmds)
-        || !ENGINE_set_ctrl_function(e, devcrypto_ctrl))
-        return 0;
+#define BYTES_ALIGNED4(y)  (((y) & 3) ? (y) + (4 - ((y) & 3)) : (y))
+#define UINT32_TO_BYTES(i)  ((i) << 2)
 
-    prepare_cipher_methods();
-#ifdef IMPLEMENT_DIGEST
-    prepare_digest_methods();
+#ifdef CRYPTODEV_BN_DEBUG
+static char *bn_hex;
 #endif
 
-    return (ENGINE_set_ciphers(e, devcrypto_ciphers)
-#ifdef IMPLEMENT_DIGEST
-        && ENGINE_set_digests(e, devcrypto_digests)
-#endif
-/*
- * Asymmetric ciphers aren't well supported with /dev/crypto.  Among the BSD
- * implementations, it seems to only exist in FreeBSD, and regarding the
- * parameters in its crypt_kop, the manual crypto(4) has this to say:
- *
- *    The semantics of these arguments are currently undocumented.
- *
- * Reading through the FreeBSD source code doesn't give much more than
- * their CRK_MOD_EXP implementation for ubsec.
- *
- * It doesn't look much better with cryptodev-linux.  They have the crypt_kop
- * structure as well as the command (CRK_*) in cryptodev.h, but no support
- * seems to be implemented at all for the moment.
- *
- * At the time of writing, it seems impossible to write proper support for
- * FreeBSD's asym features without some very deep knowledge and access to
- * specific kernel modules.
- *
- * /Richard Levitte, 2017-05-11
- */
-#if 0
-        && ENGINE_set_RSA(e, devcrypto_rsa)
-# ifndef OPENSSL_NO_DSA
-        && ENGINE_set_DSA(e, devcrypto_dsa)
-# endif
-# ifndef OPENSSL_NO_DH
-        && ENGINE_set_DH(e, devcrypto_dh)
-# endif
-# ifndef OPENSSL_NO_EC
-        && ENGINE_set_EC(e, devcrypto_ec)
-# endif
-#endif
-        );
-}
+static const int small_prime[] =
+{
+        3,    5,    7,   11,   13,   17,   19,   23,
+       29,   31,   37,   41,   43,   47,   53,   59,
+       61,   67,   71,   73,   79,   83,   89,   97,
+      101,  103,  107,  109,  113,  127,  131,  137,
+      139,  149,  151,  157,  163,  167,  173,  179,
+      181,  191,  193,  197,  199,  211,  223,  227,
+      229,  233,  239,  241,  251,  257,  263,  269,
+      271,  277,  281,  283,  293,  307,  311,  313,
+      317,  331,  337,  347,  349,  353,  359,  367,
+      373,  379,  383,  389,  397,  401,  409,  419,
+      421,  431,  433,  439,  443,  449,  457,  461,
+      463,  467,  479,  487,  491,  499,  503,  509,
+      521,  523,  541,  547,  557,  563,  569,  571,
+      577,  587,  593,  599,  601,  607,  613,  617,
+      619,  631,  641,  643,  647,  653,  659,  661,
+      673,  677,  683,  691,  701,  709,  719,  727,
+      733,  739,  743,  751,  757,  761,  769,  773,
+      787,  797,  809,  811,  821,  823,  827,  829,
+      839,  853,  857,  859,  863,  877,  881,  883,
+      887,  907,  911,  919,  929,  937,  941,  947,
+      953,  967,  971,  977,  983,  991,  997, -103
+};
 
-#ifdef OPENSSL_NO_DYNAMIC_ENGINE
-/*
- * In case this engine is built into libcrypto, then it doesn't offer any
- * ability to be dynamically loadable.
- */
-void engine_load_devcrypto_int(void)
+static inline int int_swap(unsigned char *A, unsigned short sizeA)
 {
-    ENGINE *e = NULL;
+	int i;
+	unsigned char *p;
 
-    if (!open_devcrypto())
-        return;
+    if (sizeA <= 1)
+        return 0;
+	
+	p = (unsigned char *)OPENSSL_malloc(sizeA);
+	
+	if (!p)
+		return -1;
 
-    if ((e = ENGINE_new()) == NULL
-        || !bind_devcrypto(e)) {
-        close_devcrypto();
-        ENGINE_free(e);
-        return;
-    }
+	memcpy(p, A, sizeA);
 
-    ERR_set_mark();
-    ENGINE_add(e);
-    /*
-     * If the "add" worked, it gets a structural reference. So either way, we
-     * release our just-created reference.
-     */
-    ENGINE_free(e);          /* Loose our local reference */
-    /*
-     * If the "add" didn't work, it was probably a conflict because it was
-     * already added (eg. someone calling ENGINE_load_blah then calling
-     * ENGINE_load_builtin_engines() perhaps).
-     */
-    ERR_pop_to_mark();
-}
+	for(i = 0; i < sizeA; i++)
+		A[i] = p[sizeA - 1 - i];
 
-#else
+	OPENSSL_free(p);
 
-static int bind_helper(ENGINE *e, const char *id)
+	return 0;
+}
+BIGNUM *cryptodev_bn_wexpand(BIGNUM *b, int words)
 {
-    if ((id && (strcmp(id, engine_devcrypto_id) != 0))
-        || !open_devcrypto())
-        return 0;
-    if (!bind_devcrypto(e)) {
-        close_devcrypto();
-        return 0;
+    BIGNUM *bn_p = NULL;
+    bn_p = bn_wexpand( b, words );
+    if (bn_p) {
+        bn_p->top = words;
     }
-    return 1;
+#ifdef CRYPTODEV_BN_DEBUG
+    printf("b->top %d\n", b->top);
+#endif
+    return bn_p;
 }
-
-IMPLEMENT_DYNAMIC_CHECK_FN()
-IMPLEMENT_DYNAMIC_BIND_FN(bind_helper)
-
+BIGNUM *cryptodev_bn_expand(BIGNUM *b, int bits)
+{
+    BIGNUM * bn_p = NULL;
+    bn_p = bn_expand( b, bits );
+    if (bn_p) {
+        bn_p->top =  (bits + (BN_BITS2 - 1))/BN_BITS2;
+    }
+#ifdef CRYPTODEV_BN_DEBUG
+    printf("b->top %d\n", b->top);
 #endif
+    return bn_p;
+}
+static size_t bignum_hw_base_size( const BIGNUM *X , int start_offset_bytes)
+{
+#if (HW_BASE_sections == 1)
+    return HW_BASE_chars;
+#else
+    int i, j, mpi_bytes;
+    unsigned char *chp;
+    
+#ifdef CRYPTODEV_BN_DEBUG
+    printf("HW_BASE_bits = %d, HW_BASE_chars = %d , HW_BASE_limbs= %d\n", HW_BASE_bits, HW_BASE_chars, HW_BASE_sections);
+#endif
+    mpi_bytes = (X->top) << 2  /* * sizeof(unsigned int)*/;
+    chp = (unsigned char *) (X->d);
+    
+    if ((start_offset_bytes + HW_BASE_chars) <= mpi_bytes) {
+        j = start_offset_bytes + HW_BASE_chars;
+    }
+    else {
+        j = mpi_bytes;
+    }
+
+    for( i = j ; i > start_offset_bytes; i--) {
+        if ( chp[i - 1] != 0 )
+            break;
+    }
+    
+    j = i - start_offset_bytes;
+    return (j < sizeof(unsigned int)) ? sizeof(unsigned int) : j;
+#endif
+}
+
+/* Execute Miller-Rabin primality test 
+    N = Candidate prime integer
+    A = An initial random seed for the base value of exponentiation; can be any integer 2 < A < N - 2
+    B = "t" parameter, which is the number of trial runs. By default, it is set at 1 or B[7:0]
+*/
+static inline int hw_primality_test(unsigned char *A,
+                                unsigned short sizeA,
+                                unsigned char *B,
+                                unsigned short sizeB,
+                                unsigned char *N,
+                                unsigned short sizeN,
+                                bool *result)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_PRIMALITY_TEST;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_primality_test: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+#ifndef HW_ENDIAN_SWAP
+	int_swap(A, sizeA);
+    if(B != A) int_swap(B, sizeB);
+    if((N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = sizeB * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = sizeN * 8;    
+
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_PRIMALITY_TEST;
+    kop.crk_flags = 0;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 0;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_primality_test ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result = kop.crk_status == 1 ? true : false;   
+#ifndef HW_ENDIAN_SWAP
+    int_swap(A, sizeA);
+    if(B != A) int_swap(B, sizeB);
+    if((N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+
+out:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_primality_test: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_mod_inv(unsigned char *A,
+                         unsigned short sizeA,
+                         unsigned char *N,
+                         unsigned short sizeN,
+                         unsigned char *result,
+                         unsigned short *result_size)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_MOD_INV;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_mod_inv: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+
+#ifndef HW_ENDIAN_SWAP
+	int_swap(A, sizeA);
+    if(N != A) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+    kop.crk_param[1].crp_p = N;
+    kop.crk_param[1].crp_nbits = sizeN * 8;    
+    kop.crk_param[2].crp_p = result;
+    kop.crk_param[2].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_MOD_INV;
+    kop.crk_flags = KCOP_FLAG_INTEGER_ARITH;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 2;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_mod_inv ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result_size = kop.crk_param[2].crp_nbits/8; 
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result, *result_size);    
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    if(A != result) int_swap(A, sizeA);
+    if((N != result) && (N != A)) int_swap(N, sizeN);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_mod_inv: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_mod_red(unsigned char *A,
+                         unsigned short sizeA,
+                         unsigned char *N,
+                         unsigned short sizeN,
+                         unsigned char *result,
+                         unsigned short *result_size)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_MOD_RED;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_mod_red: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+
+#ifndef HW_ENDIAN_SWAP
+	int_swap(A, sizeA);
+    if(N != A) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+    kop.crk_param[1].crp_p = N;
+    kop.crk_param[1].crp_nbits = sizeN * 8;    
+    kop.crk_param[2].crp_p = result;
+    kop.crk_param[2].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_MOD_RED;
+    kop.crk_flags = KCOP_FLAG_INTEGER_ARITH;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 2;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_mod_red ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result_size = (kop.crk_param[2].crp_nbits + 7)/8;   
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result, *result_size);    
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    if(A != result) int_swap(A, sizeA);
+    if((N != result) && (N != A)) int_swap(N, sizeN);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_mod_red: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_mod_gcd(unsigned char *A,
+                         unsigned short sizeA,
+                         unsigned char *N,
+                         unsigned short sizeN,
+                         unsigned char *result,
+                         unsigned short *result_size)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_GCD;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_mod_gcd: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+#ifndef HW_ENDIAN_SWAP
+	int_swap(A, sizeA);
+    if(N != A) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+    kop.crk_param[1].crp_p = N;
+    kop.crk_param[1].crp_nbits = sizeN * 8;    
+    kop.crk_param[2].crp_p = result;
+    kop.crk_param[2].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_GCD;
+    kop.crk_flags = KCOP_FLAG_INTEGER_ARITH;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 2;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_mod_gcd ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result_size = (kop.crk_param[2].crp_nbits + 7)/8;    
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result, *result_size);    
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    if(A != result) int_swap(A, sizeA);
+    if((N != result) && (N != A)) int_swap(N, sizeN);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_mod_gcd: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_mod_sub1(unsigned char *A,
+                         unsigned short sizeA,
+                         unsigned char *B,
+                         unsigned short sizeB,
+                         unsigned char *N,
+                         unsigned short sizeN,
+                         unsigned char *result,
+                         unsigned short *result_size)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_MOD_SUB1;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_mod_sub1: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+#ifndef HW_ENDIAN_SWAP
+    int_swap(A, sizeA);
+    if(B != A) int_swap(B, sizeB);
+    if((N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = sizeB * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = sizeN * 8;
+
+    
+    kop.crk_param[3].crp_p = result;
+    kop.crk_param[3].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_MOD_SUB1;
+    kop.crk_flags = KCOP_FLAG_INTEGER_ARITH;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_mod_sub1 ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result_size = (kop.crk_param[3].crp_nbits + 7)/8;    
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result, *result_size);       
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    if(A != result) int_swap(A, sizeA);
+    if((B != result) && (B != A)) int_swap(B, sizeB);
+    if((N != result) && (N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_mod_sub1: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_mod_add(unsigned char *A,
+                         unsigned short sizeA,
+                         unsigned char *B,
+                         unsigned short sizeB,
+                         unsigned char *N,
+                         unsigned short sizeN,
+                         unsigned char *result,
+                         unsigned short *result_size)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_MOD_ADD;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_mod_add: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+#ifndef HW_ENDIAN_SWAP
+	int_swap(A, sizeA);
+    if(B != A) int_swap(B, sizeB);
+    if((N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = sizeB * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = sizeN * 8;
+
+    
+    kop.crk_param[3].crp_p = result;
+    kop.crk_param[3].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_MOD_ADD;
+    kop.crk_flags = KCOP_FLAG_INTEGER_ARITH;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_mod_add ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result_size = (kop.crk_param[3].crp_nbits + 7)/8;    
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result, *result_size);    
+#endif
+out:
+#ifndef HW_ENDIAN_SWAP
+    if(A != result) int_swap(A, sizeA);
+    if((B != result) && (B != A)) int_swap(B, sizeB);
+    if((N != result) && (N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_mod_add: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_mod_mul(unsigned char *A,
+                         unsigned short sizeA,
+                         unsigned char *B,
+                         unsigned short sizeB,
+                         unsigned char *N,
+                         unsigned short sizeN,
+                         unsigned char *result,
+                         unsigned short *result_size)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_MOD_MUL;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_mod_mul: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+
+#ifndef HW_ENDIAN_SWAP
+    int_swap(A, sizeA);
+    if(B != A) int_swap(B, sizeB);
+    if((N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = sizeB * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = sizeN * 8;
+
+    
+    kop.crk_param[3].crp_p = result;
+    kop.crk_param[3].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_MOD_MUL;
+    kop.crk_flags = KCOP_FLAG_INTEGER_ARITH;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_mod_mul ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result_size = (kop.crk_param[3].crp_nbits + 7)/8;    
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result, *result_size);    
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    if(A != result) int_swap(A, sizeA);
+    if((B != result) && (B != A)) int_swap(B, sizeB);
+    if((N != result) && (N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_mod_mul: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_mod_exp(unsigned char *A,
+                         unsigned short sizeA,                         
+                         unsigned char *N,
+                         unsigned short sizeN,
+                         unsigned char *B,
+                         unsigned short sizeB,
+                         unsigned char *result,
+                         unsigned short *result_size)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_MOD_EXP;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_mod_exp: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+#ifndef HW_ENDIAN_SWAP
+    int_swap(A, sizeA);
+    if(B != A) int_swap(B, sizeB);
+    if((N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = sizeA * 8;
+
+    kop.crk_param[1].crp_p = N;
+    kop.crk_param[1].crp_nbits = sizeN * 8;
+
+    kop.crk_param[2].crp_p = B;
+    kop.crk_param[2].crp_nbits = sizeB * 8;
+
+    
+    kop.crk_param[3].crp_p = result;
+    kop.crk_param[3].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_MOD_EXP;
+    kop.crk_flags = KCOP_FLAG_INTEGER_ARITH;  /* integer, not MONT in/out, no time eq */
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_mod_exp ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    *result_size = (kop.crk_param[3].crp_nbits + 7)/8;    
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result, *result_size);    
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    if(A != result) int_swap(A, sizeA);
+    if((B != result) && (B != A)) int_swap(B, sizeB);
+    if((N != result) && (N != A) && (N != B)) int_swap(N, sizeN);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_mod_exp: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+static inline void set_point(cryptodev_ecc_point_t *point_a, cryptodev_ecc_point_t *point_b,
+                            unsigned char *A, unsigned char *B)
+{
+    if (NULL != point_a) { /* A[0], A[1] */
+        if (NULL != point_a->x)
+            memcpy(A, point_a->x, point_a->x_size);
+        if (NULL != point_a->y)
+            memcpy(A + QUAD1_BYTE_OFFSET, point_a->y, point_a->y_size);
+    }
+    
+    if (NULL != point_b) {  /* B[1], B[2] */
+        if (NULL != point_b->x)
+            memcpy(B + QUAD1_BYTE_OFFSET, point_b->x, point_b->x_size);
+        if (NULL != point_b->y)
+            memcpy(B + QUAD2_BYTE_OFFSET, point_b->y, point_b->y_size);
+    }
+}
+
+static inline void set_curve_parameter(unsigned char * parameter_a, unsigned short a_size, unsigned char * parameter_b, unsigned short b_size, unsigned char *A, unsigned char *B)
+{
+    /* A3 = elliptic curve parameter "a" */
+    if (NULL !=parameter_a)
+        memcpy(A + QUAD3_BYTE_OFFSET, parameter_a, a_size);
+    
+    /* B0 = elliptic curve parameter "b" */
+    if (NULL !=parameter_b)
+        memcpy(B, parameter_b, b_size);
+}
+
+static inline int hw_ec_point_add(cryptodev_ecc_point_t *point_a,
+                         cryptodev_ecc_point_t *point_b,
+                         unsigned char *N,  
+                         unsigned short n_size,
+                         unsigned char *curve_parameter_a,
+                         unsigned short a_size,
+                         unsigned char *curve_parameter_b,
+                         unsigned short b_size,                         
+                         cryptodev_ecc_point_t *result,
+                         unsigned int flags)
+{
+    int ret = 0, result_size = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    unsigned char A[QUAD_BYTES * 4] = {0};
+    unsigned char B[QUAD_BYTES * 4] = {0};
+    unsigned char R[QUAD_BYTES * 2] = {0};
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_ECC_ADD;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_ec_point_add: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+
+#ifndef HW_ENDIAN_SWAP
+	int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    int_swap(point_b->x, point_b->x_size);
+    int_swap(point_b->y, point_b->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+#endif
+    set_point(point_a, point_b, A, B);
+    set_curve_parameter(curve_parameter_a, a_size, curve_parameter_b, b_size, A, B);
+
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = n_size * 8;
+
+    kop.crk_param[3].crp_p = R;
+    kop.crk_param[3].crp_nbits = 0;
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECC_ADD;
+    kop.crk_flags = flags;  
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_ec_point_add ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    result_size = n_size;  
+    
+    memcpy(result->x, R, result_size);
+    memcpy(result->y, R + QUAD1_BYTE_OFFSET, result_size);
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result->x, result_size);  
+    int_swap(result->y, result_size); 
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    int_swap(point_b->x, point_b->x_size);
+    int_swap(point_b->y, point_b->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_ec_point_add: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_ec_point_double(cryptodev_ecc_point_t *point_a,                         
+                         unsigned char *N,
+                         unsigned short n_size,
+                         unsigned char *curve_parameter_a,
+                         unsigned short a_size,
+                         unsigned char *curve_parameter_b,
+                         unsigned short b_size,
+                         cryptodev_ecc_point_t *result,
+                         unsigned int flags)
+{
+    int ret = 0, result_size = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    unsigned char A[QUAD_BYTES * 4] = {0};
+    unsigned char B[QUAD_BYTES * 4] = {0};
+    unsigned char R[QUAD_BYTES * 2] = {0};
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_ECC_DOUBLE;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_ec_point_double: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+#ifndef HW_ENDIAN_SWAP
+	int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+#endif
+    set_point(NULL, point_a, A, B);
+    set_curve_parameter(curve_parameter_a, a_size, curve_parameter_b, b_size, A, B);
+
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = n_size * 8;
+
+    
+    kop.crk_param[3].crp_p = R;
+    kop.crk_param[3].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECC_DOUBLE;
+    kop.crk_flags = flags;  
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_ec_point_double ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    result_size = n_size;  
+    
+    memcpy(result->x, R, result_size);
+    memcpy(result->y, R + QUAD1_BYTE_OFFSET, result_size);
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result->x, result_size);  
+    int_swap(result->y, result_size); 
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_ec_point_double: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_ec_point_mul(cryptodev_ecc_point_t *point_a,
+                         unsigned char *N,
+                         unsigned short n_size,
+                         unsigned char *E,
+                         unsigned short e_size,
+                         unsigned char *curve_parameter_a,
+                         unsigned short a_size,
+                         unsigned char *curve_parameter_b,
+                         unsigned short b_size,
+                         cryptodev_ecc_point_t *result,
+                         unsigned int flags)
+{
+    int ret = 0, result_size = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    unsigned char A[QUAD_BYTES * 4] = {0};
+    unsigned char B[QUAD_BYTES * 4] = {0};
+    unsigned char R[QUAD_BYTES * 2] = {0};
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_ECC_MUL;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_ec_point_mul: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+    int_swap(E, e_size);
+#endif
+    set_point(point_a, NULL, A, B);
+    set_curve_parameter(curve_parameter_a, a_size, curve_parameter_b, b_size, A, B);
+
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = n_size * 8;
+
+    kop.crk_param[3].crp_p = E;
+    kop.crk_param[3].crp_nbits = e_size * 8;
+    
+    kop.crk_param[4].crp_p = R;
+    kop.crk_param[4].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECC_MUL;
+    kop.crk_flags = flags;  
+    kop.crk_iparams = 4;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_ec_point_mul ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    result_size = n_size;  
+    
+    memcpy(result->x, R, result_size);
+    memcpy(result->y, R + QUAD1_BYTE_OFFSET, result_size);
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result->x, result_size);  
+    int_swap(result->y, result_size);     
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+    int_swap(E, e_size);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_ec_point_mul: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+static inline int hw_ec_point_mul_is_infinity(cryptodev_ecc_point_t *point_a,
+                         unsigned char *N,
+                         unsigned short n_size,
+                         unsigned char *E,
+                         unsigned short e_size,
+                         unsigned char *curve_parameter_a,
+                         unsigned short a_size,
+                         unsigned char *curve_parameter_b,
+                         unsigned short b_size,
+                         cryptodev_ecc_point_t *result,
+                         unsigned int flags)
+{
+    int ret = 0, result_size = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    unsigned char A[QUAD_BYTES * 4] = {0};
+    unsigned char B[QUAD_BYTES * 4] = {0};
+    unsigned char R[QUAD_BYTES * 2] = {0};
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_ECC_IS_INFINITY;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_ec_point_mul_is_infinity: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+    int_swap(E, e_size);
+#endif
+    set_point(point_a, NULL, A, B);
+    set_curve_parameter(curve_parameter_a, a_size, curve_parameter_b, b_size, A, B);
+
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = n_size * 8;
+
+    kop.crk_param[3].crp_p = E;
+    kop.crk_param[3].crp_nbits = e_size * 8;
+    
+    kop.crk_param[4].crp_p = R;
+    kop.crk_param[4].crp_nbits = 0;
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECC_MUL_IS_INFINITY;
+    kop.crk_flags = flags;  
+    kop.crk_iparams = 4;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_ec_point_mul_is_infinity ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    }
+    result_size = n_size;  
+    
+    memcpy(result->x, R, result_size);
+    memcpy(result->y, R + QUAD1_BYTE_OFFSET, result_size);
+#ifndef HW_ENDIAN_SWAP
+    int_swap(result->x, result_size);  
+    int_swap(result->y, result_size);     
+#endif
+
+out:
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+    int_swap(E, e_size);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_ec_point_mul_is_infinity: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+/*check the point is on the curve (but not point at infinity).*/
+static inline int hw_ec_check_point(cryptodev_ecc_point_t *point_a,
+                         unsigned char *N,
+                         unsigned short n_size,
+                         unsigned char *curve_parameter_a,
+                         unsigned short a_size,
+                         unsigned char *curve_parameter_b,
+                         unsigned short b_size,
+                         unsigned int flags)
+{
+    int ret = 0;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    unsigned char A[QUAD_BYTES * 4] = {0};
+    unsigned char B[QUAD_BYTES * 4] = {0};
+    unsigned char R[QUAD_BYTES * 2] = {0};
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_PKHA_ECC_CHECK_POINT;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("hw_ec_check_point: ioctl(CIOCGSESSION)");
+        ret = -1;
+        goto err;
+	}
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+#endif
+    set_point(point_a, NULL, A, B);
+    set_curve_parameter(curve_parameter_a, a_size, curve_parameter_b, b_size, A, B);
+
+    kop.crk_param[0].crp_p = A;
+    kop.crk_param[0].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[1].crp_p = B;
+    kop.crk_param[1].crp_nbits = QUAD_BYTES * 4 * 8;
+
+    kop.crk_param[2].crp_p = N;
+    kop.crk_param[2].crp_nbits = n_size * 8;
+
+    kop.crk_param[3].crp_p = R;
+    kop.crk_param[3].crp_nbits = 0;
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECC_CHECK_POINT;
+    kop.crk_flags = flags;  
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) != 0) {
+        perror("\n hw_ec_check_point ioctl(CIOCKEY) \n");
+        ret = -1;
+        goto out;
+    } 
+  
+out:
+#ifndef HW_ENDIAN_SWAP
+    int_swap(point_a->x, point_a->x_size);
+    int_swap(point_a->y, point_a->y_size);
+    if (curve_parameter_a)
+        int_swap(curve_parameter_a, a_size);
+    if (curve_parameter_b)
+        int_swap(curve_parameter_b, b_size);
+    int_swap(N, n_size);
+#endif
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("hw_ec_check_point: ioctl(CIOCFSESSION)");
+    }
+err:
+	put_dev_crypto(cfd);
+    return ret;
+}
+
+/* R = A^B mod N  */
+static int cryptodev_bn_mod_exp(BIGNUM *R, const BIGNUM *A, const BIGNUM *B, const BIGNUM *N)
+{
+    int ret = 1;
+    BIGNUM *T;
+    unsigned short max_size;
+
+    // check module
+    if( N->neg || ( N->d[0] & 1 ) == 0 )
+        return( 0 );
+
+    if( B->neg )
+        return( 0 );
+
+    if(A->neg) {
+        perror("don't suport neg mod exp\n");
+        return(0);
+    }
+
+#ifdef CRYPTODEV_BN_DEBUG
+    if ((bn_hex = BN_bn2hex(A))) {
+        printf("A = %s\n", bn_hex);
+        OPENSSL_free(bn_hex);
+    }
+    if ((bn_hex = BN_bn2hex(B))) {
+        printf("B = %s\n", bn_hex);
+        OPENSSL_free(bn_hex);
+    }
+    if ((bn_hex = BN_bn2hex(N))) {
+        printf("N = %s\n", bn_hex);
+        OPENSSL_free(bn_hex);
+    }
+#endif
+
+    max_size = N->top;
+    T = BN_new();
+    if (NULL == cryptodev_bn_wexpand( R, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (NULL == cryptodev_bn_wexpand( T, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (BN_ucmp(A, N) == 1) {
+        if (0 != hw_mod_red((unsigned char *)(A->d), BN_num_bytes(A), (unsigned char *)(N->d), BN_num_bytes(N), (unsigned char *)(T->d), &max_size)) {
+            ret = 0;
+            perror("hw_mod_red failed!\n");
+            goto check_exit;
+        }
+    }
+    else {
+        if (NULL == BN_copy( T, A )) {
+            ret = 0;
+            goto check_exit;
+        }
+    }
+
+    if (0 != hw_mod_exp((unsigned char *)(T->d), BN_num_bytes(T), (unsigned char *)(N->d), BN_num_bytes(N), (unsigned char *)(B->d), BN_num_bytes(B), (unsigned char *)(R->d), &max_size)) {
+        ret = 0;
+        perror("hw_mod_exp failed!\n");
+        goto check_exit;
+    }
+
+    if (max_size < UINT32_TO_BYTES(R->top)) {
+        memset((unsigned char *)R->d + max_size, 0, UINT32_TO_BYTES(R->top) - max_size);
+    }
+
+
+check_exit:
+    BN_free( T );
+    bn_correct_top(R);
+    return( ret );
+}
+
+
+/* R = A mod N  */
+static int cryptodev_bn_mod(BIGNUM *R, const BIGNUM *A, const BIGNUM *N)
+{
+    int ret = 1;
+    unsigned short max_size;
+    char * buf = NULL;
+
+    if (A->top > N->top) {
+        max_size = A->top;
+        buf = OPENSSL_malloc(BN_num_bytes(A));
+        memset(buf, 0, BN_num_bytes(A));
+        memcpy(buf, N->d, BN_num_bytes(N));
+        if (NULL == cryptodev_bn_wexpand( R, max_size )) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (0 != hw_mod_red((unsigned char *)(A->d), BN_num_bytes(A), buf, BN_num_bytes(A), (unsigned char *)(R->d), &max_size)) {
+            ret = 0;
+            perror("hw_mod_red failed!\n");
+            goto check_exit;
+        }
+    }
+    else {
+        max_size = N->top;
+        if (NULL == cryptodev_bn_wexpand( R, max_size )) {
+            ret = 0;
+            goto check_exit;
+        }
+
+        if (0 != hw_mod_red((unsigned char *)(A->d), BN_num_bytes(A), (unsigned char *)(N->d), BN_num_bytes(N), (unsigned char *)(R->d), &max_size)) {
+            ret = 0;
+            perror("hw_mod_red failed!\n");
+            goto check_exit;
+        }
+    }
+
+    if ( A->neg != 0) {  // this is a neg
+#ifdef CRYPTODEV_BN_DEBUG
+        if ((bn_hex = BN_bn2hex(N))) {
+            printf("N = %s\n", bn_hex);
+            OPENSSL_free(bn_hex);
+        }
+        if ((bn_hex = BN_bn2hex(R))) {
+            printf("R = %s\n", bn_hex);
+            OPENSSL_free(bn_hex);
+        }
+        if ((bn_hex = BN_bn2hex(A))) {
+            printf("A = %s\n", bn_hex);
+            OPENSSL_free(bn_hex);
+        }
+#endif
+        if (0 != hw_mod_sub1((unsigned char *)(N->d), BN_num_bytes(N), (unsigned char *)(R->d), BN_num_bytes(R), (unsigned char *)(N->d), BN_num_bytes(N), (unsigned char *)(R->d), &max_size)) {
+            ret = 0;
+            perror("hw_mod_sub1 failed!\n");
+            goto check_exit;
+        }
+    }
+
+    if (max_size < UINT32_TO_BYTES(R->top)) {
+        memset((unsigned char *)R->d + max_size, 0, UINT32_TO_BYTES(R->top) - max_size);
+    }
+
+    R->neg = 0;
+
+check_exit:
+    if (NULL != buf)
+        OPENSSL_free(buf);
+    bn_correct_top(R);
+    return( ret );
+}
+
+
+/* X = A^-1 mod N */
+static int cryptodev_bn_inv_mod( BIGNUM *X, const BIGNUM *A, const BIGNUM *N)
+{
+    int ret = 1;
+    int i, j;
+    unsigned short max_size;
+    BIGNUM *G, *TA;
+    if (cryptodev_bn_int_cmp(N, 0) <= 0 )
+        return 0;
+    
+    G = BN_new(); TA = BN_new();
+    
+    if (!cryptodev_bn_gcd(G, A, N)) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (0 != cryptodev_bn_int_cmp( G, 1 )) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (NULL == cryptodev_bn_expand( TA, BN_num_bits(N))) {
+        ret = 0;
+        goto check_exit;
+    }
+    i = BN_num_bytes(A);
+    j = BN_num_bytes(N);
+    if (BN_ucmp(A, N) >= 0) {
+        if (0 != hw_mod_red((unsigned char *)(A->d), i, (unsigned char *)(N->d), j, (unsigned char *)(TA->d), &max_size)) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (max_size < UINT32_TO_BYTES(TA->top)) {
+            memset((unsigned char *)TA->d + max_size, 0, UINT32_TO_BYTES(TA->top) - max_size);
+        }
+    }
+    else {
+        if (NULL == BN_copy( TA, A )) {
+            ret = 0;
+            goto check_exit;
+        }
+        A = TA;
+    }
+    if (NULL == cryptodev_bn_expand( X, BN_num_bits(N))) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (0 != hw_mod_inv((unsigned char *)(TA->d), BN_num_bytes(TA), (unsigned char *)(N->d), BN_num_bytes(N), (unsigned char *)(X->d), &max_size)) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (max_size < UINT32_TO_BYTES(X->top)) {
+        memset((unsigned char *)X->d + max_size, 0, UINT32_TO_BYTES(X->top) - max_size);
+    }
+check_exit:
+    BN_free( G ); BN_free( TA );
+    bn_correct_top(X);
+    return( ret );
+
+}
+
+static int cryptodev_bn_gcd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
+{
+    int ret = 1;
+    int i, j;
+    unsigned short max_size;
+    BIGNUM *TA, *TB;
+    
+    TA = BN_new(); TB = BN_new();
+    if (NULL == BN_copy( TA, a )) {
+        ret = 0;
+        goto check_exit;
+    }
+    a = TA;
+    if (NULL == BN_copy( TB, b )) {
+        ret = 0;
+        goto check_exit;
+    }
+    b = TB; 
+    if (BN_cmp(a, b) > 0) {
+        if (NULL == BN_copy( TA, b )) {
+        ret = 0;
+        goto check_exit;
+        }
+        b = TA;
+        if (NULL == BN_copy( TB, a )) {
+            ret = 0;
+            goto check_exit;
+        }
+        a = TB; 
+    }
+    i = BN_num_bytes(a);
+    j = BN_num_bytes(b);
+    
+    if (0 != hw_mod_gcd((unsigned char *)(a->d), i, (unsigned char *)(b->d), j, (unsigned char *)(b->d), &max_size)) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (max_size < UINT32_TO_BYTES(b->top)) {
+        memset((unsigned char *)b->d + max_size, 0, UINT32_TO_BYTES(b->top) - max_size);
+    }
+
+    if (NULL == BN_copy( r, TB )) {
+        ret = 0;
+    }
+check_exit:
+    BN_free( TB ); BN_free( TA );
+    bn_correct_top(r);
+    return( ret );
+
+}
+
+/* unsigned add of b to a */
+/* r = a + b */
+static int cryptodev_bn_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
+{
+    int ret = 1;
+    int i, j;
+    unsigned short max_size;
+    
+    BIGNUM *TA, *TB, *Wi;
+    BIGNUM *N;
+    TA = BN_new(); TB = BN_new(); Wi = BN_new();
+    N = BN_new();
+
+    i = BN_num_bytes(a);
+    j = BN_num_bytes(b);
+
+    max_size = i > j ? i : j;
+    max_size = BYTES_ALIGNED4(max_size + 1);
+    if (NULL == cryptodev_bn_expand( N, CHARS_TO_BITS(max_size))) {
+        ret = 0;
+        goto check_exit;
+    }
+    memset((unsigned char *)N->d, 0xFF, max_size );
+
+
+    if (max_size <= BITS_TO_CHARS(HW_MAX_MODULUS_SIZE_BITS)) {
+        if (NULL == cryptodev_bn_wexpand( r, CHARS_TO_UINT32(max_size))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (0 != hw_mod_add((unsigned char *)(a->d), i, (unsigned char *)(b->d), j, (unsigned char *)(N->d), max_size,
+                                   (unsigned char *)(r->d), &max_size)) {
+            ret = 0;
+            goto check_exit;
+        }
+    }
+    else {
+        int n, t;
+        unsigned char carry[4] = {0x0, 0x0, 0x0, 0x0};
+        if (NULL == cryptodev_bn_wexpand( Wi, HW_BASE_sections + 1)) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (NULL == BN_copy( TA, a )) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (NULL == BN_copy( TB, b )) {
+            ret = 0;
+            goto check_exit;
+        }
+        
+        for( i = a->top; i > 0; i-- )
+          if( a->d[i - 1] != 0 )
+            break;
+        for( j = b->top; j > 0; j-- )
+          if( b->d[j - 1] != 0 )
+            break;
+
+        n = i > j ? i : j;
+        if (NULL == cryptodev_bn_wexpand( r, n + 1)) {
+            ret = 0;
+            goto check_exit;
+        }
+
+        if( i < j ) {
+            a = TB;   /* a must larger than b */
+            b = TA; 
+        }
+        j = TO_HW_BASE_SIZE(n);
+
+        carry[0] = 0;
+        t = TO_HW_BASE_SIZE(b->top);
+        for (i = 0; i < j; i++) {
+            unsigned short  ibase;
+            memset( (void *)(Wi->d), 0, HW_BASE_chars + 4);
+            ibase = HW_BASE_chars * i;
+
+            if (i < t ) {
+                if (0 != hw_mod_add(((unsigned char *)(a->d))  + ibase, bignum_hw_base_size(a, ibase),
+                                                        ((unsigned char *)(b->d))  + ibase, bignum_hw_base_size(b, ibase),
+                                                         /*NULL*/(unsigned char *)(N->d), HW_BASE_chars + 4,
+                                                         (unsigned char *)(Wi->d), &max_size)) {
+                    ret = 0;
+                    goto check_exit;
+                }
+            }
+            else {
+                memcpy( (unsigned char *)Wi->d, ((unsigned char *)(a->d))  + ibase, HW_BASE_chars);
+            }
+            
+            if (carry[0] == 1) {
+                if (0 != hw_mod_add((unsigned char *)(Wi->d), HW_BASE_chars + 4, carry, 4,
+                                                     /*NULL*/(unsigned char *)(N->d), HW_BASE_chars + 4,
+                                                     (unsigned char *)(Wi->d), &max_size)) {
+                    ret = 0;
+                    goto check_exit;
+                }
+            }
+            if (Wi->d[HW_BASE_sections] == 1) {
+                carry[0] = 1;
+            }
+            else {
+                carry[0] = 0;
+            }
+            memcpy(((unsigned char *)(r->d)) + HW_BASE_chars * i, (unsigned char *)(Wi->d), HW_BASE_chars);
+        }
+        if (carry[0] == 1) {
+            r->d[n] = 1;
+        }
+    }
+
+    r->neg = 0;
+
+check_exit:
+    BN_free(TA); BN_free(TB); BN_free(Wi);
+    BN_free(N);
+    bn_correct_top(r);
+    return( ret );
+}
+
+/* unsigned subtraction of b from a, a must be larger than b. */
+static int cryptodev_bn_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
+{
+    BIGNUM *N = NULL;
+    int ret = 1;
+
+    unsigned short max_size, i, j;    
+
+    if (BN_ucmp( a, b ) < 0 )
+        return 0;
+
+    N = BN_new();
+
+
+    i = BN_num_bytes(a);
+    j = BN_num_bytes(b);
+
+    // max_size unit is byte
+    max_size = i > j ? i : j;
+    max_size = BYTES_ALIGNED4(max_size+1);  
+    if (NULL == cryptodev_bn_expand( N, CHARS_TO_BITS(max_size))) {
+        ret = 0;
+        goto check_exit;
+    }
+    memset((unsigned char *)N->d, 0xFF, max_size );
+
+    // must expand r, return size is Nsize
+    if (NULL == cryptodev_bn_expand( r, CHARS_TO_BITS(max_size))) {
+        ret = 0;
+        goto check_exit;
+    }
+
+    r->neg = 0;
+    
+    if (max_size > BITS_TO_CHARS(HW_MAX_MODULUS_SIZE_BITS)) {
+        ret = 0;
+        perror("cryptodev_bn_usub: more than maximum modulus size");
+        goto check_exit;
+    }
+    
+    if (hw_mod_sub1((unsigned char *)(a->d), i, (unsigned char *)(b->d), j, (unsigned char *)(N->d), max_size, (unsigned char *)(r->d), &max_size)) {
+        ret = 0;
+        perror("hw_mod_sub1 failed!\n");
+    }
+
+    if (max_size < UINT32_TO_BYTES(r->top)) {
+        memset((unsigned char *)r->d + max_size, 0, UINT32_TO_BYTES(r->top) - max_size);
+    }
+
+check_exit:
+    BN_free(N);
+    bn_correct_top(r);
+    return( ret );
+}
+
+/* r =  a - b */
+static int cryptodev_bn_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
+{
+
+    int a_neg = a->neg;
+
+    if (a_neg ^ b->neg) {
+        if (!cryptodev_bn_uadd(r, a, b))
+            return (0);
+        r->neg = a_neg;
+    }
+    else {
+        if (BN_ucmp(a, b) < 0) {
+            if (!cryptodev_bn_usub(r, b, a))
+                return (0);
+            r->neg = a_neg == 1 ? 0: 1;
+        }
+		else {
+            if (!cryptodev_bn_usub(r, a, b))
+                return (0);
+            r->neg = a_neg == 1 ? 1: 0;;
+        }
+    }
+    return (1);
+}
+/* r = a + b */
+
+static int cryptodev_bn_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
+{
+    int a_neg = a->neg, ret = 1;
+
+    bn_check_top(a);
+    bn_check_top(b);
+
+    /*-
+       *  a +  b      a+b
+       *  a + -b      a-b
+       * -a +  b      b-a
+       * -a + -b      -(a+b)
+       */
+    if (a_neg ^ b->neg) {
+        /* we are now a - b */
+        if (BN_ucmp(a, b) < 0) {
+            if (!cryptodev_bn_usub(r, b, a))
+                return (0);
+            r->neg = a_neg == 1 ? 0: 1;
+        } 
+		else {
+            if (!cryptodev_bn_usub(r, a, b))
+                return (0);
+            r->neg = a_neg == 1 ? 1: 0;
+        }
+        return (1);
+    }
+
+    ret = cryptodev_bn_uadd(r, a, b);
+    r->neg = a_neg;
+    bn_check_top(r);
+    return ret;
+}
+
+static int cryptodev_bn_add_word(BIGNUM *a, BN_ULONG w)
+{
+    int ret = 1;
+    BIGNUM *b = NULL;
+    /* degenerate case: w is zero */
+    if (!w)
+        return 1;
+    /* degenerate case: a is zero */
+    if (BN_is_zero(a))
+        return BN_set_word(a, w);
+    b = BN_new();
+    if (NULL == b)
+        return 0;
+    BN_set_word(b, w);
+    ret = cryptodev_bn_add(a, a, b);
+    BN_free(b);
+    return ret;
+}
+
+/* big integer multiplication: r = a * b */
+static int cryptodev_bn_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
+{
+    int ret = 1;
+    int i, j;
+    BIGNUM *TA, *TB, *N;
+    BIGNUM  *C, *UV;
+    unsigned short max_size; 
+
+    TA = BN_new(); TB = BN_new();
+    C = BN_new(); UV = BN_new();
+    N = BN_new();
+
+    if (r == a) { 
+        if (NULL == BN_copy( TA, a )) {
+            ret = 0;
+            goto check_exit;
+        }
+        a = TA;
+    }
+    if (r == b) { 
+        if (NULL == BN_copy( TB, b )) {
+            ret = 0;
+            goto check_exit;
+        }
+        b = TB; 
+    }
+
+    i = BN_num_bytes(a);
+    j = BN_num_bytes(b);
+    
+    // max_size unit is byte
+    max_size = (i + j);
+    max_size = BYTES_ALIGNED4(max_size);
+    if (NULL == cryptodev_bn_expand( N, CHARS_TO_BITS(max_size))) {
+        ret = 0;
+        goto check_exit;
+    }
+   	memset((unsigned char *)N->d, 0xFF, max_size );
+
+    if (max_size <= BITS_TO_CHARS(HW_MAX_MODULUS_SIZE_BITS)) {
+        if (NULL == cryptodev_bn_wexpand( r, /*i + j*/CHARS_TO_UINT32(max_size))) {
+            ret = 0;
+            goto check_exit;
+        }
+        memset(r->d, 0x0, UINT32_TO_BYTES(r->dmax));
+#ifdef CRYPTODEV_BN_DEBUG
+        printf("r1 top %d, dmax %d\n", r->top, r->dmax );
+#endif
+        if (0 != hw_mod_mul((unsigned char *)(a->d),i, (unsigned char *)(b->d), j,
+                                          (unsigned char *)(N->d), max_size, (unsigned char *)(r->d), &max_size)) {
+            ret = 0;
+            goto check_exit;
+        }
+        
+#ifdef CRYPTODEV_BN_DEBUG
+        printf("r2 top %d, dmax %d\n", r->top, r->dmax );
+#endif
+    }
+    else {
+        if (NULL == cryptodev_bn_wexpand( C, HW_BASE_sections)) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (NULL == cryptodev_bn_wexpand( UV, HW_BASE_sections * 2 + 4)) {
+            ret = 0;
+            goto check_exit;
+        }
+    
+        int n, t;
+        for( i = a->top; i > 0; i-- )
+          if( a->d[i - 1] != 0 )
+            break;
+        for( j = b->top; j > 0; j-- )
+          if( b->d[j - 1] != 0 )
+            break;
+        n = TO_HW_BASE_SIZE(/*a->top*/ i);
+        t = TO_HW_BASE_SIZE(/*b->top*/ j);
+
+        if (NULL == cryptodev_bn_wexpand( r, (n + t) * HW_BASE_sections)) {
+            ret = 0;
+            goto check_exit;
+        }
+        memset(r->d, 0x0, UINT32_TO_BYTES(r->dmax));
+    
+        for (i = 0; i < t; i++) {
+            memset(C->d, 0x0, UINT32_TO_BYTES(C->dmax));
+
+            for(j = 0; j < n; j++) {
+                unsigned short ibase, jbase, ijbase;
+                memset(UV->d, 0x0, HW_BASE_chars * 2);
+                
+                ibase = HW_BASE_chars * i;
+                jbase = HW_BASE_chars * j;
+                ijbase = ibase + jbase;
+                if (0 != hw_mod_mul(((unsigned char *)(a->d)) + jbase, bignum_hw_base_size(a, jbase),
+                                                       ((unsigned char *)(b->d)) + ibase, bignum_hw_base_size(b, ibase),
+                                                       (unsigned char *)(N->d), HW_BASE_chars * 2 + 4,
+                                                       (unsigned char *)(UV->d), &max_size)) {
+                    ret = 0;
+                    goto check_exit;
+                }
+
+                if (0 != hw_mod_add(((unsigned char *)(r->d))  + ijbase, bignum_hw_base_size(r, ijbase),
+                                                             (unsigned char *)(UV->d), HW_BASE_chars * 2,
+                                                             (unsigned char *)(N->d), HW_BASE_chars * 2 + 4,
+                                                             (unsigned char *)(UV->d), &max_size)) {
+                    ret = 0;
+                    goto check_exit;
+                }
+
+                if (0 != hw_mod_add(((unsigned char *)(C->d)), HW_BASE_chars,
+                                                             (unsigned char *)(UV->d), HW_BASE_chars * 2,
+                                                             (unsigned char *)(N->d), HW_BASE_chars * 2 + 4,
+                                                             (unsigned char *)(UV->d), (unsigned short *)&max_size)) {
+                    ret = 0;
+                    goto check_exit;
+                }
+                
+                memcpy(((unsigned char *)(r->d)) + HW_BASE_chars * (i + j), (unsigned char *)(UV->d), HW_BASE_chars);
+
+                memcpy(((unsigned char *)(C->d)), (unsigned char *)(UV->d) + HW_BASE_chars, HW_BASE_chars);
+            }
+            memcpy(((unsigned char *)(r->d)) + HW_BASE_chars * (i + n), ((unsigned char *)(UV->d)) + HW_BASE_chars, HW_BASE_chars);
+        }
+    }
+   
+    r->neg = a->neg ^ b->neg;
+
+check_exit:
+    BN_free(TB); BN_free(TA);
+    BN_free(C); BN_free(UV);
+    BN_free(N);
+    bn_correct_top(r);
+    return( ret );
+}
+static inline int cryptodev_bn_int_cmp(const BIGNUM *a, int i)
+{
+    BIGNUM *b;
+    int ret; 
+    
+    b = BN_new();
+    if (b != NULL) {
+        if (0 == BN_set_word(b,i))
+            return -1;
+        ret = BN_cmp(a, b);
+        BN_free(b);
+        return ret;
+    }
+    else
+        return -1;
+}
+
+static inline int cryptodev_bn_int_add(BIGNUM *r, BIGNUM *a, int i)
+{
+    BIGNUM *b;
+    int ret = 1; 
+    
+    b = BN_new();
+    if (b != NULL) {
+        if (0 == BN_set_word(b,i))
+            return 0;
+        ret = cryptodev_bn_add(r, a, b);
+        BN_free(b);
+        return ret;
+    }
+    else
+        return 0;
+
+}
+static int cryptodev_bn_check_small_factors( const BIGNUM *X )
+{
+    int ret = 0;
+    int i;
+    BIGNUM *TA,*TB;
+
+    if (( X->d[0] & 1 ) == 0)
+        return -1; /* is NOT acceptable */
+    TA = BN_new(); TB = BN_new();
+    if (NULL == TA || NULL == TB) {
+        perror("No memory!\n");
+        return -2; /* error */
+    }
+    for (i = 0; small_prime[i] > 0; i++ ) {
+        if (cryptodev_bn_int_cmp( X, small_prime[i] ) <= 0) {
+            ret = 1; /* certain prime */
+            goto check_exit;
+        }
+        BN_set_word(TA,small_prime[i]);
+        if (0 == cryptodev_bn_mod( TB, X, TA)) {
+            ret = -2; /* error */
+            goto check_exit;
+        }
+        if (BN_is_zero(TB)) {
+            ret = -1; /* is NOT acceptable */ 
+            goto check_exit;
+    	}
+    }
+
+check_exit:
+    BN_free(TB); BN_free(TA);
+    return ret;
+}
+
+/* Pseudo-primality test: small factors, then Miller-Rabin */
+static int cryptodev_bn_is_prime(BIGNUM *X)
+{
+    int ret = 1, size;
+    bool result;
+    BIGNUM *A = NULL,*B = NULL;
+    unsigned char t[4] = {0x0,0x0,0x0,0x5};
+    unsigned char buf[CRYPTODEV_MAX_SIZE];
+    if (cryptodev_bn_int_cmp( X, 0 ) == 0 ||
+        cryptodev_bn_int_cmp( X, 1 ) == 0 )
+        return 0; /* is NOT acceptable */
+
+    if (cryptodev_bn_int_cmp( X, 2 ) == 0 )
+        return 1; /* is prime */
+
+    if ((ret = cryptodev_bn_check_small_factors(X)) != 0) {
+        if (ret == 1)
+            return 1; /* is prime */
+        return 0;
+    }
+    A = BN_new();
+    size = (X->top) * (sizeof(BN_ULONG)) / 2;
+    if (NULL != A && size < CRYPTODEV_MAX_SIZE) {
+        if (RAND_bytes(buf, size) <= 0) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (NULL == BN_bin2bn(buf, size, A)) {
+            ret = 0;
+            goto check_exit;
+        }
+    }
+    else {
+        ret = 0;
+        goto check_exit;
+    }
+    if(BN_ucmp(A, X) == 1) {
+        B = BN_new();
+        if (NULL == B || (NULL == BN_copy(B,A))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (1 != BN_rshift1(A, B)) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (BN_ucmp(A, X)) {
+            if( 0 == cryptodev_bn_mod(A, A, X)) {
+                ret = 0;
+                goto check_exit;
+            }
+        }
+    }
+    if (hw_primality_test((unsigned char *)(A->d), BN_num_bytes(A), (unsigned char *)t, 4, (unsigned char *)(X->d), BN_num_bytes(X), &result)) {
+        ret = 0;
+        perror("hw_primality_test failed!\n");
+        goto check_exit;
+    }
+    else {		
+		if(true == result) 
+			ret = 1;  /* is prime */
+        else 
+            ret = 0;
+    }
+check_exit:
+    BN_free(A);
+    BN_free(B);
+    return ret;
+}
+
+static int cryptodev_bn_generate_prime(BIGNUM *PRIME,int rsabits)
+{
+    int ret = 1;
+    int k = 0;
+    BIGNUM *A = NULL;
+    unsigned char buf[BITS_TO_CHARS(HW_MAX_MODULUS_SIZE_BITS)];
+
+    if (rsabits < 3 || rsabits > HW_MAX_MODULUS_SIZE_BITS)
+        return 0;
+
+    if (RAND_bytes(buf, BITS_TO_CHARS(rsabits)) <= 0) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (NULL == BN_bin2bn(buf, BITS_TO_CHARS(rsabits), PRIME)) {
+        ret = 0;
+        goto check_exit;
+    }
+    k = BN_num_bits( PRIME );
+    if (k > rsabits) {
+        A = BN_new();
+        if (NULL == BN_copy(A, PRIME)) {
+            ret = 0;
+            goto check_exit;
+        }
+        if (1 != BN_rshift(PRIME, A, k - rsabits + 1)) {
+            ret = 0;
+            goto check_exit;
+        }
+    }
+    if (1 != BN_set_bit(PRIME, rsabits - 1)) {
+        ret = 0;
+        goto check_exit;
+    }
+    
+    PRIME->d[0] |= 3;
+
+    while (1 != cryptodev_bn_is_prime(PRIME)) {
+            if (!cryptodev_bn_int_add(PRIME, PRIME, 2)) {
+                ret = 0;
+                goto check_exit;
+            }
+    }
+    
+check_exit:
+    if (NULL != A)
+        BN_free(A);
+    return ret;
+}
+static int cryptodev_bn_mul2(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
+{
+    if (BN_is_zero(a) || BN_is_zero(b)) {
+        return BN_set_word(r, 0);
+    }
+    return cryptodev_bn_mul(r, a, b);
+}
+static int cryptodev_bn_mod_ctx(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)
+{
+    return cryptodev_bn_mod(r, m, d);
+}
+
+static int cryptodev_bn_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)
+{
+    if(!cryptodev_bn_mod(r,m,d))
+        return 0;
+    if (!r->neg)
+        return 1;
+    if(d->neg)
+        return cryptodev_bn_sub(r, r, d);
+    else
+        return cryptodev_bn_add(r, r, d);
+}
+/* unsigned modular addition: r = |a| + |b| mod m  */
+static int cryptodev_bn_mod_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m)
+{
+    int ret = 1;
+    int i, j;
+    BIGNUM *TA = NULL, *TB = NULL;
+    unsigned short max_size;
+
+    if (BN_ucmp(a, m) > 0) {
+        TA = BN_new();
+        if (NULL == TA || (NULL == BN_copy( TA, a ))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if(!cryptodev_bn_mod(TA, TA, m)) {
+            ret = 0;
+            goto check_exit;
+        }
+        a = TA;
+    }
+    if (BN_ucmp(b, m) > 0) {
+        TB = BN_new();
+        if (NULL == TB || (NULL == BN_copy( TB, b ))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if(!cryptodev_bn_mod(TB, TB, m)) {
+            ret = 0;
+            goto check_exit;
+        }
+        b = TB;
+    }
+
+    i = BN_num_bytes(a);
+    j = BN_num_bytes(b);
+
+    max_size = BN_num_bytes(m);
+    max_size = BYTES_ALIGNED4(max_size + 1);
+
+    // must expand r, return size is Nsize
+    if (NULL == cryptodev_bn_expand( r, CHARS_TO_BITS(max_size))) {
+        ret = 0;
+        goto check_exit;
+    }
+    
+    r->neg = 0;
+
+    if (max_size > BITS_TO_CHARS(HW_MAX_MODULUS_SIZE_BITS)) {
+        ret = 0;
+        perror("cryptodev_bn_mod_uadd: more than maximum modulus size");
+        goto check_exit;
+    }    
+
+    if (0 != hw_mod_add((unsigned char *)(a->d), i, (unsigned char *)(b->d), j, (unsigned char *)(m->d), BN_num_bytes(m),
+                                   (unsigned char *)(r->d), &max_size)) {
+        ret = 0;
+        perror("hw_mod_add failed!\n");
+        goto check_exit;
+    }
+    
+
+check_exit:
+    if (NULL != TA)
+        BN_free(TA);
+    if (NULL != TB)
+        BN_free(TB);
+    bn_correct_top(r);    
+    return ret;
+}
+
+/* unsigned modular subtraction of b from a, a must be larger than b. r = |a| - |b| mod m */
+static int cryptodev_bn_mod_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m)
+{
+    int ret = 1;
+    BIGNUM *TA = NULL, *TB = NULL;
+    unsigned short max_size, i, j;    
+
+    if (BN_ucmp(a, m) > 0) {
+        TA = BN_new();
+        if (NULL == TA || (NULL == BN_copy( TA, a ))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if(!cryptodev_bn_mod(TA, TA, m)) {
+            ret = 0;
+            goto check_exit;
+        }
+        a = TA;
+    }
+    if (BN_ucmp(b, m) > 0) {
+        TB = BN_new();
+        if (NULL == TB || (NULL == BN_copy( TB, b ))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if(!cryptodev_bn_mod(TB, TB, m)) {
+            ret = 0;
+            goto check_exit;
+        }
+        b = TB;
+    }
+
+    i = BN_num_bytes(a);
+    j = BN_num_bytes(b);
+
+    // max_size unit is byte
+    max_size = BN_num_bytes(m);
+    max_size = BYTES_ALIGNED4(max_size+1);  
+
+    // must expand r, return size is Nsize
+    if (NULL == cryptodev_bn_expand( r, CHARS_TO_BITS(max_size))) {
+        ret = 0;
+        goto check_exit;
+    }
+
+    r->neg = 0;
+    
+    if (max_size > BITS_TO_CHARS(HW_MAX_MODULUS_SIZE_BITS)) {
+        ret = 0;
+        perror("cryptodev_bn_mod_usub: more than maximum modulus size");
+        goto check_exit;
+    }
+    
+    if (hw_mod_sub1((unsigned char *)(a->d), i, (unsigned char *)(b->d), j, (unsigned char *)(m->d), BN_num_bytes(m), (unsigned char *)(r->d), &max_size)) {
+        ret = 0;
+        perror("hw_mod_sub1 failed!\n");
+    }
+
+    if (max_size < UINT32_TO_BYTES(r->top)) 
+        memset((unsigned char *)r->d + max_size, 0, UINT32_TO_BYTES(r->top) - max_size);
+
+
+check_exit:
+    if (NULL != TA)
+        BN_free(TA);
+    if (NULL != TB)
+        BN_free(TB);
+    bn_correct_top(r);
+    return( ret );
+}
+static int cryptodev_bn_mod_umul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m)
+{
+    int ret = 1;
+    int i, j;
+    BIGNUM *TA = NULL, *TB = NULL;
+    unsigned short max_size = 0;     
+       
+    if (r == a) { 
+	    TA = BN_new();
+        if (NULL == BN_copy( TA, a )) {
+            ret = 0;
+            goto check_exit;
+        }
+        a = TA;
+    }
+    else if (BN_ucmp(a, m) > 0) {
+        TA = BN_new();
+        if (NULL == TA || (NULL == BN_copy( TA, a ))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if(!cryptodev_bn_mod(TA, TA, m)) {
+            ret = 0;
+            goto check_exit;
+        }
+        a = TA;
+    }
+    if (r == b) { 
+	    TB = BN_new();
+        if (NULL == BN_copy( TB, b )) {
+            ret = 0;
+            goto check_exit;
+        }
+        b = TB; 
+    }
+    else if (BN_ucmp(b, m) > 0) {
+        TB = BN_new();
+        if (NULL == TB || (NULL == BN_copy( TB, b ))) {
+            ret = 0;
+            goto check_exit;
+        }
+        if(!cryptodev_bn_mod(TB, TB, m)) {
+            ret = 0;
+            goto check_exit;
+        }
+        b = TB;
+    }
+
+    i = BN_num_bytes(a);
+    j = BN_num_bytes(b);
+    
+    // max_size unit is byte
+    max_size = BN_num_bytes(m);
+    max_size = BYTES_ALIGNED4(max_size);
+
+    if (max_size <= BITS_TO_CHARS(HW_MAX_MODULUS_SIZE_BITS)) {
+        if (NULL == cryptodev_bn_wexpand( r, /*i + j*/CHARS_TO_UINT32(max_size))) {
+            ret = 0;
+            goto check_exit;
+        }
+        memset(r->d, 0x0, UINT32_TO_BYTES(r->dmax));
+#ifdef CRYPTODEV_BN_DEBUG
+        printf("r1 top %d, dmax %d\n", r->top, r->dmax );
+#endif
+        if (0 != hw_mod_mul((unsigned char *)(a->d),i, (unsigned char *)(b->d), j,
+                                          (unsigned char *)(m->d), BN_num_bytes(m), (unsigned char *)(r->d), &max_size)) {
+            ret = 0;
+            goto check_exit;
+        }
+        
+#ifdef CRYPTODEV_BN_DEBUG
+        printf("r2 top %d, dmax %d\n", r->top, r->dmax );
+#endif
+    }
+    else {
+        perror("cryptodev_bn_mod_umul: more than maximum modulus size");
+        ret = 0;
+        goto check_exit;
+    }
+   
+    r->neg = 0;
+
+check_exit:
+    if (NULL != TA)
+        BN_free(TA);
+    if (NULL != TB)
+        BN_free(TB);
+    bn_correct_top(r);
+    return( ret );
+}
+
+static int cryptodev_bn_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
+{
+    int a_neg = a->neg, ret = 1;
+
+    if (BN_is_zero(a) || BN_is_zero(b)) {
+        if (BN_is_zero(a) && BN_is_zero(b)) {
+            return BN_set_word(r, 0);
+        }
+        else if (BN_is_zero(a) && !BN_is_zero(b)) {
+            return cryptodev_bn_mod(r, b, m);
+        }
+        else if (!BN_is_zero(a) && BN_is_zero(b)) {
+            return cryptodev_bn_mod(r, a, m);
+        }
+    }
+    
+    bn_check_top(a);
+    bn_check_top(b);
+
+    /*-
+       *  a +  b      a+b
+       *  a + -b      a-b
+       * -a +  b      b-a
+       * -a + -b      -(a+b)
+       */
+    if (a_neg ^ b->neg) {
+        /* we are now a - b */
+        if (BN_ucmp(a, b) < 0) {
+            if (!cryptodev_bn_mod_usub(r, b, a, m))
+                return (0);
+            r->neg = a_neg == 1 ? 0: 1;
+        } 
+		else {
+            if (!cryptodev_bn_mod_usub(r, a, b, m))
+                return (0);
+            r->neg = a_neg == 1 ? 1: 0;
+        }
+        return (1);
+    }
+
+    ret = cryptodev_bn_mod_uadd(r, a, b, m);
+    r->neg = a_neg;
+    bn_check_top(r);
+    return ret;
+}
+/* signed modular subtraction: r = a - b mod m */
+static int cryptodev_bn_mod_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
+{
+    int a_neg = a->neg;
+
+    if (BN_is_zero(a) || BN_is_zero(b)) {
+        if (BN_is_zero(a) && BN_is_zero(b)) {
+            return BN_set_word(r, 0);
+        }
+        else if (BN_is_zero(a) && !BN_is_zero(b)) {
+            BN_set_negative(b, 1);
+            return cryptodev_bn_mod(r, b, m);
+        }
+        else if (!BN_is_zero(a) && BN_is_zero(b)) {
+            return cryptodev_bn_mod(r, a, m);
+        }
+    }
+    bn_check_top(a);
+    bn_check_top(b);
+   
+    if (a_neg ^ b->neg) {
+        if (!cryptodev_bn_mod_uadd(r, a, b, m))
+            return (0);
+        if (a_neg) {
+            if (!cryptodev_bn_mod_usub(r, m, r, m))
+                return (0);
+        }
+    }
+    else {
+        if (!cryptodev_bn_mod_usub(r, a, b, m))
+            return (0);
+        r->neg = 0;
+    }
+    return (1);
+}
+/* unsigned modular multiplication: r = a * b mod m */
+static int cryptodev_bn_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
+{
+    int ret = 1;
+    if (BN_is_zero(a) || BN_is_zero(b)) {
+        return BN_set_word(r, 0);
+    }
+    if (!cryptodev_bn_mod_umul(r, a, b, m))
+        return 0;
+
+    if (a->neg ^ b->neg) {
+        if (!cryptodev_bn_mod_usub(r, m, r, m))
+            return (0);
+    }
+    
+    r->neg = 0;
+        
+    return( ret );  
+}
+
+/* unsigned modular square: r = a^2 mod m */
+static int cryptodev_bn_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx)
+{
+    int ret = 1;
+    if (BN_is_zero(a)) {
+        return BN_set_word(r, 0);
+    }
+    ret = cryptodev_bn_mod_mul(r, a, a, m, ctx);        
+    return( ret );
+}
+
+static BIGNUM *cryptodev_bn_mod_inverse(BIGNUM *ret, const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)
+{
+    if (BN_is_zero(a)) {
+        return BN_mod_inverse(ret, a, n, ctx);
+    }
+
+    if (!cryptodev_bn_inv_mod(ret,a,n))
+        return NULL;
+    else
+        return ret;
+}
+static int cryptodev_ec_point_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
+                 const EC_POINT *b, BN_CTX *ctx)
+{
+    int ret = 1;
+    unsigned short max_size = 0;
+    const EC_POINT *generator = NULL;
+    cryptodev_ecc_point_t point_a = {0}, point_b = {0}, point_r = {0};
+#ifndef HW_ENDIAN_SWAP	
+	EC_POINT *tmp_point = NULL;
+#endif	
+
+    BN_CTX_start(ctx);
+    
+    if (NULL == group || NULL == a || NULL == b || NULL == r) {
+        perror("cryptodev_ec_point_add failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    generator = EC_GROUP_get0_generator(group);
+    if (NULL == generator) {
+        perror("cryptodev_ec_point_add failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    if (!generator->Z_is_one) {
+        printf("\n cryptodev_ec_point_add : Z of the generator is NOT 1! We don't support the case\n");
+        ret = 0;
+        goto check_exit;
+    }
+    max_size = group->field->top;
+    if (NULL == cryptodev_bn_wexpand( r->X, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (NULL == cryptodev_bn_wexpand( r->Y, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+#ifndef HW_ENDIAN_SWAP
+		if (r == a) {
+			tmp_point = EC_POINT_new(group);
+			if(NULL == BN_copy(tmp_point->X,a->X))
+				goto check_exit;
+			if(NULL == BN_copy(tmp_point->Y,a->Y))
+				goto check_exit;
+			BN_set_word(tmp_point->Z,1);
+			tmp_point->Z_is_one = 1;
+			point_a.x = (unsigned char*)tmp_point->X->d;
+		    point_a.x_size = BN_num_bytes(tmp_point->X);
+		    point_a.y = (unsigned char*)tmp_point->Y->d;
+		    point_a.y_size = BN_num_bytes(tmp_point->Y);
+		    point_b.x = (unsigned char*)b->X->d;
+		    point_b.x_size = BN_num_bytes(b->X);
+		    point_b.y = (unsigned char*)b->Y->d;
+		    point_b.y_size = BN_num_bytes(b->Y);
+		}
+		else if (r == b) {
+			tmp_point = EC_POINT_new(group);
+			if(NULL == BN_copy(tmp_point->X,a->X))
+				goto check_exit;
+			if(NULL == BN_copy(tmp_point->Y,a->Y))
+				goto check_exit;
+			BN_set_word(tmp_point->Z,1);
+			tmp_point->Z_is_one = 1;
+			point_a.x = (unsigned char*)a->X->d;
+		    point_a.x_size = BN_num_bytes(a->X);
+		    point_a.y = (unsigned char*)a->Y->d;
+		    point_a.y_size = BN_num_bytes(a->Y);
+		    point_b.x = (unsigned char*)tmp_point->X->d;
+		    point_b.x_size = BN_num_bytes(tmp_point->X);
+		    point_b.y = (unsigned char*)tmp_point->Y->d;
+		    point_b.y_size = BN_num_bytes(tmp_point->Y);
+		}
+		else {
+			point_a.x = (unsigned char*)a->X->d;
+		    point_a.x_size = BN_num_bytes(a->X);
+		    point_a.y = (unsigned char*)a->Y->d;
+		    point_a.y_size = BN_num_bytes(a->Y);
+		    point_b.x = (unsigned char*)b->X->d;
+		    point_b.x_size = BN_num_bytes(b->X);
+		    point_b.y = (unsigned char*)b->Y->d;
+		    point_b.y_size = BN_num_bytes(b->Y);
+		}
+#else
+    point_a.x = (unsigned char*)a->X->d;
+    point_a.x_size = BN_num_bytes(a->X);
+    point_a.y = (unsigned char*)a->Y->d;
+    point_a.y_size = BN_num_bytes(a->Y);
+    point_b.x = (unsigned char*)b->X->d;
+    point_b.x_size = BN_num_bytes(b->X);
+    point_b.y = (unsigned char*)b->Y->d;
+    point_b.y_size = BN_num_bytes(b->Y);
+#endif
+    point_r.x = (unsigned char*)r->X->d;
+    point_r.y = (unsigned char*)r->Y->d;
+    if (0 != hw_ec_point_add(&point_a, &point_b, (unsigned char *)(group->field->d), BN_num_bytes(group->field), (unsigned char*)group->a->d,
+        BN_num_bytes(group->a), (unsigned char*)group->b->d, BN_num_bytes(group->b), &point_r, curve2field(group->curve_name))) {
+        ret = 0;
+        perror("hw_ec_point_add failed!\n");
+        goto check_exit;
+    }
+    
+check_exit:
+    BN_CTX_end(ctx);
+    return( ret );
+}
+static int cryptodev_ec_point_double(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
+                 BN_CTX *ctx)
+{
+    int ret = 1;
+    unsigned short max_size = 0;
+    const EC_POINT *generator = NULL;
+    cryptodev_ecc_point_t point_a, point_r;
+
+    BN_CTX_start(ctx);
+    
+    if (NULL == group || NULL == a || NULL == r) {
+        perror("cryptodev_ec_point_double failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    generator = EC_GROUP_get0_generator(group);
+    if (NULL == generator) {
+        perror("cryptodev_ec_point_double failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    if (!generator->Z_is_one) {
+        printf("\n cryptodev_ec_point_double : Z of the generator is NOT 1! We don't support the case\n");
+        ret = 0;
+        goto check_exit;
+    }
+    max_size = group->field->top;
+    if (NULL == cryptodev_bn_wexpand( r->X, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (NULL == cryptodev_bn_wexpand( r->Y, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+
+    point_a.x = (unsigned char*)a->X->d;
+    point_a.x_size = BN_num_bytes(a->X);
+    point_a.y = (unsigned char*)a->Y->d;
+    point_a.y_size = BN_num_bytes(a->Y);
+    point_r.x = (unsigned char*)r->X->d;
+    point_r.y = (unsigned char*)r->Y->d;
+    if (0 != hw_ec_point_double(&point_a, (unsigned char *)(group->field->d), BN_num_bytes(group->field), (unsigned char*)group->a->d,
+        BN_num_bytes(group->a), (unsigned char*)group->b->d, BN_num_bytes(group->b), &point_r, curve2field(group->curve_name))) {
+        ret = 0;
+        perror("hw_ec_point_double failed!\n");
+        goto check_exit;
+    }
+    
+check_exit:
+    BN_CTX_end(ctx);
+    return( ret );
+}
+
+static int ec_point_mul(const EC_GROUP *group, EC_POINT *r, 
+                 const EC_POINT *a, const BIGNUM *m, int flags)
+{
+    int ret = 1;
+    unsigned short max_size= 0;
+    const EC_POINT *generator = NULL;
+#ifndef HW_ENDIAN_SWAP	
+	EC_POINT *tmp_point = NULL;
+#endif
+    cryptodev_ecc_point_t point_a  = {0}, point_r  = {0};
+
+    
+    if (NULL == group || NULL == a || NULL == m || NULL == r) {
+        perror("ec_point_mul failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    generator = EC_GROUP_get0_generator(group);
+    if (NULL == generator) {
+        perror("ec_point_mul failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    if (!generator->Z_is_one) {
+        printf("\n ec_point_mul : Z of the generator is NOT 1! We don't support the case\n");
+        ret = 0;
+        goto check_exit;
+    }
+    max_size = group->field->top;
+    if (NULL == cryptodev_bn_wexpand( r->X, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+    if (NULL == cryptodev_bn_wexpand( r->Y, max_size )) {
+        ret = 0;
+        goto check_exit;
+    }
+#ifndef HW_ENDIAN_SWAP
+	if (r == a) {
+		tmp_point = EC_POINT_new(group);
+		if(NULL == BN_copy(tmp_point->X,a->X))
+            goto check_exit;
+        if(NULL == BN_copy(tmp_point->Y,a->Y))
+            goto check_exit;
+        BN_set_word(tmp_point->Z,1);
+        tmp_point->Z_is_one = 1;
+		point_a.x = (unsigned char*)tmp_point->X->d;
+	    point_a.x_size = BN_num_bytes(tmp_point->X);
+	    point_a.y = (unsigned char*)tmp_point->Y->d;
+	    point_a.y_size = BN_num_bytes(tmp_point->Y);
+	}
+	else {
+		point_a.x = (unsigned char*)a->X->d;
+	    point_a.x_size = BN_num_bytes(a->X);
+	    point_a.y = (unsigned char*)a->Y->d;
+	    point_a.y_size = BN_num_bytes(a->Y);
+	}
+#else
+    point_a.x = (unsigned char*)a->X->d;
+    point_a.x_size = BN_num_bytes(a->X);
+    point_a.y = (unsigned char*)a->Y->d;
+    point_a.y_size = BN_num_bytes(a->Y);
+#endif	
+    point_r.x = (unsigned char*)r->X->d;
+    point_r.y = (unsigned char*)r->Y->d;
+    if (SM2_FLG_CHECK_INFINITY == flags) {
+        if (0 != hw_ec_point_mul_is_infinity(&point_a, (unsigned char *)(group->field->d), BN_num_bytes(group->field), (unsigned char *)(m->d), BN_num_bytes(m),
+            (unsigned char*)group->a->d, BN_num_bytes(group->a), (unsigned char*)group->b->d, BN_num_bytes(group->b), &point_r, curve2field(group->curve_name))) {
+            ret = 0;
+            perror("hw_ec_point_mul_is_infinity failed! point at infinity\n");
+            goto check_exit;
+        }
+    }
+    else {
+        if (0 != hw_ec_point_mul(&point_a, (unsigned char *)(group->field->d), BN_num_bytes(group->field), (unsigned char *)(m->d), BN_num_bytes(m),
+            (unsigned char*)group->a->d, BN_num_bytes(group->a), (unsigned char*)group->b->d, BN_num_bytes(group->b), &point_r, curve2field(group->curve_name))) {
+            ret = 0;
+            perror("hw_ec_point_mul failed!\n");
+            goto check_exit;
+        }
+    }
+    
+check_exit:
+#ifndef HW_ENDIAN_SWAP	
+	EC_POINT_free(tmp_point);
+#endif
+    return( ret );
+}
+static int cryptodev_ec_point_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,
+                 const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx)
+{
+    int ret = 1;
+    const EC_POINT *generator = NULL;
+    EC_POINT *p = NULL,*o = NULL;
+    if (NULL == group || NULL == r) {
+        perror("cryptodev_ec_point_mul failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    generator = EC_GROUP_get0_generator(group);
+    if (NULL == generator) {
+        perror("cryptodev_ec_point_mul failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    if (NULL == n && NULL != m) {
+        if(!ec_point_mul(group, r, q, m, 0)) {
+            perror("ec_point_mul failed!\n");
+            ret = 0;
+            goto check_exit;
+        }
+    }
+    else if (NULL != n && NULL == m) {
+        if(!ec_point_mul(group, r, generator, n, 0)) {
+            perror("ec_point_mul failed!\n");
+            ret = 0;
+            goto check_exit;
+        }
+    }
+    else {        
+        if ((p = EC_POINT_new(group)) == NULL) {
+            perror("EC_POINT_new failed!\n");
+            ret = 0;
+            goto check_exit;
+        }
+        if ((o = EC_POINT_new(group)) == NULL) {
+            perror("EC_POINT_new failed!\n");
+            ret = 0;
+            goto check_exit;
+        }
+        if(!ec_point_mul(group, p, q, m, 0)) {
+            perror("ec_point_mul failed!\n");
+            ret = 0;
+            goto check_exit;
+        }
+        if(!ec_point_mul(group, o, generator, n, 0)) {
+            perror("ec_point_mul failed!\n");
+            ret = 0;
+            goto check_exit;
+        }
+        if(!cryptodev_ec_point_add(group, r, o, p, ctx)) {
+            perror("cryptodev_ec_point_add failed!\n");
+            ret = 0;
+            goto check_exit;
+        }
+    }
+check_exit:
+    if (p)
+        EC_POINT_free(p);
+    if (o)
+        EC_POINT_free(o);
+    return( ret );
+}
+static int cryptodev_ec_check_point(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)
+{
+    int ret = 1;
+    const EC_POINT *generator = NULL;
+    cryptodev_ecc_point_t check_point = {0};
+
+    BN_CTX_start(ctx);
+    
+    if (NULL == group || NULL == point) {
+        perror("cryptodev_ec_check_point failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    generator = EC_GROUP_get0_generator(group);
+    if (NULL == generator) {
+        perror("cryptodev_ec_check_point failed!\n");
+        ret = 0;
+        goto check_exit;
+    }
+    if (!generator->Z_is_one) {
+        printf("\n cryptodev_ec_check_point : Z of the generator is NOT 1! We don't support the case\n");
+        ret = 0;
+        goto check_exit;
+    }
+
+    check_point.x = (unsigned char*)point->X->d;    
+    check_point.x_size = BN_num_bytes(point->X);
+    check_point.y = (unsigned char*)point->Y->d;
+    check_point.y_size = BN_num_bytes(point->Y);
+
+    if (0 != hw_ec_check_point(&check_point, (unsigned char *)(group->field->d), BN_num_bytes(group->field), (unsigned char*)group->a->d,
+        BN_num_bytes(group->a), (unsigned char*)group->b->d, BN_num_bytes(group->b), curve2field(group->curve_name))) {
+        ret = 0;
+        perror("hw_ec_point_add failed!\n");
+        goto check_exit;
+    }
+    
+check_exit:
+    BN_CTX_end(ctx);
+    return( ret );
+}
+
+static int cryptodev_rsa_keygen (RSA *rsa, int bits, BIGNUM *e_value, BN_GENCB *cb)
+{
+    BIGNUM *r1 = NULL, *r2 = NULL, *tmp = NULL, *prime = NULL;
+    
+    int ok = -1, n = 0, bitsr[RSA_MAX_PRIME_NUM], bitse = 0;
+    int i = 0, quo = 0, rmd = 0, adj = 0, retries = 0;
+    RSA_PRIME_INFO *pinfo = NULL;
+    STACK_OF(RSA_PRIME_INFO) *prime_infos = NULL;    
+    BN_CTX *ctx = NULL;
+    int cfd, primes = RSA_DEFAULT_PRIME_NUM;
+    BN_ULONG bitst = 0;
+    unsigned long error = 0;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if (bits > HW_MAX_MODULUS_SIZE_BITS) {
+        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+        goto err;
+    }
+    if (bits < RSA_MIN_MODULUS_BITS) {
+        ok = 0;             /* we set our own err */
+        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_KEY_SIZE_TOO_SMALL);
+        goto err;
+    }
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        ok = 0;             
+        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_RSA);
+        goto err;
+    }
+
+    ctx = BN_CTX_new();
+    if (ctx == NULL)
+        goto err;
+    BN_CTX_start(ctx);
+    r1 = BN_CTX_get(ctx);
+    r2 = BN_CTX_get(ctx);    
+    if (r2 == NULL)
+        goto err;
+    
+    /* divide bits into 'primes' pieces evenly */
+    quo = bits / primes;
+    rmd = bits % primes;
+
+    for (i = 0; i < primes; i++)
+        bitsr[i] = (i < rmd) ? quo + 1 : quo;    
+
+    /* We need the RSA components non-NULL */
+    if (!rsa->n && ((rsa->n = BN_new()) == NULL))
+        goto err;
+    if (!rsa->d && ((rsa->d = BN_secure_new()) == NULL))
+        goto err;
+    if (!rsa->e && ((rsa->e = BN_new()) == NULL))
+        goto err;
+    if (!rsa->p && ((rsa->p = BN_secure_new()) == NULL))
+        goto err;
+    if (!rsa->q && ((rsa->q = BN_secure_new()) == NULL))
+        goto err;
+    if (!rsa->dmp1 && ((rsa->dmp1 = BN_secure_new()) == NULL))
+        goto err;
+    if (!rsa->dmq1 && ((rsa->dmq1 = BN_secure_new()) == NULL))
+        goto err;
+    if (!rsa->iqmp && ((rsa->iqmp = BN_secure_new()) == NULL))
+        goto err;
+
+    /* initialize multi-prime components */
+    if (primes > RSA_DEFAULT_PRIME_NUM) {
+        rsa->version = RSA_ASN1_VERSION_MULTI;
+        prime_infos = sk_RSA_PRIME_INFO_new_reserve(NULL, primes - 2);
+        if (prime_infos == NULL)
+            goto err;
+        if (rsa->prime_infos != NULL) {
+            /* could this happen? */
+            sk_RSA_PRIME_INFO_pop_free(rsa->prime_infos, ossl_rsa_multip_info_free);
+        }
+        rsa->prime_infos = prime_infos;
+
+        /* prime_info from 2 to |primes| -1 */
+        for (i = 2; i < primes; i++) {
+            pinfo = rsa_multip_info_new();
+            if (pinfo == NULL)
+                goto err;
+            (void)sk_RSA_PRIME_INFO_push(prime_infos, pinfo);
+        }
+    }
+
+    if (BN_copy(rsa->e, e_value) == NULL)
+        goto err;
+
+    /* generate p, q and other primes (if any) */
+    for (i = 0; i < primes; i++) {
+        adj = 0;
+        retries = 0;
+
+        if (i == 0) {
+            prime = rsa->p;
+        } else if (i == 1) {
+            prime = rsa->q;
+        } else {
+            pinfo = sk_RSA_PRIME_INFO_value(prime_infos, i - 2);
+            prime = pinfo->r;
+        }
+        BN_set_flags(prime, BN_FLG_CONSTTIME);
+
+        for (;;) {
+ redo:
+            if (!BN_generate_prime_ex(prime, bitsr[i] + adj, 0, NULL, NULL, cb))
+                goto err;
+            /*
+             * prime should not be equal to p, q, r_3...
+             * (those primes prior to this one)
+             */
+            {
+                int j;
+
+                for (j = 0; j < i; j++) {
+                    BIGNUM *prev_prime;
+
+                    if (j == 0)
+                        prev_prime = rsa->p;
+                    else if (j == 1)
+                        prev_prime = rsa->q;
+                    else
+                        prev_prime = sk_RSA_PRIME_INFO_value(prime_infos,
+                                                             j - 2)->r;
+
+                    if (!BN_cmp(prime, prev_prime)) {
+                        goto redo;
+                    }
+                }
+            }
+            if (!BN_sub(r2, prime, BN_value_one()))
+                goto err;
+            ERR_set_mark();
+            BN_set_flags(r2, BN_FLG_CONSTTIME);
+            if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {
+               /* GCD == 1 since inverse exists */
+                break;
+            }
+            error = ERR_peek_last_error();
+            if (ERR_GET_LIB(error) == ERR_LIB_BN
+                && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {
+                /* GCD != 1 */
+                ERR_pop_to_mark();
+            } else {
+                goto err;
+            }
+            if (!BN_GENCB_call(cb, 2, n++))
+                goto err;
+        }
+
+        bitse += bitsr[i];
+
+        /* calculate n immediately to see if it's sufficient */
+        if (i == 1) {
+            /* we get at least 2 primes */
+            if (!BN_mul(r1, rsa->p, rsa->q, ctx))
+                goto err;
+        } else if (i != 0) {
+            /* modulus n = p * q * r_3 * r_4 ... */
+            if (!BN_mul(r1, rsa->n, prime, ctx))
+                goto err;
+        } else {
+            /* i == 0, do nothing */
+            if (!BN_GENCB_call(cb, 3, i))
+                goto err;
+            continue;
+        }
+        /*
+         * if |r1|, product of factors so far, is not as long as expected
+         * (by checking the first 4 bits are less than 0x9 or greater than
+         * 0xF). If so, re-generate the last prime.
+         *
+         * NOTE: This actually can't happen in two-prime case, because of
+         * the way factors are generated.
+         *
+         * Besides, another consideration is, for multi-prime case, even the
+         * length modulus is as long as expected, the modulus could start at
+         * 0x8, which could be utilized to distinguish a multi-prime private
+         * key by using the modulus in a certificate. This is also covered
+         * by checking the length should not be less than 0x9.
+         */
+        if (!BN_rshift(r2, r1, bitse - 4))
+            goto err;
+        bitst = BN_get_word(r2);
+
+        if (bitst < 0x9 || bitst > 0xF) {
+            /*
+             * For keys with more than 4 primes, we attempt longer factor to
+             * meet length requirement.
+             *
+             * Otherwise, we just re-generate the prime with the same length.
+             *
+             * This strategy has the following goals:
+             *
+             * 1. 1024-bit factors are efficient when using 3072 and 4096-bit key
+             * 2. stay the same logic with normal 2-prime key
+             */
+            bitse -= bitsr[i];
+            if (!BN_GENCB_call(cb, 2, n++))
+                goto err;
+            if (primes > 4) {
+                if (bitst < 0x9)
+                    adj++;
+                else
+                    adj--;
+            } else if (retries == 4) {
+                /*
+                 * re-generate all primes from scratch, mainly used
+                 * in 4 prime case to avoid long loop. Max retry times
+                 * is set to 4.
+                 */
+                i = -1;
+                bitse = 0;
+                continue;
+            }
+            retries++;
+            goto redo;
+        }
+        /* save product of primes for further use, for multi-prime only */
+        if (i > 1 && BN_copy(pinfo->pp, rsa->n) == NULL)
+            goto err;
+        if (BN_copy(rsa->n, r1) == NULL)
+            goto err;
+        if (!BN_GENCB_call(cb, 3, i))
+            goto err;
+    }
+
+    if (BN_cmp(rsa->p, rsa->q) < 0) {
+        tmp = rsa->p;
+        rsa->p = rsa->q;
+        rsa->q = tmp;
+    }
+    
+    /* calculate n d dp dq qp*/
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_RSA_GENERATE_KEY;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_rsa_keygen: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_RSA_GENERATE_KEY;
+    kop.crk_pad1 = (bits + 7) / 8; /* n len*/
+	if (bn2crparam(rsa->p, &kop.crk_param[0]))
+        goto out_rsa_keygen;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->p));
+    if (bn2crparam(rsa->q, &kop.crk_param[1]))
+        goto out_rsa_keygen;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->q));
+	if (bn2crparam(rsa->e, &kop.crk_param[2]))
+        goto out_rsa_keygen;
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(rsa->e));
+    kop.crk_iparams = 3;
+    
+    kop.crk_param[kop.crk_iparams].crp_p = OPENSSL_malloc(kop.crk_pad1);
+    if(NULL == kop.crk_param[kop.crk_iparams].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams].crp_p, 0, kop.crk_pad1);
+
+    kop.crk_param[kop.crk_iparams+1].crp_p = OPENSSL_malloc(kop.crk_pad1);
+    if(NULL == kop.crk_param[kop.crk_iparams+1].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams+1].crp_p, 0, kop.crk_pad1);
+
+    kop.crk_param[kop.crk_iparams+2].crp_p = OPENSSL_malloc(BN_num_bytes(rsa->p));
+    if(NULL == kop.crk_param[kop.crk_iparams+2].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams+2].crp_p, 0, BN_num_bytes(rsa->p));
+
+    kop.crk_param[kop.crk_iparams+3].crp_p = OPENSSL_malloc(BN_num_bytes(rsa->p));
+    if(NULL == kop.crk_param[kop.crk_iparams+3].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams+3].crp_p, 0, BN_num_bytes(rsa->p));
+
+    kop.crk_param[kop.crk_iparams+4].crp_p = OPENSSL_malloc(BN_num_bytes(rsa->p));
+    if(NULL == kop.crk_param[kop.crk_iparams+4].crp_p)
+        goto out_rsa_keygen;
+    memset(kop.crk_param[kop.crk_iparams+4].crp_p, 0, BN_num_bytes(rsa->p));
+
+    kop.crk_oparams = 5;
+    if (ioctl(cfd, CIOCKEY, &kop)) {
+        perror("\n cryptodev_rsa_keygen failed \n");
+        goto out_rsa_keygen;
+    }
+
+    /* Get n = p * q */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8, rsa->n);
+    /* Get D  = E^-1 mod ((P-1)*(Q-1)) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams+1].crp_p, (kop.crk_param[kop.crk_iparams+1].crp_nbits + 7)/8, rsa->d);
+    /* Get DP = D mod (P - 1) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams+2].crp_p, (kop.crk_param[kop.crk_iparams+2].crp_nbits + 7)/8, rsa->dmp1);
+    /* Get DQ = D mod (Q - 1) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams+3].crp_p, (kop.crk_param[kop.crk_iparams+3].crp_nbits + 7)/8, rsa->dmq1);
+    /* Get QP = Q^-1 mod P */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams+4].crp_p, (kop.crk_param[kop.crk_iparams+4].crp_nbits + 7)/8, rsa->iqmp);
+    ok = 1;
+    
+out_rsa_keygen:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses))
+        perror("cryptodev_rsa_keygen : ioctl(CIOCFSESSION)");
+    zapparams(&kop);
+
+err:
+    if (ok == -1) {
+        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_BN);
+        ok = 0;
+    }
+    if (ctx != NULL) {
+        BN_CTX_end(ctx);
+        BN_CTX_free(ctx);
+    }
+
+    return ok;
+
+}
+static int rsa_padding_check_ssl_v23(unsigned char *to, const unsigned char *from, int flen, int num)
+{
+    int i, j;
+    const unsigned char *p;
+
+    p = from;
+    if (flen < 10) {
+        RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, RSA_R_DATA_TOO_SMALL);
+        return (-1);
+    }
+    if ((*(p+1) != 02)) {
+        RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, RSA_R_BLOCK_TYPE_IS_NOT_02);
+        return (-1);
+    }
+    p += 2;
+    /* scan over padding data */
+    j = flen - 7;               /* one for type */
+    for (i = 0; i < j; i++)
+        if (p[i] == 03 && p[i+1] == 03 && p[i+2] == 03 && p[i+3] == 03 && p[i+4] == 03 && p[i+5] == 03 && p[i+6] == 03 && p[i+7] == 03)
+            break;
+
+    if ((i == j) || (i < 8)) {
+        RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,
+               RSA_R_NULL_BEFORE_BLOCK_MISSING);
+        return (-1);
+    }
+
+    i += 9;                        /* Skip over the '\0' */
+    p += i;
+    j = flen - i -2;
+    memcpy(to, p, (unsigned int)j);
+
+    return (j);
+}
+
+static int rsa_padding_check_pkcs1_oaep(unsigned char *to,
+                                      const unsigned char *from, int flen,
+                                      int num, const unsigned char *param,
+                                      int plen)
+{
+    int i, dblen, mlen = -1, one_index = 0, msg_index;
+    unsigned int good, found_one_byte;
+    const unsigned char *maskedseed, *maskeddb;
+    const EVP_MD *md;
+    const EVP_MD *mgf1md;
+    /*
+     * |em| is the encoded message, zero-padded to exactly |num| bytes: em =
+     * Y || maskedSeed || maskedDB
+     */
+    unsigned char *db = NULL, *em = NULL, seed[EVP_MAX_MD_SIZE],
+        phash[EVP_MAX_MD_SIZE];
+    int mdlen;
+
+    md = EVP_sha1();
+    mgf1md = md;
+
+    mdlen = EVP_MD_size(md);
+
+    if (flen <= 0)
+        return -1;
+    /*
+     * |num| is the length of the modulus; |flen| is the length of the
+     * encoded message. Therefore, for any |from| that was obtained by
+     * decrypting a ciphertext, we must have |flen| <= |num|. Similarly,
+     * num < 2 * mdlen + 2 must hold for the modulus irrespective of
+     * the ciphertext, see PKCS #1 v2.2, section 7.1.2.
+     * This does not leak any side-channel information.
+     */
+    if (num < flen || num < 2 * mdlen + 2)
+        goto decoding_err;
+
+    dblen = num - mdlen - 1;
+    db = OPENSSL_malloc(dblen);
+    em = OPENSSL_malloc(num);
+    if (db == NULL || em == NULL) {
+        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1, ERR_R_MALLOC_FAILURE);
+        goto cleanup;
+    }
+
+    /*
+     * Always do this zero-padding copy (even when num == flen) to avoid
+     * leaking that information. The copy still leaks some side-channel
+     * information, but it's impossible to have a fixed  memory access
+     * pattern since we can't read out of the bounds of |from|.
+     *
+     * TODO(emilia): Consider porting BN_bn2bin_padded from BoringSSL.
+     */
+    memset(em, 0, num);
+    memcpy(em + num - flen, from, flen);
+
+    /*
+     * The first byte must be zero, however we must not leak if this is
+     * true. See James H. Manger, "A Chosen Ciphertext  Attack on RSA
+     * Optimal Asymmetric Encryption Padding (OAEP) [...]", CRYPTO 2001).
+     */
+    good = constant_time_is_zero(em[0]);
+
+    maskedseed = em + 1;
+    maskeddb = em + 1 + mdlen;
+
+    if (PKCS1_MGF1(seed, mdlen, maskeddb, dblen, mgf1md))
+        goto cleanup;
+    for (i = 0; i < mdlen; i++)
+        seed[i] ^= maskedseed[i];
+
+    if (PKCS1_MGF1(db, dblen, seed, mdlen, mgf1md))
+        goto cleanup;
+    for (i = 0; i < dblen; i++)
+        db[i] ^= maskeddb[i];
+
+    if (!EVP_Digest((void *)param, plen, phash, NULL, md, NULL))
+        goto cleanup;
+
+    good &= constant_time_is_zero(CRYPTO_memcmp(db, phash, mdlen));
+
+    found_one_byte = 0;
+    for (i = mdlen; i < dblen; i++) {
+        /*
+         * Padding consists of a number of 0-bytes, followed by a 1.
+         */
+        unsigned int equals1 = constant_time_eq(db[i], 1);
+        unsigned int equals0 = constant_time_is_zero(db[i]);
+        one_index = constant_time_select_int(~found_one_byte & equals1,
+                                             i, one_index);
+        found_one_byte |= equals1;
+        good &= (found_one_byte | equals0);
+    }
+
+    good &= found_one_byte;
+
+    /*
+     * At this point |good| is zero unless the plaintext was valid,
+     * so plaintext-awareness ensures timing side-channels are no longer a
+     * concern.
+     */
+    if (!good)
+        goto decoding_err;
+
+    msg_index = one_index + 1;
+    mlen = dblen - msg_index;
+
+    memcpy(to, db + msg_index, mlen);
+    goto cleanup;
+
+ decoding_err:
+    /*
+     * To avoid chosen ciphertext attacks, the error message should not
+     * reveal which kind of decoding error happened.
+     */
+    RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1,
+           RSA_R_OAEP_DECODING_ERROR);
+ cleanup:
+    if (db != NULL)
+        OPENSSL_free(db);
+    if (em != NULL)
+        OPENSSL_free(em);
+    return mlen;
+}
+
+static int cryptodev_rsa_public_encrypt(int flen, const unsigned char *from,
+                                  unsigned char *to, RSA *rsa, int padding)
+{
+    BIGNUM *f;
+    int i, num = 0, r = -1;
+    unsigned char *buf = NULL;
+    BN_CTX *ctx = NULL;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+   
+    if (BN_num_bits(rsa->n) > HW_MAX_MODULUS_SIZE_BITS || BN_num_bits(rsa->e) > HW_RSA_MAX_PUBEXP_BITS) {
+        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, RSA_R_MODULUS_TOO_LARGE);
+        return -1;
+    }
+
+    if (BN_ucmp(rsa->n, rsa->e) <= 0) {
+        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
+        return -1;
+    }
+    
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    if ((ctx = BN_CTX_new()) == NULL)
+        goto err;
+    BN_CTX_start(ctx);
+    num = BN_num_bytes(rsa->n);
+    f = BN_CTX_get(ctx);
+    buf = OPENSSL_malloc(num);
+    if (!f || !buf) {
+        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+    memset(buf, 0, num);
+    
+    switch (padding) {
+    case RSA_PKCS1_PADDING:
+        i = RSA_padding_add_PKCS1_type_2(buf, num, from, flen);
+        break;
+# ifndef OPENSSL_NO_SHA
+    case RSA_PKCS1_OAEP_PADDING:
+        i = RSA_padding_add_PKCS1_OAEP(buf, num, from, flen, NULL, 0);
+        break;
+# endif
+    case RSA_NO_PADDING:
+        i = RSA_padding_add_none(buf, num, from, flen);
+        break;
+    default:
+        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+        goto err;
+    }
+    if (i <= 0)
+        goto err;
+
+    if (BN_bin2bn(buf, num, f) == NULL)
+        goto err;
+
+    if (BN_ucmp(f, rsa->n) >= 0) {
+        /* usually the padding functions would catch this */
+        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT,
+               RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+        goto err;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_RSA_PUBLIC;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_rsa_public_encrypt: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_RSA_PUBLIC;
+
+    /* inputs: rsa->n rsa->e f */    
+    if (bn2crparam(rsa->n, &kop.crk_param[0]))
+        goto out_rsa_public_encrypt;
+	int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->n));
+    if (bn2crparam(rsa->e, &kop.crk_param[1]))
+        goto out_rsa_public_encrypt;
+	int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->e));
+    kop.crk_param[2].crp_p = buf;
+    kop.crk_param[2].crp_nbits = num * 8;
+    kop.crk_param[3].crp_p = OPENSSL_malloc(num);
+    if(NULL == kop.crk_param[3].crp_p)
+        goto out_rsa_public_encrypt;
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) == 0) { 
+        int_swap(kop.crk_param[kop.crk_iparams].crp_p, num);
+        memcpy(to, kop.crk_param[kop.crk_iparams].crp_p, num);
+    }
+    else {
+        perror("\ncryptodev_rsa_public_encrypt: RSA encryption failed \n");
+        goto out_rsa_public_encrypt;
+    }
+    r = num;
+out_rsa_public_encrypt:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses))
+        perror("ncryptodev_rsa_public_encrypt : ioctl(CIOCFSESSION)");
+    zapparams(&kop);
+    
+err:    
+    if (ctx != NULL) {
+        BN_CTX_end(ctx);
+        BN_CTX_free(ctx);
+    }
+    put_dev_crypto(cfd);    
+    return (r);
+
+}
+/* signing */
+static int cryptodev_rsa_private_encrypt(int flen, const unsigned char *from,
+                                   unsigned char *to, RSA *rsa, int padding)
+{
+    BIGNUM *f;
+    int i, num = 0, r = -1;
+    unsigned char *buf = NULL;
+    BN_CTX *ctx = NULL;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    ssize_t nbits;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    if ((ctx = BN_CTX_new()) == NULL)
+        goto err;
+    
+    BN_CTX_start(ctx);
+    num = BN_num_bytes(rsa->n);
+    f = BN_CTX_get(ctx);
+    buf = OPENSSL_malloc(num);
+    if (!f || !buf) {
+        RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+    memset(buf, 0, num);
+
+    switch (padding) {
+    case RSA_PKCS1_PADDING:
+        i = RSA_padding_add_PKCS1_type_1(buf, num, from, flen);
+        break;
+    case RSA_X931_PADDING:
+        i = RSA_padding_add_X931(buf, num, from, flen);
+        break;
+    case RSA_NO_PADDING:
+        i = RSA_padding_add_none(buf, num, from, flen);
+        break;
+    default:
+        RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+        goto err;
+    }
+    if (i <= 0)
+        goto err;
+
+    if (BN_bin2bn(buf, num, f) == NULL)
+        goto err;
+
+    if (BN_ucmp(f, rsa->n) >= 0) {
+        /* usually the padding functions would catch this */
+        RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+        goto err;
+    }
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_RSA_PRIVATE;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_rsa_private_encrypt: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_RSA_PRIVATE;
+    /* inputs: rsa->p rsa->q rsa->iqmp rsa->dmp1 rsa->dmq1  f*/
+    if(rsa->p != NULL && rsa->q != NULL && rsa->dmp1 != NULL && rsa->dmq1 != NULL && rsa->iqmp != NULL) {
+        nbits = BN_num_bits(rsa->n);
+        kop.crk_pad1 = (nbits + 7) / 8; /* n len*/
+		if (bn2crparam(rsa->p, &kop.crk_param[0]))
+            goto out_rsa_private_encrypt;
+        int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->p));
+        if (bn2crparam(rsa->q, &kop.crk_param[1]))
+            goto out_rsa_private_encrypt;
+        int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->q));
+		if (bn2crparam(rsa->iqmp, &kop.crk_param[2]))
+            goto out_rsa_private_encrypt;
+        int_swap(kop.crk_param[2].crp_p, BN_num_bytes(rsa->iqmp));
+        if (bn2crparam(rsa->dmp1, &kop.crk_param[3]))
+            goto out_rsa_private_encrypt;
+        int_swap(kop.crk_param[3].crp_p, BN_num_bytes(rsa->dmp1));
+		if (bn2crparam(rsa->dmq1, &kop.crk_param[4]))
+            goto out_rsa_private_encrypt;
+        int_swap(kop.crk_param[4].crp_p, BN_num_bytes(rsa->dmq1));
+		kop.crk_param[5].crp_p = buf;
+        kop.crk_param[5].crp_nbits = num * 8;
+        kop.crk_param[6].crp_p = OPENSSL_malloc(num);
+        if(NULL == kop.crk_param[6].crp_p) {
+    		perror("cryptodev_rsa_private_encrypt: OPENSSL_malloc error");
+    		goto out_rsa_private_encrypt;
+    	}            
+        memset(kop.crk_param[6].crp_p, 0, num);
+        kop.crk_iparams = 6;
+        kop.crk_oparams = 1;
+    }
+    else {
+		/* inputs: rsa->n rsa->d f*/
+        if (bn2crparam(rsa->n, &kop.crk_param[0]))
+            goto out_rsa_private_encrypt;
+        int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->n));
+        if (bn2crparam(rsa->d, &kop.crk_param[1]))
+            goto out_rsa_private_encrypt;
+        int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->d));
+        kop.crk_param[2].crp_p = buf;
+        kop.crk_param[2].crp_nbits = num * 8;
+        kop.crk_param[3].crp_p = OPENSSL_malloc(num);
+        if(NULL == kop.crk_param[3].crp_p) {
+    		perror("cryptodev_rsa_private_encrypt: OPENSSL_malloc error");
+    		goto out_rsa_private_encrypt;
+    	}  
+        memset(kop.crk_param[3].crp_p, 0, num);
+        kop.crk_iparams = 3;
+        kop.crk_oparams = 1;
+    }
+
+    if (ioctl(cfd, CIOCKEY, &kop) == 0) {     
+        int_swap(kop.crk_param[kop.crk_iparams].crp_p, num);
+        memcpy(to, kop.crk_param[kop.crk_iparams].crp_p, num);           
+        r = num; 
+    }
+    else {
+        perror("cryptodev_rsa_private_encrypt: RSA encryption failed \n");
+        goto out_rsa_private_encrypt;
+    }    
+out_rsa_private_encrypt:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses))
+        perror("cryptodev_rsa_private_encrypt : ioctl(CIOCFSESSION)");    
+    zapparams(&kop);
+    
+err:
+    if (ctx != NULL) {
+        BN_CTX_end(ctx);
+        BN_CTX_free(ctx);
+    }
+    put_dev_crypto(cfd);
+    return (r);
+}
+/* signature verification */
+static int cryptodev_rsa_public_decrypt(int flen, const unsigned char *from,
+                                  unsigned char *to, RSA *rsa, int padding)
+{
+    BIGNUM *ret;
+    int i, num = 0, r = -1;
+    BN_CTX *ctx = NULL;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    if ((ctx = BN_CTX_new()) == NULL)
+        goto err;
+    
+    BN_CTX_start(ctx);
+    num = BN_num_bytes(rsa->n);
+    ret = BN_CTX_get(ctx);
+    if (!ret) {
+        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    if (flen > num) {
+        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_DATA_GREATER_THAN_MOD_LEN);
+        goto err;
+    }
+
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_RSA_PUBLIC;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_rsa_public_encrypt: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_RSA_PUBLIC;
+
+    /* inputs: rsa->n rsa->e f */    
+    if (bn2crparam(rsa->n, &kop.crk_param[0]))
+        goto out_rsa_public_decrypt;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->n));
+    if (bn2crparam(rsa->e, &kop.crk_param[1]))
+        goto out_rsa_public_decrypt;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->e));	
+    kop.crk_param[2].crp_p = OPENSSL_malloc(flen);
+    if(NULL == kop.crk_param[2].crp_p)
+        goto out_rsa_public_decrypt;
+    memset(kop.crk_param[2].crp_p, 0, flen);
+    kop.crk_param[2].crp_nbits = flen * 8;
+    memcpy(kop.crk_param[2].crp_p, from, flen);
+    int_swap(kop.crk_param[2].crp_p, flen);
+    kop.crk_param[3].crp_p = OPENSSL_malloc(num);
+    if(NULL == kop.crk_param[3].crp_p) {
+		perror("cryptodev_rsa_public_decrypt: OPENSSL_malloc error");
+		goto out_rsa_public_decrypt;
+	} 
+    memset(kop.crk_param[3].crp_p, 0, num);
+    kop.crk_iparams = 3;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop) == 0) {     
+        crparam2bn(&kop.crk_param[kop.crk_iparams], ret);
+        if ((padding == RSA_X931_PADDING) && ((kop.crk_param[kop.crk_iparams].crp_p[0] & 0xf) != 12))             
+            if (!BN_sub(ret, rsa->n, ret))
+                goto out_rsa_public_decrypt;
+
+        switch (padding) {
+        case RSA_PKCS1_PADDING:
+            {
+                int ilen, pad_count = 0, i;
+                unsigned char *p, bad, pad_done = 0;
+                
+                ilen = BN_num_bytes(rsa->n);
+                p = kop.crk_param[kop.crk_iparams].crp_p;
+                bad = 0;
+
+                bad |= *p++; /* First byte must be 0 */
+
+                /* This test does not depend on secret data */
+                 bad |= *p++ ^ 1;
+
+                /* Get padding len, but always read till end of buffer
+                             * (minus one, for the 00 byte) */
+                for( i = 0; i < ilen - 3; i++ )
+                {
+                    pad_done |= ( p[i] != 0xFF );
+                    pad_count += ( pad_done == 0 );
+                }
+
+                p += pad_count;
+                bad |= *p++; /* Must be zero */            
+
+                if( bad ) {
+                    RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+                    goto out_rsa_public_decrypt;
+                }
+                    
+                r = ilen - (p - kop.crk_param[kop.crk_iparams].crp_p);
+                memcpy( to, p, r );
+            }
+            break;
+        case RSA_X931_PADDING:
+            i = num;
+            r = RSA_padding_check_X931(to, num, kop.crk_param[kop.crk_iparams].crp_p, i, num);
+            break;
+        case RSA_NO_PADDING:
+            memcpy( to, kop.crk_param[kop.crk_iparams].crp_p, num );
+            r = num;
+            break;
+        default:
+            RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+            goto out_rsa_public_decrypt;
+        }
+        if (r < 0)
+            RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_PADDING_CHECK_FAILED);
+    }
+    else {
+        perror("\ncryptodev_rsa_public_encrypt: RSA decryption failed \n");
+        goto out_rsa_public_decrypt;
+    }
+out_rsa_public_decrypt:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses))
+        perror("ncryptodev_rsa_public_encrypt : ioctl(CIOCFSESSION)");
+    zapparams(&kop);
+    
+err:
+    if (ctx != NULL) {
+        BN_CTX_end(ctx);
+        BN_CTX_free(ctx);
+    }
+    put_dev_crypto(cfd);    
+    return (r);
+}
+
+static int cryptodev_rsa_private_decrypt(int flen, const unsigned char *from,
+                                   unsigned char *to, RSA *rsa, int padding)
+{
+    int j, num = 0, r = -1;
+    unsigned char *buf = NULL;
+    BN_CTX *ctx = NULL;
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    ssize_t nbits;
+
+ 
+    if (flen <= 0 || (cfd = get_dev_crypto()) < 0) {
+        return -1;
+    }
+    
+    if ((ctx = BN_CTX_new()) == NULL)
+        goto err;
+    BN_CTX_start(ctx);
+    num = BN_num_bytes(rsa->n);
+    buf = OPENSSL_malloc(num);
+    if (!buf) {
+        RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+    memset(buf, 0, num);
+
+    /*
+     * This check was for equality but PGP does evil things and chops off the
+     * top '0' bytes
+     */
+    if (flen > num) {
+        RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_DATA_GREATER_THAN_MOD_LEN);
+        goto err;
+    }
+
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_RSA_PRIVATE;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_rsa_private_decrypt: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_RSA_PRIVATE;
+    /* inputs: rsa->p rsa->q rsa->iqmp rsa->dmp1 rsa->dmq1  f*/
+    if(rsa->p != NULL && rsa->q != NULL && rsa->dmp1 != NULL && rsa->dmq1 != NULL && rsa->iqmp != NULL) {
+        nbits = BN_num_bits(rsa->n);
+        kop.crk_pad1 = (nbits + 7) / 8; /* n len*/
+		if (bn2crparam(rsa->p, &kop.crk_param[0]))
+            goto out_rsa_private_decrypt;
+        int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->p));
+        if (bn2crparam(rsa->q, &kop.crk_param[1]))
+            goto out_rsa_private_decrypt;
+        int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->q));
+		if (bn2crparam(rsa->iqmp, &kop.crk_param[2]))
+            goto out_rsa_private_decrypt;
+        int_swap(kop.crk_param[2].crp_p, BN_num_bytes(rsa->iqmp));
+        if (bn2crparam(rsa->dmp1, &kop.crk_param[3]))
+            goto out_rsa_private_decrypt;
+        int_swap(kop.crk_param[3].crp_p, BN_num_bytes(rsa->dmp1));
+		if (bn2crparam(rsa->dmq1, &kop.crk_param[4]))
+            goto out_rsa_private_decrypt;
+        int_swap(kop.crk_param[4].crp_p, BN_num_bytes(rsa->dmq1));
+        kop.crk_param[5].crp_p = OPENSSL_malloc(flen);
+        if(NULL == kop.crk_param[5].crp_p) {
+            perror("cryptodev_rsa_private_decrypt: OPENSSL_malloc error");
+            goto out_rsa_private_decrypt;
+        }
+        memset(kop.crk_param[5].crp_p, 0, flen);
+        kop.crk_param[5].crp_nbits = flen * 8;
+        memcpy(kop.crk_param[5].crp_p, from, flen);
+        kop.crk_param[5].crp_nbits = flen * 8;
+        int_swap(kop.crk_param[5].crp_p, flen);
+        kop.crk_param[6].crp_p = OPENSSL_malloc(num);
+        if(NULL == kop.crk_param[6].crp_p) {
+    		perror("cryptodev_rsa_private_decrypt: OPENSSL_malloc error");
+    		goto out_rsa_private_decrypt;
+    	}            
+        memset(kop.crk_param[6].crp_p, 0, num);
+        kop.crk_iparams = 6;
+        kop.crk_oparams = 1;
+    }
+    else {
+		/* inputs: rsa->n rsa->d f*/
+        if (bn2crparam(rsa->n, &kop.crk_param[0]))
+            goto out_rsa_private_decrypt;
+        int_swap(kop.crk_param[0].crp_p, BN_num_bytes(rsa->n));
+        if (bn2crparam(rsa->d, &kop.crk_param[1]))
+            goto out_rsa_private_decrypt;
+        int_swap(kop.crk_param[1].crp_p, BN_num_bytes(rsa->d));
+        kop.crk_param[2].crp_p = OPENSSL_malloc(flen);
+        if(NULL == kop.crk_param[2].crp_p) {
+            perror("cryptodev_rsa_private_decrypt: OPENSSL_malloc error");
+            goto out_rsa_private_decrypt;
+        }
+        memset(kop.crk_param[2].crp_p, 0, flen);
+        kop.crk_param[2].crp_nbits = flen * 8;
+        memcpy(kop.crk_param[2].crp_p, from, flen);
+        int_swap(kop.crk_param[2].crp_p, flen);
+        kop.crk_param[3].crp_p = OPENSSL_malloc(num);
+        if(NULL == kop.crk_param[3].crp_p) {
+    		perror("cryptodev_rsa_private_decrypt: OPENSSL_malloc error");
+    		goto out_rsa_private_decrypt;
+    	}            
+        memset(kop.crk_param[3].crp_p, 0, num);
+        kop.crk_iparams = 3;
+        kop.crk_oparams = 1;
+    }
+
+    if (ioctl(cfd, CIOCKEY, &kop) == 0) {  
+        memcpy(buf, kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8);      
+        switch (padding) {
+        case RSA_PKCS1_PADDING:
+            {
+                int ilen, pad_count = 0, i;
+                unsigned char *p, bad, pad_done = 0;
+
+                
+                ilen = BN_num_bytes(rsa->n);
+                p = buf;
+                bad = 0;
+
+                bad |= *p++; /* First byte must be 0 */
+
+                /* This test does not depend on secret data */
+                bad |= *p++ ^ 2;
+
+                /* Get padding len, but always read till end of buffer
+                 * (minus one, for the 00 byte) */
+                for( i = 0; i < ilen - 3; i++ )
+                {
+                    pad_done |= ( p[i] == 0 );
+                    pad_count += ( pad_done == 0 );  /* all nozero padding bytes */
+                }
+                p += pad_count;
+                bad |= *p++; /* Must be zero */            
+
+                if( bad ) {
+                    RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+                    goto out_rsa_private_decrypt;
+                }
+                    
+                r = ilen - (p - buf);
+                memcpy( to, p, r );
+            }
+            break;
+
+# ifndef OPENSSL_NO_SHA
+        case RSA_PKCS1_OAEP_PADDING:
+            j = (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8;
+            r = rsa_padding_check_pkcs1_oaep(to, buf, j, num, NULL, 0);
+            break;
+# endif
+
+        case RSA_NO_PADDING:
+            memcpy( to, buf, num );
+            r = num;
+            break;
+        default:
+            RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+            goto out_rsa_private_decrypt;
+        }
+        if (r < 0)
+            RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_PADDING_CHECK_FAILED);
+    
+    }
+    else {
+        perror("cryptodev_rsa_private_decrypt: RSA decryption failed \n");
+        goto out_rsa_private_decrypt;
+    }
+out_rsa_private_decrypt:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses))
+        perror("cryptodev_rsa_private_decrypt : ioctl(CIOCFSESSION)");
+    zapparams(&kop);
+    
+err:
+    if (ctx != NULL) {
+        BN_CTX_end(ctx);
+        BN_CTX_free(ctx);
+    }
+    if (buf != NULL) {
+        OPENSSL_free(buf);
+    }
+    put_dev_crypto(cfd);
+    
+    return (r);
+}
+
+#ifndef OPENSSL_NO_DSA
+static DSA_SIG *cryptodev_dsa_do_sign(const unsigned char *dgst, int dlen,
+                                      DSA *dsa)
+{
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    BIGNUM *r = NULL, *s = NULL;
+    DSA_SIG *dsaret = NULL;    
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+    if (!dsa->params.p || !dsa->params.q || !dsa->params.g) {
+        printf("\n cryptodev_dsa_do_sign : missing parameters! \n");
+        goto err;
+    }
+    if ((r = BN_new()) == NULL)
+        goto err;
+    if ((s = BN_new()) == NULL) {
+        BN_free(r);
+        goto err;
+    }
+
+    if (dlen > BN_num_bytes(dsa->params.q))
+        goto err;
+        
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_DSA_SIGN;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_dsa_do_sign: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_DSA_SIGN;
+
+    /* inputs: dsa->p dsa->q dsa->g dsa->priv_key dgst */    
+    if (bn2crparam(dsa->params.p, &kop.crk_param[0]))
+        goto out_dsa_sign;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(dsa->params.p));
+    if (bn2crparam(dsa->params.q, &kop.crk_param[1]))
+        goto out_dsa_sign;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(dsa->params.q));
+    if (bn2crparam(dsa->params.g, &kop.crk_param[2]))
+        goto out_dsa_sign;
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(dsa->params.g));
+    if (bn2crparam(dsa->priv_key, &kop.crk_param[3]))
+        goto out_dsa_sign;
+    int_swap(kop.crk_param[3].crp_p, BN_num_bytes(dsa->priv_key));
+    kop.crk_param[4].crp_p = malloc(BN_num_bytes(dsa->params.q));
+    if (NULL == kop.crk_param[4].crp_p) {
+        perror("cryptodev_dsa_do_sign: OPENSSL_malloc error");
+        goto out_dsa_sign;
+    }
+    memset(kop.crk_param[4].crp_p, 0, BN_num_bytes(dsa->params.q));
+    kop.crk_param[4].crp_nbits = BN_num_bytes(dsa->params.q) * 8;
+    memcpy(kop.crk_param[4].crp_p, dgst, dlen);
+    kop.crk_iparams = 5;
+
+    if (r) {
+        kop.crk_param[kop.crk_iparams].crp_p = OPENSSL_malloc(BN_num_bytes(dsa->params.q));
+        kop.crk_param[kop.crk_iparams].crp_nbits = BN_num_bytes(dsa->params.q) * 8;
+    }
+    if (s) {
+        kop.crk_param[kop.crk_iparams + 1].crp_p = OPENSSL_malloc(BN_num_bytes(dsa->params.q));
+        kop.crk_param[kop.crk_iparams + 1].crp_nbits = BN_num_bytes(dsa->params.q) * 8;
+    }
+    kop.crk_oparams = 2;
+
+    if (ioctl(cfd, CIOCKEY, &kop) == 0) {
+        if (r) {
+            BN_bin2bn(kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8, r);
+        }
+        if (s) {
+            BN_bin2bn(kop.crk_param[kop.crk_iparams + 1].crp_p, (kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8, s);
+        }
+        dsaret = DSA_SIG_new();
+        if (dsaret == NULL)
+            goto out_dsa_sign;
+        dsaret->r = r;
+        dsaret->s = s;
+        r = s = NULL;
+    }
+out_dsa_sign:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_dsa_do_sign: ioctl(CIOCFSESSION)");
+    }
+ err:
+    BN_free(r);
+    BN_free(s);
+    kop.crk_param[4].crp_p = NULL;
+    put_dev_crypto(cfd);
+    zapparams(&kop);
+    return (dsaret);
+}
+
+static int
+cryptodev_dsa_verify(const unsigned char *dgst, int dlen,
+                     DSA_SIG *sig, DSA *dsa)
+{
+    int cfd;
+    struct session_op sess;
+    struct crypt_kop kop;
+    int dsaret = 0;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+
+    if (BN_is_zero(sig->r) || BN_is_negative(sig->r) ||
+        BN_ucmp(sig->r, dsa->params.q) >= 0) {
+        dsaret = 0;
+        goto err;
+    }
+    if (BN_is_zero(sig->s) || BN_is_negative(sig->s) ||
+        BN_ucmp(sig->s, dsa->params.q) >= 0) {
+        dsaret = 0;
+        goto err;
+    }
+
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_DSA_VERIFY;
+  
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_dsa_verify: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_DSA_VERIFY;
+
+    /* inputs: dsa->p dsa->q dsa->g dsa->pub_key dgst sig->r sig->s */
+    
+    if (bn2crparam(dsa->params.p, &kop.crk_param[0]))
+        goto out_dsa_verify;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(dsa->params.p));
+    if (bn2crparam(dsa->params.q, &kop.crk_param[1]))
+        goto out_dsa_verify;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(dsa->params.q));
+    if (bn2crparam(dsa->params.g, &kop.crk_param[2]))
+        goto out_dsa_verify;
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(dsa->params.g));
+    if (bn2crparam(dsa->pub_key, &kop.crk_param[3]))
+        goto out_dsa_verify;
+    int_swap(kop.crk_param[3].crp_p, BN_num_bytes(dsa->pub_key));
+    kop.crk_param[4].crp_p =  OPENSSL_malloc(dlen);
+    if(NULL == kop.crk_param[4].crp_p) {
+        perror("cryptodev_dsa_verify: OPENSSL_malloc error");
+        goto out_dsa_verify;
+    }
+    memset(kop.crk_param[4].crp_p, 0, BN_num_bytes(dsa->params.q));
+    memcpy(kop.crk_param[4].crp_p, dgst, dlen);
+    kop.crk_param[4].crp_nbits = BN_num_bytes(dsa->params.q) * 8;
+    if (bn2crparam(sig->r, &kop.crk_param[5]))
+        goto out_dsa_verify;
+    int_swap(kop.crk_param[5].crp_p, BN_num_bytes(sig->r));
+    if (bn2crparam(sig->s, &kop.crk_param[6]))
+        goto out_dsa_verify;
+    int_swap(kop.crk_param[6].crp_p, BN_num_bytes(sig->s));
+    kop.crk_iparams = 7;
+
+    if (ioctl(cfd, CIOCKEY, &kop)) {
+        dsaret = 0;
+		perror("\n cryptodev_dsa_verify failed \n");
+	}
+    else {
+        if (1 == kop.crk_status)
+            dsaret = 1;
+        else
+            dsaret = 0;
+    }
+out_dsa_verify:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_dsa_verify: ioctl(CIOCFSESSION)");
+    }
+ err:
+    kop.crk_param[0].crp_p = NULL;
+    zapparams(&kop);
+    put_dev_crypto(cfd);
+    return (dsaret);
+}
+
+static int
+cryptodev_dsa_keygen(DSA *dsa)
+{
+    int ok = 0;
+    BIGNUM *pub_key = NULL, *priv_key = NULL;
+    struct session_op sess;
+    struct crypt_kop kop;
+    int cfd, priv_key_len, pub_key_len;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+    if (dsa->priv_key == NULL) {
+        if ((priv_key = BN_new()) == NULL)
+            goto err;
+    } else
+        priv_key = dsa->priv_key;
+
+    if (dsa->pub_key == NULL) {
+        if ((pub_key = BN_new()) == NULL)
+            goto err;
+    } else
+        pub_key = dsa->pub_key;
+
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+
+	sess.pk_cipher = CRYPTO_ASYMMETRIC_DH_GENERATE_KEY;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_dsa_keygen: ioctl(CIOCGSESSION)");
+		goto err;
+	}
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_DH_GENERATE_KEY;
+    /* Set parameter q */
+    if (bn2crparam(dsa->params.p, &kop.crk_param[0]))
+        goto out_dsa_keygen;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(dsa->params.p));
+    /* Set parameter r */
+    if (bn2crparam(dsa->params.q, &kop.crk_param[1]))
+        goto out_dsa_keygen;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(dsa->params.q));
+    /* Set parameter g */
+    if (bn2crparam(dsa->params.g, &kop.crk_param[2]))
+        goto out_dsa_keygen;
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(dsa->params.g));
+    kop.crk_iparams = 3;
+    priv_key_len = BN_num_bytes(dsa->params.q);
+    pub_key_len = BN_num_bytes(dsa->params.p);
+    kop.crk_param[kop.crk_iparams].crp_p = OPENSSL_malloc(priv_key_len);
+    if (NULL == kop.crk_param[kop.crk_iparams].crp_p) {
+        perror("cryptodev_dsa_keygen: OPENSSL_malloc error");
+        goto out_dsa_keygen;
+    }
+    kop.crk_param[kop.crk_iparams].crp_nbits = priv_key_len * 8;    
+    kop.crk_param[kop.crk_iparams + 1].crp_p = OPENSSL_malloc(pub_key_len);
+    if (NULL == kop.crk_param[kop.crk_iparams + 1].crp_p) {
+        perror("cryptodev_dsa_keygen: OPENSSL_malloc error");
+        goto out_dsa_keygen;
+    }
+    kop.crk_param[kop.crk_iparams + 1].crp_nbits = pub_key_len * 8;
+	kop.crk_oparams = 2;
+    if (ioctl(cfd, CIOCKEY, &kop)) {
+		perror("\n cryptodev_dsa_keygen failed \n");
+		goto out_dsa_keygen;
+	}
+    /* Get parameter s (Private key) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8, priv_key);
+    /* Get parameter w (Public key) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams + 1].crp_p, (kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8, pub_key);
+    
+    dsa->priv_key = priv_key;
+    dsa->pub_key = pub_key;
+    ok = 1;
+    
+out_dsa_keygen:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_dsa_keygen: ioctl(CIOCFSESSION)");
+    }
+    zapparams(&kop);
+ err:
+    if ((pub_key != NULL) && (dsa->pub_key == NULL))
+        BN_free(pub_key);
+    if ((priv_key != NULL) && (dsa->priv_key == NULL))
+        BN_free(priv_key);
+    put_dev_crypto(cfd);
+    return (ok);
+}
+#endif
+
+static ECDSA_SIG *cryptodev_ecdsa_sign_sig(const unsigned char *dgst, int dgst_len,
+                                const BIGNUM *in_kinv, const BIGNUM *in_r,
+                                EC_KEY *eckey)
+{
+    BIGNUM *r = NULL, *s = NULL, *m = NULL, *order = NULL;
+    BN_CTX *ctx = NULL;
+    const EC_GROUP *group = NULL;
+    ECDSA_SIG *ecdsaret = NULL;
+    const EC_POINT *generator = NULL;
+    const BIGNUM *priv_key = NULL;
+    int cfd, i, free_tmpbuff = 0;
+    unsigned char *tmp_buff = NULL;
+    struct session_op sess;
+    struct crypt_kop kop;
+
+	if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+	
+    group = EC_KEY_get0_group(eckey);
+    priv_key = EC_KEY_get0_private_key(eckey);
+
+    if (group == NULL || priv_key == NULL) {
+        ECDSAerr(EC_F_ECDSA_DO_SIGN_EX, ERR_R_PASSED_NULL_PARAMETER);
+        goto err;
+    }
+
+    if ((ctx = BN_CTX_new()) == NULL || (order = BN_new()) == NULL  || (m = BN_new()) == NULL) {
+        ECDSAerr(EC_F_ECDSA_DO_SIGN_EX, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+    
+    generator = EC_GROUP_get0_generator(group);
+    if (generator == NULL) {
+        ECerr(EC_F_ECDSA_DO_SIGN_EX, EC_R_UNDEFINED_GENERATOR);
+        goto err;
+    }
+    if (!generator->Z_is_one) {
+        printf("\n cryptodev_ecdsa_sign_sig : Z of the generator is NOT 1! We don't support the case\n");
+        goto err;
+    }
+    
+    if (!EC_GROUP_get_order(group, order, ctx)) {
+        ECDSAerr(EC_F_ECDSA_DO_SIGN_EX, ERR_R_EC_LIB);
+        goto err;
+    }
+    /*
+     * Need to truncate digest if it is too long.
+     */
+    i = BN_num_bits(order);
+    if ( i >= (8 * dgst_len - 7) && i < 8 * dgst_len) {
+        if (!BN_bin2bn(dgst, dgst_len, m) || !BN_rshift(m, m, 8 - (i & 0x7))) {
+            ECDSAerr(EC_F_ECDSA_DO_SIGN_EX, ERR_R_BN_LIB);
+            goto err;
+        }
+        dgst_len = BN_num_bytes(m);
+        tmp_buff = OPENSSL_malloc(dgst_len);
+        if (NULL == tmp_buff) {
+            perror("cryptodev_ecdsa_sign_sig: OPENSSL_malloc error");
+            goto err;
+        }
+        BN_bn2bin(m, tmp_buff);
+        free_tmpbuff = 1;
+    }
+    else if (i < (8 * dgst_len - 7)) {
+        dgst_len = (i + 7) / 8; 
+        tmp_buff = dgst;
+    }
+    else
+        tmp_buff = dgst;
+
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_ECDSA_SIGN;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_ecdsa_sign_sig : ioctl(CIOCGSESSION)");
+		goto err;
+	}    
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECDSA_SIGN;
+    kop.crk_flags = curve2field(group->curve_name);
+    if (KCOP_FLAG_NONE == kop.crk_flags)
+        goto out_ecdsa_sign;
+    /* inputs: ecdsa->p ecdsa->q ecdsa->g ecdsa->priv_key dgst ecdsa->a,b*/    
+	/* Set parameter q */
+    if (bn2crparam(group->field, &kop.crk_param[0]))
+        goto out_ecdsa_sign;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(group->field));
+
+	/* Set parameter r */
+    if (bn2crparam(order, &kop.crk_param[1]))
+        goto out_ecdsa_sign;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(order));
+
+    /* Set parameter Gx,y */
+    kop.crk_param[2].crp_p = OPENSSL_malloc(BN_num_bytes(group->field)*2);
+    if (NULL == kop.crk_param[2].crp_p)
+        goto out_ecdsa_sign;
+    memset(kop.crk_param[2].crp_p, 0, BN_num_bytes(group->field)*2);
+    kop.crk_param[2].crp_nbits = BN_num_bytes(group->field) * 16;
+    memcpy(kop.crk_param[2].crp_p, generator->X->d, BN_num_bytes(generator->X));
+    memcpy(kop.crk_param[2].crp_p + BN_num_bytes(group->field), generator->Y->d, BN_num_bytes(generator->Y));
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(group->field));
+    int_swap(kop.crk_param[2].crp_p + BN_num_bytes(group->field), BN_num_bytes(group->field));
+
+    /* Set parameter private key */
+    kop.crk_param[3].crp_p = OPENSSL_malloc(BN_num_bytes(order));
+    if(NULL == kop.crk_param[3].crp_p)
+        goto out_ecdsa_sign;
+    memset(kop.crk_param[3].crp_p, 0, BN_num_bytes(order));
+    kop.crk_param[3].crp_nbits = BN_num_bytes(order) * 8;
+    memcpy(kop.crk_param[3].crp_p, priv_key->d, BN_num_bytes(priv_key));
+    int_swap(kop.crk_param[3].crp_p, BN_num_bytes(order));
+
+    /* Set parameter f (or m) */
+    kop.crk_param[4].crp_p = OPENSSL_malloc(BN_num_bytes(order));
+    if(NULL == kop.crk_param[4].crp_p)
+        goto out_ecdsa_sign;
+    memset(kop.crk_param[4].crp_p, 0, BN_num_bytes(order));
+    kop.crk_param[4].crp_nbits = BN_num_bytes(order) * 8;
+    memcpy(kop.crk_param[4].crp_p, tmp_buff, dgst_len);    
+
+    /* Set parameter a,b */
+    kop.crk_param[5].crp_p = OPENSSL_malloc(BN_num_bytes(group->field)*2);
+    if (NULL == kop.crk_param[5].crp_p)
+        goto out_ecdsa_sign;
+    memset(kop.crk_param[5].crp_p, 0, BN_num_bytes(group->field)*2);
+    kop.crk_param[5].crp_nbits = BN_num_bytes(group->field) * 16;	
+    memcpy(kop.crk_param[5].crp_p,group->a->d, BN_num_bytes(group->a));
+    memcpy(kop.crk_param[5].crp_p + BN_num_bytes(group->field), group->b->d, BN_num_bytes(group->b));
+    int_swap(kop.crk_param[5].crp_p, BN_num_bytes(group->field));
+    int_swap(kop.crk_param[5].crp_p + BN_num_bytes(group->field), BN_num_bytes(group->field));	
+    kop.crk_iparams = 6;
+
+    kop.crk_param[kop.crk_iparams].crp_p = OPENSSL_malloc(BN_num_bytes(order));
+    kop.crk_param[kop.crk_iparams].crp_nbits = BN_num_bytes(order) * 8;
+    kop.crk_param[kop.crk_iparams + 1].crp_p = OPENSSL_malloc(BN_num_bytes(order));
+    kop.crk_param[kop.crk_iparams + 1].crp_nbits = BN_num_bytes(order) * 8;
+    kop.crk_oparams = 2;
+
+    if (ioctl(cfd, CIOCKEY, &kop) == 0) {
+        ecdsaret = ECDSA_SIG_new();
+        if (ecdsaret == NULL) {
+            ECDSAerr(EC_F_ECDSA_DO_SIGN_EX, ERR_R_MALLOC_FAILURE);
+            goto out_ecdsa_sign;
+        }
+        ecdsaret->r = BN_new();
+        ecdsaret->s = BN_new();
+        if (ecdsaret->r == NULL || ecdsaret->s == NULL) {
+            ECerr(EC_F_ECDSA_DO_SIGN_EX, ERR_R_MALLOC_FAILURE);
+            goto out_ecdsa_sign;
+        }
+        r = ecdsaret->r;
+        s = ecdsaret->s;
+        if (r) {
+            BN_bin2bn(kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8, r);
+        }
+        if (s) {
+            BN_bin2bn(kop.crk_param[kop.crk_iparams + 1].crp_p, (kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8, s);
+        }
+    }
+out_ecdsa_sign:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_ecdsa_sign_sig : ioctl(CIOCFSESSION)");
+    }
+   
+    zapparams(&kop);
+ err:  
+    if (ctx)
+        BN_CTX_free(ctx);
+    if (m)
+        BN_clear_free(m);
+    if (free_tmpbuff)
+        OPENSSL_free(tmp_buff);
+    if (order)
+        BN_free(order);
+    put_dev_crypto(cfd);    
+    return (ecdsaret);
+}
+
+int cryptodev_ecdsa_sign(int type, const unsigned char *dgst, int dlen,
+                    unsigned char *sig, unsigned int *siglen,
+                    const BIGNUM *kinv, const BIGNUM *r, EC_KEY *eckey)
+{
+    ECDSA_SIG *s;
+    RAND_seed(dgst, dlen);
+    s = cryptodev_ecdsa_sign_sig(dgst, dlen, kinv, r, eckey);
+    if (s == NULL) {
+        *siglen = 0;
+        return 0;
+    }
+    *siglen = i2d_ECDSA_SIG(s, &sig);
+    ECDSA_SIG_free(s);
+    return 1;
+}
+
+
+static int
+cryptodev_ecdsa_verify_sig(const unsigned char *dgst, int dlen,
+                     const ECDSA_SIG *sig, EC_KEY *eckey)
+{
+    int cfd, i, free_tmpbuff = 0;
+    unsigned char *tmp_buff = NULL;
+    struct session_op sess;
+    struct crypt_kop kop;
+    int dsaret = 0;
+    BIGNUM *order = NULL, *m = NULL;
+    const EC_POINT *generator = NULL;
+    BN_CTX *ctx = NULL;
+    const EC_GROUP *group;
+    const EC_POINT *pub_key;
+
+    /* check input values */
+    if (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL ||
+        (pub_key = EC_KEY_get0_public_key(eckey)) == NULL || sig == NULL) {
+        ECDSAerr(EC_F_ECDSA_DO_VERIFY, EC_R_MISSING_PARAMETERS);
+        return -1;
+    }
+
+    
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+    ctx = BN_CTX_new();
+    if (!ctx) {
+        ECDSAerr(EC_F_ECDSA_DO_VERIFY, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+    BN_CTX_start(ctx);
+
+    generator = EC_GROUP_get0_generator(group);
+    if (generator == NULL) {
+        ECerr(EC_F_EC_WNAF_MUL, EC_R_UNDEFINED_GENERATOR);
+        goto err;
+    }
+    if (!(generator->Z_is_one)) {
+        printf("\n cryptodev_ecdsa_verify_sig : Z of the generator is NOT 1! We don't support the case\n");
+        goto err;
+    }
+
+    order = BN_CTX_get(ctx);
+    m = BN_CTX_get(ctx);
+    if (!EC_GROUP_get_order(group, order, ctx))
+        goto err;
+    if (BN_is_zero(sig->r) || BN_is_negative(sig->r) ||
+        BN_ucmp(sig->r, order) >= 0 || BN_is_zero(sig->s) ||
+        BN_is_negative(sig->s) || BN_ucmp(sig->s, order) >= 0) {
+        ECDSAerr(EC_F_ECDSA_DO_VERIFY, EC_R_BAD_SIGNATURE);
+        dsaret = 0;                /* signature is invalid */
+        goto err;
+    }
+
+    /*
+      * Need to truncate digest if it is too long.
+      */
+    i = BN_num_bits(order);
+    if ( i >= (8 * dlen - 7) && i < 8 * dlen) {
+        if (!BN_bin2bn(dgst, dlen, m) || !BN_rshift(m, m, 8 - (i & 0x7))) {
+            ECDSAerr(EC_F_ECDSA_DO_SIGN_EX, ERR_R_BN_LIB);
+            goto err;
+        }
+        dlen = BN_num_bytes(m);
+        tmp_buff = OPENSSL_malloc(dlen);
+        if (NULL == tmp_buff) {
+            perror("cryptodev_ecdsa_verify_sig: OPENSSL_malloc error");
+            goto err;
+        }
+        BN_bn2bin(m, tmp_buff);
+        free_tmpbuff = 1;
+    }
+    else if (i < (8 * dlen - 7)) {
+        dlen = (i + 7) / 8; 
+        tmp_buff = dgst;
+    }
+    else
+        tmp_buff = dgst;
+    
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_ECDSA_VERIFY;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_ecdsa_verify_sig : ioctl(CIOCGSESSION)");
+		goto err;
+	}
+
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECDSA_VERIFY;
+    kop.crk_flags = curve2field(group->curve_name);
+    if (KCOP_FLAG_NONE == kop.crk_flags)
+        goto out_ecdsa_verify;
+    
+    /* inputs: ecdsa->q ecdsa->r ecdsa->g ecdsa->pub_key dgst sig->r sig->s ecdsa->a,b*/
+    /* Set parameter q */
+    if (bn2crparam(group->field, &kop.crk_param[0]))
+        goto out_ecdsa_verify;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(group->field));
+
+	/* Set parameter r */
+    if (bn2crparam(order, &kop.crk_param[1]))
+        goto out_ecdsa_verify;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(order));
+
+    /* Set parameter Gx,y */
+    kop.crk_param[2].crp_p = OPENSSL_malloc(BN_num_bytes(group->field)*2);
+    if (NULL == kop.crk_param[2].crp_p)
+        goto out_ecdsa_verify;
+    memset(kop.crk_param[2].crp_p, 0, BN_num_bytes(group->field)*2);
+    kop.crk_param[2].crp_nbits = BN_num_bytes(group->field) * 16;
+    memcpy(kop.crk_param[2].crp_p, generator->X->d, BN_num_bytes(generator->X));
+    memcpy(kop.crk_param[2].crp_p + BN_num_bytes(group->field), generator->Y->d, BN_num_bytes(generator->Y));
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(group->field));
+    int_swap(kop.crk_param[2].crp_p + BN_num_bytes(group->field), BN_num_bytes(group->field));	
+
+    /* Set parameter public key */
+    kop.crk_param[3].crp_p = OPENSSL_malloc(BN_num_bytes(group->field)*2);
+    if (NULL == kop.crk_param[3].crp_p)
+        goto out_ecdsa_verify;
+    memset(kop.crk_param[3].crp_p, 0, BN_num_bytes(group->field)*2);
+    kop.crk_param[3].crp_nbits = BN_num_bytes(group->field) * 16;
+    memcpy(kop.crk_param[3].crp_p, pub_key->X->d, BN_num_bytes(pub_key->X));
+    memcpy(kop.crk_param[3].crp_p + BN_num_bytes(group->field), pub_key->Y->d, BN_num_bytes(pub_key->Y));
+    int_swap(kop.crk_param[3].crp_p, BN_num_bytes(group->field));
+    int_swap(kop.crk_param[3].crp_p + BN_num_bytes(group->field), BN_num_bytes(group->field));
+
+    /* Set parameter f (or m) */
+    kop.crk_param[4].crp_p = OPENSSL_malloc(BN_num_bytes(order));    
+    if(NULL == kop.crk_param[4].crp_p)
+        goto out_ecdsa_verify;
+    memset(kop.crk_param[4].crp_p, 0, BN_num_bytes(order));
+    kop.crk_param[4].crp_nbits = BN_num_bytes(order) * 8;
+    memcpy(kop.crk_param[4].crp_p, tmp_buff, dlen);    
+
+    /* Set parameter c */
+    kop.crk_param[5].crp_p = OPENSSL_malloc(BN_num_bytes(order));
+    if (NULL == kop.crk_param[5].crp_p)
+        goto out_ecdsa_verify;
+    memset(kop.crk_param[5].crp_p, 0, BN_num_bytes(order));
+    kop.crk_param[5].crp_nbits = BN_num_bytes(order) * 8;
+    memcpy(kop.crk_param[5].crp_p, sig->r->d, BN_num_bytes(sig->r));	
+    int_swap(kop.crk_param[5].crp_p, BN_num_bytes(order));
+
+    /* Set parameter d */
+    kop.crk_param[6].crp_p = OPENSSL_malloc(BN_num_bytes(order));
+    if (NULL == kop.crk_param[6].crp_p)
+        goto out_ecdsa_verify;
+    memset(kop.crk_param[6].crp_p, 0, BN_num_bytes(order));
+    kop.crk_param[6].crp_nbits = BN_num_bytes(order) * 8;
+    memcpy(kop.crk_param[6].crp_p, sig->s->d, BN_num_bytes(sig->s));	
+    int_swap(kop.crk_param[6].crp_p, BN_num_bytes(order));
+
+    /* Set parameter a,b */
+    kop.crk_param[7].crp_p = OPENSSL_malloc(BN_num_bytes(group->field)*2);
+    if (NULL == kop.crk_param[7].crp_p)
+        goto out_ecdsa_verify;
+    memset(kop.crk_param[7].crp_p, 0, BN_num_bytes(group->field)*2);
+    kop.crk_param[7].crp_nbits = BN_num_bytes(group->field) * 16;
+    memcpy(kop.crk_param[7].crp_p,eckey->group->a->d, BN_num_bytes(eckey->group->a));
+    memcpy(kop.crk_param[7].crp_p + BN_num_bytes(group->field), eckey->group->b->d, BN_num_bytes(eckey->group->b));
+    int_swap(kop.crk_param[7].crp_p, BN_num_bytes(group->field));
+    int_swap(kop.crk_param[7].crp_p + BN_num_bytes(group->field), BN_num_bytes(group->field));	
+	
+    kop.crk_iparams = 8;
+
+    if (ioctl(cfd, CIOCKEY, &kop)) {
+        dsaret = 0;
+		perror("\n cryptodev_ecdsa_verify_sig failed \n");
+	}
+    else {
+    /*
+       * OCF success value is 0, if not zero, change dsaret to fail
+       */
+        if (1 == kop.crk_status)
+            dsaret = 1;
+        else
+            dsaret = 0;
+    } 
+out_ecdsa_verify:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_ecdsa_verify_sig : ioctl(CIOCFSESSION)");
+    }
+    zapparams(&kop);
+ err:
+    BN_CTX_end(ctx);
+    if (ctx != NULL)
+        BN_CTX_free(ctx);
+    if (free_tmpbuff)
+        OPENSSL_free(tmp_buff);
+    put_dev_crypto(cfd);
+    return (dsaret);
+}
+
+int cryptodev_ecdsa_verify(int type, const unsigned char *dgst, int dgst_len,
+                      const unsigned char *sigbuf, int sig_len, EC_KEY *eckey)
+{
+    ECDSA_SIG *s;
+    const unsigned char *p = sigbuf;
+    unsigned char *der = NULL;
+    int derlen = -1;
+    int ret = -1;
+
+    s = ECDSA_SIG_new();
+    if (s == NULL)
+        return (ret);
+    if (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL)
+        goto err;
+    /* Ensure signature uses DER and doesn't have trailing garbage */
+    derlen = i2d_ECDSA_SIG(s, &der);
+    if (derlen != sig_len || memcmp(sigbuf, der, derlen) != 0)
+        goto err;
+    ret = cryptodev_ecdsa_verify_sig(dgst, dgst_len, s, eckey);
+ err:
+    OPENSSL_clear_free(der, derlen);
+    ECDSA_SIG_free(s);
+    return (ret);
+}
+
+int cryptodev_has_pkc(void)
+{
+    if ((cryptodev_asymfeat & CRF_ECDSA_SIGN) && (cryptodev_asymfeat & CRF_ECDSA_VERIFY) \
+            && (cryptodev_asymfeat & CRF_RSA_PUBLIC) && (cryptodev_asymfeat & CRF_RSA_PRIVATE) \
+            && (cryptodev_asymfeat & CRF_ECDH_COMPUTE_KEY) && (cryptodev_asymfeat & CRF_ECDH_GENERATE_KEY) \
+            && (cryptodev_asymfeat & CRF_DSA_SIGN) && (cryptodev_asymfeat & CRF_DSA_VERIFY) \
+            && (cryptodev_asymfeat & CRF_DH_COMPUTE_KEY) && (cryptodev_asymfeat & CRF_DH_GENERATE_KEY))
+        return 1;
+    else
+        return 0;
+}
+int cryptodev_ec_keygen(EC_KEY *eckey)
+{
+    int ok = 0;
+    BIGNUM *priv_key = NULL, *order = NULL;
+    EC_POINT *pub_key = NULL;
+    const EC_POINT *generator = NULL;
+    struct session_op sess;
+	struct crypt_kop kop;
+    int cfd, priv_key_len, pub_key_len;
+    BN_CTX *ctx = NULL;
+
+    if (!eckey || !eckey->group) {
+        ECerr(EC_F_EC_KEY_GENERATE_KEY, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+
+    generator = EC_GROUP_get0_generator(eckey->group);
+    if (generator == NULL) {
+        ECerr(EC_F_EC_WNAF_MUL, EC_R_UNDEFINED_GENERATOR);
+        goto err;
+    }
+    if (!(generator->Z_is_one)) {
+        printf("\n cryptodev_ecdsa_keygen : Z of the generator is NOT 1! We don't support the case\n");
+        goto err;
+    }
+
+    if ((order = BN_new()) == NULL)
+        goto err;
+    if ((ctx = BN_CTX_new()) == NULL)
+        goto err;
+    
+    if (eckey->priv_key == NULL) {
+        priv_key = BN_new();
+        if (priv_key == NULL)
+            goto err;
+    } else
+        priv_key = eckey->priv_key;
+
+    if (!EC_GROUP_get_order(eckey->group, order, ctx))
+        goto err;
+
+    if (eckey->pub_key == NULL) {
+        pub_key = EC_POINT_new(eckey->group);
+        if (pub_key == NULL)
+            goto err;
+    } else
+        pub_key = eckey->pub_key;
+
+    memset(&sess, 0, sizeof(sess));
+	memset(&kop, 0, sizeof(kop));
+
+	sess.pk_cipher = CRYPTO_ASYMMETRIC_ECDH_GENERATE_KEY;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_ecdsa_keygen : ioctl(CIOCGSESSION)");
+		goto err;
+	}
+    kop.ses = sess.ses;
+	kop.crk_op = CRK_ECDH_GENERATE_KEY;
+    kop.crk_flags = curve2field(eckey->group->curve_name);
+    if (KCOP_FLAG_NONE == kop.crk_flags)
+        goto out_ec_keygen;
+    /* Set parameter q */
+    if (bn2crparam(eckey->group->field, &kop.crk_param[0]))
+        goto out_ec_keygen;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(eckey->group->field));
+	
+    /* Set parameter r */
+    if (bn2crparam(order, &kop.crk_param[1]))
+        goto out_ec_keygen;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(order));
+	
+    /* Set parameter Gx,y */
+    kop.crk_param[2].crp_p = OPENSSL_malloc(BN_num_bytes(eckey->group->field)*2);
+    if (NULL == kop.crk_param[2].crp_p)
+        goto out_ec_keygen;
+    memset(kop.crk_param[2].crp_p, 0, BN_num_bytes(eckey->group->field)*2);
+    kop.crk_param[2].crp_nbits = BN_num_bytes(eckey->group->field) * 16;
+    memcpy(kop.crk_param[2].crp_p, generator->X->d, BN_num_bytes(generator->X));
+    memcpy(kop.crk_param[2].crp_p + BN_num_bytes(eckey->group->field), generator->Y->d, BN_num_bytes(generator->Y));
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(eckey->group->field));
+    int_swap(kop.crk_param[2].crp_p + BN_num_bytes(eckey->group->field), BN_num_bytes(eckey->group->field));
+	
+    /* Set parameter a,b */
+    kop.crk_param[3].crp_p = OPENSSL_malloc(BN_num_bytes(eckey->group->field)*2);
+    if (NULL == kop.crk_param[3].crp_p)
+        goto out_ec_keygen;
+    memset(kop.crk_param[3].crp_p, 0, BN_num_bytes(eckey->group->field)*2);
+    kop.crk_param[3].crp_nbits = BN_num_bytes(eckey->group->field) * 16;
+    memcpy(kop.crk_param[3].crp_p,eckey->group->a->d, BN_num_bytes(eckey->group->a));
+    memcpy(kop.crk_param[3].crp_p + BN_num_bytes(eckey->group->field), eckey->group->b->d, BN_num_bytes(eckey->group->b));
+    int_swap(kop.crk_param[3].crp_p, BN_num_bytes(eckey->group->field));
+    int_swap(kop.crk_param[3].crp_p + BN_num_bytes(eckey->group->field), BN_num_bytes(eckey->group->field));
+	
+    kop.crk_iparams = 4;
+    priv_key_len = BN_num_bytes(order);
+    pub_key_len = 2 * BN_num_bytes(eckey->group->field);
+    kop.crk_param[kop.crk_iparams].crp_p = OPENSSL_malloc(priv_key_len);
+    kop.crk_param[kop.crk_iparams].crp_nbits = priv_key_len * 8;
+    kop.crk_param[kop.crk_iparams + 1].crp_p = OPENSSL_malloc(pub_key_len);
+    kop.crk_param[kop.crk_iparams + 1].crp_nbits = pub_key_len * 8;
+	kop.crk_oparams = 2;
+    if (ioctl(cfd, CIOCKEY, &kop)) {
+		perror("\n cryptodev_ecdsa_keygen failed \n");
+		goto out_ec_keygen;
+	}
+    /* Get parameter s (Private key) */
+	BN_bin2bn(kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8, priv_key);
+    /* Get parameter Wx,y (Public key) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams + 1].crp_p, (kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8/2, pub_key->X);
+	BN_bin2bn(kop.crk_param[kop.crk_iparams + 1].crp_p + (kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8/2, (kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8/2, pub_key->Y);
+    BN_set_word(pub_key->Z,1);
+    pub_key->Z_is_one = 1;
+    
+    eckey->priv_key = priv_key;
+    eckey->pub_key = pub_key;
+    ok = 1;
+    
+out_ec_keygen:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_ecdsa_keygen : ioctl(CIOCFSESSION)");
+    }
+    zapparams(&kop);
+ err:
+    if (order)
+        BN_free(order);
+    if (pub_key != NULL && eckey->pub_key == NULL)
+        EC_POINT_free(pub_key);
+    if (priv_key != NULL && eckey->priv_key == NULL)
+        BN_free(priv_key);
+    if (ctx != NULL)
+        BN_CTX_free(ctx);
+    put_dev_crypto(cfd);
+    return (ok);
+}
+
+#ifndef OPENSSL_NO_DH
+static int cryptodev_dh_generate_key(DH *dh)
+{
+    int ok = 0;
+    BIGNUM *pub_key = NULL, *priv_key = NULL;
+    struct session_op sess;
+    struct crypt_kop kop;
+    int cfd, priv_key_len, pub_key_len;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+    if (dh->priv_key == NULL) {
+        if ((priv_key = BN_secure_new()) == NULL)
+            goto err;
+    } else
+        priv_key = dh->priv_key;
+
+    if (dh->pub_key == NULL) {
+        if ((pub_key = BN_new()) == NULL)
+            goto err;
+    } else
+        pub_key = dh->pub_key;
+
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_DH_GENERATE_KEY;
+    if (ioctl(cfd, CIOCGSESSION, &sess)) {
+        perror("cryptodev_dh_generate_key : ioctl(CIOCGSESSION)");
+        goto err;
+    }
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_DH_GENERATE_KEY;
+    /* Set parameter q */
+    if (bn2crparam(dh->params.p, &kop.crk_param[0]))
+        goto out_dh_keygen;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(dh->params.p));
+    /* Set parameter r */
+    if(dh->params.q) {
+        if (bn2crparam(dh->params.q, &kop.crk_param[1]))
+            goto out_dh_keygen;
+        int_swap(kop.crk_param[1].crp_p, BN_num_bytes(dh->params.q));
+    }
+    else {
+        if (bn2crparam(dh->params.p, &kop.crk_param[1]))
+            goto out_dh_keygen;
+        int_swap(kop.crk_param[1].crp_p, BN_num_bytes(dh->params.p));
+    }
+    
+    /* Set parameter g */
+    if (bn2crparam(dh->params.g, &kop.crk_param[2]))
+        goto out_dh_keygen;
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(dh->params.g));
+    kop.crk_iparams = 3;
+    if(dh->params.q)
+        priv_key_len = BN_num_bytes(dh->params.q);
+    else
+        priv_key_len = BN_num_bytes(dh->params.p);
+    pub_key_len = BN_num_bytes(dh->params.p);
+    kop.crk_param[kop.crk_iparams].crp_p = OPENSSL_malloc(priv_key_len);
+    kop.crk_param[kop.crk_iparams].crp_nbits = priv_key_len * 8;
+    kop.crk_param[kop.crk_iparams + 1].crp_p = OPENSSL_malloc(pub_key_len);
+    kop.crk_param[kop.crk_iparams + 1].crp_nbits = pub_key_len * 8;
+    kop.crk_oparams = 2;
+    if (ioctl(cfd, CIOCKEY, &kop)) {
+        perror("\n cryptodev_dh_generate_key failed \n");
+        goto out_dh_keygen;
+    }
+    /* Get parameter s (Private key) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams].crp_p, (kop.crk_param[kop.crk_iparams].crp_nbits + 7)/8, priv_key);
+    /* Get parameter w (Public key) */
+    BN_bin2bn(kop.crk_param[kop.crk_iparams + 1].crp_p, (kop.crk_param[kop.crk_iparams + 1].crp_nbits + 7)/8, pub_key);
+    
+    dh->priv_key = priv_key;
+    dh->pub_key = pub_key;
+    ok = 1;
+    
+out_dh_keygen:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_dh_generate_key : ioctl(CIOCFSESSION)");
+    }
+    zapparams(&kop);
+ err:
+    if ((pub_key != NULL) && (dh->pub_key == NULL))
+        BN_free(pub_key);
+    if ((priv_key != NULL) && (dh->priv_key == NULL))
+        BN_free(priv_key);
+    put_dev_crypto(cfd);
+    return (ok);
+}
+
+static int cryptodev_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)
+{
+    int ok = 0;
+    BIGNUM *tmp = NULL;
+    BN_CTX *ctx = NULL;
+
+    *ret = 0;
+    ctx = BN_CTX_new();
+    if (ctx == NULL)
+        goto err;
+    BN_CTX_start(ctx);
+    tmp = BN_CTX_get(ctx);
+    if (tmp == NULL || !BN_set_word(tmp, 1))
+        goto err;
+    if (BN_cmp(pub_key, tmp) <= 0)
+        *ret |= DH_CHECK_PUBKEY_TOO_SMALL;
+    if (BN_copy(tmp, dh->params.p) == NULL || !BN_sub_word(tmp, 1))
+        goto err;
+    if (BN_cmp(pub_key, tmp) >= 0)
+        *ret |= DH_CHECK_PUBKEY_TOO_LARGE;
+
+    if (dh->params.q != NULL) {
+        /* Check pub_key^q == 1 mod p */
+        if (!cryptodev_bn_mod_exp(tmp, pub_key, dh->params.q, dh->params.p))
+            goto err;
+        if (!BN_is_one(tmp))
+            *ret |= DH_CHECK_PUBKEY_INVALID;
+    }
+
+    ok = 1;
+ err:
+    if (ctx != NULL) {
+        BN_CTX_end(ctx);
+        BN_CTX_free(ctx);
+    }
+    return (ok);
+}
+static int
+cryptodev_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)
+{
+    struct session_op sess;
+    struct crypt_kop kop;
+    int dhret = -1;
+    int cfd, keylen;
+    int check_result;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+    if (BN_num_bits(dh->params.p) > HW_DH_MAX_MODULUS_BITS) {
+        DHerr(DH_F_COMPUTE_KEY, DH_R_MODULUS_TOO_LARGE);
+        return 0;
+    }
+    if (!cryptodev_check_pub_key(dh, pub_key, &check_result) || check_result) {
+        DHerr(DH_F_COMPUTE_KEY, DH_R_INVALID_PUBKEY);
+        return -1;
+    }
+
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_DH_COMPUTE_KEY;
+    if (ioctl(cfd, CIOCGSESSION, &sess)) {
+        perror("cryptodev_dh_compute_key : ioctl(CIOCGSESSION)");
+        goto err;
+    }    
+    
+    keylen = BN_num_bits(dh->params.p);
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_DH_COMPUTE_KEY;
+
+    /* inputs: dh->p dh->priv_key pub_key key */
+    if (bn2crparam(dh->params.p, &kop.crk_param[0]))
+        goto out_dh_compute_key;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(dh->params.p));
+    if (bn2crparam(dh->priv_key, &kop.crk_param[1]))
+        goto out_dh_compute_key;
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(dh->priv_key));
+    if (bn2crparam(pub_key, &kop.crk_param[2]))
+        goto out_dh_compute_key;    
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(pub_key));
+    kop.crk_iparams = 3;
+
+    kop.crk_param[3].crp_p = OPENSSL_malloc((keylen + 7)/8);  
+    if(NULL == kop.crk_param[3].crp_p)
+        goto out_dh_compute_key;
+    kop.crk_param[3].crp_nbits = keylen;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop))
+        perror("\n cryptodev_dh_compute_key failed \n");
+    else {        
+        dhret = (keylen + 7)/ 8;
+        int_swap(kop.crk_param[3].crp_p, dhret);
+        memcpy(key, kop.crk_param[3].crp_p, dhret);        
+    }
+out_dh_compute_key:
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_dh_compute_key : ioctl(CIOCFSESSION)");
+    }    
+err:
+    put_dev_crypto(cfd);
+    zapparams(&kop);
+    return (dhret);
+}
+
+#endif /* ndef OPENSSL_NO_DH */
+static int cryptodev_ecdh_compute_key(unsigned char **pout, size_t *outlen, const EC_POINT *pub_key,
+                            const EC_KEY *ecdh)
+{
+    const BIGNUM *priv_key;
+    const EC_GROUP *group;
+	BIGNUM *order = NULL;
+	BN_CTX *ctx = NULL;
+    struct session_op sess;
+    struct crypt_kop kop;
+    int cfd, keylen;
+    int ecdhret = -1;
+    unsigned char *out = NULL;
+
+    if ((cfd = get_dev_crypto()) < 0) {
+        return 0;
+    }
+   	ctx = BN_CTX_new();
+    if (!ctx) {
+        ECDSAerr(EC_F_ECDH_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+    BN_CTX_start(ctx);
+	
+    priv_key = EC_KEY_get0_private_key(ecdh);
+    if (priv_key == NULL) {
+        ECDHerr(EC_F_ECDH_COMPUTE_KEY, EC_R_NO_PRIVATE_VALUE);
+        goto err;
+    }
+
+    group = EC_KEY_get0_group(ecdh);
+    if (group == NULL) {
+        ECDSAerr(EC_F_ECDH_COMPUTE_KEY, EC_R_UNDEFINED_ORDER);
+        goto err;
+    }
+
+	order = BN_CTX_get(ctx);
+    if (!EC_GROUP_get_order(group, order, ctx))
+        goto err;
+	
+    if (pub_key == NULL) {
+        ECerr(EC_F_EC_WNAF_MUL, EC_R_MISSING_PARAMETERS);
+        goto err;
+    }
+    if (!(pub_key->Z_is_one)) {
+        printf("\n cryptodev_ecdh_compute_key : Z of the generator is NOT 1! We don't support the case\n");
+        goto err;
+    }
+   
+    keylen = BN_num_bits(group->field);
+    memset(&sess, 0, sizeof(sess));
+    memset(&kop, 0, sizeof(kop));
+    sess.pk_cipher = CRYPTO_ASYMMETRIC_ECDH_COMPUTE_KEY;
+    
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("cryptodev_ecdh_compute_key : ioctl(CIOCGSESSION)");
+		goto err;
+	}
+    
+    kop.ses = sess.ses;
+    kop.crk_op = CRK_ECDH_COMPUTE_KEY;
+    kop.crk_flags = curve2field(group->curve_name);
+    if (KCOP_FLAG_NONE == kop.crk_flags)
+        goto out_ecdh_compute_key;
+
+    /* inputs: ecdh->q ecdh->priv_key pub_key ecdh->a,b*/  
+	/* Set parameter q */
+    if (bn2crparam(group->field, &kop.crk_param[0]))
+        goto out_ecdh_compute_key;
+    int_swap(kop.crk_param[0].crp_p, BN_num_bytes(group->field));
+	
+    /* Set parameter private key */
+    kop.crk_param[1].crp_p = OPENSSL_malloc(BN_num_bytes(order));
+    if(NULL == kop.crk_param[1].crp_p)
+        goto out_ecdh_compute_key;
+    memset(kop.crk_param[1].crp_p, 0, BN_num_bytes(order));
+    kop.crk_param[1].crp_nbits = BN_num_bytes(order) * 8;
+    memcpy(kop.crk_param[1].crp_p, priv_key->d, BN_num_bytes(priv_key));
+    int_swap(kop.crk_param[1].crp_p, BN_num_bytes(order));
+
+    /* Set parameter public key */
+    kop.crk_param[2].crp_p = OPENSSL_malloc(BN_num_bytes(group->field)*2);
+    if (NULL == kop.crk_param[2].crp_p)
+        goto out_ecdh_compute_key;
+    memset(kop.crk_param[2].crp_p, 0, BN_num_bytes(group->field)*2);
+    kop.crk_param[2].crp_nbits = BN_num_bytes(group->field) * 16;
+    memcpy(kop.crk_param[2].crp_p, pub_key->X->d, BN_num_bytes(pub_key->X));
+    memcpy(kop.crk_param[2].crp_p + BN_num_bytes(group->field), pub_key->Y->d, BN_num_bytes(pub_key->Y));
+    int_swap(kop.crk_param[2].crp_p, BN_num_bytes(group->field));
+    int_swap(kop.crk_param[2].crp_p + BN_num_bytes(group->field), BN_num_bytes(group->field));
+
+    /* Set parameter a,b */
+    kop.crk_param[3].crp_p = OPENSSL_malloc(BN_num_bytes(group->field)*2);
+    if (NULL == kop.crk_param[3].crp_p)
+        goto out_ecdh_compute_key;
+    memset(kop.crk_param[3].crp_p, 0, BN_num_bytes(group->field)*2);
+    kop.crk_param[3].crp_nbits = BN_num_bytes(group->field) * 16;
+    memcpy(kop.crk_param[3].crp_p, group->a->d, BN_num_bytes(group->a));
+    memcpy(kop.crk_param[3].crp_p + BN_num_bytes(group->field), group->b->d, BN_num_bytes(group->b));
+    int_swap(kop.crk_param[3].crp_p, BN_num_bytes(group->field));
+    int_swap(kop.crk_param[3].crp_p + BN_num_bytes(group->field), BN_num_bytes(group->field));
+    
+    kop.crk_iparams = 4;
+    kop.crk_param[4].crp_p = OPENSSL_malloc((keylen + 7)/8);
+    if(NULL == kop.crk_param[4].crp_p)
+        goto out_ecdh_compute_key;
+    kop.crk_param[4].crp_nbits = keylen;
+    kop.crk_oparams = 1;
+
+    if (ioctl(cfd, CIOCKEY, &kop)) 
+        perror("\n cryptodev_ecdh_compute_key failed \n");
+    else {
+        ecdhret = (keylen + 7)/ 8;
+        int_swap(kop.crk_param[4].crp_p, ecdhret);        
+        if ((out = OPENSSL_malloc(ecdhret)) == NULL) {
+            perror("\n cryptodev_ecdh_compute_key failed \n");
+            goto out_ecdh_compute_key;
+        }
+        memcpy(out, kop.crk_param[4].crp_p, ecdhret);
+        *pout = out;
+        *outlen = ecdhret;
+    }
+
+out_ecdh_compute_key:
+
+    /* Finish session */
+    if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+        perror("cryptodev_ecdh_compute_key : ioctl(CIOCFSESSION)");
+    }
+    zapparams(&kop);    
+err:
+	BN_CTX_end(ctx);
+    if (ctx != NULL)
+        BN_CTX_free(ctx);
+    put_dev_crypto(cfd);    
+    return (ecdhret);
+}
+
+static const EC_KEY_METHOD cryptodev_ec_key = {
+    "cryptodev EC_KEY method",
+    0,
+    0,0,0,0,0,0,
+    cryptodev_ec_keygen,
+    cryptodev_ecdh_compute_key,
+    cryptodev_ecdsa_sign,
+    NULL,
+    cryptodev_ecdsa_sign_sig,
+    cryptodev_ecdsa_verify,
+    cryptodev_ecdsa_verify_sig,
+    cryptodev_bn_add_word,
+    cryptodev_bn_add,
+    cryptodev_bn_sub,
+    cryptodev_bn_mul2,
+    cryptodev_bn_mod_add,
+    cryptodev_bn_mod_sub,
+    cryptodev_bn_mod_mul,
+    cryptodev_bn_mod_sqr,
+    cryptodev_bn_mod_inverse,
+    cryptodev_bn_mod_ctx,
+    cryptodev_bn_nnmod,
+    cryptodev_ec_point_add,
+    cryptodev_ec_point_double,
+    cryptodev_ec_point_mul,
+    cryptodev_ec_check_point,
+};
+
+
+static int cryptodev_rand_bytes(unsigned char *buf, int num)
+{
+    int fd;
+	int cnt = 0;
+
+	fd = open("/dev/hwrng", O_RDONLY);
+	if(fd < 0) {
+		printf("hwrng open failed");
+		return -1;
+	}
+
+	do {
+		cnt = read(fd, buf, num);
+	} while(cnt != num);
+
+	close(fd);
+
+	return 1;
+}
+
+RAND_METHOD cryptodev_rand = {
+    NULL,
+    cryptodev_rand_bytes,
+    NULL,
+    NULL,
+    cryptodev_rand_bytes,
+    NULL
+};
+
+/******************************************************************************
+ *
+ * LOAD / UNLOAD
+ *
+ *****/
+
+/*
+ * Opens /dev/crypto
+ */
+static int open_devcrypto(void)
+{
+    int fd;
+
+    if (cfd >= 0)
+        return 1;
+
+    if ((fd = open("/dev/crypto", O_RDWR, 0)) < 0) {
+#ifndef ENGINE_DEVCRYPTO_DEBUG
+        if (errno != ENOENT)
+#endif
+            fprintf(stderr, "Could not open /dev/crypto: %s\n", strerror(errno));
+        return 0;
+    }
+
+#ifdef CRIOGET
+    if (ioctl(fd, CRIOGET, &cfd) < 0) {
+        fprintf(stderr, "Could not create crypto fd: %s\n", strerror(errno));
+        close(fd);
+        cfd = -1;
+        return 0;
+    }
+    close(fd);
+#else
+    cfd = fd;
+#endif
+
+    return 1;
+}
+
+static int close_devcrypto(void)
+{
+    int ret;
+
+    if (cfd < 0)
+        return 1;
+    ret = close(cfd);
+    cfd = -1;
+    if (ret != 0) {
+        fprintf(stderr, "Error closing /dev/crypto: %s\n", strerror(errno));
+        return 0;
+    }
+    return 1;
+}
+
+static int devcrypto_unload(ENGINE *e)
+{
+    destroy_all_cipher_methods();
+#ifdef IMPLEMENT_DIGEST
+    destroy_all_digest_methods();
+#endif
+
+    close_devcrypto();
+
+    return 1;
+}
+
+static int bind_devcrypto(ENGINE *e) {
+
+    if (!ENGINE_set_id(e, engine_devcrypto_id)
+        || !ENGINE_set_name(e, "/dev/crypto engine")
+        || !ENGINE_set_destroy_function(e, devcrypto_unload)
+        || !ENGINE_set_cmd_defns(e, devcrypto_cmds)
+        || !ENGINE_set_ctrl_function(e, devcrypto_ctrl))
+        return 0;
+
+    prepare_cipher_methods();
+#ifdef IMPLEMENT_DIGEST
+    prepare_digest_methods();
+#endif
+    
+    if (ENGINE_set_RAND(e, &cryptodev_rand)) {
+        rand_fd = open("/dev/hwrng", O_RDONLY);
+    	if (rand_fd < 0) {
+    		perror("hwrng open failed");
+            const RAND_METHOD *rand_meth = RAND_OpenSSL();
+            cryptodev_rand.seed = rand_meth->seed;
+            cryptodev_rand.bytes = rand_meth->bytes;
+            cryptodev_rand.cleanup = rand_meth->cleanup;
+            cryptodev_rand.add = rand_meth->add;
+            cryptodev_rand.pseudorand = rand_meth->pseudorand;
+            cryptodev_rand.status = rand_meth->status;
+    	}
+    }
+
+    
+    /*
+     * find out what asymmetric crypto algorithms we support
+     */
+    if (ioctl(cfd, CIOCASYMFEAT, &cryptodev_asymfeat) == 0) {
+        cryptodev_rsa = RSA_meth_dup(RSA_PKCS1_OpenSSL());
+        if (cryptodev_rsa != NULL) {
+            RSA_meth_set1_name(cryptodev_rsa, "cryptodev RSA method");
+            RSA_meth_set_flags(cryptodev_rsa, 0);
+            if (ENGINE_set_RSA(e, cryptodev_rsa)) {
+                if ((cryptodev_asymfeat & CRF_RSA_PUBLIC) && (cryptodev_asymfeat & CRF_RSA_PRIVATE)) {
+                    RSA_meth_set_pub_enc(cryptodev_rsa, cryptodev_rsa_public_encrypt);
+                    RSA_meth_set_pub_dec(cryptodev_rsa, cryptodev_rsa_public_decrypt);
+                    RSA_meth_set_priv_enc(cryptodev_rsa, cryptodev_rsa_private_encrypt);
+                    RSA_meth_set_priv_dec(cryptodev_rsa, cryptodev_rsa_private_decrypt);
+                    RSA_meth_set_keygen(cryptodev_rsa, cryptodev_rsa_keygen);
+                    RSA_meth_set_mod_exp(cryptodev_rsa, NULL);
+                    RSA_meth_set_bn_mod_exp(cryptodev_rsa, NULL);
+                    RSA_meth_set_init(cryptodev_rsa, NULL);
+                    RSA_meth_set_finish(cryptodev_rsa, NULL);
+                    RSA_meth_set_flags(cryptodev_rsa, 0);
+                    RSA_meth_set0_app_data(cryptodev_rsa, NULL);
+                    RSA_meth_set_sign(cryptodev_rsa, NULL);
+                    RSA_meth_set_verify(cryptodev_rsa, NULL);
+                }
+            }
+        }    
+#ifndef OPENSSL_NO_DSA
+        cryptodev_dsa = DSA_meth_dup(DSA_OpenSSL());
+        if (cryptodev_dsa != NULL) {
+            DSA_meth_set1_name(cryptodev_dsa, "cryptodev DSA method");
+            DSA_meth_set_flags(cryptodev_dsa, 0);
+            if (ENGINE_set_DSA(e, cryptodev_dsa)) {
+                if ((cryptodev_asymfeat & CRF_DSA_SIGN) && (cryptodev_asymfeat & CRF_DSA_VERIFY)) {            
+                    DSA_meth_set_sign(cryptodev_dsa, cryptodev_dsa_do_sign);
+                    DSA_meth_set_verify(cryptodev_dsa, cryptodev_dsa_verify);
+                    DSA_meth_set_keygen(cryptodev_dsa, cryptodev_dsa_keygen);
+                    DSA_meth_set_sign_setup(cryptodev_dsa, NULL);
+                    DSA_meth_set_mod_exp(cryptodev_dsa, NULL);
+                    DSA_meth_set_bn_mod_exp(cryptodev_dsa, NULL);
+                    DSA_meth_set_init(cryptodev_dsa, NULL);
+                    DSA_meth_set_finish(cryptodev_dsa, NULL);
+                    DSA_meth_set_flags(cryptodev_dsa, 0);
+                    DSA_meth_set0_app_data(cryptodev_dsa, NULL);
+                    DSA_meth_set_paramgen(cryptodev_dsa, NULL);
+                }
+            }
+        }
+#endif
+#if 0            
+        cryptodev_dh = DH_meth_dup(DH_OpenSSL());
+        if (cryptodev_dh != NULL) {
+            DH_meth_set1_name(cryptodev_dh, "cryptodev DH method");
+            DH_meth_set_flags(cryptodev_dh, 0);
+            if (ENGINE_set_DH(e, cryptodev_dh)) {
+                if ((cryptodev_asymfeat & CRF_DH_COMPUTE_KEY) && (cryptodev_asymfeat & CRF_DH_GENERATE_KEY)) {
+                    DH_meth_set_generate_key(cryptodev_dh, cryptodev_dh_generate_key);
+                    DH_meth_set_compute_key(cryptodev_dh, cryptodev_dh_compute_key);
+                    DH_meth_set_bn_mod_exp(cryptodev_dh, NULL);
+                    DH_meth_set_init(cryptodev_dh, NULL);
+                    DH_meth_set_finish(cryptodev_dh, NULL);
+                    DH_meth_set_flags(cryptodev_dh, 0);
+                    DH_meth_set0_app_data(cryptodev_dh, NULL);
+                    DH_meth_set_generate_params(cryptodev_dh, NULL);
+                }
+            }
+        }
+#endif            
+        if (ENGINE_set_EC(e, &cryptodev_ec_key)) {
+            if (!((cryptodev_asymfeat & CRF_ECDSA_SIGN) && (cryptodev_asymfeat & CRF_ECDSA_VERIFY) \
+                && (cryptodev_asymfeat & CRF_ECDH_COMPUTE_KEY) && (cryptodev_asymfeat & CRF_ECDH_GENERATE_KEY))) {
+                ENGINE_set_EC(e, EC_KEY_OpenSSL());
+            }
+        }
+
+    }
+
+    return (ENGINE_set_ciphers(e, devcrypto_ciphers)
+#ifdef IMPLEMENT_DIGEST
+        && ENGINE_set_digests(e, devcrypto_digests)
+#endif
+        );
+}
+
+#ifdef OPENSSL_NO_DYNAMIC_ENGINE
+/*
+ * In case this engine is built into libcrypto, then it doesn't offer any
+ * ability to be dynamically loadable.
+ */
+void engine_load_devcrypto_int(void)
+{
+    ENGINE *e = NULL;
+
+    if (!open_devcrypto())
+        return;
+
+    if ((e = ENGINE_new()) == NULL
+        || !bind_devcrypto(e)) {
+        close_devcrypto();
+        ENGINE_free(e);
+        return;
+    }
+
+    ERR_set_mark();
+    ENGINE_add(e);
+    /*
+     * If the "add" worked, it gets a structural reference. So either way, we
+     * release our just-created reference.
+     */
+    ENGINE_free(e);          /* Loose our local reference */
+    /*
+     * If the "add" didn't work, it was probably a conflict because it was
+     * already added (eg. someone calling ENGINE_load_blah then calling
+     * ENGINE_load_builtin_engines() perhaps).
+     */
+    ERR_pop_to_mark();
+}
+
+#else
+
+static int bind_helper(ENGINE *e, const char *id)
+{
+    if ((id && (strcmp(id, engine_devcrypto_id) != 0))
+        || !open_devcrypto())
+        return 0;
+    if (!bind_devcrypto(e)) {
+        close_devcrypto();
+        return 0;
+    }
+    return 1;
+}
+
+IMPLEMENT_DYNAMIC_CHECK_FN()
+IMPLEMENT_DYNAMIC_BIND_FN(bind_helper)
+
+#endif
+int cryptodev_pkc_unsupported_curve(int nid)
+{
+    if (nid == NID_secp112r1 || nid == NID_secp112r2 || nid == NID_secp128r1 || nid == NID_secp128r2 || nid == NID_sect113r1 || nid == NID_sect113r2 || nid == NID_sect131r1 || nid == NID_sect131r2 || \
+		nid == NID_sect163r1 || nid == NID_sect163r2 || nid == NID_sect193r1 || nid == NID_sect193r2 || nid == NID_sect233r1 || nid == NID_sect283r1 || nid == NID_sect409r1 || nid == NID_sect571r1 ||  \
+        nid == NID_X9_62_c2pnb163v1 || nid == NID_X9_62_c2pnb163v2 || nid == NID_X9_62_c2pnb163v3 || nid == NID_X9_62_c2pnb176v1 || nid == NID_X9_62_c2tnb191v1 || nid == NID_X9_62_c2tnb191v3 || nid == NID_X9_62_c2pnb208w1 || \
+        nid == NID_X9_62_c2tnb239v1 || nid == NID_X9_62_c2tnb239v2 || nid == NID_X9_62_c2tnb239v3 || nid == NID_X9_62_c2pnb272w1 || nid == NID_X9_62_c2pnb304w1 || nid == NID_X9_62_c2tnb359v1 || nid == NID_X9_62_c2pnb368w1 || \
+        nid == NID_X9_62_c2tnb431r1 || nid == NID_wap_wsg_idm_ecid_wtls11 || nid == NID_wap_wsg_idm_ecid_wtls4 || nid == NID_wap_wsg_idm_ecid_wtls5 || nid == NID_wap_wsg_idm_ecid_wtls11 || nid == NID_ipsec3 || nid == NID_ipsec4 \
+        || nid == NID_X25519)
+        return 1;
+    else
+        return 0;
+}
diff --git a/test/dsatest.c b/test/dsatest.c
index b1de58575d..1e07aaec61 100644
--- a/test/dsatest.c
+++ b/test/dsatest.c
@@ -30,6 +30,9 @@
 #include "internal/nelem.h"
 
 #ifndef OPENSSL_NO_DSA
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
 static int dsa_cb(int p, int n, BN_GENCB *arg);
 
 static unsigned char out_p[] = {
@@ -413,10 +416,24 @@ err:
 int setup_tests(void)
 {
 #ifndef OPENSSL_NO_DSA
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE *e = NULL;
+
+    ENGINE_load_builtin_engines();
+    if (!(e = ENGINE_by_id("devcrypto")))
+        return 1;
+    if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+        ENGINE_free(e);
+        return 1;
+    }
+    if (e)
+        ENGINE_free(e);
+#endif
+
     ADD_TEST(dsa_test);
-    ADD_TEST(dsa_keygen_test);
-    ADD_TEST(test_dsa_sig_infinite_loop);
-    ADD_ALL_TESTS(test_dsa_default_paramgen_validate, 2);
 #endif
+#ifndef OPENSSL_NO_ENGINE
+     ENGINE_cleanup();
+#endif 
     return 1;
 }
diff --git a/test/ecdsatest.c b/test/ecdsatest.c
index 32e929ed3d..7648e4d9e9 100644
--- a/test/ecdsatest.c
+++ b/test/ecdsatest.c
@@ -24,6 +24,9 @@
 # include <openssl/rand.h>
 # include "internal/nelem.h"
 # include "ecdsatest.h"
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
 
 static fake_random_generate_cb fbytes;
 
@@ -134,13 +137,13 @@ static int x9_62_tests(int n)
         /* verify the signature */
         || !TEST_int_eq(ECDSA_do_verify(digest, dgst_len, signature, key), 1))
         goto err;
-
+#ifdef OPENSSL_NO_ENGINE
     /* compare the created signature with the expected signature */
     ECDSA_SIG_get0(signature, &sig_r, &sig_s);
     if (!TEST_BN_eq(sig_r, r)
         || !TEST_BN_eq(sig_s, s))
         goto err;
-
+#endif
     ret = 1;
 
  err:
@@ -199,7 +202,16 @@ static int test_builtin(int n, int as)
     nid = curves[n].nid;
 
     /* skip built-in curves where ord(G) is not prime */
+#ifdef OPENSSL_NO_DEVCRYPTOENG
     if (nid == NID_ipsec4 || nid == NID_ipsec3) {
+#else
+    if (nid == NID_secp112r1 || nid == NID_secp112r2 || nid == NID_secp128r1 || nid == NID_secp128r2 || nid == NID_sect113r1 || nid == NID_sect113r2 || nid == NID_sect131r1 || nid == NID_sect131r2 || \
+        nid == NID_sect163r1 || nid == NID_sect163r2 || nid == NID_sect193r1 || nid == NID_sect193r2 || nid == NID_sect233r1 || nid == NID_sect283r1 || nid == NID_sect409r1 || nid == NID_sect571r1 ||  \
+        nid == NID_X9_62_c2pnb163v1 || nid == NID_X9_62_c2pnb163v2 || nid == NID_X9_62_c2pnb163v3 || nid == NID_X9_62_c2pnb176v1 || nid == NID_X9_62_c2tnb191v1 || nid == NID_X9_62_c2tnb191v3 || nid == NID_X9_62_c2pnb208w1 || \
+        nid == NID_X9_62_c2tnb239v1 || nid == NID_X9_62_c2tnb239v2 || nid == NID_X9_62_c2tnb239v3 || nid == NID_X9_62_c2pnb272w1 || nid == NID_X9_62_c2pnb304w1 || nid == NID_X9_62_c2tnb359v1 || nid == NID_X9_62_c2pnb368w1 || \
+        nid == NID_X9_62_c2tnb431r1 || nid == NID_wap_wsg_idm_ecid_wtls11 || nid == NID_wap_wsg_idm_ecid_wtls4 || nid == NID_wap_wsg_idm_ecid_wtls5 || nid == NID_wap_wsg_idm_ecid_wtls11 || nid == NID_ipsec3 || nid == NID_ipsec4 \
+        || nid == NID_X25519 || nid == NID_sm2) {
+#endif
         TEST_info("skipped: ECDSA unsupported for curve %s", OBJ_nid2sn(nid));
         return 1;
     }
@@ -353,6 +365,22 @@ int setup_tests(void)
 #ifdef OPENSSL_NO_EC
     TEST_note("Elliptic curves are disabled.");
 #else
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE *e = NULL;
+#endif
+    
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE_load_builtin_engines();
+    if (!(e = ENGINE_by_id("devcrypto")))
+        return 1;
+    if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+        ENGINE_free(e);
+        return 1;
+    }
+    if (e)
+        ENGINE_free(e);
+#endif
+    
     fake_rand = fake_rand_start(NULL);
     if (fake_rand == NULL)
         return 0;
@@ -368,7 +396,9 @@ int setup_tests(void)
 # ifndef OPENSSL_NO_SM2
     ADD_ALL_TESTS(test_builtin_as_sm2, crv_len);
 # endif
+#ifdef OPENSSL_NO_ENGINE  
     ADD_ALL_TESTS(x9_62_tests, OSSL_NELEM(ecdsa_cavs_kats));
+#endif
 #endif
     return 1;
 }
@@ -376,6 +406,9 @@ int setup_tests(void)
 void cleanup_tests(void)
 {
 #ifndef OPENSSL_NO_EC
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE_cleanup();
+#endif
     fake_rand_finish(fake_rand);
     OPENSSL_free(curves);
 #endif
diff --git a/test/rsa_test.c b/test/rsa_test.c
index 62a54df74d..b401b09fb9 100644
--- a/test/rsa_test.c
+++ b/test/rsa_test.c
@@ -28,6 +28,9 @@
 #include "testutil.h"
 
 #include <openssl/rsa.h>
+#ifndef OPENSSL_NO_ENGINE
+# include <openssl/engine.h>
+#endif
 
 #define SetKey \
     RSA_set0_key(key,                                           \
@@ -277,7 +280,40 @@ static int test_rsa_pkcs1(int idx)
     return test_rsa_simple(idx, RSA_PKCS1_PADDING, RSA_PKCS1_PADDING, 1, NULL,
                            NULL, NULL);
 }
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+static int test_rsa_oaep(int idx)
+{
+    int ret = 0;
+    RSA *key = NULL; 
+    int rsa_num = 0;
+    unsigned char buf[64], buf2[1024 + 8 + 1];
+    
+    RAND_pseudo_bytes(buf, 36);   
+
+    if (!test_rsa_simple(idx, RSA_PKCS1_OAEP_PADDING, RSA_PKCS1_OAEP_PADDING, 1,
+                         NULL, NULL, &key))
+        goto err;
 
+    printf("OAEP encryption/decryption ok\n");
+
+    printf("\n");
+    memset(buf2, 0, 1024 + 8 + 1);
+    ret = RSA_sign(NID_md5_sha1, buf, 36, buf2, &rsa_num, key);
+    if (ret == 0) {
+        printf("RSA sign failure.  No RSA sign will be done.\n");
+    }
+    ret = RSA_verify(NID_md5_sha1, buf, 36, buf2, rsa_num, key);
+    if (ret <= 0) {
+        printf("RSA verify failure.  No RSA verify will be done.\n");
+    }
+    else
+        printf("RSA verify successfully.\n");
+    ret = 1;
+err:
+    RSA_free(key);
+    return ret;
+}
+#else
 static int test_rsa_oaep(int idx)
 {
     int ret = 0;
@@ -325,7 +361,7 @@ err:
     RSA_free(key);
     return ret;
 }
-
+#endif
 static const struct {
     int bits;
     unsigned int r;
@@ -393,8 +429,23 @@ err:
 
 int setup_tests(void)
 {
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE *e = NULL;
+    ENGINE_load_builtin_engines();
+    if (!(e = ENGINE_by_id("devcrypto")))
+        return 1;
+    if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+        ENGINE_free(e);
+        return 1;
+    }
+    if (e)
+        ENGINE_free(e);
+#endif
     ADD_ALL_TESTS(test_rsa_pkcs1, 3);
     ADD_ALL_TESTS(test_rsa_oaep, 3);
     ADD_ALL_TESTS(test_rsa_security_bit, OSSL_NELEM(rsa_security_bits_cases));
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE_cleanup();
+#endif        
     return 1;
 }
-- 
2.25.1

